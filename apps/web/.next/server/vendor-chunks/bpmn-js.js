/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bpmn-js";
exports.ids = ["vendor-chunks/bpmn-js"];
exports.modules = {

/***/ "(ssr)/../../node_modules/bpmn-js/dist/bpmn-navigated-viewer.development.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/bpmn-js/dist/bpmn-navigated-viewer.development.js ***!
  \****************************************************************************/
/***/ (function(module) {

eval("/*!\r\n * bpmn-js - bpmn-navigated-viewer v18.6.3\r\n *\r\n * Copyright (c) 2014-present, camunda Services GmbH\r\n *\r\n * Released under the bpmn.io license\r\n * http://bpmn.io/license\r\n *\r\n * Source Code: https://github.com/bpmn-io/bpmn-js\r\n *\r\n * Date: 2025-08-19\r\n */\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n})(this, (function () { 'use strict';\n\n  function e(e,t){t&&(e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:false,writable:true,configurable:true}}));}\n\n  /**\n   * Flatten array, one level deep.\n   *\n   * @template T\n   *\n   * @param {T[][] | T[] | null} [arr]\n   *\n   * @return {T[]}\n   */\n\n  const nativeToString$1 = Object.prototype.toString;\n  const nativeHasOwnProperty$1 = Object.prototype.hasOwnProperty;\n\n  function isUndefined$2(obj) {\n    return obj === undefined;\n  }\n\n  function isDefined(obj) {\n    return obj !== undefined;\n  }\n\n  function isNil(obj) {\n    return obj == null;\n  }\n\n  function isArray$2(obj) {\n    return nativeToString$1.call(obj) === '[object Array]';\n  }\n\n  function isObject(obj) {\n    return nativeToString$1.call(obj) === '[object Object]';\n  }\n\n  function isNumber(obj) {\n    return nativeToString$1.call(obj) === '[object Number]';\n  }\n\n  /**\n   * @param {any} obj\n   *\n   * @return {boolean}\n   */\n  function isFunction(obj) {\n    const tag = nativeToString$1.call(obj);\n\n    return (\n      tag === '[object Function]' ||\n      tag === '[object AsyncFunction]' ||\n      tag === '[object GeneratorFunction]' ||\n      tag === '[object AsyncGeneratorFunction]' ||\n      tag === '[object Proxy]'\n    );\n  }\n\n  function isString(obj) {\n    return nativeToString$1.call(obj) === '[object String]';\n  }\n\n  /**\n   * Return true, if target owns a property with the given key.\n   *\n   * @param {Object} target\n   * @param {String} key\n   *\n   * @return {Boolean}\n   */\n  function has$1(target, key) {\n    return nativeHasOwnProperty$1.call(target, key);\n  }\n\n  /**\n   * @template T\n   * @typedef { (\n   *   ((e: T) => boolean) |\n   *   ((e: T, idx: number) => boolean) |\n   *   ((e: T, key: string) => boolean) |\n   *   string |\n   *   number\n   * ) } Matcher\n   */\n\n  /**\n   * @template T\n   * @template U\n   *\n   * @typedef { (\n   *   ((e: T) => U) | string | number\n   * ) } Extractor\n   */\n\n\n  /**\n   * @template T\n   * @typedef { (val: T, key: any) => boolean } MatchFn\n   */\n\n  /**\n   * @template T\n   * @typedef { T[] } ArrayCollection\n   */\n\n  /**\n   * @template T\n   * @typedef { { [key: string]: T } } StringKeyValueCollection\n   */\n\n  /**\n   * @template T\n   * @typedef { { [key: number]: T } } NumberKeyValueCollection\n   */\n\n  /**\n   * @template T\n   * @typedef { StringKeyValueCollection<T> | NumberKeyValueCollection<T> } KeyValueCollection\n   */\n\n  /**\n   * @template T\n   * @typedef { KeyValueCollection<T> | ArrayCollection<T> } Collection\n   */\n\n  /**\n   * Find element in collection.\n   *\n   * @template T\n   * @param {Collection<T>} collection\n   * @param {Matcher<T>} matcher\n   *\n   * @return {Object}\n   */\n  function find(collection, matcher) {\n\n    const matchFn = toMatcher(matcher);\n\n    let match;\n\n    forEach$1(collection, function(val, key) {\n      if (matchFn(val, key)) {\n        match = val;\n\n        return false;\n      }\n    });\n\n    return match;\n\n  }\n\n\n  /**\n   * Find element index in collection.\n   *\n   * @template T\n   * @param {Collection<T>} collection\n   * @param {Matcher<T>} matcher\n   *\n   * @return {number}\n   */\n  function findIndex(collection, matcher) {\n\n    const matchFn = toMatcher(matcher);\n\n    let idx = isArray$2(collection) ? -1 : undefined;\n\n    forEach$1(collection, function(val, key) {\n      if (matchFn(val, key)) {\n        idx = key;\n\n        return false;\n      }\n    });\n\n    return idx;\n  }\n\n\n  /**\n   * Filter elements in collection.\n   *\n   * @template T\n   * @param {Collection<T>} collection\n   * @param {Matcher<T>} matcher\n   *\n   * @return {T[]} result\n   */\n  function filter(collection, matcher) {\n\n    const matchFn = toMatcher(matcher);\n\n    let result = [];\n\n    forEach$1(collection, function(val, key) {\n      if (matchFn(val, key)) {\n        result.push(val);\n      }\n    });\n\n    return result;\n  }\n\n\n  /**\n   * Iterate over collection; returning something\n   * (non-undefined) will stop iteration.\n   *\n   * @template T\n   * @param {Collection<T>} collection\n   * @param { ((item: T, idx: number) => (boolean|void)) | ((item: T, key: string) => (boolean|void)) } iterator\n   *\n   * @return {T} return result that stopped the iteration\n   */\n  function forEach$1(collection, iterator) {\n\n    let val,\n        result;\n\n    if (isUndefined$2(collection)) {\n      return;\n    }\n\n    const convertKey = isArray$2(collection) ? toNum$1 : identity$1;\n\n    for (let key in collection) {\n\n      if (has$1(collection, key)) {\n        val = collection[key];\n\n        result = iterator(val, convertKey(key));\n\n        if (result === false) {\n          return val;\n        }\n      }\n    }\n  }\n\n\n  /**\n   * Reduce collection, returning a single result.\n   *\n   * @template T\n   * @template V\n   *\n   * @param {Collection<T>} collection\n   * @param {(result: V, entry: T, index: any) => V} iterator\n   * @param {V} result\n   *\n   * @return {V} result returned from last iterator\n   */\n  function reduce(collection, iterator, result) {\n\n    forEach$1(collection, function(value, idx) {\n      result = iterator(result, value, idx);\n    });\n\n    return result;\n  }\n\n\n  /**\n   * Return true if every element in the collection\n   * matches the criteria.\n   *\n   * @param  {Object|Array} collection\n   * @param  {Function} matcher\n   *\n   * @return {Boolean}\n   */\n  function every(collection, matcher) {\n\n    return !!reduce(collection, function(matches, val, key) {\n      return matches && matcher(val, key);\n    }, true);\n  }\n\n\n  /**\n   * Return true if some elements in the collection\n   * match the criteria.\n   *\n   * @param  {Object|Array} collection\n   * @param  {Function} matcher\n   *\n   * @return {Boolean}\n   */\n  function some(collection, matcher) {\n\n    return !!find(collection, matcher);\n  }\n\n\n  /**\n   * Transform a collection into another collection\n   * by piping each member through the given fn.\n   *\n   * @param  {Object|Array}   collection\n   * @param  {Function} fn\n   *\n   * @return {Array} transformed collection\n   */\n  function map$1(collection, fn) {\n\n    let result = [];\n\n    forEach$1(collection, function(val, key) {\n      result.push(fn(val, key));\n    });\n\n    return result;\n  }\n\n\n  /**\n   * Create an object pattern matcher.\n   *\n   * @example\n   *\n   * ```javascript\n   * const matcher = matchPattern({ id: 1 });\n   *\n   * let element = find(elements, matcher);\n   * ```\n   *\n   * @template T\n   *\n   * @param {T} pattern\n   *\n   * @return { (el: any) =>  boolean } matcherFn\n   */\n  function matchPattern(pattern) {\n\n    return function(el) {\n\n      return every(pattern, function(val, key) {\n        return el[key] === val;\n      });\n\n    };\n  }\n\n\n  /**\n   * @template T\n   * @param {Matcher<T>} matcher\n   *\n   * @return {MatchFn<T>}\n   */\n  function toMatcher(matcher) {\n    return isFunction(matcher) ? matcher : (e) => {\n      return e === matcher;\n    };\n  }\n\n\n  function identity$1(arg) {\n    return arg;\n  }\n\n  function toNum$1(arg) {\n    return Number(arg);\n  }\n\n  /* global setTimeout clearTimeout */\n\n  /**\n   * @typedef { {\n   *   (...args: any[]): any;\n   *   flush: () => void;\n   *   cancel: () => void;\n   * } } DebouncedFunction\n   */\n\n  /**\n   * Debounce fn, calling it only once if the given time\n   * elapsed between calls.\n   *\n   * Lodash-style the function exposes methods to `#clear`\n   * and `#flush` to control internal behavior.\n   *\n   * @param  {Function} fn\n   * @param  {Number} timeout\n   *\n   * @return {DebouncedFunction} debounced function\n   */\n  function debounce(fn, timeout) {\n\n    let timer;\n\n    let lastArgs;\n    let lastThis;\n\n    let lastNow;\n\n    function fire(force) {\n\n      let now = Date.now();\n\n      let scheduledDiff = force ? 0 : (lastNow + timeout) - now;\n\n      if (scheduledDiff > 0) {\n        return schedule(scheduledDiff);\n      }\n\n      fn.apply(lastThis, lastArgs);\n\n      clear();\n    }\n\n    function schedule(timeout) {\n      timer = setTimeout(fire, timeout);\n    }\n\n    function clear() {\n      if (timer) {\n        clearTimeout(timer);\n      }\n\n      timer = lastNow = lastArgs = lastThis = undefined;\n    }\n\n    function flush() {\n      if (timer) {\n        fire(true);\n      }\n\n      clear();\n    }\n\n    /**\n     * @type { DebouncedFunction }\n     */\n    function callback(...args) {\n      lastNow = Date.now();\n\n      lastArgs = args;\n      lastThis = this;\n\n      // ensure an execution is scheduled\n      if (!timer) {\n        schedule(timeout);\n      }\n    }\n\n    callback.flush = flush;\n    callback.cancel = clear;\n\n    return callback;\n  }\n\n  /**\n   * Bind function against target <this>.\n   *\n   * @param  {Function} fn\n   * @param  {Object}   target\n   *\n   * @return {Function} bound function\n   */\n  function bind$2(fn, target) {\n    return fn.bind(target);\n  }\n\n  /**\n   * Convenience wrapper for `Object.assign`.\n   *\n   * @param {Object} target\n   * @param {...Object} others\n   *\n   * @return {Object} the target\n   */\n  function assign$1(target, ...others) {\n    return Object.assign(target, ...others);\n  }\n\n  /**\n   * Sets a nested property of a given object to the specified value.\n   *\n   * This mutates the object and returns it.\n   *\n   * @template T\n   *\n   * @param {T} target The target of the set operation.\n   * @param {(string|number)[]} path The path to the nested value.\n   * @param {any} value The value to set.\n   *\n   * @return {T}\n   */\n  function set$1(target, path, value) {\n\n    let currentTarget = target;\n\n    forEach$1(path, function(key, idx) {\n\n      if (typeof key !== 'number' && typeof key !== 'string') {\n        throw new Error('illegal key type: ' + typeof key + '. Key should be of type number or string.');\n      }\n\n      if (key === 'constructor') {\n        throw new Error('illegal key: constructor');\n      }\n\n      if (key === '__proto__') {\n        throw new Error('illegal key: __proto__');\n      }\n\n      let nextKey = path[idx + 1];\n      let nextTarget = currentTarget[key];\n\n      if (isDefined(nextKey) && isNil(nextTarget)) {\n        nextTarget = currentTarget[key] = isNaN(+nextKey) ? {} : [];\n      }\n\n      if (isUndefined$2(nextKey)) {\n        if (isUndefined$2(value)) {\n          delete currentTarget[key];\n        } else {\n          currentTarget[key] = value;\n        }\n      } else {\n        currentTarget = nextTarget;\n      }\n    });\n\n    return target;\n  }\n\n  /**\n   * Pick properties from the given target.\n   *\n   * @template T\n   * @template {any[]} V\n   *\n   * @param {T} target\n   * @param {V} properties\n   *\n   * @return Pick<T, V>\n   */\n  function pick(target, properties) {\n\n    let result = {};\n\n    let obj = Object(target);\n\n    forEach$1(properties, function(prop) {\n\n      if (prop in obj) {\n        result[prop] = target[prop];\n      }\n    });\n\n    return result;\n  }\n\n  /**\n   * Pick all target properties, excluding the given ones.\n   *\n   * @template T\n   * @template {any[]} V\n   *\n   * @param {T} target\n   * @param {V} properties\n   *\n   * @return {Omit<T, V>} target\n   */\n  function omit(target, properties) {\n\n    let result = {};\n\n    let obj = Object(target);\n\n    forEach$1(obj, function(prop, key) {\n\n      if (properties.indexOf(key) === -1) {\n        result[key] = prop;\n      }\n    });\n\n    return result;\n  }\n\n  var DEFAULT_RENDER_PRIORITY$1 = 1000;\n\n  /**\n   * @typedef {import('../core/Types').ElementLike} Element\n   * @typedef {import('../core/Types').ConnectionLike} Connection\n   * @typedef {import('../core/Types').ShapeLike} Shape\n   *\n   * @typedef {import('../core/EventBus').default} EventBus\n   */\n\n  /**\n   * The base implementation of shape and connection renderers.\n   *\n   * @param {EventBus} eventBus\n   * @param {number} [renderPriority=1000]\n   */\n  function BaseRenderer(eventBus, renderPriority) {\n    var self = this;\n\n    renderPriority = renderPriority || DEFAULT_RENDER_PRIORITY$1;\n\n    eventBus.on([ 'render.shape', 'render.connection' ], renderPriority, function(evt, context) {\n      var type = evt.type,\n          element = context.element,\n          visuals = context.gfx,\n          attrs = context.attrs;\n\n      if (self.canRender(element)) {\n        if (type === 'render.shape') {\n          return self.drawShape(visuals, element, attrs);\n        } else {\n          return self.drawConnection(visuals, element, attrs);\n        }\n      }\n    });\n\n    eventBus.on([ 'render.getShapePath', 'render.getConnectionPath' ], renderPriority, function(evt, element) {\n      if (self.canRender(element)) {\n        if (evt.type === 'render.getShapePath') {\n          return self.getShapePath(element);\n        } else {\n          return self.getConnectionPath(element);\n        }\n      }\n    });\n  }\n\n  /**\n   * Checks whether an element can be rendered.\n   *\n   * @param {Element} element The element to be rendered.\n   *\n   * @return {boolean} Whether the element can be rendered.\n   */\n  BaseRenderer.prototype.canRender = function(element) {};\n\n  /**\n   * Draws a shape.\n   *\n   * @param {SVGElement} visuals The SVG element to draw the shape into.\n   * @param {Shape} shape The shape to be drawn.\n   *\n   * @return {SVGElement} The SVG element of the shape drawn.\n   */\n  BaseRenderer.prototype.drawShape = function(visuals, shape) {};\n\n  /**\n   * Draws a connection.\n   *\n   * @param {SVGElement} visuals The SVG element to draw the connection into.\n   * @param {Connection} connection The connection to be drawn.\n   *\n   * @return {SVGElement} The SVG element of the connection drawn.\n   */\n  BaseRenderer.prototype.drawConnection = function(visuals, connection) {};\n\n  /**\n   * Gets the SVG path of the graphical representation of a shape.\n   *\n   * @param {Shape} shape The shape.\n   *\n   * @return {string} The SVG path of the shape.\n   */\n  BaseRenderer.prototype.getShapePath = function(shape) {};\n\n  /**\n   * Gets the SVG path of the graphical representation of a connection.\n   *\n   * @param {Connection} connection The connection.\n   *\n   * @return {string} The SVG path of the connection.\n   */\n  BaseRenderer.prototype.getConnectionPath = function(connection) {};\n\n  /**\r\n   * @typedef { import('../model/Types').Element } Element\r\n   * @typedef { import('../model/Types').ModdleElement } ModdleElement\r\n   */\r\n\r\n  /**\r\n   * Is an element of the given BPMN type?\r\n   *\r\n   * @param  {Element|ModdleElement} element\r\n   * @param  {string} type\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  function is$1(element, type) {\r\n    var bo = getBusinessObject(element);\r\n\r\n    return bo && (typeof bo.$instanceOf === 'function') && bo.$instanceOf(type);\r\n  }\r\n\r\n\r\n  /**\r\n   * Return true if element has any of the given types.\r\n   *\r\n   * @param {Element|ModdleElement} element\r\n   * @param {string[]} types\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  function isAny(element, types) {\r\n    return some(types, function(t) {\r\n      return is$1(element, t);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Return the business object for a given element.\r\n   *\r\n   * @param {Element|ModdleElement} element\r\n   *\r\n   * @return {ModdleElement}\r\n   */\r\n  function getBusinessObject(element) {\r\n    return (element && element.businessObject) || element;\r\n  }\r\n\r\n  /**\r\n   * Return the di object for a given element.\r\n   *\r\n   * @param {Element} element\r\n   *\r\n   * @return {ModdleElement}\r\n   */\r\n  function getDi(element) {\r\n    return element && element.di;\r\n  }\n\n  /**\r\n   * @typedef {import('../model/Types').Element} Element\r\n   * @typedef {import('../model/Types').ModdleElement} ModdleElement\r\n   */\r\n\r\n  /**\r\n   * @param {Element} element\r\n   * @param {ModdleElement} [di]\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  function isExpanded(element, di) {\r\n\r\n    if (is$1(element, 'bpmn:CallActivity')) {\r\n      return false;\r\n    }\r\n\r\n    if (is$1(element, 'bpmn:SubProcess')) {\r\n      di = di || getDi(element);\r\n\r\n      if (di && is$1(di, 'bpmndi:BPMNPlane')) {\r\n        return true;\r\n      }\r\n\r\n      return di && !!di.isExpanded;\r\n    }\r\n\r\n    if (is$1(element, 'bpmn:Participant')) {\r\n      return !!getBusinessObject(element).processRef;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @param {Element} element\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  function isHorizontal(element) {\r\n\r\n    if (!is$1(element, 'bpmn:Participant') && !is$1(element, 'bpmn:Lane')) {\r\n      return undefined;\r\n    }\r\n\r\n    var isHorizontal = getDi(element).isHorizontal;\r\n\r\n    if (isHorizontal === undefined) {\r\n      return true;\r\n    }\r\n\r\n    return isHorizontal;\r\n  }\r\n\r\n  /**\r\n   * @param {Element} element\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  function isEventSubProcess(element) {\r\n    return element && !!getBusinessObject(element).triggeredByEvent;\r\n  }\n\n  /**\n   * Checks whether a value is an instance of Connection.\n   *\n   * @param {any} value\n   *\n   * @return {boolean}\n   */\n  function isConnection(value) {\n    return isObject(value) && has$1(value, 'waypoints');\n  }\n\n  /**\r\n   * @typedef {import('diagram-js/lib/util/Types').Point} Point\r\n   * @typedef {import('diagram-js/lib/util/Types').Rect} Rect\r\n   *\r\n   * @typedef {import('../model/Types').Element} Element\r\n   * @typedef {import('../model/Types').ModdleElement} ModdleElement\r\n   */\r\n\r\n  var DEFAULT_LABEL_SIZE$1 = {\r\n    width: 90,\r\n    height: 20\r\n  };\r\n\r\n  var FLOW_LABEL_INDENT = 15;\r\n\r\n\r\n  /**\r\n   * Return true if the given semantic has an external label.\r\n   *\r\n   * @param {Element} semantic\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  function isLabelExternal(semantic) {\r\n    return is$1(semantic, 'bpmn:Event') ||\r\n           is$1(semantic, 'bpmn:Gateway') ||\r\n           is$1(semantic, 'bpmn:DataStoreReference') ||\r\n           is$1(semantic, 'bpmn:DataObjectReference') ||\r\n           is$1(semantic, 'bpmn:DataInput') ||\r\n           is$1(semantic, 'bpmn:DataOutput') ||\r\n           is$1(semantic, 'bpmn:SequenceFlow') ||\r\n           is$1(semantic, 'bpmn:MessageFlow') ||\r\n           is$1(semantic, 'bpmn:Group');\r\n  }\r\n\r\n  /**\r\n   * Get the position of a sequence flow label.\r\n   *\r\n   * @param  {Point[]} waypoints\r\n   *\r\n   * @return {Point}\r\n   */\r\n  function getFlowLabelPosition(waypoints) {\r\n\r\n    // get the waypoints mid\r\n    var mid = waypoints.length / 2 - 1;\r\n\r\n    var first = waypoints[Math.floor(mid)];\r\n    var second = waypoints[Math.ceil(mid + 0.01)];\r\n\r\n    // get position\r\n    var position = getWaypointsMid(waypoints);\r\n\r\n    // calculate angle\r\n    var angle = Math.atan((second.y - first.y) / (second.x - first.x));\r\n\r\n    var x = position.x,\r\n        y = position.y;\r\n\r\n    if (Math.abs(angle) < Math.PI / 2) {\r\n      y -= FLOW_LABEL_INDENT;\r\n    } else {\r\n      x += FLOW_LABEL_INDENT;\r\n    }\r\n\r\n    return { x: x, y: y };\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the middle of a number of waypoints.\r\n   *\r\n   * @param  {Point[]} waypoints\r\n   *\r\n   * @return {Point}\r\n   */\r\n  function getWaypointsMid(waypoints) {\r\n\r\n    var mid = waypoints.length / 2 - 1;\r\n\r\n    var first = waypoints[Math.floor(mid)];\r\n    var second = waypoints[Math.ceil(mid + 0.01)];\r\n\r\n    return {\r\n      x: first.x + (second.x - first.x) / 2,\r\n      y: first.y + (second.y - first.y) / 2\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get the middle of the external label of an element.\r\n   *\r\n   * @param {Element} element\r\n   *\r\n   * @return {Point}\r\n   */\r\n  function getExternalLabelMid(element) {\r\n\r\n    if (element.waypoints) {\r\n      return getFlowLabelPosition(element.waypoints);\r\n    } else if (is$1(element, 'bpmn:Group')) {\r\n      return {\r\n        x: element.x + element.width / 2,\r\n        y: element.y + DEFAULT_LABEL_SIZE$1.height / 2\r\n      };\r\n    } else {\r\n      return {\r\n        x: element.x + element.width / 2,\r\n        y: element.y + element.height + DEFAULT_LABEL_SIZE$1.height / 2\r\n      };\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Return the bounds of an elements label, parsed from the elements DI or\r\n   * generated from its bounds.\r\n   *\r\n   * @param {ModdleElement} di\r\n   * @param {Element} element\r\n   *\r\n   * @return {Rect}\r\n   */\r\n  function getExternalLabelBounds(di, element) {\r\n\r\n    var mid,\r\n        size,\r\n        bounds,\r\n        label = di.label;\r\n\r\n    if (label && label.bounds) {\r\n      bounds = label.bounds;\r\n\r\n      size = {\r\n        width: Math.max(DEFAULT_LABEL_SIZE$1.width, bounds.width),\r\n        height: bounds.height\r\n      };\r\n\r\n      mid = {\r\n        x: bounds.x + bounds.width / 2,\r\n        y: bounds.y + bounds.height / 2\r\n      };\r\n    } else {\r\n\r\n      mid = getExternalLabelMid(element);\r\n\r\n      size = DEFAULT_LABEL_SIZE$1;\r\n    }\r\n\r\n    return assign$1({\r\n      x: mid.x - size.width / 2,\r\n      y: mid.y - size.height / 2\r\n    }, size);\r\n  }\r\n\r\n  /**\r\n   * @param {ModdleElement} semantic\r\n   *\r\n   * @returns {string}\r\n   */\r\n  function getLabelAttr(semantic) {\r\n    if (\r\n      is$1(semantic, 'bpmn:FlowElement') ||\r\n      is$1(semantic, 'bpmn:Participant') ||\r\n      is$1(semantic, 'bpmn:Lane') ||\r\n      is$1(semantic, 'bpmn:SequenceFlow') ||\r\n      is$1(semantic, 'bpmn:MessageFlow') ||\r\n      is$1(semantic, 'bpmn:DataInput') ||\r\n      is$1(semantic, 'bpmn:DataOutput')\r\n    ) {\r\n      return 'name';\r\n    }\r\n\r\n    if (is$1(semantic, 'bpmn:TextAnnotation')) {\r\n      return 'text';\r\n    }\r\n\r\n    if (is$1(semantic, 'bpmn:Group')) {\r\n      return 'categoryValueRef';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {ModdleElement} semantic\r\n   *\r\n   * @returns {string}\r\n   */\r\n  function getCategoryValue(semantic) {\r\n    var categoryValueRef = semantic['categoryValueRef'];\r\n\r\n    if (!categoryValueRef) {\r\n      return '';\r\n    }\r\n\r\n\r\n    return categoryValueRef.value || '';\r\n  }\r\n\r\n  /**\r\n   * @param {Element} element\r\n   *\r\n   * @return {string}\r\n   */\r\n  function getLabel(element) {\r\n    var semantic = element.businessObject,\r\n        attr = getLabelAttr(semantic);\r\n\r\n    if (attr) {\r\n\r\n      if (attr === 'categoryValueRef') {\r\n\r\n        return getCategoryValue(semantic);\r\n      }\r\n\r\n      return semantic[attr] || '';\r\n    }\r\n  }\n\n  function ensureImported(element, target) {\n\n    if (element.ownerDocument !== target.ownerDocument) {\n      try {\n\n        // may fail on webkit\n        return target.ownerDocument.importNode(element, true);\n      } catch (e) {\n\n        // ignore\n      }\n    }\n\n    return element;\n  }\n\n  /**\n   * appendTo utility\n   */\n\n\n  /**\n   * Append a node to a target element and return the appended node.\n   *\n   * @param  {SVGElement} element\n   * @param  {SVGElement} target\n   *\n   * @return {SVGElement} the appended node\n   */\n  function appendTo(element, target) {\n    return target.appendChild(ensureImported(element, target));\n  }\n\n  /**\n   * append utility\n   */\n\n\n  /**\n   * Append a node to an element\n   *\n   * @param  {SVGElement} element\n   * @param  {SVGElement} node\n   *\n   * @return {SVGElement} the element\n   */\n  function append(target, node) {\n    appendTo(node, target);\n    return target;\n  }\n\n  /**\n   * attribute accessor utility\n   */\n\n  var LENGTH_ATTR = 2;\n\n  var CSS_PROPERTIES = {\n    'alignment-baseline': 1,\n    'baseline-shift': 1,\n    'clip': 1,\n    'clip-path': 1,\n    'clip-rule': 1,\n    'color': 1,\n    'color-interpolation': 1,\n    'color-interpolation-filters': 1,\n    'color-profile': 1,\n    'color-rendering': 1,\n    'cursor': 1,\n    'direction': 1,\n    'display': 1,\n    'dominant-baseline': 1,\n    'enable-background': 1,\n    'fill': 1,\n    'fill-opacity': 1,\n    'fill-rule': 1,\n    'filter': 1,\n    'flood-color': 1,\n    'flood-opacity': 1,\n    'font': 1,\n    'font-family': 1,\n    'font-size': LENGTH_ATTR,\n    'font-size-adjust': 1,\n    'font-stretch': 1,\n    'font-style': 1,\n    'font-variant': 1,\n    'font-weight': 1,\n    'glyph-orientation-horizontal': 1,\n    'glyph-orientation-vertical': 1,\n    'image-rendering': 1,\n    'kerning': 1,\n    'letter-spacing': 1,\n    'lighting-color': 1,\n    'marker': 1,\n    'marker-end': 1,\n    'marker-mid': 1,\n    'marker-start': 1,\n    'mask': 1,\n    'opacity': 1,\n    'overflow': 1,\n    'pointer-events': 1,\n    'shape-rendering': 1,\n    'stop-color': 1,\n    'stop-opacity': 1,\n    'stroke': 1,\n    'stroke-dasharray': 1,\n    'stroke-dashoffset': 1,\n    'stroke-linecap': 1,\n    'stroke-linejoin': 1,\n    'stroke-miterlimit': 1,\n    'stroke-opacity': 1,\n    'stroke-width': LENGTH_ATTR,\n    'text-anchor': 1,\n    'text-decoration': 1,\n    'text-rendering': 1,\n    'unicode-bidi': 1,\n    'visibility': 1,\n    'word-spacing': 1,\n    'writing-mode': 1\n  };\n\n\n  function getAttribute(node, name) {\n    if (CSS_PROPERTIES[name]) {\n      return node.style[name];\n    } else {\n      return node.getAttributeNS(null, name);\n    }\n  }\n\n  function setAttribute(node, name, value) {\n    var hyphenated = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n\n    var type = CSS_PROPERTIES[hyphenated];\n\n    if (type) {\n\n      // append pixel unit, unless present\n      if (type === LENGTH_ATTR && typeof value === 'number') {\n        value = String(value) + 'px';\n      }\n\n      node.style[hyphenated] = value;\n    } else {\n      node.setAttributeNS(null, name, value);\n    }\n  }\n\n  function setAttributes(node, attrs) {\n\n    var names = Object.keys(attrs), i, name;\n\n    for (i = 0, name; (name = names[i]); i++) {\n      setAttribute(node, name, attrs[name]);\n    }\n  }\n\n  /**\n   * Gets or sets raw attributes on a node.\n   *\n   * @param  {SVGElement} node\n   * @param  {Object} [attrs]\n   * @param  {String} [name]\n   * @param  {String} [value]\n   *\n   * @return {String}\n   */\n  function attr$1(node, name, value) {\n    if (typeof name === 'string') {\n      if (value !== undefined) {\n        setAttribute(node, name, value);\n      } else {\n        return getAttribute(node, name);\n      }\n    } else {\n      setAttributes(node, name);\n    }\n\n    return node;\n  }\n\n  /**\r\n   * Taken from https://github.com/component/classes\r\n   *\r\n   * Without the component bits.\r\n   */\r\n\r\n  /**\r\n   * toString reference.\r\n   */\r\n\r\n  const toString$1 = Object.prototype.toString;\r\n\r\n  /**\r\n    * Wrap `el` in a `ClassList`.\r\n    *\r\n    * @param {Element} el\r\n    * @return {ClassList}\r\n    * @api public\r\n    */\r\n\r\n  function classes$1(el) {\r\n    return new ClassList$1(el);\r\n  }\r\n\r\n  function ClassList$1(el) {\r\n    if (!el || !el.nodeType) {\r\n      throw new Error('A DOM element reference is required');\r\n    }\r\n    this.el = el;\r\n    this.list = el.classList;\r\n  }\r\n\r\n  /**\r\n    * Add class `name` if not already present.\r\n    *\r\n    * @param {String} name\r\n    * @return {ClassList}\r\n    * @api public\r\n    */\r\n\r\n  ClassList$1.prototype.add = function(name) {\r\n    this.list.add(name);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n    * Remove class `name` when present, or\r\n    * pass a regular expression to remove\r\n    * any which match.\r\n    *\r\n    * @param {String|RegExp} name\r\n    * @return {ClassList}\r\n    * @api public\r\n    */\r\n\r\n  ClassList$1.prototype.remove = function(name) {\r\n    if ('[object RegExp]' == toString$1.call(name)) {\r\n      return this.removeMatching(name);\r\n    }\r\n\r\n    this.list.remove(name);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n    * Remove all classes matching `re`.\r\n    *\r\n    * @param {RegExp} re\r\n    * @return {ClassList}\r\n    * @api private\r\n    */\r\n\r\n  ClassList$1.prototype.removeMatching = function(re) {\r\n    const arr = this.array();\r\n    for (let i = 0; i < arr.length; i++) {\r\n      if (re.test(arr[i])) {\r\n        this.remove(arr[i]);\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  /**\r\n    * Toggle class `name`, can force state via `force`.\r\n    *\r\n    * For browsers that support classList, but do not support `force` yet,\r\n    * the mistake will be detected and corrected.\r\n    *\r\n    * @param {String} name\r\n    * @param {Boolean} force\r\n    * @return {ClassList}\r\n    * @api public\r\n    */\r\n\r\n  ClassList$1.prototype.toggle = function(name, force) {\r\n    if ('undefined' !== typeof force) {\r\n      if (force !== this.list.toggle(name, force)) {\r\n        this.list.toggle(name); // toggle again to correct\r\n      }\r\n    } else {\r\n      this.list.toggle(name);\r\n    }\r\n    return this;\r\n  };\r\n\r\n  /**\r\n    * Return an array of classes.\r\n    *\r\n    * @return {Array}\r\n    * @api public\r\n    */\r\n\r\n  ClassList$1.prototype.array = function() {\r\n    return Array.from(this.list);\r\n  };\r\n\r\n  /**\r\n    * Check if class `name` is present.\r\n    *\r\n    * @param {String} name\r\n    * @return {ClassList}\r\n    * @api public\r\n    */\r\n\r\n  ClassList$1.prototype.has =\r\n   ClassList$1.prototype.contains = function(name) {\r\n     return this.list.contains(name);\r\n   };\n\n  var ns = {\n    svg: 'http://www.w3.org/2000/svg'\n  };\n\n  /**\n   * DOM parsing utility\n   */\n\n\n  var SVG_START = '<svg xmlns=\"' + ns.svg + '\"';\n\n  function parse$1(svg) {\n\n    var unwrap = false;\n\n    // ensure we import a valid svg document\n    if (svg.substring(0, 4) === '<svg') {\n      if (svg.indexOf(ns.svg) === -1) {\n        svg = SVG_START + svg.substring(4);\n      }\n    } else {\n\n      // namespace svg\n      svg = SVG_START + '>' + svg + '</svg>';\n      unwrap = true;\n    }\n\n    var parsed = parseDocument(svg);\n\n    if (!unwrap) {\n      return parsed;\n    }\n\n    var fragment = document.createDocumentFragment();\n\n    var parent = parsed.firstChild;\n\n    while (parent.firstChild) {\n      fragment.appendChild(parent.firstChild);\n    }\n\n    return fragment;\n  }\n\n  function parseDocument(svg) {\n\n    var parser;\n\n    // parse\n    parser = new DOMParser();\n    parser.async = false;\n\n    return parser.parseFromString(svg, 'text/xml');\n  }\n\n  /**\n   * Create utility for SVG elements\n   */\n\n\n\n  /**\n   * Create a specific type from name or SVG markup.\n   *\n   * @param {String} name the name or markup of the element\n   * @param {Object} [attrs] attributes to set on the element\n   *\n   * @returns {SVGElement}\n   */\n  function create$1(name, attrs) {\n    var element;\n\n    name = name.trim();\n\n    if (name.charAt(0) === '<') {\n      element = parse$1(name).firstChild;\n      element = document.importNode(element, true);\n    } else {\n      element = document.createElementNS(ns.svg, name);\n    }\n\n    if (attrs) {\n      attr$1(element, attrs);\n    }\n\n    return element;\n  }\n\n  /**\n   * Geometry helpers\n   */\n\n\n  // fake node used to instantiate svg geometry elements\n  var node = null;\n\n  function getNode() {\n    if (node === null) {\n      node = create$1('svg');\n    }\n\n    return node;\n  }\n\n  function extend$1(object, props) {\n    var i, k, keys = Object.keys(props);\n\n    for (i = 0; (k = keys[i]); i++) {\n      object[k] = props[k];\n    }\n\n    return object;\n  }\n\n  /**\n   * Create matrix via args.\n   *\n   * @example\n   *\n   * createMatrix({ a: 1, b: 1 });\n   * createMatrix();\n   * createMatrix(1, 2, 0, 0, 30, 20);\n   *\n   * @return {SVGMatrix}\n   */\n  function createMatrix(a, b, c, d, e, f) {\n    var matrix = getNode().createSVGMatrix();\n\n    switch (arguments.length) {\n    case 0:\n      return matrix;\n    case 1:\n      return extend$1(matrix, a);\n    case 6:\n      return extend$1(matrix, {\n        a: a,\n        b: b,\n        c: c,\n        d: d,\n        e: e,\n        f: f\n      });\n    }\n  }\n\n  function createTransform(matrix) {\n    {\n      return getNode().createSVGTransform();\n    }\n  }\n\n  /**\n   * Serialization util\n   */\n\n  var TEXT_ENTITIES = /([&<>]{1})/g;\n  var ATTR_ENTITIES = /([\\n\\r\"]{1})/g;\n\n  var ENTITY_REPLACEMENT = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '\\''\n  };\n\n  function escape$1(str, pattern) {\n\n    function replaceFn(match, entity) {\n      return ENTITY_REPLACEMENT[entity] || entity;\n    }\n\n    return str.replace(pattern, replaceFn);\n  }\n\n  function serialize(node, output) {\n\n    var i, len, attrMap, attrNode, childNodes;\n\n    switch (node.nodeType) {\n\n    // TEXT\n    case 3:\n\n      // replace special XML characters\n      output.push(escape$1(node.textContent, TEXT_ENTITIES));\n      break;\n\n    // ELEMENT\n    case 1:\n      output.push('<', node.tagName);\n\n      if (node.hasAttributes()) {\n        attrMap = node.attributes;\n        for (i = 0, len = attrMap.length; i < len; ++i) {\n          attrNode = attrMap.item(i);\n          output.push(' ', attrNode.name, '=\"', escape$1(attrNode.value, ATTR_ENTITIES), '\"');\n        }\n      }\n\n      if (node.hasChildNodes()) {\n        output.push('>');\n        childNodes = node.childNodes;\n        for (i = 0, len = childNodes.length; i < len; ++i) {\n          serialize(childNodes.item(i), output);\n        }\n        output.push('</', node.tagName, '>');\n      } else {\n        output.push('/>');\n      }\n      break;\n\n    // COMMENT\n    case 8:\n      output.push('<!--', escape$1(node.nodeValue, TEXT_ENTITIES), '-->');\n      break;\n\n    // CDATA\n    case 4:\n      output.push('<![CDATA[', node.nodeValue, ']]>');\n      break;\n\n    default:\n      throw new Error('unable to handle node ' + node.nodeType);\n    }\n\n    return output;\n  }\n\n  function get(element) {\n    var child = element.firstChild,\n        output = [];\n\n    while (child) {\n      serialize(child, output);\n      child = child.nextSibling;\n    }\n\n    return output.join('');\n  }\n\n  function innerSVG(element, svg) {\n\n    {\n      return get(element);\n    }\n  }\n\n  function remove$2(element) {\n    var parent = element.parentNode;\n\n    if (parent) {\n      parent.removeChild(element);\n    }\n\n    return element;\n  }\n\n  /**\n   * transform accessor utility\n   */\n\n  function wrapMatrix(transformList, transform) {\n    if (transform instanceof SVGMatrix) {\n      return transformList.createSVGTransformFromMatrix(transform);\n    }\n\n    return transform;\n  }\n\n\n  function setTransforms(transformList, transforms) {\n    var i, t;\n\n    transformList.clear();\n\n    for (i = 0; (t = transforms[i]); i++) {\n      transformList.appendItem(wrapMatrix(transformList, t));\n    }\n  }\n\n  /**\n   * Get or set the transforms on the given node.\n   *\n   * @param {SVGElement} node\n   * @param  {SVGTransform|SVGMatrix|Array<SVGTransform|SVGMatrix>} [transforms]\n   *\n   * @return {SVGTransform} the consolidated transform\n   */\n  function transform$1(node, transforms) {\n    var transformList = node.transform.baseVal;\n\n    if (transforms) {\n\n      if (!Array.isArray(transforms)) {\n        transforms = [ transforms ];\n      }\n\n      setTransforms(transformList, transforms);\n    }\n\n    return transformList.consolidate();\n  }\n\n  /**\n   * @typedef {(string|number)[]} Component\n   *\n   * @typedef {import('../util/Types').Point} Point\n   */\n\n  /**\n   * @param {Component[] | Component[][]} elements\n   *\n   * @return {string}\n   */\n  function componentsToPath(elements) {\n    return elements.flat().join(',').replace(/,?([A-Za-z]),?/g, '$1');\n  }\n\n  /**\n   * @param {Point} point\n   *\n   * @return {Component[]}\n   */\n  function move(point) {\n    return [ 'M', point.x, point.y ];\n  }\n\n  /**\n   * @param {Point} point\n   *\n   * @return {Component[]}\n   */\n  function lineTo(point) {\n    return [ 'L', point.x, point.y ];\n  }\n\n  /**\n   * @param {Point} p1\n   * @param {Point} p2\n   * @param {Point} p3\n   *\n   * @return {Component[]}\n   */\n  function curveTo(p1, p2, p3) {\n    return [ 'C', p1.x, p1.y, p2.x, p2.y, p3.x, p3.y ];\n  }\n\n  /**\n   * @param {Point[]} waypoints\n   * @param {number} [cornerRadius]\n   * @return {Component[][]}\n   */\n  function drawPath(waypoints, cornerRadius) {\n    const pointCount = waypoints.length;\n\n    const path = [ move(waypoints[0]) ];\n\n    for (let i = 1; i < pointCount; i++) {\n\n      const pointBefore = waypoints[i - 1];\n      const point = waypoints[i];\n      const pointAfter = waypoints[i + 1];\n\n      if (!pointAfter || !cornerRadius) {\n        path.push(lineTo(point));\n\n        continue;\n      }\n\n      const effectiveRadius = Math.min(\n        cornerRadius,\n        vectorLength(point.x - pointBefore.x, point.y - pointBefore.y),\n        vectorLength(pointAfter.x - point.x, pointAfter.y - point.y)\n      );\n\n      if (!effectiveRadius) {\n        path.push(lineTo(point));\n\n        continue;\n      }\n\n      const beforePoint = getPointAtLength(point, pointBefore, effectiveRadius);\n      const beforePoint2 = getPointAtLength(point, pointBefore, effectiveRadius * .5);\n\n      const afterPoint = getPointAtLength(point, pointAfter, effectiveRadius);\n      const afterPoint2 = getPointAtLength(point, pointAfter, effectiveRadius * .5);\n\n      path.push(lineTo(beforePoint));\n      path.push(curveTo(beforePoint2, afterPoint2, afterPoint));\n    }\n\n    return path;\n  }\n\n  function getPointAtLength(start, end, length) {\n\n    const deltaX = end.x - start.x;\n    const deltaY = end.y - start.y;\n\n    const totalLength = vectorLength(deltaX, deltaY);\n\n    const percent = length / totalLength;\n\n    return {\n      x: start.x + deltaX * percent,\n      y: start.y + deltaY * percent\n    };\n  }\n\n  function vectorLength(x, y) {\n    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n  }\n\n  /**\n   * @param {Point[]} points\n   * @param {number|Object} [attrs]\n   * @param {number} [radius]\n   *\n   * @return {SVGElement}\n   */\n  function createLine(points, attrs, radius) {\n\n    if (isNumber(attrs)) {\n      radius = attrs;\n      attrs = null;\n    }\n\n    if (!attrs) {\n      attrs = {};\n    }\n\n    const line = create$1('path', attrs);\n\n    if (isNumber(radius)) {\n      line.dataset.cornerRadius = String(radius);\n    }\n\n    return updateLine(line, points);\n  }\n\n  /**\n   * @param {SVGElement} gfx\n   * @param {Point[]} points\n   *\n   * @return {SVGElement}\n   */\n  function updateLine(gfx, points) {\n\n    const cornerRadius = parseInt(gfx.dataset.cornerRadius, 10) || 0;\n\n    attr$1(gfx, {\n      d: componentsToPath(drawPath(points, cornerRadius))\n    });\n\n    return gfx;\n  }\n\n  var black = 'hsl(225, 10%, 15%)';\r\n  var white = 'white';\r\n\r\n  // element utils //////////////////////\r\n\r\n  /**\r\n   * Checks if eventDefinition of the given element matches with semantic type.\r\n   *\r\n   * @param {ModdleElement} event\r\n   * @param {string} eventDefinitionType\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  function isTypedEvent(event, eventDefinitionType) {\r\n    return some(event.eventDefinitions, function(definition) {\r\n      return definition.$type === eventDefinitionType;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if element is a throw event.\r\n   *\r\n   * @param {ModdleElement} event\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  function isThrowEvent(event) {\r\n    return (event.$type === 'bpmn:IntermediateThrowEvent') || (event.$type === 'bpmn:EndEvent');\r\n  }\r\n\r\n  /**\r\n   * Check if element is a throw event.\r\n   *\r\n   * @param {ModdleElement} element\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  function isCollection(element) {\r\n    var dataObject = element.dataObjectRef;\r\n\r\n    return element.isCollection || (dataObject && dataObject.isCollection);\r\n  }\r\n\r\n\r\n  // color access //////////////////////\r\n\r\n  /**\r\n   * @param {Element} element\r\n   * @param {string} [defaultColor]\r\n   * @param {string} [overrideColor]\r\n   *\r\n   * @return {string}\r\n   */\r\n  function getFillColor(element, defaultColor, overrideColor) {\r\n    var di = getDi(element);\r\n\r\n    return overrideColor || di.get('color:background-color') || di.get('bioc:fill') || defaultColor || white;\r\n  }\r\n\r\n  /**\r\n   * @param {Element} element\r\n   * @param {string} [defaultColor]\r\n   * @param {string} [overrideColor]\r\n   *\r\n   * @return {string}\r\n   */\r\n  function getStrokeColor(element, defaultColor, overrideColor) {\r\n    var di = getDi(element);\r\n\r\n    return overrideColor || di.get('color:border-color') || di.get('bioc:stroke') || defaultColor || black;\r\n  }\r\n\r\n  /**\r\n   * @param {Element} element\r\n   * @param {string} [defaultColor]\r\n   * @param {string} [defaultStrokeColor]\r\n   * @param {string} [overrideColor]\r\n   *\r\n   * @return {string}\r\n   */\r\n  function getLabelColor(element, defaultColor, defaultStrokeColor, overrideColor) {\r\n    var di = getDi(element),\r\n        label = di.get('label');\r\n\r\n    return overrideColor || (label && label.get('color:color')) || defaultColor ||\r\n      getStrokeColor(element, defaultStrokeColor);\r\n  }\r\n\r\n  // cropping path customizations //////////////////////\r\n\r\n  /**\r\n   * @param {ShapeLike} shape\r\n   *\r\n   * @return {string} path\r\n   */\r\n  function getCirclePath(shape) {\r\n\r\n    var cx = shape.x + shape.width / 2,\r\n        cy = shape.y + shape.height / 2,\r\n        radius = shape.width / 2;\r\n\r\n    var circlePath = [\r\n      [ 'M', cx, cy ],\r\n      [ 'm', 0, -radius ],\r\n      [ 'a', radius, radius, 0, 1, 1, 0, 2 * radius ],\r\n      [ 'a', radius, radius, 0, 1, 1, 0, -2 * radius ],\r\n      [ 'z' ]\r\n    ];\r\n\r\n    return componentsToPath(circlePath);\r\n  }\r\n\r\n  /**\r\n   * @param {ShapeLike} shape\r\n   * @param {number} [borderRadius]\r\n   *\r\n   * @return {string} path\r\n   */\r\n  function getRoundRectPath(shape, borderRadius) {\r\n\r\n    var x = shape.x,\r\n        y = shape.y,\r\n        width = shape.width,\r\n        height = shape.height;\r\n\r\n    var roundRectPath = [\r\n      [ 'M', x + borderRadius, y ],\r\n      [ 'l', width - borderRadius * 2, 0 ],\r\n      [ 'a', borderRadius, borderRadius, 0, 0, 1, borderRadius, borderRadius ],\r\n      [ 'l', 0, height - borderRadius * 2 ],\r\n      [ 'a', borderRadius, borderRadius, 0, 0, 1, -10, borderRadius ],\r\n      [ 'l', borderRadius * 2 - width, 0 ],\r\n      [ 'a', borderRadius, borderRadius, 0, 0, 1, -10, -10 ],\r\n      [ 'l', 0, borderRadius * 2 - height ],\r\n      [ 'a', borderRadius, borderRadius, 0, 0, 1, borderRadius, -10 ],\r\n      [ 'z' ]\r\n    ];\r\n\r\n    return componentsToPath(roundRectPath);\r\n  }\r\n\r\n  /**\r\n   * @param {ShapeLike} shape\r\n   *\r\n   * @return {string} path\r\n   */\r\n  function getDiamondPath(shape) {\r\n\r\n    var width = shape.width,\r\n        height = shape.height,\r\n        x = shape.x,\r\n        y = shape.y,\r\n        halfWidth = width / 2,\r\n        halfHeight = height / 2;\r\n\r\n    var diamondPath = [\r\n      [ 'M', x + halfWidth, y ],\r\n      [ 'l', halfWidth, halfHeight ],\r\n      [ 'l', -halfWidth, halfHeight ],\r\n      [ 'l', -halfWidth, -halfHeight ],\r\n      [ 'z' ]\r\n    ];\r\n\r\n    return componentsToPath(diamondPath);\r\n  }\r\n\r\n  /**\r\n   * @param {ShapeLike} shape\r\n   *\r\n   * @return {string} path\r\n   */\r\n  function getRectPath(shape) {\r\n    var x = shape.x,\r\n        y = shape.y,\r\n        width = shape.width,\r\n        height = shape.height;\r\n\r\n    var rectPath = [\r\n      [ 'M', x, y ],\r\n      [ 'l', width, 0 ],\r\n      [ 'l', 0, height ],\r\n      [ 'l', -width, 0 ],\r\n      [ 'z' ]\r\n    ];\r\n\r\n    return componentsToPath(rectPath);\r\n  }\r\n\r\n  /**\r\n   * Get width and height from element or overrides.\r\n   *\r\n   * @param {Dimensions|Rect|ShapeLike} bounds\r\n   * @param {Object} overrides\r\n   *\r\n   * @returns {Dimensions}\r\n   */\r\n  function getBounds(bounds, overrides = {}) {\r\n    return {\r\n      width: getWidth(bounds, overrides),\r\n      height: getHeight(bounds, overrides)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get width from element or overrides.\r\n   *\r\n   * @param {Dimensions|Rect|ShapeLike} bounds\r\n   * @param {Object} overrides\r\n   *\r\n   * @returns {number}\r\n   */\r\n  function getWidth(bounds, overrides = {}) {\r\n    return has$1(overrides, 'width') ? overrides.width : bounds.width;\r\n  }\r\n\r\n  /**\r\n   * Get height from element or overrides.\r\n   *\r\n   * @param {Dimensions|Rect|ShapeLike} bounds\r\n   * @param {Object} overrides\r\n   *\r\n   * @returns {number}\r\n   */\r\n  function getHeight(bounds, overrides = {}) {\r\n    return has$1(overrides, 'height') ? overrides.height : bounds.height;\r\n  }\n\n  function _mergeNamespaces$1(n, m) {\n    m.forEach(function (e) {\n      e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n        if (k !== 'default' && !(k in n)) {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () { return e[k]; }\n          });\n        }\n      });\n    });\n    return Object.freeze(n);\n  }\n\n  /**\n   * Flatten array, one level deep.\n   *\n   * @template T\n   *\n   * @param {T[][] | T[] | null} [arr]\n   *\n   * @return {T[]}\n   */\n\n  const nativeToString = Object.prototype.toString;\n  const nativeHasOwnProperty = Object.prototype.hasOwnProperty;\n\n  function isUndefined$1(obj) {\n    return obj === undefined;\n  }\n\n  function isArray$1(obj) {\n    return nativeToString.call(obj) === '[object Array]';\n  }\n\n  /**\n   * Return true, if target owns a property with the given key.\n   *\n   * @param {Object} target\n   * @param {String} key\n   *\n   * @return {Boolean}\n   */\n  function has(target, key) {\n    return nativeHasOwnProperty.call(target, key);\n  }\n\n\n  /**\n   * Iterate over collection; returning something\n   * (non-undefined) will stop iteration.\n   *\n   * @template T\n   * @param {Collection<T>} collection\n   * @param { ((item: T, idx: number) => (boolean|void)) | ((item: T, key: string) => (boolean|void)) } iterator\n   *\n   * @return {T} return result that stopped the iteration\n   */\n  function forEach(collection, iterator) {\n\n    let val,\n        result;\n\n    if (isUndefined$1(collection)) {\n      return;\n    }\n\n    const convertKey = isArray$1(collection) ? toNum : identity;\n\n    for (let key in collection) {\n\n      if (has(collection, key)) {\n        val = collection[key];\n\n        result = iterator(val, convertKey(key));\n\n        if (result === false) {\n          return val;\n        }\n      }\n    }\n  }\n\n\n  function identity(arg) {\n    return arg;\n  }\n\n  function toNum(arg) {\n    return Number(arg);\n  }\n\n  /**\n   * Assigns style attributes in a style-src compliant way.\n   *\n   * @param {Element} element\n   * @param {...Object} styleSources\n   *\n   * @return {Element} the element\n   */\n  function assign(element, ...styleSources) {\n    const target = element.style;\n\n    forEach(styleSources, function(style) {\n      if (!style) {\n        return;\n      }\n\n      forEach(style, function(value, key) {\n        target[key] = value;\n      });\n    });\n\n    return element;\n  }\n\n  /**\n   * Set attribute `name` to `val`, or get attr `name`.\n   *\n   * @param {Element} el\n   * @param {String} name\n   * @param {String} [val]\n   * @api public\n   */\n  function attr(el, name, val) {\n\n    // get\n    if (arguments.length == 2) {\n      return el.getAttribute(name);\n    }\n\n    // remove\n    if (val === null) {\n      return el.removeAttribute(name);\n    }\n\n    // set\n    el.setAttribute(name, val);\n\n    return el;\n  }\n\n  /**\n   * Taken from https://github.com/component/classes\n   *\n   * Without the component bits.\n   */\n\n  /**\n   * toString reference.\n   */\n\n  const toString = Object.prototype.toString;\n\n  /**\n   * Wrap `el` in a `ClassList`.\n   *\n   * @param {Element} el\n   * @return {ClassList}\n   * @api public\n   */\n\n  function classes(el) {\n    return new ClassList(el);\n  }\n\n  /**\n   * Initialize a new ClassList for `el`.\n   *\n   * @param {Element} el\n   * @api private\n   */\n\n  function ClassList(el) {\n    if (!el || !el.nodeType) {\n      throw new Error('A DOM element reference is required');\n    }\n    this.el = el;\n    this.list = el.classList;\n  }\n\n  /**\n   * Add class `name` if not already present.\n   *\n   * @param {String} name\n   * @return {ClassList}\n   * @api public\n   */\n\n  ClassList.prototype.add = function(name) {\n    this.list.add(name);\n    return this;\n  };\n\n  /**\n   * Remove class `name` when present, or\n   * pass a regular expression to remove\n   * any which match.\n   *\n   * @param {String|RegExp} name\n   * @return {ClassList}\n   * @api public\n   */\n\n  ClassList.prototype.remove = function(name) {\n    if ('[object RegExp]' == toString.call(name)) {\n      return this.removeMatching(name);\n    }\n\n    this.list.remove(name);\n    return this;\n  };\n\n  /**\n   * Remove all classes matching `re`.\n   *\n   * @param {RegExp} re\n   * @return {ClassList}\n   * @api private\n   */\n\n  ClassList.prototype.removeMatching = function(re) {\n    const arr = this.array();\n    for (let i = 0; i < arr.length; i++) {\n      if (re.test(arr[i])) {\n        this.remove(arr[i]);\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Toggle class `name`, can force state via `force`.\n   *\n   * For browsers that support classList, but do not support `force` yet,\n   * the mistake will be detected and corrected.\n   *\n   * @param {String} name\n   * @param {Boolean} force\n   * @return {ClassList}\n   * @api public\n   */\n\n  ClassList.prototype.toggle = function(name, force) {\n    if ('undefined' !== typeof force) {\n      if (force !== this.list.toggle(name, force)) {\n        this.list.toggle(name); // toggle again to correct\n      }\n    } else {\n      this.list.toggle(name);\n    }\n    return this;\n  };\n\n  /**\n   * Return an array of classes.\n   *\n   * @return {Array}\n   * @api public\n   */\n\n  ClassList.prototype.array = function() {\n    return Array.from(this.list);\n  };\n\n  /**\n   * Check if class `name` is present.\n   *\n   * @param {String} name\n   * @return {ClassList}\n   * @api public\n   */\n\n  ClassList.prototype.has =\n  ClassList.prototype.contains = function(name) {\n    return this.list.contains(name);\n  };\n\n  /**\n   * Clear utility\n   */\n\n  /**\n   * Removes all children from the given element\n   *\n   * @param {Element} element\n   *\n   * @return {Element} the element (for chaining)\n   */\n  function clear(element) {\n    var child;\n\n    while ((child = element.firstChild)) {\n      element.removeChild(child);\n    }\n\n    return element;\n  }\n\n  /**\n   * Closest\n   *\n   * @param {Element} el\n   * @param {string} selector\n   * @param {boolean} checkYourSelf (optional)\n   */\n  function closest(element, selector, checkYourSelf) {\n    var actualElement = checkYourSelf ? element : element.parentNode;\n\n    return actualElement && typeof actualElement.closest === 'function' && actualElement.closest(selector) || null;\n  }\n\n  var componentEvent = {};\n\n  var bind$1, unbind$1, prefix$6;\n\n  function detect () {\n    bind$1 = window.addEventListener ? 'addEventListener' : 'attachEvent';\n    unbind$1 = window.removeEventListener ? 'removeEventListener' : 'detachEvent';\n    prefix$6 = bind$1 !== 'addEventListener' ? 'on' : '';\n  }\n\n  /**\n   * Bind `el` event `type` to `fn`.\n   *\n   * @param {Element} el\n   * @param {String} type\n   * @param {Function} fn\n   * @param {Boolean} capture\n   * @return {Function}\n   * @api public\n   */\n\n  var bind_1 = componentEvent.bind = function(el, type, fn, capture){\n    if (!bind$1) detect();\n    el[bind$1](prefix$6 + type, fn, capture || false);\n    return fn;\n  };\n\n  /**\n   * Unbind `el` event `type`'s callback `fn`.\n   *\n   * @param {Element} el\n   * @param {String} type\n   * @param {Function} fn\n   * @param {Boolean} capture\n   * @return {Function}\n   * @api public\n   */\n\n  var unbind_1 = componentEvent.unbind = function(el, type, fn, capture){\n    if (!unbind$1) detect();\n    el[unbind$1](prefix$6 + type, fn, capture || false);\n    return fn;\n  };\n\n  var event = /*#__PURE__*/_mergeNamespaces$1({\n    __proto__: null,\n    bind: bind_1,\n    unbind: unbind_1,\n    'default': componentEvent\n  }, [componentEvent]);\n\n  /**\n   * Module dependencies.\n   */\n\n  /**\n   * Delegate event `type` to `selector`\n   * and invoke `fn(e)`. A callback function\n   * is returned which may be passed to `.unbind()`.\n   *\n   * @param {Element} el\n   * @param {String} selector\n   * @param {String} type\n   * @param {Function} fn\n   * @param {Boolean} capture\n   * @return {Function}\n   * @api public\n   */\n\n  // Some events don't bubble, so we want to bind to the capture phase instead\n  // when delegating.\n  var forceCaptureEvents = [ 'focus', 'blur' ];\n\n  function bind(el, selector, type, fn, capture) {\n    if (forceCaptureEvents.indexOf(type) !== -1) {\n      capture = true;\n    }\n\n    return event.bind(el, type, function(e) {\n      var target = e.target || e.srcElement;\n      e.delegateTarget = closest(target, selector, true);\n      if (e.delegateTarget) {\n        fn.call(el, e);\n      }\n    }, capture);\n  }\n\n  /**\n   * Unbind event `type`'s callback `fn`.\n   *\n   * @param {Element} el\n   * @param {String} type\n   * @param {Function} fn\n   * @param {Boolean} capture\n   * @api public\n   */\n  function unbind(el, type, fn, capture) {\n    if (forceCaptureEvents.indexOf(type) !== -1) {\n      capture = true;\n    }\n\n    return event.unbind(el, type, fn, capture);\n  }\n\n  var delegate = {\n    bind,\n    unbind\n  };\n\n  /**\n   * Expose `parse`.\n   */\n\n  var domify = parse;\n\n  /**\n   * Tests for browser support.\n   */\n\n  var innerHTMLBug = false;\n  var bugTestDiv;\n  if (typeof document !== 'undefined') {\n    bugTestDiv = document.createElement('div');\n    // Setup\n    bugTestDiv.innerHTML = '  <link/><table></table><a href=\"/a\">a</a><input type=\"checkbox\"/>';\n    // Make sure that link elements get serialized correctly by innerHTML\n    // This requires a wrapper element in IE\n    innerHTMLBug = !bugTestDiv.getElementsByTagName('link').length;\n    bugTestDiv = undefined;\n  }\n\n  /**\n   * Wrap map from jquery.\n   */\n\n  var map = {\n    legend: [1, '<fieldset>', '</fieldset>'],\n    tr: [2, '<table><tbody>', '</tbody></table>'],\n    col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],\n    // for script/link/style tags to work in IE6-8, you have to wrap\n    // in a div with a non-whitespace character in front, ha!\n    _default: innerHTMLBug ? [1, 'X<div>', '</div>'] : [0, '', '']\n  };\n\n  map.td =\n  map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\n\n  map.option =\n  map.optgroup = [1, '<select multiple=\"multiple\">', '</select>'];\n\n  map.thead =\n  map.tbody =\n  map.colgroup =\n  map.caption =\n  map.tfoot = [1, '<table>', '</table>'];\n\n  map.polyline =\n  map.ellipse =\n  map.polygon =\n  map.circle =\n  map.text =\n  map.line =\n  map.path =\n  map.rect =\n  map.g = [1, '<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">','</svg>'];\n\n  /**\n   * Parse `html` and return a DOM Node instance, which could be a TextNode,\n   * HTML DOM Node of some kind (<div> for example), or a DocumentFragment\n   * instance, depending on the contents of the `html` string.\n   *\n   * @param {String} html - HTML string to \"domify\"\n   * @param {Document} doc - The `document` instance to create the Node for\n   * @return {DOMNode} the TextNode, DOM Node, or DocumentFragment instance\n   * @api private\n   */\n\n  function parse(html, doc) {\n    if ('string' != typeof html) throw new TypeError('String expected');\n\n    // default to the global `document` object\n    if (!doc) doc = document;\n\n    // tag name\n    var m = /<([\\w:]+)/.exec(html);\n    if (!m) return doc.createTextNode(html);\n\n    html = html.replace(/^\\s+|\\s+$/g, ''); // Remove leading/trailing whitespace\n\n    var tag = m[1];\n\n    // body support\n    if (tag == 'body') {\n      var el = doc.createElement('html');\n      el.innerHTML = html;\n      return el.removeChild(el.lastChild);\n    }\n\n    // wrap map\n    var wrap = Object.prototype.hasOwnProperty.call(map, tag) ? map[tag] : map._default;\n    var depth = wrap[0];\n    var prefix = wrap[1];\n    var suffix = wrap[2];\n    var el = doc.createElement('div');\n    el.innerHTML = prefix + html + suffix;\n    while (depth--) el = el.lastChild;\n\n    // one element\n    if (el.firstChild == el.lastChild) {\n      return el.removeChild(el.firstChild);\n    }\n\n    // several elements\n    var fragment = doc.createDocumentFragment();\n    while (el.firstChild) {\n      fragment.appendChild(el.removeChild(el.firstChild));\n    }\n\n    return fragment;\n  }\n\n  var domify$1 = domify;\n\n  function query(selector, el) {\n    el = el || document;\n\n    return el.querySelector(selector);\n  }\n\n  function all(selector, el) {\n    el = el || document;\n\n    return el.querySelectorAll(selector);\n  }\n\n  function remove$1(el) {\n    el.parentNode && el.parentNode.removeChild(el);\n  }\n\n  /**\r\n   * @param {SVGElement} gfx\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {number} [angle]\r\n   * @param {number} [amount]\r\n   */\r\n  function transform(gfx, x, y, angle, amount) {\r\n    var translate = createTransform();\r\n    translate.setTranslate(x, y);\r\n\r\n    var rotate = createTransform();\r\n    rotate.setRotate(angle || 0, 0, 0);\r\n\r\n    var scale = createTransform();\r\n    scale.setScale(1, 1);\r\n\r\n    transform$1(gfx, [ translate, rotate, scale ]);\r\n  }\r\n\r\n\r\n  /**\r\n   * @param {SVGElement} gfx\r\n   * @param {number} x\r\n   * @param {number} y\r\n   */\r\n  function translate$1(gfx, x, y) {\r\n    var translate = createTransform();\r\n    translate.setTranslate(x, y);\r\n\r\n    transform$1(gfx, translate);\r\n  }\r\n\r\n\r\n  /**\r\n   * @param {SVGElement} gfx\r\n   * @param {number} angle\r\n   */\r\n  function rotate(gfx, angle) {\r\n    var rotate = createTransform();\r\n    rotate.setRotate(angle, 0, 0);\r\n\r\n    transform$1(gfx, rotate);\r\n  }\n\n  function createCommonjsModule(fn, module) {\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  var hat_1 = createCommonjsModule(function (module) {\n  var hat = module.exports = function (bits, base) {\n      if (!base) base = 16;\n      if (bits === undefined) bits = 128;\n      if (bits <= 0) return '0';\n      \n      var digits = Math.log(Math.pow(2, bits)) / Math.log(base);\n      for (var i = 2; digits === Infinity; i *= 2) {\n          digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;\n      }\n      \n      var rem = digits - Math.floor(digits);\n      \n      var res = '';\n      \n      for (var i = 0; i < Math.floor(digits); i++) {\n          var x = Math.floor(Math.random() * base).toString(base);\n          res = x + res;\n      }\n      \n      if (rem) {\n          var b = Math.pow(base, rem);\n          var x = Math.floor(Math.random() * b).toString(base);\n          res = x + res;\n      }\n      \n      var parsed = parseInt(res, base);\n      if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {\n          return hat(bits, base)\n      }\n      else return res;\n  };\n\n  hat.rack = function (bits, base, expandBy) {\n      var fn = function (data) {\n          var iters = 0;\n          do {\n              if (iters ++ > 10) {\n                  if (expandBy) bits += expandBy;\n                  else throw new Error('too many ID collisions, use more bits')\n              }\n              \n              var id = hat(bits, base);\n          } while (Object.hasOwnProperty.call(hats, id));\n          \n          hats[id] = data;\n          return id;\n      };\n      var hats = fn.hats = {};\n      \n      fn.get = function (id) {\n          return fn.hats[id];\n      };\n      \n      fn.set = function (id, value) {\n          fn.hats[id] = value;\n          return fn;\n      };\n      \n      fn.bits = bits || 128;\n      fn.base = base || 16;\n      return fn;\n  };\n  });\n\n  /**\n   * Create a new id generator / cache instance.\n   *\n   * You may optionally provide a seed that is used internally.\n   *\n   * @param {Seed} seed\n   */\n  function Ids(seed) {\n    if (!(this instanceof Ids)) {\n      return new Ids(seed);\n    }\n    seed = seed || [128, 36, 1];\n    this._seed = seed.length ? hat_1.rack(seed[0], seed[1], seed[2]) : seed;\n  }\n\n  /**\n   * Generate a next id.\n   *\n   * @param {Object} [element] element to bind the id to\n   *\n   * @return {String} id\n   */\n  Ids.prototype.next = function (element) {\n    return this._seed(element || true);\n  };\n\n  /**\n   * Generate a next id with a given prefix.\n   *\n   * @param {Object} [element] element to bind the id to\n   *\n   * @return {String} id\n   */\n  Ids.prototype.nextPrefixed = function (prefix, element) {\n    var id;\n    do {\n      id = prefix + this.next(true);\n    } while (this.assigned(id));\n\n    // claim {prefix}{random}\n    this.claim(id, element);\n\n    // return\n    return id;\n  };\n\n  /**\n   * Manually claim an existing id.\n   *\n   * @param {String} id\n   * @param {String} [element] element the id is claimed by\n   */\n  Ids.prototype.claim = function (id, element) {\n    this._seed.set(id, element || true);\n  };\n\n  /**\n   * Returns true if the given id has already been assigned.\n   *\n   * @param  {String} id\n   * @return {Boolean}\n   */\n  Ids.prototype.assigned = function (id) {\n    return this._seed.get(id) || false;\n  };\n\n  /**\n   * Unclaim an id.\n   *\n   * @param  {String} id the id to unclaim\n   */\n  Ids.prototype.unclaim = function (id) {\n    delete this._seed.hats[id];\n  };\n\n  /**\n   * Clear all claimed ids.\n   */\n  Ids.prototype.clear = function () {\n    var hats = this._seed.hats,\n      id;\n    for (id in hats) {\n      this.unclaim(id);\n    }\n  };\n\n  var markerIds = new Ids();\n\n  var ELEMENT_LABEL_DISTANCE = 10,\n      INNER_OUTER_DIST = 3,\n      PARTICIPANT_STROKE_WIDTH = 1.5,\n      TASK_BORDER_RADIUS = 10;\n\n  var DEFAULT_OPACITY = 0.95,\n      FULL_OPACITY = 1,\n      LOW_OPACITY = 0.25;\n\n  /**\n   * @typedef { Partial<{\n   *   defaultFillColor: string,\n   *   defaultStrokeColor: string,\n   *   defaultLabelColor: string\n   * }> } BpmnRendererConfig\n   *\n   * @typedef { Partial<{\n   *   fill: string,\n   *   stroke: string,\n   *   width: string,\n   *   height: string\n   * }> } Attrs\n   */\n\n  /**\n   * @typedef { import('../model/Types').Element } Element\n   * @typedef { import('../model/Types').Shape } Shape\n   * @typedef { import('../model/Types').Connection } Connection\n   */\n\n  /**\n   * A renderer for BPMN elements\n   *\n   * @param {BpmnRendererConfig} config\n   * @param {import('diagram-js/lib/core/EventBus').default} eventBus\n   * @param {import('diagram-js/lib/draw/Styles').default} styles\n   * @param {import('./PathMap').default} pathMap\n   * @param {import('diagram-js/lib/core/Canvas').default} canvas\n   * @param {import('./TextRenderer').default} textRenderer\n   * @param {number} [priority]\n   */\n  function BpmnRenderer(\n      config, eventBus, styles, pathMap,\n      canvas, textRenderer, priority) {\n\n    BaseRenderer.call(this, eventBus, priority);\n\n    var defaultFillColor = config && config.defaultFillColor,\n        defaultStrokeColor = config && config.defaultStrokeColor,\n        defaultLabelColor = config && config.defaultLabelColor;\n\n    function shapeStyle(attrs) {\n      return styles.computeStyle(attrs, {\n        strokeLinecap: 'round',\n        strokeLinejoin: 'round',\n        stroke: black,\n        strokeWidth: 2,\n        fill: 'white'\n      });\n    }\n\n    function lineStyle(attrs) {\n      return styles.computeStyle(attrs, [ 'no-fill' ], {\n        strokeLinecap: 'round',\n        strokeLinejoin: 'round',\n        stroke: black,\n        strokeWidth: 2\n      });\n    }\n\n    function addMarker(id, options) {\n      var {\n        ref = { x: 0, y: 0 },\n        scale = 1,\n        element,\n        parentGfx = canvas._svg\n      } = options;\n\n      var marker = create$1('marker', {\n        id: id,\n        viewBox: '0 0 20 20',\n        refX: ref.x,\n        refY: ref.y,\n        markerWidth: 20 * scale,\n        markerHeight: 20 * scale,\n        orient: 'auto'\n      });\n\n      append(marker, element);\n\n      var defs = query(':scope > defs', parentGfx);\n\n      if (!defs) {\n        defs = create$1('defs');\n\n        append(parentGfx, defs);\n      }\n\n      append(defs, marker);\n    }\n\n    function marker(parentGfx, type, fill, stroke) {\n\n\n      var id = markerIds.nextPrefixed('marker-');\n\n      createMarker(parentGfx, id, type, fill, stroke);\n\n      return 'url(#' + id + ')';\n    }\n\n    function createMarker(parentGfx, id, type, fill, stroke) {\n\n      if (type === 'sequenceflow-end') {\n        var sequenceflowEnd = create$1('path', {\n          d: 'M 1 5 L 11 10 L 1 15 Z',\n          ...shapeStyle({\n            fill: stroke,\n            stroke: stroke,\n            strokeWidth: 1\n          })\n        });\n\n        addMarker(id, {\n          element: sequenceflowEnd,\n          ref: { x: 11, y: 10 },\n          scale: 0.5,\n          parentGfx\n        });\n      }\n\n      if (type === 'messageflow-start') {\n        var messageflowStart = create$1('circle', {\n          cx: 6,\n          cy: 6,\n          r: 3.5,\n          ...shapeStyle({\n            fill,\n            stroke: stroke,\n            strokeWidth: 1,\n\n            // fix for safari / chrome / firefox bug not correctly\n            // resetting stroke dash array\n            strokeDasharray: [ 10000, 1 ]\n          })\n        });\n\n        addMarker(id, {\n          element: messageflowStart,\n          ref: { x: 6, y: 6 },\n          parentGfx\n        });\n      }\n\n      if (type === 'messageflow-end') {\n        var messageflowEnd = create$1('path', {\n          d: 'm 1 5 l 0 -3 l 7 3 l -7 3 z',\n          ...shapeStyle({\n            fill,\n            stroke: stroke,\n            strokeWidth: 1,\n\n            // fix for safari / chrome / firefox bug not correctly\n            // resetting stroke dash array\n            strokeDasharray: [ 10000, 1 ]\n          })\n        });\n\n        addMarker(id, {\n          element: messageflowEnd,\n          ref: { x: 8.5, y: 5 },\n          parentGfx\n        });\n      }\n\n      if (type === 'association-start') {\n        var associationStart = create$1('path', {\n          d: 'M 11 5 L 1 10 L 11 15',\n          ...lineStyle({\n            fill: 'none',\n            stroke,\n            strokeWidth: 1.5,\n\n            // fix for safari / chrome / firefox bug not correctly\n            // resetting stroke dash array\n            strokeDasharray: [ 10000, 1 ]\n          })\n        });\n\n        addMarker(id, {\n          element: associationStart,\n          ref: { x: 1, y: 10 },\n          scale: 0.5,\n          parentGfx\n        });\n      }\n\n      if (type === 'association-end') {\n        var associationEnd = create$1('path', {\n          d: 'M 1 5 L 11 10 L 1 15',\n          ...lineStyle({\n            fill: 'none',\n            stroke,\n            strokeWidth: 1.5,\n\n            // fix for safari / chrome / firefox bug not correctly\n            // resetting stroke dash array\n            strokeDasharray: [ 10000, 1 ]\n          })\n        });\n\n        addMarker(id, {\n          element: associationEnd,\n          ref: { x: 11, y: 10 },\n          scale: 0.5,\n          parentGfx\n        });\n      }\n\n      if (type === 'conditional-flow-marker') {\n        var conditionalFlowMarker = create$1('path', {\n          d: 'M 0 10 L 8 6 L 16 10 L 8 14 Z',\n          ...shapeStyle({\n            fill,\n            stroke: stroke\n          })\n        });\n\n        addMarker(id, {\n          element: conditionalFlowMarker,\n          ref: { x: -1, y: 10 },\n          scale: 0.5,\n          parentGfx\n        });\n      }\n\n      if (type === 'conditional-default-flow-marker') {\n        var defaultFlowMarker = create$1('path', {\n          d: 'M 6 4 L 10 16',\n          ...shapeStyle({\n            stroke: stroke,\n            fill: 'none'\n          })\n        });\n\n        addMarker(id, {\n          element: defaultFlowMarker,\n          ref: { x: 0, y: 10 },\n          scale: 0.5,\n          parentGfx\n        });\n      }\n    }\n\n    function drawCircle(parentGfx, width, height, offset, attrs = {}) {\n\n      if (isObject(offset)) {\n        attrs = offset;\n        offset = 0;\n      }\n\n      offset = offset || 0;\n\n      attrs = shapeStyle(attrs);\n\n      var cx = width / 2,\n          cy = height / 2;\n\n      var circle = create$1('circle', {\n        cx: cx,\n        cy: cy,\n        r: Math.round((width + height) / 4 - offset),\n        ...attrs\n      });\n\n      append(parentGfx, circle);\n\n      return circle;\n    }\n\n    function drawRect(parentGfx, width, height, r, offset, attrs) {\n\n      if (isObject(offset)) {\n        attrs = offset;\n        offset = 0;\n      }\n\n      offset = offset || 0;\n\n      attrs = shapeStyle(attrs);\n\n      var rect = create$1('rect', {\n        x: offset,\n        y: offset,\n        width: width - offset * 2,\n        height: height - offset * 2,\n        rx: r,\n        ry: r,\n        ...attrs\n      });\n\n      append(parentGfx, rect);\n\n      return rect;\n    }\n\n    function drawDiamond(parentGfx, width, height, attrs) {\n\n      var x_2 = width / 2;\n      var y_2 = height / 2;\n\n      var points = [\n        { x: x_2, y: 0 },\n        { x: width, y: y_2 },\n        { x: x_2, y: height },\n        { x: 0, y: y_2 }\n      ];\n\n      var pointsString = points.map(function(point) {\n        return point.x + ',' + point.y;\n      }).join(' ');\n\n      attrs = shapeStyle(attrs);\n\n      var polygon = create$1('polygon', {\n        ...attrs,\n        points: pointsString\n      });\n\n      append(parentGfx, polygon);\n\n      return polygon;\n    }\n\n    /**\n     * @param {SVGElement} parentGfx\n     * @param {Point[]} waypoints\n     * @param {any} attrs\n     * @param {number} [radius]\n     *\n     * @return {SVGElement}\n     */\n    function drawLine(parentGfx, waypoints, attrs, radius) {\n      attrs = lineStyle(attrs);\n\n      var line = createLine(waypoints, attrs, radius);\n\n      append(parentGfx, line);\n\n      return line;\n    }\n\n    /**\n     * @param {SVGElement} parentGfx\n     * @param {Point[]} waypoints\n     * @param {any} attrs\n     *\n     * @return {SVGElement}\n     */\n    function drawConnectionSegments(parentGfx, waypoints, attrs) {\n      return drawLine(parentGfx, waypoints, attrs, 5);\n    }\n\n    function drawPath(parentGfx, d, attrs) {\n      attrs = lineStyle(attrs);\n\n      var path = create$1('path', {\n        ...attrs,\n        d\n      });\n\n      append(parentGfx, path);\n\n      return path;\n    }\n\n    function drawMarker(type, parentGfx, path, attrs) {\n      return drawPath(parentGfx, path, assign$1({ 'data-marker': type }, attrs));\n    }\n\n    function renderer(type) {\n      return handlers[type];\n    }\n\n    function as(type) {\n      return function(parentGfx, element, attrs) {\n        return renderer(type)(parentGfx, element, attrs);\n      };\n    }\n\n    var eventIconRenderers = {\n      'bpmn:MessageEventDefinition': function(parentGfx, element, attrs = {}, isThrowing) {\n        var pathData = pathMap.getScaledPath('EVENT_MESSAGE', {\n          xScaleFactor: 0.9,\n          yScaleFactor: 0.9,\n          containerWidth: attrs.width || element.width,\n          containerHeight: attrs.height || element.height,\n          position: {\n            mx: 0.235,\n            my: 0.315\n          }\n        });\n\n        var fill = isThrowing\n          ? getStrokeColor(element, defaultStrokeColor, attrs.stroke)\n          : getFillColor(element, defaultFillColor, attrs.fill);\n\n        var stroke = isThrowing\n          ? getFillColor(element, defaultFillColor, attrs.fill)\n          : getStrokeColor(element, defaultStrokeColor, attrs.stroke);\n\n        var messagePath = drawPath(parentGfx, pathData, {\n          fill,\n          stroke,\n          strokeWidth: 1\n        });\n\n        return messagePath;\n      },\n      'bpmn:TimerEventDefinition': function(parentGfx, element, attrs = {}) {\n        var baseWidth = attrs.width || element.width;\n        var baseHeight = attrs.height || element.height;\n\n        // use a lighter stroke for event suprocess icons\n        var strokeWidth = attrs.width ? 1 : 2;\n\n        var circle = drawCircle(parentGfx, baseWidth, baseHeight, 0.2 * baseHeight, {\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: strokeWidth\n        });\n\n        var pathData = pathMap.getScaledPath('EVENT_TIMER_WH', {\n          xScaleFactor: 0.75,\n          yScaleFactor: 0.75,\n          containerWidth: baseWidth,\n          containerHeight: baseHeight,\n          position: {\n            mx: 0.5,\n            my: 0.5\n          }\n        });\n\n        drawPath(parentGfx, pathData, {\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: strokeWidth\n        });\n\n        for (var i = 0; i < 12; i++) {\n          var linePathData = pathMap.getScaledPath('EVENT_TIMER_LINE', {\n            xScaleFactor: 0.75,\n            yScaleFactor: 0.75,\n            containerWidth: baseWidth,\n            containerHeight: baseHeight,\n            position: {\n              mx: 0.5,\n              my: 0.5\n            }\n          });\n\n          var width = baseWidth / 2,\n              height = baseHeight / 2;\n\n          drawPath(parentGfx, linePathData, {\n            strokeWidth: 1,\n            stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n            transform: 'rotate(' + (i * 30) + ',' + height + ',' + width + ')'\n          });\n        }\n\n        return circle;\n      },\n      'bpmn:EscalationEventDefinition': function(parentGfx, event, attrs = {}, isThrowing) {\n        var pathData = pathMap.getScaledPath('EVENT_ESCALATION', {\n          xScaleFactor: 1,\n          yScaleFactor: 1,\n          containerWidth: attrs.width || event.width,\n          containerHeight: attrs.height || event.height,\n          position: {\n            mx: 0.5,\n            my: 0.2\n          }\n        });\n\n        var fill = isThrowing\n          ? getStrokeColor(event, defaultStrokeColor, attrs.stroke)\n          : getFillColor(event, defaultFillColor, attrs.fill);\n\n        return drawPath(parentGfx, pathData, {\n          fill,\n          stroke: getStrokeColor(event, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1\n        });\n      },\n      'bpmn:ConditionalEventDefinition': function(parentGfx, event, attrs = {}) {\n        var pathData = pathMap.getScaledPath('EVENT_CONDITIONAL', {\n          xScaleFactor: 1,\n          yScaleFactor: 1,\n          containerWidth: attrs.width || event.width,\n          containerHeight: attrs.height || event.height,\n          position: {\n            mx: 0.5,\n            my: 0.222\n          }\n        });\n\n        return drawPath(parentGfx, pathData, {\n          fill: getFillColor(event, defaultFillColor, attrs.fill),\n          stroke: getStrokeColor(event, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1\n        });\n      },\n      'bpmn:LinkEventDefinition': function(parentGfx, event, attrs = {}, isThrowing) {\n        var pathData = pathMap.getScaledPath('EVENT_LINK', {\n          xScaleFactor: 1,\n          yScaleFactor: 1,\n          containerWidth: event.width,\n          containerHeight: event.height,\n          position: {\n            mx: 0.57,\n            my: 0.263\n          }\n        });\n\n        var fill = isThrowing\n          ? getStrokeColor(event, defaultStrokeColor, attrs.stroke)\n          : getFillColor(event, defaultFillColor, attrs.fill);\n\n        return drawPath(parentGfx, pathData, {\n          fill,\n          stroke: getStrokeColor(event, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1\n        });\n      },\n      'bpmn:ErrorEventDefinition': function(parentGfx, event, attrs = {}, isThrowing) {\n        var pathData = pathMap.getScaledPath('EVENT_ERROR', {\n          xScaleFactor: 1.1,\n          yScaleFactor: 1.1,\n          containerWidth: attrs.width || event.width,\n          containerHeight: attrs.height || event.height,\n          position: {\n            mx: 0.2,\n            my: 0.722\n          }\n        });\n\n        var fill = isThrowing\n          ? getStrokeColor(event, defaultStrokeColor, attrs.stroke)\n          : getFillColor(event, defaultFillColor, attrs.fill);\n\n        return drawPath(parentGfx, pathData, {\n          fill,\n          stroke: getStrokeColor(event, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1\n        });\n      },\n      'bpmn:CancelEventDefinition': function(parentGfx, event, attrs = {}, isThrowing) {\n        var pathData = pathMap.getScaledPath('EVENT_CANCEL_45', {\n          xScaleFactor: 1.0,\n          yScaleFactor: 1.0,\n          containerWidth: event.width,\n          containerHeight: event.height,\n          position: {\n            mx: 0.638,\n            my: -0.055\n          }\n        });\n\n        var fill = isThrowing ? getStrokeColor(event, defaultStrokeColor, attrs.stroke) : 'none';\n\n        var path = drawPath(parentGfx, pathData, {\n          fill,\n          stroke: getStrokeColor(event, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1\n        });\n\n        rotate(path, 45);\n\n        return path;\n      },\n      'bpmn:CompensateEventDefinition': function(parentGfx, event, attrs = {}, isThrowing) {\n        var pathData = pathMap.getScaledPath('EVENT_COMPENSATION', {\n          xScaleFactor: 1,\n          yScaleFactor: 1,\n          containerWidth: attrs.width || event.width,\n          containerHeight: attrs.height || event.height,\n          position: {\n            mx: 0.22,\n            my: 0.5\n          }\n        });\n\n        var fill = isThrowing\n          ? getStrokeColor(event, defaultStrokeColor, attrs.stroke)\n          : getFillColor(event, defaultFillColor, attrs.fill);\n\n        return drawPath(parentGfx, pathData, {\n          fill,\n          stroke: getStrokeColor(event, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1\n        });\n      },\n      'bpmn:SignalEventDefinition': function(parentGfx, event, attrs = {}, isThrowing) {\n        var pathData = pathMap.getScaledPath('EVENT_SIGNAL', {\n          xScaleFactor: 0.9,\n          yScaleFactor: 0.9,\n          containerWidth: attrs.width || event.width,\n          containerHeight: attrs.height || event.height,\n          position: {\n            mx: 0.5,\n            my: 0.2\n          }\n        });\n\n        var fill = isThrowing\n          ? getStrokeColor(event, defaultStrokeColor, attrs.stroke)\n          : getFillColor(event, defaultFillColor, attrs.fill);\n\n        return drawPath(parentGfx, pathData, {\n          strokeWidth: 1,\n          fill,\n          stroke: getStrokeColor(event, defaultStrokeColor, attrs.stroke)\n        });\n      },\n      'bpmn:MultipleEventDefinition': function(parentGfx, event, attrs = {}, isThrowing) {\n        var pathData = pathMap.getScaledPath('EVENT_MULTIPLE', {\n          xScaleFactor: 1.1,\n          yScaleFactor: 1.1,\n          containerWidth: attrs.width || event.width,\n          containerHeight: attrs.height || event.height,\n          position: {\n            mx: 0.211,\n            my: 0.36\n          }\n        });\n\n        var fill = isThrowing\n          ? getStrokeColor(event, defaultStrokeColor, attrs.stroke)\n          : getFillColor(event, defaultFillColor, attrs.fill);\n\n        return drawPath(parentGfx, pathData, {\n          fill,\n          stroke: getStrokeColor(event, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1\n        });\n      },\n      'bpmn:ParallelMultipleEventDefinition': function(parentGfx, event, attrs = {}) {\n        var pathData = pathMap.getScaledPath('EVENT_PARALLEL_MULTIPLE', {\n          xScaleFactor: 1.2,\n          yScaleFactor: 1.2,\n          containerWidth: attrs.width || event.width,\n          containerHeight: attrs.height || event.height,\n          position: {\n            mx: 0.458,\n            my: 0.194\n          }\n        });\n\n        return drawPath(parentGfx, pathData, {\n          fill: getFillColor(event, defaultFillColor, attrs.fill),\n          stroke: getStrokeColor(event, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1\n        });\n      },\n      'bpmn:TerminateEventDefinition': function(parentGfx, element, attrs = {}) {\n        var circle = drawCircle(parentGfx, element.width, element.height, 8, {\n          fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 4\n        });\n\n        return circle;\n      }\n    };\n\n    function renderEventIcon(element, parentGfx, attrs = {}, proxyElement) {\n      var semantic = getBusinessObject(element),\n          isThrowing = isThrowEvent(semantic);\n\n      var nodeElement = proxyElement || element;\n\n      if (semantic.get('eventDefinitions') && semantic.get('eventDefinitions').length > 1) {\n        if (semantic.get('parallelMultiple')) {\n          return eventIconRenderers[ 'bpmn:ParallelMultipleEventDefinition' ](parentGfx, nodeElement, attrs, isThrowing);\n        }\n        else {\n          return eventIconRenderers[ 'bpmn:MultipleEventDefinition' ](parentGfx, nodeElement, attrs, isThrowing);\n        }\n      }\n\n      if (isTypedEvent(semantic, 'bpmn:MessageEventDefinition')) {\n        return eventIconRenderers[ 'bpmn:MessageEventDefinition' ](parentGfx, nodeElement, attrs, isThrowing);\n      }\n\n      if (isTypedEvent(semantic, 'bpmn:TimerEventDefinition')) {\n        return eventIconRenderers[ 'bpmn:TimerEventDefinition' ](parentGfx, nodeElement, attrs, isThrowing);\n      }\n\n      if (isTypedEvent(semantic, 'bpmn:ConditionalEventDefinition')) {\n        return eventIconRenderers[ 'bpmn:ConditionalEventDefinition' ](parentGfx, nodeElement, attrs, isThrowing);\n      }\n\n      if (isTypedEvent(semantic, 'bpmn:SignalEventDefinition')) {\n        return eventIconRenderers[ 'bpmn:SignalEventDefinition' ](parentGfx, nodeElement, attrs, isThrowing);\n      }\n\n      if (isTypedEvent(semantic, 'bpmn:EscalationEventDefinition')) {\n        return eventIconRenderers[ 'bpmn:EscalationEventDefinition' ](parentGfx, nodeElement, attrs, isThrowing);\n      }\n\n      if (isTypedEvent(semantic, 'bpmn:LinkEventDefinition')) {\n        return eventIconRenderers[ 'bpmn:LinkEventDefinition' ](parentGfx, nodeElement, attrs, isThrowing);\n      }\n\n      if (isTypedEvent(semantic, 'bpmn:ErrorEventDefinition')) {\n        return eventIconRenderers[ 'bpmn:ErrorEventDefinition' ](parentGfx, nodeElement, attrs, isThrowing);\n      }\n\n      if (isTypedEvent(semantic, 'bpmn:CancelEventDefinition')) {\n        return eventIconRenderers[ 'bpmn:CancelEventDefinition' ](parentGfx, nodeElement, attrs, isThrowing);\n      }\n\n      if (isTypedEvent(semantic, 'bpmn:CompensateEventDefinition')) {\n        return eventIconRenderers[ 'bpmn:CompensateEventDefinition' ](parentGfx, nodeElement, attrs, isThrowing);\n      }\n\n      if (isTypedEvent(semantic, 'bpmn:TerminateEventDefinition')) {\n        return eventIconRenderers[ 'bpmn:TerminateEventDefinition' ](parentGfx, nodeElement, attrs, isThrowing);\n      }\n\n      return null;\n    }\n\n    var taskMarkerRenderers = {\n      'ParticipantMultiplicityMarker': function(parentGfx, element, attrs = {}) {\n        var width = getWidth(element, attrs),\n            height = getHeight(element, attrs);\n\n        var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {\n          xScaleFactor: 1,\n          yScaleFactor: 1,\n          containerWidth: width,\n          containerHeight: height,\n          position: {\n            mx: ((width / 2 - 6) / width),\n            my: (height - 15) / height\n          }\n        });\n\n        drawMarker('participant-multiplicity', parentGfx, markerPath, {\n          strokeWidth: 2,\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)\n        });\n      },\n      'SubProcessMarker': function(parentGfx, element, attrs = {}) {\n        var markerRect = drawRect(parentGfx, 14, 14, 0, {\n          strokeWidth: 1,\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)\n        });\n\n        translate$1(markerRect, element.width / 2 - 7.5, element.height - 20);\n\n        var markerPath = pathMap.getScaledPath('MARKER_SUB_PROCESS', {\n          xScaleFactor: 1.5,\n          yScaleFactor: 1.5,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: (element.width / 2 - 7.5) / element.width,\n            my: (element.height - 20) / element.height\n          }\n        });\n\n        drawMarker('sub-process', parentGfx, markerPath, {\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)\n        });\n      },\n      'ParallelMarker': function(parentGfx, element, attrs) {\n        var width = getWidth(element, attrs),\n            height = getHeight(element, attrs);\n\n        var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {\n          xScaleFactor: 1,\n          yScaleFactor: 1,\n          containerWidth: width,\n          containerHeight: height,\n          position: {\n            mx: ((width / 2 + attrs.parallel) / width),\n            my: (height - 20) / height\n          }\n        });\n\n        drawMarker('parallel', parentGfx, markerPath, {\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)\n        });\n      },\n      'SequentialMarker': function(parentGfx, element, attrs) {\n        var markerPath = pathMap.getScaledPath('MARKER_SEQUENTIAL', {\n          xScaleFactor: 1,\n          yScaleFactor: 1,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: ((element.width / 2 + attrs.seq) / element.width),\n            my: (element.height - 19) / element.height\n          }\n        });\n\n        drawMarker('sequential', parentGfx, markerPath, {\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)\n        });\n      },\n      'CompensationMarker': function(parentGfx, element, attrs) {\n        var markerMath = pathMap.getScaledPath('MARKER_COMPENSATION', {\n          xScaleFactor: 1,\n          yScaleFactor: 1,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: ((element.width / 2 + attrs.compensation) / element.width),\n            my: (element.height - 13) / element.height\n          }\n        });\n\n        drawMarker('compensation', parentGfx, markerMath, {\n          strokeWidth: 1,\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)\n        });\n      },\n      'LoopMarker': function(parentGfx, element, attrs) {\n        var width = getWidth(element, attrs),\n            height = getHeight(element, attrs);\n\n        var markerPath = pathMap.getScaledPath('MARKER_LOOP', {\n          xScaleFactor: 1,\n          yScaleFactor: 1,\n          containerWidth: width,\n          containerHeight: height,\n          position: {\n            mx: ((width / 2 + attrs.loop) / width),\n            my: (height - 7) / height\n          }\n        });\n\n        drawMarker('loop', parentGfx, markerPath, {\n          strokeWidth: 1.5,\n          fill: 'none',\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeMiterlimit: 0.5\n        });\n      },\n      'AdhocMarker': function(parentGfx, element, attrs) {\n        var width = getWidth(element, attrs),\n            height = getHeight(element, attrs);\n\n        var markerPath = pathMap.getScaledPath('MARKER_ADHOC', {\n          xScaleFactor: 1,\n          yScaleFactor: 1,\n          containerWidth: width,\n          containerHeight: height,\n          position: {\n            mx: ((width / 2 + attrs.adhoc) / width),\n            my: (height - 15) / height\n          }\n        });\n\n        drawMarker('adhoc', parentGfx, markerPath, {\n          strokeWidth: 1,\n          fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)\n        });\n      }\n    };\n\n    function renderTaskMarker(type, parentGfx, element, attrs) {\n      taskMarkerRenderers[ type ](parentGfx, element, attrs);\n    }\n\n    function renderTaskMarkers(parentGfx, element, taskMarkers = [], attrs = {}) {\n      attrs = {\n        fill: attrs.fill,\n        stroke: attrs.stroke,\n        width: getWidth(element, attrs),\n        height: getHeight(element, attrs)\n      };\n\n      var semantic = getBusinessObject(element);\n\n      var subprocess = taskMarkers.includes('SubProcessMarker');\n\n      if (subprocess) {\n        attrs = {\n          ...attrs,\n          seq: -21,\n          parallel: -22,\n          compensation: -25,\n          loop: -18,\n          adhoc: 10\n        };\n      } else {\n        attrs = {\n          ...attrs,\n          seq: -5,\n          parallel: -6,\n          compensation: -7,\n          loop: 0,\n          adhoc: -8\n        };\n      }\n\n      if (semantic.get('isForCompensation')) {\n        taskMarkers.push('CompensationMarker');\n      }\n\n      if (is$1(semantic, 'bpmn:AdHocSubProcess')) {\n        taskMarkers.push('AdhocMarker');\n\n        if (!subprocess) {\n          assign$1(attrs, { compensation: attrs.compensation - 18 });\n        }\n      }\n\n      var loopCharacteristics = semantic.get('loopCharacteristics'),\n          isSequential = loopCharacteristics && loopCharacteristics.get('isSequential');\n\n      if (loopCharacteristics) {\n\n        assign$1(attrs, {\n          compensation: attrs.compensation - 18,\n        });\n\n        if (taskMarkers.includes('AdhocMarker')) {\n          assign$1(attrs, {\n            seq: -23,\n            loop: -18,\n            parallel: -24\n          });\n        }\n\n        if (isSequential === undefined) {\n          taskMarkers.push('LoopMarker');\n        }\n\n        if (isSequential === false) {\n          taskMarkers.push('ParallelMarker');\n        }\n\n        if (isSequential === true) {\n          taskMarkers.push('SequentialMarker');\n        }\n      }\n\n      if (taskMarkers.includes('CompensationMarker') && taskMarkers.length === 1) {\n        assign$1(attrs, {\n          compensation: -8\n        });\n      }\n\n      forEach$1(taskMarkers, function(marker) {\n        renderTaskMarker(marker, parentGfx, element, attrs);\n      });\n    }\n\n    function renderLabel(parentGfx, label, attrs = {}) {\n      attrs = assign$1({\n        size: {\n          width: 100\n        }\n      }, attrs);\n\n      var text = textRenderer.createText(label || '', attrs);\n\n      classes$1(text).add('djs-label');\n\n      append(parentGfx, text);\n\n      return text;\n    }\n\n    function renderEmbeddedLabel(parentGfx, element, align, attrs = {}) {\n      var semantic = getBusinessObject(element);\n\n      var box = getBounds({\n        x: element.x,\n        y: element.y,\n        width: element.width,\n        height: element.height\n      }, attrs);\n\n      return renderLabel(parentGfx, semantic.name, {\n        align,\n        box,\n        padding: 7,\n        style: {\n          fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)\n        }\n      });\n    }\n\n    function renderExternalLabel(parentGfx, element, attrs = {}) {\n      var box = {\n        width: 90,\n        height: 30,\n        x: element.width / 2 + element.x,\n        y: element.height / 2 + element.y\n      };\n\n      return renderLabel(parentGfx, getLabel(element), {\n        box: box,\n        fitBox: true,\n        style: assign$1(\n          {},\n          textRenderer.getExternalStyle(),\n          {\n            fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)\n          }\n        )\n      });\n    }\n\n    function renderLaneLabel(parentGfx, text, element, attrs = {}) {\n      var isHorizontalLane = isHorizontal(element);\n\n      var textBox = renderLabel(parentGfx, text, {\n        box: {\n          height: 30,\n          width: isHorizontalLane ? getHeight(element, attrs) : getWidth(element, attrs),\n        },\n        align: 'center-middle',\n        style: {\n          fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)\n        }\n      });\n\n      if (isHorizontalLane) {\n        var top = -1 * getHeight(element, attrs);\n        transform(textBox, 0, -top, 270);\n      }\n    }\n\n    function renderActivity(parentGfx, element, attrs = {}) {\n      var {\n        width,\n        height\n      } = getBounds(element, attrs);\n\n      return drawRect(parentGfx, width, height, TASK_BORDER_RADIUS, {\n        ...attrs,\n        fill: getFillColor(element, defaultFillColor, attrs.fill),\n        fillOpacity: DEFAULT_OPACITY,\n        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)\n      });\n    }\n\n    function renderAssociation(parentGfx, element, attrs = {}) {\n      var semantic = getBusinessObject(element);\n\n      var fill = getFillColor(element, defaultFillColor, attrs.fill),\n          stroke = getStrokeColor(element, defaultStrokeColor, attrs.stroke);\n\n      if (semantic.get('associationDirection') === 'One' ||\n          semantic.get('associationDirection') === 'Both') {\n        attrs.markerEnd = marker(parentGfx, 'association-end', fill, stroke);\n      }\n\n      if (semantic.get('associationDirection') === 'Both') {\n        attrs.markerStart = marker(parentGfx, 'association-start', fill, stroke);\n      }\n\n      attrs = pickAttrs(attrs, [\n        'markerStart',\n        'markerEnd'\n      ]);\n\n      return drawConnectionSegments(parentGfx, element.waypoints, {\n        ...attrs,\n        stroke,\n        strokeDasharray: '0, 5'\n      });\n    }\n\n    function renderDataObject(parentGfx, element, attrs = {}) {\n      var fill = getFillColor(element, defaultFillColor, attrs.fill),\n          stroke = getStrokeColor(element, defaultStrokeColor, attrs.stroke);\n\n      var pathData = pathMap.getScaledPath('DATA_OBJECT_PATH', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.474,\n          my: 0.296\n        }\n      });\n\n      var dataObject = drawPath(parentGfx, pathData, {\n        fill,\n        fillOpacity: DEFAULT_OPACITY,\n        stroke\n      });\n\n      var semantic = getBusinessObject(element);\n\n      if (isCollection(semantic)) {\n        var collectionPathData = pathMap.getScaledPath('DATA_OBJECT_COLLECTION_PATH', {\n          xScaleFactor: 1,\n          yScaleFactor: 1,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: 0.33,\n            my: (element.height - 18) / element.height\n          }\n        });\n\n        drawPath(parentGfx, collectionPathData, {\n          strokeWidth: 2,\n          fill,\n          stroke\n        });\n      }\n\n      return dataObject;\n    }\n\n    function renderEvent(parentGfx, element, attrs = {}) {\n      return drawCircle(parentGfx, element.width, element.height, {\n        fillOpacity: DEFAULT_OPACITY,\n        ...attrs,\n        fill: getFillColor(element, defaultFillColor, attrs.fill),\n        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)\n      });\n    }\n\n    function renderGateway(parentGfx, element, attrs = {}) {\n      return drawDiamond(parentGfx, element.width, element.height, {\n        fill: getFillColor(element, defaultFillColor, attrs.fill),\n        fillOpacity: DEFAULT_OPACITY,\n        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)\n      });\n    }\n\n    function renderLane(parentGfx, element, attrs = {}) {\n      var lane = drawRect(parentGfx, getWidth(element, attrs), getHeight(element, attrs), 0, {\n        fill: getFillColor(element, defaultFillColor, attrs.fill),\n        fillOpacity: attrs.fillOpacity || DEFAULT_OPACITY,\n        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n        strokeWidth: 1.5\n      });\n\n      var semantic = getBusinessObject(element);\n\n      if (is$1(semantic, 'bpmn:Lane')) {\n        var text = semantic.get('name');\n\n        renderLaneLabel(parentGfx, text, element, attrs);\n      }\n\n      return lane;\n    }\n\n    function renderSubProcess(parentGfx, element, attrs = {}) {\n      var activity = renderActivity(parentGfx, element, attrs);\n\n      var expanded = isExpanded(element);\n\n      if (isEventSubProcess(element)) {\n        attr$1(activity, {\n          strokeDasharray: '0, 5.5',\n          strokeWidth: 2.5\n        });\n\n        if (!expanded) {\n          var flowElements = getBusinessObject(element).flowElements || [];\n          var startEvents = flowElements.filter(e => is$1(e, 'bpmn:StartEvent'));\n\n          if (startEvents.length === 1) {\n            renderEventSubProcessIcon(startEvents[0], parentGfx, attrs, element);\n          }\n        }\n      }\n\n      renderEmbeddedLabel(parentGfx, element, expanded ? 'center-top' : 'center-middle', attrs);\n\n      if (expanded) {\n        renderTaskMarkers(parentGfx, element, undefined, attrs);\n      } else {\n        renderTaskMarkers(parentGfx, element, [ 'SubProcessMarker' ], attrs);\n      }\n\n      return activity;\n    }\n\n    function renderEventSubProcessIcon(startEvent, parentGfx, attrs, proxyElement) {\n      var iconSize = 22;\n\n      // match the colors of the enclosing subprocess\n      var proxyAttrs = {\n        fill: getFillColor(proxyElement, defaultFillColor, attrs.fill),\n        stroke: getStrokeColor(proxyElement, defaultStrokeColor, attrs.stroke),\n        width: iconSize,\n        height: iconSize\n      };\n\n      var interrupting = getBusinessObject(startEvent).isInterrupting;\n      var strokeDasharray = interrupting ? 0 : 3;\n\n      // better visibility for non-interrupting events\n      var strokeWidth = interrupting ? 1 : 1.2;\n\n      // make the icon look larger by drawing a smaller circle\n      var circleSize = 20;\n      var shift = (iconSize - circleSize) / 2;\n      var transform = 'translate(' + shift + ',' + shift + ')';\n\n      drawCircle(parentGfx, circleSize, circleSize, {\n        fill: proxyAttrs.fill,\n        stroke: proxyAttrs.stroke,\n        strokeWidth,\n        strokeDasharray,\n        transform\n      });\n\n      renderEventIcon(startEvent, parentGfx, proxyAttrs, proxyElement);\n    }\n\n    function renderTask(parentGfx, element, attrs = {}) {\n      var activity = renderActivity(parentGfx, element, attrs);\n\n      renderEmbeddedLabel(parentGfx, element, 'center-middle', attrs);\n\n      renderTaskMarkers(parentGfx, element, undefined, attrs);\n\n      return activity;\n    }\n\n    var handlers = this.handlers = {\n      'bpmn:AdHocSubProcess': function(parentGfx, element, attrs = {}) {\n        if (isExpanded(element)) {\n          attrs = pickAttrs(attrs, [\n            'fill',\n            'stroke',\n            'width',\n            'height'\n          ]);\n        } else {\n          attrs = pickAttrs(attrs, [\n            'fill',\n            'stroke'\n          ]);\n        }\n\n        return renderSubProcess(parentGfx, element, attrs);\n      },\n      'bpmn:Association': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        return renderAssociation(parentGfx, element, attrs);\n      },\n      'bpmn:BoundaryEvent': function(parentGfx, element, attrs = {}) {\n        var { renderIcon = true } = attrs;\n\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var semantic = getBusinessObject(element),\n            cancelActivity = semantic.get('cancelActivity');\n\n        attrs = {\n          strokeWidth: 1.5,\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          fillOpacity: FULL_OPACITY,\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)\n        };\n\n        if (!cancelActivity) {\n          attrs.strokeDasharray = '6';\n        }\n\n        var event = renderEvent(parentGfx, element, attrs);\n\n        drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, {\n          ...attrs,\n          fill: 'none'\n        });\n\n        if (renderIcon) {\n          renderEventIcon(element, parentGfx, attrs);\n        }\n\n        return event;\n      },\n      'bpmn:BusinessRuleTask': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var task = renderTask(parentGfx, element, attrs);\n\n        var headerData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_MAIN', {\n          abspos: {\n            x: 8,\n            y: 8\n          }\n        });\n\n        var businessPath = drawPath(parentGfx, headerData);\n\n        attr$1(businessPath, {\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1\n        });\n\n        var headerPathData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_HEADER', {\n          abspos: {\n            x: 8,\n            y: 8\n          }\n        });\n\n        var businessHeaderPath = drawPath(parentGfx, headerPathData);\n\n        attr$1(businessHeaderPath, {\n          fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1\n        });\n\n        return task;\n      },\n      'bpmn:CallActivity': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        return renderSubProcess(parentGfx, element, {\n          strokeWidth: 5,\n          ...attrs\n        });\n      },\n      'bpmn:ComplexGateway': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var gateway = renderGateway(parentGfx, element, attrs);\n\n        var pathData = pathMap.getScaledPath('GATEWAY_COMPLEX', {\n          xScaleFactor: 0.5,\n          yScaleFactor:0.5,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: 0.46,\n            my: 0.26\n          }\n        });\n\n        drawPath(parentGfx, pathData, {\n          fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1\n        });\n\n        return gateway;\n      },\n      'bpmn:DataInput': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var arrowPathData = pathMap.getRawPath('DATA_ARROW');\n\n        var dataObject = renderDataObject(parentGfx, element, attrs);\n\n        drawPath(parentGfx, arrowPathData, {\n          fill: 'none',\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1\n        });\n\n        return dataObject;\n      },\n      'bpmn:DataInputAssociation': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        return renderAssociation(parentGfx, element, {\n          ...attrs,\n          markerEnd: marker(parentGfx, 'association-end', getFillColor(element, defaultFillColor, attrs.fill), getStrokeColor(element, defaultStrokeColor, attrs.stroke))\n        });\n      },\n      'bpmn:DataObject': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        return renderDataObject(parentGfx, element, attrs);\n      },\n      'bpmn:DataObjectReference': as('bpmn:DataObject'),\n      'bpmn:DataOutput': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var arrowPathData = pathMap.getRawPath('DATA_ARROW');\n\n        var dataObject = renderDataObject(parentGfx, element, attrs);\n\n        drawPath(parentGfx, arrowPathData, {\n          strokeWidth: 1,\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)\n        });\n\n        return dataObject;\n      },\n      'bpmn:DataOutputAssociation': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        return renderAssociation(parentGfx, element, {\n          ...attrs,\n          markerEnd: marker(parentGfx, 'association-end', getFillColor(element, defaultFillColor, attrs.fill), getStrokeColor(element, defaultStrokeColor, attrs.stroke))\n        });\n      },\n      'bpmn:DataStoreReference': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var dataStorePath = pathMap.getScaledPath('DATA_STORE', {\n          xScaleFactor: 1,\n          yScaleFactor: 1,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: 0,\n            my: 0.133\n          }\n        });\n\n        return drawPath(parentGfx, dataStorePath, {\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          fillOpacity: DEFAULT_OPACITY,\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 2\n        });\n      },\n      'bpmn:EndEvent': function(parentGfx, element, attrs = {}) {\n        var { renderIcon = true } = attrs;\n\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var event = renderEvent(parentGfx, element, {\n          ...attrs,\n          strokeWidth: 4\n        });\n\n        if (renderIcon) {\n          renderEventIcon(element, parentGfx, attrs);\n        }\n\n        return event;\n      },\n      'bpmn:EventBasedGateway': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var semantic = getBusinessObject(element);\n\n        var diamond = renderGateway(parentGfx, element, attrs);\n\n        drawCircle(parentGfx, element.width, element.height, element.height * 0.20, {\n          fill: getFillColor(element, 'none', attrs.fill),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1\n        });\n\n        var type = semantic.get('eventGatewayType'),\n            instantiate = !!semantic.get('instantiate');\n\n        function drawEvent() {\n\n          var pathData = pathMap.getScaledPath('GATEWAY_EVENT_BASED', {\n            xScaleFactor: 0.18,\n            yScaleFactor: 0.18,\n            containerWidth: element.width,\n            containerHeight: element.height,\n            position: {\n              mx: 0.36,\n              my: 0.44\n            }\n          });\n\n          drawPath(parentGfx, pathData, {\n            fill: 'none',\n            stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n            strokeWidth: 2\n          });\n        }\n\n        if (type === 'Parallel') {\n          var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {\n            xScaleFactor: 0.4,\n            yScaleFactor: 0.4,\n            containerWidth: element.width,\n            containerHeight: element.height,\n            position: {\n              mx: 0.474,\n              my: 0.296\n            }\n          });\n\n          drawPath(parentGfx, pathData, {\n            fill: 'none',\n            stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n            strokeWidth: 1\n          });\n        } else if (type === 'Exclusive') {\n          if (!instantiate) {\n            drawCircle(parentGfx, element.width, element.height, element.height * 0.26, {\n              fill: 'none',\n              stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n              strokeWidth: 1\n            });\n          }\n\n          drawEvent();\n        }\n\n\n        return diamond;\n      },\n      'bpmn:ExclusiveGateway': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var gateway = renderGateway(parentGfx, element, attrs);\n\n        var pathData = pathMap.getScaledPath('GATEWAY_EXCLUSIVE', {\n          xScaleFactor: 0.4,\n          yScaleFactor: 0.4,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: 0.32,\n            my: 0.3\n          }\n        });\n\n        var di = getDi(element);\n\n        if (di.get('isMarkerVisible')) {\n          drawPath(parentGfx, pathData, {\n            fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n            stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n            strokeWidth: 1\n          });\n        }\n\n        return gateway;\n      },\n      'bpmn:Gateway': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        return renderGateway(parentGfx, element, attrs);\n      },\n      'bpmn:Group': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke',\n          'width',\n          'height'\n        ]);\n\n        return drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, {\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1.5,\n          strokeDasharray: '10, 6, 0, 6',\n          fill: 'none',\n          pointerEvents: 'none',\n          width: getWidth(element, attrs),\n          height: getHeight(element, attrs)\n        });\n      },\n      'bpmn:InclusiveGateway': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var gateway = renderGateway(parentGfx, element, attrs);\n\n        drawCircle(parentGfx, element.width, element.height, element.height * 0.24, {\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 2.5\n        });\n\n        return gateway;\n      },\n      'bpmn:IntermediateEvent': function(parentGfx, element, attrs = {}) {\n        var { renderIcon = true } = attrs;\n\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var outer = renderEvent(parentGfx, element, {\n          ...attrs,\n          strokeWidth: 1.5\n        });\n\n        drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, {\n          fill: 'none',\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1.5\n        });\n\n        if (renderIcon) {\n          renderEventIcon(element, parentGfx, attrs);\n        }\n\n        return outer;\n      },\n      'bpmn:IntermediateCatchEvent': as('bpmn:IntermediateEvent'),\n      'bpmn:IntermediateThrowEvent': as('bpmn:IntermediateEvent'),\n      'bpmn:Lane': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke',\n          'width',\n          'height'\n        ]);\n\n        return renderLane(parentGfx, element, {\n          ...attrs,\n          fillOpacity: LOW_OPACITY\n        });\n      },\n      'bpmn:ManualTask': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var task = renderTask(parentGfx, element, attrs);\n\n        var pathData = pathMap.getScaledPath('TASK_TYPE_MANUAL', {\n          abspos: {\n            x: 17,\n            y: 15\n          }\n        });\n\n        drawPath(parentGfx, pathData, {\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 0.5\n        });\n\n        return task;\n      },\n      'bpmn:MessageFlow': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var semantic = getBusinessObject(element),\n            di = getDi(element);\n\n        var fill = getFillColor(element, defaultFillColor, attrs.fill),\n            stroke = getStrokeColor(element, defaultStrokeColor, attrs.stroke);\n\n        var path = drawConnectionSegments(parentGfx, element.waypoints, {\n          markerEnd: marker(parentGfx, 'messageflow-end', fill, stroke),\n          markerStart: marker(parentGfx, 'messageflow-start', fill, stroke),\n          stroke,\n          strokeDasharray: '10, 11',\n          strokeWidth: 1.5\n        });\n\n        if (semantic.get('messageRef')) {\n          var midPoint = path.getPointAtLength(path.getTotalLength() / 2);\n\n          var markerPathData = pathMap.getScaledPath('MESSAGE_FLOW_MARKER', {\n            abspos: {\n              x: midPoint.x,\n              y: midPoint.y\n            }\n          });\n\n          var messageAttrs = {\n            strokeWidth: 1\n          };\n\n          if (di.get('messageVisibleKind') === 'initiating') {\n            messageAttrs.fill = fill;\n            messageAttrs.stroke = stroke;\n          } else {\n            messageAttrs.fill = stroke;\n            messageAttrs.stroke = fill;\n          }\n\n          var message = drawPath(parentGfx, markerPathData, messageAttrs);\n\n          var messageRef = semantic.get('messageRef'),\n              name = messageRef.get('name');\n\n          var label = renderLabel(parentGfx, name, {\n            align: 'center-top',\n            fitBox: true,\n            style: {\n              fill: stroke\n            }\n          });\n\n          var messageBounds = message.getBBox(),\n              labelBounds = label.getBBox();\n\n          var translateX = midPoint.x - labelBounds.width / 2,\n              translateY = midPoint.y + messageBounds.height / 2 + ELEMENT_LABEL_DISTANCE;\n\n          transform(label, translateX, translateY, 0);\n        }\n\n        return path;\n      },\n      'bpmn:ParallelGateway': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var diamond = renderGateway(parentGfx, element, attrs);\n\n        var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {\n          xScaleFactor: 0.6,\n          yScaleFactor: 0.6,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: 0.46,\n            my: 0.2\n          }\n        });\n\n        drawPath(parentGfx, pathData, {\n          fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1\n        });\n\n        return diamond;\n      },\n      'bpmn:Participant': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke',\n          'width',\n          'height'\n        ]);\n\n        var participant = renderLane(parentGfx, element, attrs);\n\n        var expandedParticipant = isExpanded(element);\n        var horizontalParticipant = isHorizontal(element);\n\n        var semantic = getBusinessObject(element),\n            name = semantic.get('name');\n\n        if (expandedParticipant) {\n          var waypoints = horizontalParticipant ? [\n            {\n              x: 30,\n              y: 0\n            },\n            {\n              x: 30,\n              y: getHeight(element, attrs)\n            }\n          ] : [\n            {\n              x: 0,\n              y: 30\n            },\n            {\n              x: getWidth(element, attrs),\n              y: 30\n            }\n          ];\n\n          drawLine(parentGfx, waypoints, {\n            stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n            strokeWidth: PARTICIPANT_STROKE_WIDTH\n          });\n\n          renderLaneLabel(parentGfx, name, element, attrs);\n        } else {\n          var bounds = getBounds(element, attrs);\n\n          if (!horizontalParticipant) {\n            bounds.height = getWidth(element, attrs);\n            bounds.width = getHeight(element, attrs);\n          }\n\n          var textBox = renderLabel(parentGfx, name, {\n            box: bounds,\n            align: 'center-middle',\n            style: {\n              fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)\n            }\n          });\n\n          if (!horizontalParticipant) {\n            var top = -1 * getHeight(element, attrs);\n            transform(textBox, 0, -top, 270);\n          }\n        }\n\n        if (semantic.get('participantMultiplicity')) {\n          renderTaskMarker('ParticipantMultiplicityMarker', parentGfx, element, attrs);\n        }\n\n        return participant;\n      },\n      'bpmn:ReceiveTask' : function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var semantic = getBusinessObject(element);\n\n        var task = renderTask(parentGfx, element, attrs);\n\n        var pathData;\n\n        if (semantic.get('instantiate')) {\n          drawCircle(parentGfx, 28, 28, 20 * 0.22, {\n            fill: getFillColor(element, defaultFillColor, attrs.fill),\n            stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n            strokeWidth: 1\n          });\n\n          pathData = pathMap.getScaledPath('TASK_TYPE_INSTANTIATING_SEND', {\n            abspos: {\n              x: 7.77,\n              y: 9.52\n            }\n          });\n        } else {\n          pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {\n            xScaleFactor: 0.9,\n            yScaleFactor: 0.9,\n            containerWidth: 21,\n            containerHeight: 14,\n            position: {\n              mx: 0.3,\n              my: 0.4\n            }\n          });\n        }\n\n        drawPath(parentGfx, pathData, {\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1\n        });\n\n        return task;\n      },\n      'bpmn:ScriptTask': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var task = renderTask(parentGfx, element, attrs);\n\n        var pathData = pathMap.getScaledPath('TASK_TYPE_SCRIPT', {\n          abspos: {\n            x: 15,\n            y: 20\n          }\n        });\n\n        drawPath(parentGfx, pathData, {\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1\n        });\n\n        return task;\n      },\n      'bpmn:SendTask': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var task = renderTask(parentGfx, element, attrs);\n\n        var pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {\n          xScaleFactor: 1,\n          yScaleFactor: 1,\n          containerWidth: 21,\n          containerHeight: 14,\n          position: {\n            mx: 0.285,\n            my: 0.357\n          }\n        });\n\n        drawPath(parentGfx, pathData, {\n          fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          stroke: getFillColor(element, defaultFillColor, attrs.fill),\n          strokeWidth: 1\n        });\n\n        return task;\n      },\n      'bpmn:SequenceFlow': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var fill = getFillColor(element, defaultFillColor, attrs.fill),\n            stroke = getStrokeColor(element, defaultStrokeColor, attrs.stroke);\n\n        var connection = drawConnectionSegments(parentGfx, element.waypoints, {\n          markerEnd: marker(parentGfx, 'sequenceflow-end', fill, stroke),\n          stroke\n        });\n\n        var semantic = getBusinessObject(element);\n\n        var { source } = element;\n\n        if (source) {\n          var sourceSemantic = getBusinessObject(source);\n\n          // conditional flow marker\n          if (semantic.get('conditionExpression') && is$1(sourceSemantic, 'bpmn:Activity')) {\n            attr$1(connection, {\n              markerStart: marker(parentGfx, 'conditional-flow-marker', fill, stroke)\n            });\n          }\n\n          // default marker\n          if (sourceSemantic.get('default') && (is$1(sourceSemantic, 'bpmn:Gateway') || is$1(sourceSemantic, 'bpmn:Activity')) &&\n              sourceSemantic.get('default') === semantic) {\n            attr$1(connection, {\n              markerStart: marker(parentGfx, 'conditional-default-flow-marker', fill, stroke)\n            });\n          }\n        }\n\n        return connection;\n      },\n      'bpmn:ServiceTask': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var task = renderTask(parentGfx, element, attrs);\n\n        drawCircle(parentGfx, 10, 10, {\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          stroke: 'none',\n          transform: 'translate(6, 6)'\n        });\n\n        var pathDataService1 = pathMap.getScaledPath('TASK_TYPE_SERVICE', {\n          abspos: {\n            x: 12,\n            y: 18\n          }\n        });\n\n        drawPath(parentGfx, pathDataService1, {\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1\n        });\n\n        drawCircle(parentGfx, 10, 10, {\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          stroke: 'none',\n          transform: 'translate(11, 10)'\n        });\n\n        var pathDataService2 = pathMap.getScaledPath('TASK_TYPE_SERVICE', {\n          abspos: {\n            x: 17,\n            y: 22\n          }\n        });\n\n        drawPath(parentGfx, pathDataService2, {\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1\n        });\n\n        return task;\n      },\n      'bpmn:StartEvent': function(parentGfx, element, attrs = {}) {\n        var { renderIcon = true } = attrs;\n\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var semantic = getBusinessObject(element);\n\n        if (!semantic.get('isInterrupting')) {\n          attrs = {\n            ...attrs,\n            strokeDasharray: '6'\n          };\n        }\n\n        var event = renderEvent(parentGfx, element, attrs);\n\n        if (renderIcon) {\n          renderEventIcon(element, parentGfx, attrs);\n        }\n\n        return event;\n      },\n      'bpmn:SubProcess': function(parentGfx, element, attrs = {}) {\n        if (isExpanded(element)) {\n          attrs = pickAttrs(attrs, [\n            'fill',\n            'stroke',\n            'width',\n            'height'\n          ]);\n        } else {\n          attrs = pickAttrs(attrs, [\n            'fill',\n            'stroke'\n          ]);\n        }\n\n        return renderSubProcess(parentGfx, element, attrs);\n      },\n      'bpmn:Task': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        return renderTask(parentGfx, element, attrs);\n      },\n      'bpmn:TextAnnotation': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke',\n          'width',\n          'height'\n        ]);\n\n        var {\n          width,\n          height\n        } = getBounds(element, attrs);\n\n        var textElement = drawRect(parentGfx, width, height, 0, 0, {\n          fill: 'none',\n          stroke: 'none'\n        });\n\n        var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {\n          xScaleFactor: 1,\n          yScaleFactor: 1,\n          containerWidth: width,\n          containerHeight: height,\n          position: {\n            mx: 0.0,\n            my: 0.0\n          }\n        });\n\n        drawPath(parentGfx, textPathData, {\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)\n        });\n\n        var semantic = getBusinessObject(element),\n            text = semantic.get('text') || '';\n\n        renderLabel(parentGfx, text, {\n          align: 'left-top',\n          box: getBounds(element, attrs),\n          padding: 7,\n          style: {\n            fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)\n          }\n        });\n\n        return textElement;\n      },\n      'bpmn:Transaction': function(parentGfx, element, attrs = {}) {\n        if (isExpanded(element)) {\n          attrs = pickAttrs(attrs, [\n            'fill',\n            'stroke',\n            'width',\n            'height'\n          ]);\n        } else {\n          attrs = pickAttrs(attrs, [\n            'fill',\n            'stroke'\n          ]);\n        }\n\n        var outer = renderSubProcess(parentGfx, element, {\n          strokeWidth: 1.5,\n          ...attrs\n        });\n\n        var innerAttrs = styles.style([ 'no-fill', 'no-events' ], {\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 1.5\n        });\n\n        var expanded = isExpanded(element);\n\n        if (!expanded) {\n          attrs = {};\n        }\n\n        drawRect(\n          parentGfx,\n          getWidth(element, attrs),\n          getHeight(element, attrs),\n          TASK_BORDER_RADIUS - INNER_OUTER_DIST,\n          INNER_OUTER_DIST,\n          innerAttrs\n        );\n\n        return outer;\n      },\n      'bpmn:UserTask': function(parentGfx, element, attrs = {}) {\n        attrs = pickAttrs(attrs, [\n          'fill',\n          'stroke'\n        ]);\n\n        var task = renderTask(parentGfx, element, attrs);\n\n        var x = 15;\n        var y = 12;\n\n        var pathDataUser1 = pathMap.getScaledPath('TASK_TYPE_USER_1', {\n          abspos: {\n            x: x,\n            y: y\n          }\n        });\n\n        drawPath(parentGfx, pathDataUser1, {\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 0.5\n        });\n\n        var pathDataUser2 = pathMap.getScaledPath('TASK_TYPE_USER_2', {\n          abspos: {\n            x: x,\n            y: y\n          }\n        });\n\n        drawPath(parentGfx, pathDataUser2, {\n          fill: getFillColor(element, defaultFillColor, attrs.fill),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 0.5\n        });\n\n        var pathDataUser3 = pathMap.getScaledPath('TASK_TYPE_USER_3', {\n          abspos: {\n            x: x,\n            y: y\n          }\n        });\n\n        drawPath(parentGfx, pathDataUser3, {\n          fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),\n          strokeWidth: 0.5\n        });\n\n        return task;\n      },\n      'label': function(parentGfx, element, attrs = {}) {\n        return renderExternalLabel(parentGfx, element, attrs);\n      }\n    };\n\n    // extension API, use at your own risk\n    this._drawPath = drawPath;\n\n    this._renderer = renderer;\n  }\n\n\n  e(BpmnRenderer, BaseRenderer);\n\n  BpmnRenderer.$inject = [\n    'config.bpmnRenderer',\n    'eventBus',\n    'styles',\n    'pathMap',\n    'canvas',\n    'textRenderer'\n  ];\n\n\n  /**\n   * @param {Element} element\n   *\n   * @return {boolean}\n   */\n  BpmnRenderer.prototype.canRender = function(element) {\n    return is$1(element, 'bpmn:BaseElement');\n  };\n\n  /**\n   * Draw shape into parentGfx.\n   *\n   * @param {SVGElement} parentGfx\n   * @param {Shape} shape\n   * @param {Attrs} [attrs]\n   *\n   * @return {SVGElement} mainGfx\n   */\n  BpmnRenderer.prototype.drawShape = function(parentGfx, shape, attrs = {}) {\n    var { type } = shape;\n\n    var handler = this._renderer(type);\n\n    return handler(parentGfx, shape, attrs);\n  };\n\n  /**\n   * Draw connection into parentGfx.\n   *\n   * @param {SVGElement} parentGfx\n   * @param {Connection} connection\n   * @param {Attrs} [attrs]\n   *\n   * @return {SVGElement} mainGfx\n   */\n  BpmnRenderer.prototype.drawConnection = function(parentGfx, connection, attrs = {}) {\n    var { type } = connection;\n\n    var handler = this._renderer(type);\n\n    return handler(parentGfx, connection, attrs);\n  };\n\n  /**\n   * Get shape path.\n   *\n   * @param {Shape} shape\n   *\n   * @return {string} path\n   */\n  BpmnRenderer.prototype.getShapePath = function(shape) {\n    if (is$1(shape, 'bpmn:Event')) {\n      return getCirclePath(shape);\n    }\n\n    if (is$1(shape, 'bpmn:Activity')) {\n      return getRoundRectPath(shape, TASK_BORDER_RADIUS);\n    }\n\n    if (is$1(shape, 'bpmn:Gateway')) {\n      return getDiamondPath(shape);\n    }\n\n    return getRectPath(shape);\n  };\n\n  /**\n   * Pick attributes if they exist.\n   *\n   * @param {Object} attrs\n   * @param {string[]} keys\n   *\n   * @returns {Object}\n   */\n  function pickAttrs(attrs, keys = []) {\n    return keys.reduce((pickedAttrs, key) => {\n      if (attrs[ key ]) {\n        pickedAttrs[ key ] = attrs[ key ];\n      }\n\n      return pickedAttrs;\n    }, {});\n  }\n\n  /**\n   * @typedef {import('../util/Types').Dimensions} Dimensions\n   *\n   * @typedef { {\n   *   top: number;\n   *   left: number;\n   *   right: number;\n   *   bottom: number;\n   * } } Padding\n   *\n   * @typedef { number | Partial<Padding> } PaddingConfig\n   *\n   * @typedef { {\n   *   horizontal: 'center' | 'left' | 'right';\n   *   vertical: 'top' | 'middle';\n   * } } Alignment\n   *\n   *  @typedef { 'center-middle' | 'center-top' } AlignmentConfig\n   *\n   * @typedef { Partial<{\n   *   align: AlignmentConfig;\n   *   style: Record<string, number | string>;\n   *   padding: PaddingConfig;\n   * }> } BaseTextConfig\n   *\n   * @typedef { BaseTextConfig & Partial<{\n   *   size: Dimensions;\n   * }> } TextConfig\n   *\n   * @typedef { BaseTextConfig & Partial<{\n   *   box: Dimensions;\n   *   fitBox: boolean;\n   * }> } TextLayoutConfig\n   *\n   *  @typedef { Dimensions & {\n   *  text: string;\n   * } } LineDescriptor\n   */\n\n  var DEFAULT_BOX_PADDING = 0;\n\n  var DEFAULT_LABEL_SIZE = {\n    width: 150,\n    height: 50\n  };\n\n\n  /**\n   * @param {AlignmentConfig} align\n   * @return {Alignment}\n   */\n  function parseAlign(align) {\n\n    var parts = align.split('-');\n\n    return {\n      horizontal: parts[0] || 'center',\n      vertical: parts[1] || 'top'\n    };\n  }\n\n  /**\n   * @param {PaddingConfig} padding\n   *\n   * @return {Padding}\n   */\n  function parsePadding(padding) {\n\n    if (isObject(padding)) {\n      return assign$1({ top: 0, left: 0, right: 0, bottom: 0 }, padding);\n    } else {\n      return {\n        top: padding,\n        left: padding,\n        right: padding,\n        bottom: padding\n      };\n    }\n  }\n\n  /**\n   * @param {string} text\n   * @param {SVGTextElement} fakeText\n   *\n   * @return {import('../util/Types').Dimensions}\n   */\n  function getTextBBox(text, fakeText) {\n\n    fakeText.textContent = text;\n\n    var textBBox;\n\n    try {\n      var bbox,\n          emptyLine = text === '';\n\n      // add dummy text, when line is empty to\n      // determine correct height\n      fakeText.textContent = emptyLine ? 'dummy' : text;\n\n      textBBox = fakeText.getBBox();\n\n      // take text rendering related horizontal\n      // padding into account\n      bbox = {\n        width: textBBox.width + textBBox.x * 2,\n        height: textBBox.height\n      };\n\n      if (emptyLine) {\n\n        // correct width\n        bbox.width = 0;\n      }\n\n      return bbox;\n    } catch (e) {\n      console.log(e);\n\n      return { width: 0, height: 0 };\n    }\n  }\n\n\n  /**\n   * Layout the next line and return the layouted element.\n   *\n   * Alters the lines passed.\n   *\n   * @param {string[]} lines\n   * @param {number} maxWidth\n   * @param {SVGTextElement} fakeText\n   *\n   * @return {LineDescriptor} the line descriptor\n   */\n  function layoutNext(lines, maxWidth, fakeText) {\n\n    var originalLine = lines.shift(),\n        fitLine = originalLine;\n\n    var textBBox;\n\n    for (;;) {\n      textBBox = getTextBBox(fitLine, fakeText);\n\n      textBBox.width = fitLine ? textBBox.width : 0;\n\n      // try to fit\n      if (fitLine === ' ' || fitLine === '' || textBBox.width < Math.round(maxWidth) || fitLine.length < 2) {\n        return fit(lines, fitLine, originalLine, textBBox);\n      }\n\n      fitLine = shortenLine(fitLine, textBBox.width, maxWidth);\n    }\n  }\n\n  /**\n   * @param {string[]} lines\n   * @param {string} fitLine\n   * @param {string} originalLine\n   * @param {Dimensions} textBBox\n   *\n   * @return {LineDescriptor}\n   */\n  function fit(lines, fitLine, originalLine, textBBox) {\n    if (fitLine.length < originalLine.length) {\n      var remainder = originalLine.slice(fitLine.length).trim();\n\n      lines.unshift(remainder);\n    }\n\n    return {\n      width: textBBox.width,\n      height: textBBox.height,\n      text: fitLine\n    };\n  }\n\n  var SOFT_BREAK = '\\u00AD';\n\n\n  /**\n   * Shortens a line based on spacing and hyphens.\n   * Returns the shortened result on success.\n   *\n   * @param {string} line\n   * @param {number} maxLength the maximum characters of the string\n   *\n   * @return {string} the shortened string\n   */\n  function semanticShorten(line, maxLength) {\n\n    var parts = line.split(/(\\s|-|\\u00AD)/g),\n        part,\n        shortenedParts = [],\n        length = 0;\n\n    // try to shorten via break chars\n    if (parts.length > 1) {\n\n      while ((part = parts.shift())) {\n        if (part.length + length < maxLength) {\n          shortenedParts.push(part);\n          length += part.length;\n        } else {\n\n          // remove previous part, too if hyphen does not fit anymore\n          if (part === '-' || part === SOFT_BREAK) {\n            shortenedParts.pop();\n          }\n\n          break;\n        }\n      }\n    }\n\n    var last = shortenedParts[shortenedParts.length - 1];\n\n    // translate trailing soft break to actual hyphen\n    if (last && last === SOFT_BREAK) {\n      shortenedParts[shortenedParts.length - 1] = '-';\n    }\n\n    return shortenedParts.join('');\n  }\n\n\n  /**\n   * @param {string} line\n   * @param {number} width\n   * @param {number} maxWidth\n   *\n   * @return {string}\n   */\n  function shortenLine(line, width, maxWidth) {\n    var length = Math.max(line.length * (maxWidth / width), 1);\n\n    // try to shorten semantically (i.e. based on spaces and hyphens)\n    var shortenedLine = semanticShorten(line, length);\n\n    if (!shortenedLine) {\n\n      // force shorten by cutting the long word\n      shortenedLine = line.slice(0, Math.max(Math.round(length - 1), 1));\n    }\n\n    return shortenedLine;\n  }\n\n\n  /**\n   * @return {SVGSVGElement}\n   */\n  function getHelperSvg() {\n    var helperSvg = document.getElementById('helper-svg');\n\n    if (!helperSvg) {\n      helperSvg = create$1('svg');\n\n      attr$1(helperSvg, {\n        id: 'helper-svg'\n      });\n\n      assign(helperSvg, {\n        visibility: 'hidden',\n        position: 'fixed',\n        width: 0,\n        height: 0\n      });\n\n      document.body.appendChild(helperSvg);\n    }\n\n    return helperSvg;\n  }\n\n\n  /**\n   * Creates a new label utility\n   *\n   * @param {TextConfig} [config]\n   */\n  function Text(config) {\n\n    this._config = assign$1({}, {\n      size: DEFAULT_LABEL_SIZE,\n      padding: DEFAULT_BOX_PADDING,\n      style: {},\n      align: 'center-top'\n    }, config || {});\n  }\n\n  /**\n   * Returns the layouted text as an SVG element.\n   *\n   * @param {string} text\n   * @param {TextLayoutConfig} options\n   *\n   * @return {SVGElement}\n   */\n  Text.prototype.createText = function(text, options) {\n    return this.layoutText(text, options).element;\n  };\n\n  /**\n   * Returns a labels layouted dimensions.\n   *\n   * @param {string} text to layout\n   * @param {TextLayoutConfig} options\n   *\n   * @return {Dimensions}\n   */\n  Text.prototype.getDimensions = function(text, options) {\n    return this.layoutText(text, options).dimensions;\n  };\n\n  /**\n   * Creates and returns a label and its bounding box.\n   *\n   * @param {string} text the text to render on the label\n   * @param {TextLayoutConfig} options\n   *\n   * @return { {\n   *   element: SVGElement,\n   *   dimensions: Dimensions\n   * } }\n   */\n  Text.prototype.layoutText = function(text, options) {\n    var box = assign$1({}, this._config.size, options.box),\n        style = assign$1({}, this._config.style, options.style),\n        align = parseAlign(options.align || this._config.align),\n        padding = parsePadding(options.padding !== undefined ? options.padding : this._config.padding),\n        fitBox = options.fitBox || false;\n\n    var lineHeight = getLineHeight(style);\n\n    // we split text by lines and normalize\n    // {soft break} + {line break} => { line break }\n    var lines = text.split(/\\u00AD?\\r?\\n/),\n        layouted = [];\n\n    var maxWidth = box.width - padding.left - padding.right;\n\n    // ensure correct rendering by attaching helper text node to invisible SVG\n    var helperText = create$1('text');\n    attr$1(helperText, { x: 0, y: 0 });\n    attr$1(helperText, style);\n\n    var helperSvg = getHelperSvg();\n\n    append(helperSvg, helperText);\n\n    while (lines.length) {\n      layouted.push(layoutNext(lines, maxWidth, helperText));\n    }\n\n    if (align.vertical === 'middle') {\n      padding.top = padding.bottom = 0;\n    }\n\n    var totalHeight = reduce(layouted, function(sum, line, idx) {\n      return sum + (lineHeight || line.height);\n    }, 0) + padding.top + padding.bottom;\n\n    var maxLineWidth = reduce(layouted, function(sum, line, idx) {\n      return line.width > sum ? line.width : sum;\n    }, 0);\n\n    // the y position of the next line\n    var y = padding.top;\n\n    if (align.vertical === 'middle') {\n      y += (box.height - totalHeight) / 2;\n    }\n\n    // magic number initial offset\n    y -= (lineHeight || layouted[0].height) / 4;\n\n\n    var textElement = create$1('text');\n\n    attr$1(textElement, style);\n\n    // layout each line taking into account that parent\n    // shape might resize to fit text size\n    forEach$1(layouted, function(line) {\n\n      var x;\n\n      y += (lineHeight || line.height);\n\n      switch (align.horizontal) {\n      case 'left':\n        x = padding.left;\n        break;\n\n      case 'right':\n        x = ((fitBox ? maxLineWidth : maxWidth)\n          - padding.right - line.width);\n        break;\n\n      default:\n\n        // aka center\n        x = Math.max((((fitBox ? maxLineWidth : maxWidth)\n          - line.width) / 2 + padding.left), 0);\n      }\n\n      var tspan = create$1('tspan');\n      attr$1(tspan, { x: x, y: y });\n\n      tspan.textContent = line.text;\n\n      append(textElement, tspan);\n    });\n\n    remove$2(helperText);\n\n    var dimensions = {\n      width: maxLineWidth,\n      height: totalHeight\n    };\n\n    return {\n      dimensions: dimensions,\n      element: textElement\n    };\n  };\n\n\n  function getLineHeight(style) {\n    if ('fontSize' in style && 'lineHeight' in style) {\n      return style.lineHeight * parseInt(style.fontSize, 10);\n    }\n  }\n\n  var DEFAULT_FONT_SIZE = 12;\r\n  var LINE_HEIGHT_RATIO = 1.2;\r\n\r\n  var MIN_TEXT_ANNOTATION_HEIGHT = 30;\r\n\r\n  /**\r\n   * @typedef { {\r\n   *   fontFamily: string;\r\n   *   fontSize: number;\r\n   *   fontWeight: string;\r\n   *   lineHeight: number;\r\n   * } } TextRendererStyle\r\n   *\r\n   * @typedef { {\r\n   *   defaultStyle?: Partial<TextRendererStyle>;\r\n   *   externalStyle?: Partial<TextRendererStyle>;\r\n   * } } TextRendererConfig\r\n   *\r\n   * @typedef { import('diagram-js/lib/util/Text').TextLayoutConfig } TextLayoutConfig\r\n   *\r\n   * @typedef { import('diagram-js/lib/util/Types').Rect } Rect\r\n   */\r\n\r\n\r\n  /**\r\n   * Renders text and computes text bounding boxes.\r\n   *\r\n   * @param {TextRendererConfig} [config]\r\n   */\r\n  function TextRenderer(config) {\r\n\r\n    var defaultStyle = assign$1({\r\n      fontFamily: 'Arial, sans-serif',\r\n      fontSize: DEFAULT_FONT_SIZE,\r\n      fontWeight: 'normal',\r\n      lineHeight: LINE_HEIGHT_RATIO\r\n    }, config && config.defaultStyle || {});\r\n\r\n    var fontSize = parseInt(defaultStyle.fontSize, 10) - 1;\r\n\r\n    var externalStyle = assign$1({}, defaultStyle, {\r\n      fontSize: fontSize\r\n    }, config && config.externalStyle || {});\r\n\r\n    var textUtil = new Text({\r\n      style: defaultStyle\r\n    });\r\n\r\n    /**\r\n     * Get the new bounds of an externally rendered,\r\n     * layouted label.\r\n     *\r\n     * @param {Rect} bounds\r\n     * @param {string} text\r\n     *\r\n     * @return {Rect}\r\n     */\r\n    this.getExternalLabelBounds = function(bounds, text) {\r\n\r\n      var layoutedDimensions = textUtil.getDimensions(text, {\r\n        box: {\r\n          width: 90,\r\n          height: 30\r\n        },\r\n        style: externalStyle\r\n      });\r\n\r\n      // resize label shape to fit label text\r\n      return {\r\n        x: Math.round(bounds.x + bounds.width / 2 - layoutedDimensions.width / 2),\r\n        y: Math.round(bounds.y),\r\n        width: Math.ceil(layoutedDimensions.width),\r\n        height: Math.ceil(layoutedDimensions.height)\r\n      };\r\n\r\n    };\r\n\r\n    /**\r\n     * Get the new bounds of text annotation.\r\n     *\r\n     * @param {Rect} bounds\r\n     * @param {string} text\r\n     *\r\n     * @return {Rect}\r\n     */\r\n    this.getTextAnnotationBounds = function(bounds, text) {\r\n\r\n      var layoutedDimensions = textUtil.getDimensions(text, {\r\n        box: bounds,\r\n        style: defaultStyle,\r\n        align: 'left-top',\r\n        padding: 5\r\n      });\r\n\r\n      return {\r\n        x: bounds.x,\r\n        y: bounds.y,\r\n        width: bounds.width,\r\n        height: Math.max(MIN_TEXT_ANNOTATION_HEIGHT, Math.round(layoutedDimensions.height))\r\n      };\r\n    };\r\n\r\n    /**\r\n     * Create a layouted text element.\r\n     *\r\n     * @param {string} text\r\n     * @param {TextLayoutConfig} [options]\r\n     *\r\n     * @return {SVGElement} rendered text\r\n     */\r\n    this.createText = function(text, options) {\r\n      return textUtil.createText(text, options || {});\r\n    };\r\n\r\n    /**\r\n     * Get default text style.\r\n     */\r\n    this.getDefaultStyle = function() {\r\n      return defaultStyle;\r\n    };\r\n\r\n    /**\r\n     * Get the external text style.\r\n     */\r\n    this.getExternalStyle = function() {\r\n      return externalStyle;\r\n    };\r\n\r\n  }\r\n\r\n  TextRenderer.$inject = [\r\n    'config.textRenderer'\r\n  ];\n\n  /**\r\n   * Map containing SVG paths needed by BpmnRenderer\r\n   */\r\n  function PathMap() {\r\n\r\n    /**\r\n     * Contains a map of path elements\r\n     *\r\n     * <h1>Path definition</h1>\r\n     * A parameterized path is defined like this:\r\n     * <pre>\r\n     * 'GATEWAY_PARALLEL': {\r\n     *   d: 'm {mx},{my} {e.x0},0 0,{e.x1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +\r\n            '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',\r\n     *   height: 17.5,\r\n     *   width:  17.5,\r\n     *   heightElements: [2.5, 7.5],\r\n     *   widthElements: [2.5, 7.5]\r\n     * }\r\n     * </pre>\r\n     * <p>It's important to specify a correct <b>height and width</b> for the path as the scaling\r\n     * is based on the ratio between the specified height and width in this object and the\r\n     * height and width that is set as scale target (Note x,y coordinates will be scaled with\r\n     * individual ratios).</p>\r\n     * <p>The '<b>heightElements</b>' and '<b>widthElements</b>' array must contain the values that will be scaled.\r\n     * The scaling is based on the computed ratios.\r\n     * Coordinates on the y axis should be in the <b>heightElement</b>'s array, they will be scaled using\r\n     * the computed ratio coefficient.\r\n     * In the parameterized path the scaled values can be accessed through the 'e' object in {} brackets.\r\n     *   <ul>\r\n     *    <li>The values for the y axis can be accessed in the path string using {e.y0}, {e.y1}, ....</li>\r\n     *    <li>The values for the x axis can be accessed in the path string using {e.x0}, {e.x1}, ....</li>\r\n     *   </ul>\r\n     *   The numbers x0, x1 respectively y0, y1, ... map to the corresponding array index.\r\n     * </p>\r\n     */\r\n    this.pathMap = {\r\n      'EVENT_MESSAGE': {\r\n        d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',\r\n        height: 36,\r\n        width:  36,\r\n        heightElements: [ 6, 14 ],\r\n        widthElements: [ 10.5, 21 ]\r\n      },\r\n      'EVENT_SIGNAL': {\r\n        d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x1},0 Z',\r\n        height: 36,\r\n        width: 36,\r\n        heightElements: [ 18 ],\r\n        widthElements: [ 10, 20 ]\r\n      },\r\n      'EVENT_ESCALATION': {\r\n        d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x0},-{e.y1} l -{e.x0},{e.y1} Z',\r\n        height: 36,\r\n        width: 36,\r\n        heightElements: [ 20, 7 ],\r\n        widthElements: [ 8 ]\r\n      },\r\n      'EVENT_CONDITIONAL': {\r\n        d: 'M {e.x0},{e.y0} l {e.x1},0 l 0,{e.y2} l -{e.x1},0 Z ' +\r\n           'M {e.x2},{e.y3} l {e.x0},0 ' +\r\n           'M {e.x2},{e.y4} l {e.x0},0 ' +\r\n           'M {e.x2},{e.y5} l {e.x0},0 ' +\r\n           'M {e.x2},{e.y6} l {e.x0},0 ' +\r\n           'M {e.x2},{e.y7} l {e.x0},0 ' +\r\n           'M {e.x2},{e.y8} l {e.x0},0 ',\r\n        height: 36,\r\n        width:  36,\r\n        heightElements: [ 8.5, 14.5, 18, 11.5, 14.5, 17.5, 20.5, 23.5, 26.5 ],\r\n        widthElements:  [ 10.5, 14.5, 12.5 ]\r\n      },\r\n      'EVENT_LINK': {\r\n        d: 'm {mx},{my} 0,{e.y0} -{e.x1},0 0,{e.y1} {e.x1},0 0,{e.y0} {e.x0},-{e.y2} -{e.x0},-{e.y2} z',\r\n        height: 36,\r\n        width: 36,\r\n        heightElements: [ 4.4375, 6.75, 7.8125 ],\r\n        widthElements: [ 9.84375, 13.5 ]\r\n      },\r\n      'EVENT_ERROR': {\r\n        d: 'm {mx},{my} {e.x0},-{e.y0} {e.x1},-{e.y1} {e.x2},{e.y2} {e.x3},-{e.y3} -{e.x4},{e.y4} -{e.x5},-{e.y5} z',\r\n        height: 36,\r\n        width: 36,\r\n        heightElements: [ 0.023, 8.737, 8.151, 16.564, 10.591, 8.714 ],\r\n        widthElements: [ 0.085, 6.672, 6.97, 4.273, 5.337, 6.636 ]\r\n      },\r\n      'EVENT_CANCEL_45': {\r\n        d: 'm {mx},{my} -{e.x1},0 0,{e.x0} {e.x1},0 0,{e.y1} {e.x0},0 ' +\r\n          '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',\r\n        height: 36,\r\n        width: 36,\r\n        heightElements: [ 4.75, 8.5 ],\r\n        widthElements: [ 4.75, 8.5 ]\r\n      },\r\n      'EVENT_COMPENSATION': {\r\n        d: 'm {mx},{my} {e.x0},-{e.y0} 0,{e.y1} z m {e.x1},-{e.y2} {e.x2},-{e.y3} 0,{e.y1} -{e.x2},-{e.y3} z',\r\n        height: 36,\r\n        width: 36,\r\n        heightElements: [ 6.5, 13, 0.4, 6.1 ],\r\n        widthElements: [ 9, 9.3, 8.7 ]\r\n      },\r\n      'EVENT_TIMER_WH': {\r\n        d: 'M {mx},{my} l {e.x0},-{e.y0} m -{e.x0},{e.y0} l {e.x1},{e.y1} ',\r\n        height: 36,\r\n        width:  36,\r\n        heightElements: [ 10, 2 ],\r\n        widthElements: [ 3, 7 ]\r\n      },\r\n      'EVENT_TIMER_LINE': {\r\n        d:  'M {mx},{my} ' +\r\n            'm {e.x0},{e.y0} l -{e.x1},{e.y1} ',\r\n        height: 36,\r\n        width:  36,\r\n        heightElements: [ 10, 3 ],\r\n        widthElements: [ 0, 0 ]\r\n      },\r\n      'EVENT_MULTIPLE': {\r\n        d:'m {mx},{my} {e.x1},-{e.y0} {e.x1},{e.y0} -{e.x0},{e.y1} -{e.x2},0 z',\r\n        height: 36,\r\n        width:  36,\r\n        heightElements: [ 6.28099, 12.56199 ],\r\n        widthElements: [ 3.1405, 9.42149, 12.56198 ]\r\n      },\r\n      'EVENT_PARALLEL_MULTIPLE': {\r\n        d:'m {mx},{my} {e.x0},0 0,{e.y1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +\r\n          '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',\r\n        height: 36,\r\n        width:  36,\r\n        heightElements: [ 2.56228, 7.68683 ],\r\n        widthElements: [ 2.56228, 7.68683 ]\r\n      },\r\n      'GATEWAY_EXCLUSIVE': {\r\n        d:'m {mx},{my} {e.x0},{e.y0} {e.x1},{e.y0} {e.x2},0 {e.x4},{e.y2} ' +\r\n                      '{e.x4},{e.y1} {e.x2},0 {e.x1},{e.y3} {e.x0},{e.y3} ' +\r\n                      '{e.x3},0 {e.x5},{e.y1} {e.x5},{e.y2} {e.x3},0 z',\r\n        height: 17.5,\r\n        width:  17.5,\r\n        heightElements: [ 8.5, 6.5312, -6.5312, -8.5 ],\r\n        widthElements:  [ 6.5, -6.5, 3, -3, 5, -5 ]\r\n      },\r\n      'GATEWAY_PARALLEL': {\r\n        d:'m {mx},{my} 0,{e.y1} -{e.x1},0 0,{e.y0} {e.x1},0 0,{e.y1} {e.x0},0 ' +\r\n          '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',\r\n        height: 30,\r\n        width:  30,\r\n        heightElements: [ 5, 12.5 ],\r\n        widthElements: [ 5, 12.5 ]\r\n      },\r\n      'GATEWAY_EVENT_BASED': {\r\n        d:'m {mx},{my} {e.x0},{e.y0} {e.x0},{e.y1} {e.x1},{e.y2} {e.x2},0 z',\r\n        height: 11,\r\n        width:  11,\r\n        heightElements: [ -6, 6, 12, -12 ],\r\n        widthElements: [ 9, -3, -12 ]\r\n      },\r\n      'GATEWAY_COMPLEX': {\r\n        d:'m {mx},{my} 0,{e.y0} -{e.x0},-{e.y1} -{e.x1},{e.y2} {e.x0},{e.y1} -{e.x2},0 0,{e.y3} ' +\r\n          '{e.x2},0  -{e.x0},{e.y1} l {e.x1},{e.y2} {e.x0},-{e.y1} 0,{e.y0} {e.x3},0 0,-{e.y0} {e.x0},{e.y1} ' +\r\n          '{e.x1},-{e.y2} -{e.x0},-{e.y1} {e.x2},0 0,-{e.y3} -{e.x2},0 {e.x0},-{e.y1} -{e.x1},-{e.y2} ' +\r\n          '-{e.x0},{e.y1} 0,-{e.y0} -{e.x3},0 z',\r\n        height: 17.125,\r\n        width:  17.125,\r\n        heightElements: [ 4.875, 3.4375, 2.125, 3 ],\r\n        widthElements: [ 3.4375, 2.125, 4.875, 3 ]\r\n      },\r\n      'DATA_OBJECT_PATH': {\r\n        d:'m 0,0 {e.x1},0 {e.x0},{e.y0} 0,{e.y1} -{e.x2},0 0,-{e.y2} {e.x1},0 0,{e.y0} {e.x0},0',\r\n        height: 61,\r\n        width:  51,\r\n        heightElements: [ 10, 50, 60 ],\r\n        widthElements: [ 10, 40, 50, 60 ]\r\n      },\r\n      'DATA_OBJECT_COLLECTION_PATH': {\r\n        d: 'm{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10',\r\n        height: 10,\r\n        width: 10,\r\n        heightElements: [],\r\n        widthElements: []\r\n      },\r\n      'DATA_ARROW': {\r\n        d:'m 5,9 9,0 0,-3 5,5 -5,5 0,-3 -9,0 z',\r\n        height: 61,\r\n        width:  51,\r\n        heightElements: [],\r\n        widthElements: []\r\n      },\r\n      'DATA_STORE': {\r\n        d:'m  {mx},{my} ' +\r\n          'l  0,{e.y2} ' +\r\n          'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +\r\n          'l  0,-{e.y2} ' +\r\n          'c -{e.x0},-{e.y1} -{e.x1},-{e.y1} -{e.x2},0' +\r\n          'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +\r\n          'm  -{e.x2},{e.y0}' +\r\n          'c  {e.x0},{e.y1} {e.x1},{e.y1} {e.x2},0' +\r\n          'm  -{e.x2},{e.y0}' +\r\n          'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0',\r\n        height: 61,\r\n        width:  61,\r\n        heightElements: [ 7, 10, 45 ],\r\n        widthElements:  [ 2, 58, 60 ]\r\n      },\r\n      'TEXT_ANNOTATION': {\r\n        d: 'm {mx}, {my} m 10,0 l -10,0 l 0,{e.y0} l 10,0',\r\n        height: 30,\r\n        width: 10,\r\n        heightElements: [ 30 ],\r\n        widthElements: [ 10 ]\r\n      },\r\n      'MARKER_SUB_PROCESS': {\r\n        d: 'm{mx},{my} m 7,2 l 0,10 m -5,-5 l 10,0',\r\n        height: 10,\r\n        width: 10,\r\n        heightElements: [],\r\n        widthElements: []\r\n      },\r\n      'MARKER_PARALLEL': {\r\n        d: 'm{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10',\r\n        height: 10,\r\n        width: 10,\r\n        heightElements: [],\r\n        widthElements: []\r\n      },\r\n      'MARKER_SEQUENTIAL': {\r\n        d: 'm{mx},{my} m 0,3 l 10,0 m -10,3 l 10,0 m -10,3 l 10,0',\r\n        height: 10,\r\n        width: 10,\r\n        heightElements: [],\r\n        widthElements: []\r\n      },\r\n      'MARKER_COMPENSATION': {\r\n        d: 'm {mx},{my} 7,-5 0,10 z m 7.1,-0.3 6.9,-4.7 0,10 -6.9,-4.7 z',\r\n        height: 10,\r\n        width: 21,\r\n        heightElements: [],\r\n        widthElements: []\r\n      },\r\n      'MARKER_LOOP': {\r\n        d: 'm {mx},{my} c 3.526979,0 6.386161,-2.829858 6.386161,-6.320661 0,-3.490806 -2.859182,-6.320661 ' +\r\n          '-6.386161,-6.320661 -3.526978,0 -6.38616,2.829855 -6.38616,6.320661 0,1.745402 ' +\r\n          '0.714797,3.325567 1.870463,4.469381 0.577834,0.571908 1.265885,1.034728 2.029916,1.35457 ' +\r\n          'l -0.718163,-3.909793 m 0.718163,3.909793 -3.885211,0.802902',\r\n        height: 13.9,\r\n        width: 13.7,\r\n        heightElements: [],\r\n        widthElements: []\r\n      },\r\n      'MARKER_ADHOC': {\r\n        d: 'm {mx},{my} m 0.84461,2.64411 c 1.05533,-1.23780996 2.64337,-2.07882 4.29653,-1.97997996 2.05163,0.0805 ' +\r\n          '3.85579,1.15803 5.76082,1.79107 1.06385,0.34139996 2.24454,0.1438 3.18759,-0.43767 0.61743,-0.33642 ' +\r\n          '1.2775,-0.64078 1.7542,-1.17511 0,0.56023 0,1.12046 0,1.6807 -0.98706,0.96237996 -2.29792,1.62393996 ' +\r\n          '-3.6918,1.66181996 -1.24459,0.0927 -2.46671,-0.2491 -3.59505,-0.74812 -1.35789,-0.55965 ' +\r\n          '-2.75133,-1.33436996 -4.27027,-1.18121996 -1.37741,0.14601 -2.41842,1.13685996 -3.44288,1.96782996 z',\r\n        height: 4,\r\n        width: 15,\r\n        heightElements: [],\r\n        widthElements: []\r\n      },\r\n      'TASK_TYPE_SEND': {\r\n        d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',\r\n        height: 14,\r\n        width:  21,\r\n        heightElements: [ 6, 14 ],\r\n        widthElements: [ 10.5, 21 ]\r\n      },\r\n      'TASK_TYPE_SCRIPT': {\r\n        d: 'm {mx},{my} c 9.966553,-6.27276 -8.000926,-7.91932 2.968968,-14.938 l -8.802728,0 ' +\r\n          'c -10.969894,7.01868 6.997585,8.66524 -2.968967,14.938 z ' +\r\n          'm -7,-12 l 5,0 ' +\r\n          'm -4.5,3 l 4.5,0 ' +\r\n          'm -3,3 l 5,0' +\r\n          'm -4,3 l 5,0',\r\n        height: 15,\r\n        width:  12.6,\r\n        heightElements: [ 6, 14 ],\r\n        widthElements: [ 10.5, 21 ]\r\n      },\r\n      'TASK_TYPE_USER_1': {\r\n        d: 'm {mx},{my} c 0.909,-0.845 1.594,-2.049 1.594,-3.385 0,-2.554 -1.805,-4.62199999 ' +\r\n          '-4.357,-4.62199999 -2.55199998,0 -4.28799998,2.06799999 -4.28799998,4.62199999 0,1.348 ' +\r\n          '0.974,2.562 1.89599998,3.405 -0.52899998,0.187 -5.669,2.097 -5.794,4.7560005 v 6.718 ' +\r\n          'h 17 v -6.718 c 0,-2.2980005 -5.5279996,-4.5950005 -6.0509996,-4.7760005 z' +\r\n          'm -8,6 l 0,5.5 m 11,0 l 0,-5'\r\n      },\r\n      'TASK_TYPE_USER_2': {\r\n        d: 'm {mx},{my} m 2.162,1.009 c 0,2.4470005 -2.158,4.4310005 -4.821,4.4310005 ' +\r\n          '-2.66499998,0 -4.822,-1.981 -4.822,-4.4310005 '\r\n      },\r\n      'TASK_TYPE_USER_3': {\r\n        d: 'm {mx},{my} m -6.9,-3.80 c 0,0 2.25099998,-2.358 4.27399998,-1.177 2.024,1.181 4.221,1.537 ' +\r\n          '4.124,0.965 -0.098,-0.57 -0.117,-3.79099999 -4.191,-4.13599999 -3.57499998,0.001 ' +\r\n          '-4.20799998,3.36699999 -4.20699998,4.34799999 z'\r\n      },\r\n      'TASK_TYPE_MANUAL': {\r\n        d: 'm {mx},{my} c 0.234,-0.01 5.604,0.008 8.029,0.004 0.808,0 1.271,-0.172 1.417,-0.752 0.227,-0.898 ' +\r\n          '-0.334,-1.314 -1.338,-1.316 -2.467,-0.01 -7.886,-0.004 -8.108,-0.004 -0.014,-0.079 0.016,-0.533 0,-0.61 ' +\r\n          '0.195,-0.042 8.507,0.006 9.616,0.002 0.877,-0.007 1.35,-0.438 1.353,-1.208 0.003,-0.768 -0.479,-1.09 ' +\r\n          '-1.35,-1.091 -2.968,-0.002 -9.619,-0.013 -9.619,-0.013 v -0.591 c 0,0 5.052,-0.016 7.225,-0.016 ' +\r\n          '0.888,-0.002 1.354,-0.416 1.351,-1.193 -0.006,-0.761 -0.492,-1.196 -1.361,-1.196 -3.473,-0.005 ' +\r\n          '-10.86,-0.003 -11.0829995,-0.003 -0.022,-0.047 -0.045,-0.094 -0.069,-0.139 0.3939995,-0.319 ' +\r\n          '2.0409995,-1.626 2.4149995,-2.017 0.469,-0.4870005 0.519,-1.1650005 0.162,-1.6040005 -0.414,-0.511 ' +\r\n          '-0.973,-0.5 -1.48,-0.236 -1.4609995,0.764 -6.5999995,3.6430005 -7.7329995,4.2710005 -0.9,0.499 ' +\r\n          '-1.516,1.253 -1.882,2.19 -0.37000002,0.95 -0.17,2.01 -0.166,2.979 0.004,0.718 -0.27300002,1.345 ' +\r\n          '-0.055,2.063 0.629,2.087 2.425,3.312 4.859,3.318 4.6179995,0.014 9.2379995,-0.139 13.8569995,-0.158 ' +\r\n          '0.755,-0.004 1.171,-0.301 1.182,-1.033 0.012,-0.754 -0.423,-0.969 -1.183,-0.973 -1.778,-0.01 ' +\r\n          '-5.824,-0.004 -6.04,-0.004 10e-4,-0.084 0.003,-0.586 10e-4,-0.67 z'\r\n      },\r\n      'TASK_TYPE_INSTANTIATING_SEND': {\r\n        d: 'm {mx},{my} l 0,8.4 l 12.6,0 l 0,-8.4 z l 6.3,3.6 l 6.3,-3.6'\r\n      },\r\n      'TASK_TYPE_SERVICE': {\r\n        d: 'm {mx},{my} v -1.71335 c 0.352326,-0.0705 0.703932,-0.17838 1.047628,-0.32133 ' +\r\n          '0.344416,-0.14465 0.665822,-0.32133 0.966377,-0.52145 l 1.19431,1.18005 1.567487,-1.57688 ' +\r\n          '-1.195028,-1.18014 c 0.403376,-0.61394 0.683079,-1.29908 0.825447,-2.01824 l 1.622133,-0.01 ' +\r\n          'v -2.2196 l -1.636514,0.01 c -0.07333,-0.35153 -0.178319,-0.70024 -0.323564,-1.04372 ' +\r\n          '-0.145244,-0.34406 -0.321407,-0.6644 -0.522735,-0.96217 l 1.131035,-1.13631 -1.583305,-1.56293 ' +\r\n          '-1.129598,1.13589 c -0.614052,-0.40108 -1.302883,-0.68093 -2.022633,-0.82247 l 0.0093,-1.61852 ' +\r\n          'h -2.241173 l 0.0042,1.63124 c -0.353763,0.0736 -0.705369,0.17977 -1.049785,0.32371 -0.344415,0.14437 ' +\r\n          '-0.665102,0.32092 -0.9635006,0.52046 l -1.1698628,-1.15823 -1.5667691,1.5792 1.1684265,1.15669 ' +\r\n          'c -0.4026573,0.61283 -0.68308,1.29797 -0.8247287,2.01713 l -1.6588041,0.003 v 2.22174 ' +\r\n          'l 1.6724648,-0.006 c 0.073327,0.35077 0.1797598,0.70243 0.3242851,1.04472 0.1452428,0.34448 ' +\r\n          '0.3214064,0.6644 0.5227339,0.96066 l -1.1993431,1.19723 1.5840256,1.56011 1.1964668,-1.19348 ' +\r\n          'c 0.6140517,0.40346 1.3028827,0.68232 2.0233517,0.82331 l 7.19e-4,1.69892 h 2.226848 z ' +\r\n          'm 0.221462,-3.9957 c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +\r\n          '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +\r\n          '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'\r\n      },\r\n      'TASK_TYPE_SERVICE_FILL': {\r\n        d: 'm {mx},{my} c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +\r\n          '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +\r\n          '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'\r\n      },\r\n      'TASK_TYPE_BUSINESS_RULE_HEADER': {\r\n        d: 'm {mx},{my} 0,4 20,0 0,-4 z'\r\n      },\r\n      'TASK_TYPE_BUSINESS_RULE_MAIN': {\r\n        d: 'm {mx},{my} 0,12 20,0 0,-12 z' +\r\n          'm 0,8 l 20,0 ' +\r\n          'm -13,-4 l 0,8'\r\n      },\r\n      'MESSAGE_FLOW_MARKER': {\r\n        d: 'm {mx},{my} m -10.5 ,-7 l 0,14 l 21,0 l 0,-14 z l 10.5,6 l 10.5,-6'\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Return raw path for the given ID.\r\n     *\r\n     * @param {string} pathId\r\n     *\r\n     * @return {string} raw path\r\n     */\r\n    this.getRawPath = function getRawPath(pathId) {\r\n      return this.pathMap[pathId].d;\r\n    };\r\n\r\n    /**\r\n     * Scales the path to the given height and width.\r\n     * <h1>Use case</h1>\r\n     * <p>Use case is to scale the content of elements (event, gateways) based\r\n     * on the element bounding box's size.\r\n     * </p>\r\n     * <h1>Why not transform</h1>\r\n     * <p>Scaling a path with transform() will also scale the stroke and IE does not support\r\n     * the option 'non-scaling-stroke' to prevent this.\r\n     * Also there are use cases where only some parts of a path should be\r\n     * scaled.</p>\r\n     *\r\n     * @param {string} pathId The ID of the path.\r\n     * @param {Object} param <p>\r\n     *   Example param object scales the path to 60% size of the container (data.width, data.height).\r\n     *   <pre>\r\n     *   {\r\n     *     xScaleFactor: 0.6,\r\n     *     yScaleFactor:0.6,\r\n     *     containerWidth: data.width,\r\n     *     containerHeight: data.height,\r\n     *     position: {\r\n     *       mx: 0.46,\r\n     *       my: 0.2,\r\n     *     }\r\n     *   }\r\n     *   </pre>\r\n     *   <ul>\r\n     *    <li>targetpathwidth = xScaleFactor * containerWidth</li>\r\n     *    <li>targetpathheight = yScaleFactor * containerHeight</li>\r\n     *    <li>Position is used to set the starting coordinate of the path. M is computed:\r\n      *    <ul>\r\n      *      <li>position.x * containerWidth</li>\r\n      *      <li>position.y * containerHeight</li>\r\n      *    </ul>\r\n      *    Center of the container <pre> position: {\r\n     *       mx: 0.5,\r\n     *       my: 0.5,\r\n     *     }</pre>\r\n     *     Upper left corner of the container\r\n     *     <pre> position: {\r\n     *       mx: 0.0,\r\n     *       my: 0.0,\r\n     *     }</pre>\r\n     *    </li>\r\n     *   </ul>\r\n     * </p>\r\n     *\r\n     * @return {string} scaled path\r\n     */\r\n    this.getScaledPath = function getScaledPath(pathId, param) {\r\n      var rawPath = this.pathMap[pathId];\r\n\r\n      // positioning\r\n      // compute the start point of the path\r\n      var mx, my;\r\n\r\n      if (param.abspos) {\r\n        mx = param.abspos.x;\r\n        my = param.abspos.y;\r\n      } else {\r\n        mx = param.containerWidth * param.position.mx;\r\n        my = param.containerHeight * param.position.my;\r\n      }\r\n\r\n      var coordinates = {}; // map for the scaled coordinates\r\n      if (param.position) {\r\n\r\n        // path\r\n        var heightRatio = (param.containerHeight / rawPath.height) * param.yScaleFactor;\r\n        var widthRatio = (param.containerWidth / rawPath.width) * param.xScaleFactor;\r\n\r\n\r\n        // Apply height ratio\r\n        for (var heightIndex = 0; heightIndex < rawPath.heightElements.length; heightIndex++) {\r\n          coordinates['y' + heightIndex] = rawPath.heightElements[heightIndex] * heightRatio;\r\n        }\r\n\r\n        // Apply width ratio\r\n        for (var widthIndex = 0; widthIndex < rawPath.widthElements.length; widthIndex++) {\r\n          coordinates['x' + widthIndex] = rawPath.widthElements[widthIndex] * widthRatio;\r\n        }\r\n      }\r\n\r\n      // Apply value to raw path\r\n      var path = format(\r\n        rawPath.d, {\r\n          mx: mx,\r\n          my: my,\r\n          e: coordinates\r\n        }\r\n      );\r\n      return path;\r\n    };\r\n  }\r\n\r\n  // helpers //////////////////////\r\n\r\n  // copied and adjusted from https://github.com/adobe-webplatform/Snap.svg/blob/master/src/svg.js\r\n  var tokenRegex = /\\{([^{}]+)\\}/g,\r\n      objNotationRegex = /(?:(?:^|\\.)(.+?)(?=\\[|\\.|$|\\()|\\[('|\")(.+?)\\2\\])(\\(\\))?/g; // matches .xxxxx or [\"xxxxx\"] to run over object properties\r\n\r\n  function replacer(all, key, obj) {\r\n    var res = obj;\r\n    key.replace(objNotationRegex, function(all, name, quote, quotedName, isFunc) {\r\n      name = name || quotedName;\r\n      if (res) {\r\n        if (name in res) {\r\n          res = res[name];\r\n        }\r\n        typeof res == 'function' && isFunc && (res = res());\r\n      }\r\n    });\r\n    res = (res == null || res == obj ? all : res) + '';\r\n\r\n    return res;\r\n  }\r\n\r\n  function format(str, obj) {\r\n    return String(str).replace(tokenRegex, function(all, key) {\r\n      return replacer(all, key, obj);\r\n    });\r\n  }\n\n  var DrawModule$1 = {\r\n    __init__: [ 'bpmnRenderer' ],\r\n    bpmnRenderer: [ 'type', BpmnRenderer ],\r\n    textRenderer: [ 'type', TextRenderer ],\r\n    pathMap: [ 'type', PathMap ]\r\n  };\n\n  /**\n   * @typedef { {\n   *   [key: string]: string;\n   * } } TranslateReplacements\n   */\n\n  /**\n   * A simple translation stub to be used for multi-language support\n   * in diagrams. Can be easily replaced with a more sophisticated\n   * solution.\n   *\n   * @example\n   *\n   * ```javascript\n   * // use it inside any diagram component by injecting `translate`.\n   *\n   * function MyService(translate) {\n   *   alert(translate('HELLO {you}', { you: 'You!' }));\n   * }\n   * ```\n   *\n   * @param {string} template to interpolate\n   * @param {TranslateReplacements} [replacements] a map with substitutes\n   *\n   * @return {string} the translated string\n   */\n  function translate(template, replacements) {\n\n    replacements = replacements || {};\n\n    return template.replace(/{([^}]+)}/g, function(_, key) {\n      return replacements[key] || '{' + key + '}';\n    });\n  }\n\n  /**\n   * @type { import('didi').ModuleDeclaration }\n   */\n  var TranslateModule = {\n    translate: [ 'value', translate ]\n  };\n\n  /**\n   * @param {Point} point\n   *\n   * @returns {Point}\n   */\n  function roundPoint(point) {\n\n    return {\n      x: Math.round(point.x),\n      y: Math.round(point.y)\n    };\n  }\n\n\n  /**\n   * Convert the given bounds to a { top, left, bottom, right } descriptor.\n   *\n   * @param {Point|Rect} bounds\n   *\n   * @return {RectTRBL}\n   */\n  function asTRBL(bounds) {\n    return {\n      top: bounds.y,\n      right: bounds.x + (bounds.width || 0),\n      bottom: bounds.y + (bounds.height || 0),\n      left: bounds.x\n    };\n  }\n\n\n  /**\n   * Convert a { top, left, bottom, right } to an objects bounds.\n   *\n   * @param {RectTRBL} trbl\n   *\n   * @return {Rect}\n   */\n  function asBounds(trbl) {\n    return {\n      x: trbl.left,\n      y: trbl.top,\n      width: trbl.right - trbl.left,\n      height: trbl.bottom - trbl.top\n    };\n  }\n\n\n  /**\n   * Get the mid of the given bounds or point.\n   *\n   * @param {Point|Rect} bounds\n   *\n   * @return {Point}\n   */\n  function getBoundsMid(bounds) {\n    return roundPoint({\n      x: bounds.x + (bounds.width || 0) / 2,\n      y: bounds.y + (bounds.height || 0) / 2\n    });\n  }\n\n\n  /**\n   * Get the mid of the given Connection.\n   *\n   * @param {Connection} connection\n   *\n   * @return {Point}\n   */\n  function getConnectionMid(connection) {\n    var waypoints = connection.waypoints;\n\n    // calculate total length and length of each segment\n    var parts = waypoints.reduce(function(parts, point, index) {\n\n      var lastPoint = waypoints[index - 1];\n\n      if (lastPoint) {\n        var lastPart = parts[parts.length - 1];\n\n        var startLength = lastPart && lastPart.endLength || 0;\n        var length = distance(lastPoint, point);\n\n        parts.push({\n          start: lastPoint,\n          end: point,\n          startLength: startLength,\n          endLength: startLength + length,\n          length: length\n        });\n      }\n\n      return parts;\n    }, []);\n\n    var totalLength = parts.reduce(function(length, part) {\n      return length + part.length;\n    }, 0);\n\n    // find which segement contains middle point\n    var midLength = totalLength / 2;\n\n    var i = 0;\n    var midSegment = parts[i];\n\n    while (midSegment.endLength < midLength) {\n      midSegment = parts[++i];\n    }\n\n    // calculate relative position on mid segment\n    var segmentProgress = (midLength - midSegment.startLength) / midSegment.length;\n\n    var midPoint = {\n      x: midSegment.start.x + (midSegment.end.x - midSegment.start.x) * segmentProgress,\n      y: midSegment.start.y + (midSegment.end.y - midSegment.start.y) * segmentProgress\n    };\n\n    return midPoint;\n  }\n\n\n  /**\n   * Get the mid of the given Element.\n   *\n   * @param {Element} element\n   *\n   * @return {Point}\n   */\n  function getMid(element) {\n    if (isConnection(element)) {\n      return getConnectionMid(element);\n    }\n\n    return getBoundsMid(element);\n  }\n\n  // helpers //////////////////////\n\n  function distance(a, b) {\n    return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n  }\n\n  function elementToString(e) {\r\n    if (!e) {\r\n      return '<null>';\r\n    }\r\n\r\n    return '<' + e.$type + (e.id ? ' id=\"' + e.id : '') + '\" />';\r\n  }\n\n  /**\r\n   * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas\r\n   * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry\r\n   * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\r\n   *\r\n   * @typedef {import('../features/modeling/ElementFactory').default} ElementFactory\r\n   * @typedef {import('../draw/TextRenderer').default} TextRenderer\r\n   *\r\n   * @typedef {import('../model/Types').Element} Element\r\n   * @typedef {import('../model/Types').Label} Label\r\n   * @typedef {import('../model/Types').Shape} Shape\r\n   * @typedef {import('../model/Types').Connection} Connection\r\n   * @typedef {import('../model/Types').Root} Root\r\n   * @typedef {import('../model/Types').ModdleElement} ModdleElement\r\n   */\r\n\r\n  /**\r\n   * @param {ModdleElement} semantic\r\n   * @param {ModdleElement} di\r\n   * @param {Object} [attrs=null]\r\n   *\r\n   * @return {Object}\r\n   */\r\n  function elementData(semantic, di, attrs) {\r\n    return assign$1({\r\n      id: semantic.id,\r\n      type: semantic.$type,\r\n      businessObject: semantic,\r\n      di: di\r\n    }, attrs);\r\n  }\r\n\r\n  function getWaypoints(di, source, target) {\r\n\r\n    var waypoints = di.waypoint;\r\n\r\n    if (!waypoints || waypoints.length < 2) {\r\n      return [ getMid(source), getMid(target) ];\r\n    }\r\n\r\n    return waypoints.map(function(p) {\r\n      return { x: p.x, y: p.y };\r\n    });\r\n  }\r\n\r\n  function notYetDrawn(semantic, refSemantic, property) {\r\n    return new Error(\r\n      `element ${ elementToString(refSemantic) } referenced by ${ elementToString(semantic) }#${ property } not yet drawn`\r\n    );\r\n  }\r\n\r\n\r\n  /**\r\n   * An importer that adds bpmn elements to the canvas\r\n   *\r\n   * @param {EventBus} eventBus\r\n   * @param {Canvas} canvas\r\n   * @param {ElementFactory} elementFactory\r\n   * @param {ElementRegistry} elementRegistry\r\n   * @param {TextRenderer} textRenderer\r\n   */\r\n  function BpmnImporter(\r\n      eventBus, canvas, elementFactory,\r\n      elementRegistry, textRenderer) {\r\n\r\n    this._eventBus = eventBus;\r\n    this._canvas = canvas;\r\n    this._elementFactory = elementFactory;\r\n    this._elementRegistry = elementRegistry;\r\n    this._textRenderer = textRenderer;\r\n  }\r\n\r\n  BpmnImporter.$inject = [\r\n    'eventBus',\r\n    'canvas',\r\n    'elementFactory',\r\n    'elementRegistry',\r\n    'textRenderer'\r\n  ];\r\n\r\n\r\n  /**\r\n   * Add a BPMN element (semantic) to the canvas making it a child of the\r\n   * given parent.\r\n   *\r\n   * @param {ModdleElement} semantic\r\n   * @param {ModdleElement} di\r\n   * @param {Shape} parentElement\r\n   *\r\n   * @return {Shape | Root | Connection}\r\n   */\r\n  BpmnImporter.prototype.add = function(semantic, di, parentElement) {\r\n    var element,\r\n        hidden;\r\n\r\n    var parentIndex;\r\n\r\n    // ROOT ELEMENT\r\n    // handle the special case that we deal with a\r\n    // invisible root element (process, subprocess or collaboration)\r\n    if (is$1(di, 'bpmndi:BPMNPlane')) {\r\n\r\n      var attrs = is$1(semantic, 'bpmn:SubProcess')\r\n        ? { id: semantic.id + '_plane' }\r\n        : {};\r\n\r\n      // add a virtual element (not being drawn)\r\n      element = this._elementFactory.createRoot(elementData(semantic, di, attrs));\r\n\r\n      this._canvas.addRootElement(element);\r\n    }\r\n\r\n    // SHAPE\r\n    else if (is$1(di, 'bpmndi:BPMNShape')) {\r\n\r\n      var collapsed = !isExpanded(semantic, di),\r\n          isFrame = isFrameElement$1(semantic);\r\n\r\n      hidden = parentElement && (parentElement.hidden || parentElement.collapsed);\r\n\r\n      var bounds = di.bounds;\r\n\r\n      element = this._elementFactory.createShape(elementData(semantic, di, {\r\n        collapsed: collapsed,\r\n        hidden: hidden,\r\n        x: Math.round(bounds.x),\r\n        y: Math.round(bounds.y),\r\n        width: Math.round(bounds.width),\r\n        height: Math.round(bounds.height),\r\n        isFrame: isFrame\r\n      }));\r\n\r\n      if (is$1(semantic, 'bpmn:BoundaryEvent')) {\r\n        this._attachBoundary(semantic, element);\r\n      }\r\n\r\n      // insert lanes behind other flow nodes (cf. #727)\r\n      if (is$1(semantic, 'bpmn:Lane')) {\r\n        parentIndex = 0;\r\n      }\r\n\r\n      if (is$1(semantic, 'bpmn:DataStoreReference')) {\r\n\r\n        // check whether data store is inside our outside of its semantic parent\r\n        if (!isPointInsideBBox(parentElement, getMid(bounds))) {\r\n          parentElement = this._canvas.findRoot(parentElement);\r\n        }\r\n      }\r\n\r\n      this._canvas.addShape(element, parentElement, parentIndex);\r\n    }\r\n\r\n    // CONNECTION\r\n    else if (is$1(di, 'bpmndi:BPMNEdge')) {\r\n\r\n      var source = this._getSource(semantic),\r\n          target = this._getTarget(semantic);\r\n\r\n      hidden = parentElement && (parentElement.hidden || parentElement.collapsed);\r\n\r\n      element = this._elementFactory.createConnection(elementData(semantic, di, {\r\n        hidden: hidden,\r\n        source: source,\r\n        target: target,\r\n        waypoints: getWaypoints(di, source, target)\r\n      }));\r\n\r\n      if (is$1(semantic, 'bpmn:DataAssociation')) {\r\n\r\n        // render always on top; this ensures DataAssociations\r\n        // are rendered correctly across different \"hacks\" people\r\n        // love to model such as cross participant / sub process\r\n        // associations\r\n        parentElement = this._canvas.findRoot(parentElement);\r\n      }\r\n\r\n      this._canvas.addConnection(element, parentElement, parentIndex);\r\n    } else {\r\n      throw new Error(\r\n        `unknown di ${ elementToString(di) } for element ${ elementToString(semantic) }`\r\n      );\r\n    }\r\n\r\n    // (optional) LABEL\r\n    if (isLabelExternal(semantic) && getLabel(element)) {\r\n      this.addLabel(semantic, di, element);\r\n    }\r\n\r\n    this._eventBus.fire('bpmnElement.added', { element: element });\r\n\r\n    return element;\r\n  };\r\n\r\n\r\n  /**\r\n   * Attach a boundary element to the given host.\r\n   *\r\n   * @param {ModdleElement} boundarySemantic\r\n   * @param {Shape} boundaryElement\r\n   */\r\n  BpmnImporter.prototype._attachBoundary = function(boundarySemantic, boundaryElement) {\r\n    var hostSemantic = boundarySemantic.attachedToRef;\r\n\r\n    if (!hostSemantic) {\r\n      throw new Error(\r\n        `missing ${ elementToString(boundarySemantic) }#attachedToRef`\r\n      );\r\n    }\r\n\r\n    var host = this._elementRegistry.get(hostSemantic.id),\r\n        attachers = host && host.attachers;\r\n\r\n    if (!host) {\r\n      throw notYetDrawn(boundarySemantic, hostSemantic, 'attachedToRef');\r\n    }\r\n\r\n    // wire element.host <> host.attachers\r\n    boundaryElement.host = host;\r\n\r\n    if (!attachers) {\r\n      host.attachers = attachers = [];\r\n    }\r\n\r\n    if (attachers.indexOf(boundaryElement) === -1) {\r\n      attachers.push(boundaryElement);\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Add a label to a given element.\r\n   *\r\n   * @param {ModdleElement} semantic\r\n   * @param {ModdleElement} di\r\n   * @param {Element} element\r\n   *\r\n   * @return {Label}\r\n   */\r\n  BpmnImporter.prototype.addLabel = function(semantic, di, element) {\r\n    var bounds,\r\n        text,\r\n        label;\r\n\r\n    bounds = getExternalLabelBounds(di, element);\r\n\r\n    text = getLabel(element);\r\n\r\n    if (text) {\r\n\r\n      // get corrected bounds from actual layouted text\r\n      bounds = this._textRenderer.getExternalLabelBounds(bounds, text);\r\n    }\r\n\r\n    label = this._elementFactory.createLabel(elementData(semantic, di, {\r\n      id: semantic.id + '_label',\r\n      labelTarget: element,\r\n      type: 'label',\r\n      hidden: element.hidden || !getLabel(element),\r\n      x: Math.round(bounds.x),\r\n      y: Math.round(bounds.y),\r\n      width: Math.round(bounds.width),\r\n      height: Math.round(bounds.height)\r\n    }));\r\n\r\n    return this._canvas.addShape(label, element.parent);\r\n  };\r\n\r\n  /**\r\n   * Get the source or target of the given connection.\r\n   *\r\n   * @param {ModdleElement} semantic\r\n   * @param {'source' | 'target'} side\r\n   *\r\n   * @return {Element}\r\n   */\r\n  BpmnImporter.prototype._getConnectedElement = function(semantic, side) {\r\n\r\n    var element,\r\n        refSemantic,\r\n        type = semantic.$type;\r\n\r\n    refSemantic = semantic[side + 'Ref'];\r\n\r\n    // handle mysterious isMany DataAssociation#sourceRef\r\n    if (side === 'source' && type === 'bpmn:DataInputAssociation') {\r\n      refSemantic = refSemantic && refSemantic[0];\r\n    }\r\n\r\n    // fix source / target for DataInputAssociation / DataOutputAssociation\r\n    if (side === 'source' && type === 'bpmn:DataOutputAssociation' ||\r\n        side === 'target' && type === 'bpmn:DataInputAssociation') {\r\n\r\n      refSemantic = semantic.$parent;\r\n    }\r\n\r\n    element = refSemantic && this._getElement(refSemantic);\r\n\r\n    if (element) {\r\n      return element;\r\n    }\r\n\r\n    if (refSemantic) {\r\n      throw notYetDrawn(semantic, refSemantic, side + 'Ref');\r\n    } else {\r\n      throw new Error(\r\n        `${ elementToString(semantic) }#${ side } Ref not specified`\r\n      );\r\n    }\r\n  };\r\n\r\n  BpmnImporter.prototype._getSource = function(semantic) {\r\n    return this._getConnectedElement(semantic, 'source');\r\n  };\r\n\r\n  BpmnImporter.prototype._getTarget = function(semantic) {\r\n    return this._getConnectedElement(semantic, 'target');\r\n  };\r\n\r\n\r\n  BpmnImporter.prototype._getElement = function(semantic) {\r\n    return this._elementRegistry.get(semantic.id);\r\n  };\r\n\r\n\r\n  // helpers ////////////////////\r\n\r\n  function isPointInsideBBox(bbox, point) {\r\n    var x = point.x,\r\n        y = point.y;\r\n\r\n    return x >= bbox.x &&\r\n      x <= bbox.x + bbox.width &&\r\n      y >= bbox.y &&\r\n      y <= bbox.y + bbox.height;\r\n  }\r\n\r\n  function isFrameElement$1(semantic) {\r\n    return is$1(semantic, 'bpmn:Group');\r\n  }\n\n  var ImportModule = {\r\n    __depends__: [\r\n      TranslateModule\r\n    ],\r\n    bpmnImporter: [ 'type', BpmnImporter ]\r\n  };\n\n  var CoreModule$1 = {\r\n    __depends__: [\r\n      DrawModule$1,\r\n      ImportModule\r\n    ]\r\n  };\n\n  /**\n   * Returns the surrounding bbox for all elements in\n   * the array or the element primitive.\n   *\n   * @param {Element|Element[]} elements\n   * @param {boolean} [stopRecursion=false]\n   *\n   * @return {Rect}\n   */\n  function getBBox(elements, stopRecursion) {\n\n    stopRecursion = !!stopRecursion;\n    if (!isArray$2(elements)) {\n      elements = [ elements ];\n    }\n\n    var minX,\n        minY,\n        maxX,\n        maxY;\n\n    forEach$1(elements, function(element) {\n\n      // If element is a connection the bbox must be computed first\n      var bbox = element;\n      if (element.waypoints && !stopRecursion) {\n        bbox = getBBox(element.waypoints, true);\n      }\n\n      var x = bbox.x,\n          y = bbox.y,\n          height = bbox.height || 0,\n          width = bbox.width || 0;\n\n      if (x < minX || minX === undefined) {\n        minX = x;\n      }\n      if (y < minY || minY === undefined) {\n        minY = y;\n      }\n\n      if ((x + width) > maxX || maxX === undefined) {\n        maxX = x + width;\n      }\n      if ((y + height) > maxY || maxY === undefined) {\n        maxY = y + height;\n      }\n    });\n\n    return {\n      x: minX,\n      y: minY,\n      height: maxY - minY,\n      width: maxX - minX\n    };\n  }\n\n  /**\n   * Get the element's type\n   *\n   * @param {Element} element\n   *\n   * @return {'connection' | 'shape' | 'root'}\n   */\n  function getType(element) {\n\n    if ('waypoints' in element) {\n      return 'connection';\n    }\n\n    if ('x' in element) {\n      return 'shape';\n    }\n\n    return 'root';\n  }\n\n  /**\n   * @param {Element} element\n   *\n   * @return {boolean}\n   */\n  function isFrameElement(element) {\n    return !!(element && element.isFrame);\n  }\n\n  /**\n   * Util that provides unique IDs.\n   *\n   * @class\n   * @constructor\n   *\n   * The ids can be customized via a given prefix and contain a random value to avoid collisions.\n   *\n   * @param {string} [prefix] a prefix to prepend to generated ids (for better readability)\n   */\n  function IdGenerator(prefix) {\n\n    this._counter = 0;\n    this._prefix = (prefix ? prefix + '-' : '') + Math.floor(Math.random() * 1000000000) + '-';\n  }\n\n  /**\n   * Returns a next unique ID.\n   *\n   * @return {string} the id\n   */\n  IdGenerator.prototype.next = function() {\n    return this._prefix + (++this._counter);\n  };\n\n  // document wide unique overlay ids\n  var ids = new IdGenerator('ov');\n\n  var LOW_PRIORITY$3 = 500;\n\n  /**\n   * @typedef {import('../../core/Canvas').default} Canvas\n   * @typedef {import('../../core/ElementRegistry').default} ElementRegistry\n   * @typedef {import('../../core/EventBus').default} EventBus\n   *\n   * @typedef {import('../../model/Types').Element} Element\n   *\n   * @typedef { {\n   *   minZoom?: number,\n   *   maxZoom?: number\n   * } } OverlaysConfigShow\n   *\n   * @typedef { {\n   *   min?: number,\n   *   max?: number\n   * } } OverlaysConfigScale\n   *\n   * @typedef { {\n  *   id: string,\n  *   type: string | null,\n  *   element: Element | string\n  * } & OverlayAttrs } Overlay\n  *\n   * @typedef { {\n   *   html: HTMLElement | string,\n   *   position: {\n   *     top?: number,\n   *     right?: number,\n   *     bottom?: number,\n   *     left?: number\n   *   }\n   * } & OverlaysConfigDefault } OverlayAttrs\n   *\n   * @typedef { {\n   *   html: HTMLElement,\n   *   element: Element,\n   *   overlays: Overlay[]\n   * } } OverlayContainer\n   *\n   * @typedef {{\n   *   defaults?: OverlaysConfigDefault\n   * }} OverlaysConfig\n   *\n   * @typedef { {\n   *  show?: OverlaysConfigShow,\n   *  scale?: OverlaysConfigScale | boolean\n   * } } OverlaysConfigDefault\n   *\n   * @typedef { {\n   *   id?: string;\n   *   element?: Element | string;\n   *   type?: string;\n   * } | string } OverlaysFilter\n   */\n\n  /**\n   * A service that allows users to attach overlays to diagram elements.\n   *\n   * The overlay service will take care of overlay positioning during updates.\n   *\n   * @example\n   *\n   * ```javascript\n   * // add a pink badge on the top left of the shape\n   *\n   * overlays.add(someShape, {\n   *   position: {\n   *     top: -5,\n   *     left: -5\n   *   },\n   *   html: '<div style=\"width: 10px; background: fuchsia; color: white;\">0</div>'\n   * });\n   *\n   * // or add via shape id\n   *\n   * overlays.add('some-element-id', {\n   *   position: {\n   *     top: -5,\n   *     left: -5\n   *   }\n   *   html: '<div style=\"width: 10px; background: fuchsia; color: white;\">0</div>'\n   * });\n   *\n   * // or add with optional type\n   *\n   * overlays.add(someShape, 'badge', {\n   *   position: {\n   *     top: -5,\n   *     left: -5\n   *   }\n   *   html: '<div style=\"width: 10px; background: fuchsia; color: white;\">0</div>'\n   * });\n   * ```\n   *\n   * ```javascript\n   * // remove an overlay\n   *\n   * var id = overlays.add(...);\n   * overlays.remove(id);\n   *\n   *\n   * You may configure overlay defaults during tool by providing a `config` module\n   * with `overlays.defaults` as an entry:\n   *\n   * {\n   *   overlays: {\n   *     defaults: {\n   *       show: {\n   *         minZoom: 0.7,\n   *         maxZoom: 5.0\n   *       },\n   *       scale: {\n   *         min: 1\n   *       }\n   *     }\n   * }\n   * ```\n   *\n   * @param {OverlaysConfig} config\n   * @param {EventBus} eventBus\n   * @param {Canvas} canvas\n   * @param {ElementRegistry} elementRegistry\n   */\n  function Overlays(config, eventBus, canvas, elementRegistry) {\n    this._eventBus = eventBus;\n    this._canvas = canvas;\n    this._elementRegistry = elementRegistry;\n\n    this._ids = ids;\n\n    /**\n     * @type {OverlaysConfigDefault}\n     */\n    this._overlayDefaults = assign$1({\n\n      // no show constraints\n      show: null,\n\n      // always scale\n      scale: true\n    }, config && config.defaults);\n\n    /**\n     * @type {Record<string, Overlay>}\n     */\n    this._overlays = {};\n\n    /**\n     * @type {OverlayContainer[]}\n     */\n    this._overlayContainers = [];\n\n    /**\n     * @type {HTMLElement}\n     */\n    this._overlayRoot = createRoot(canvas.getContainer());\n\n    this._init();\n  }\n\n\n  Overlays.$inject = [\n    'config.overlays',\n    'eventBus',\n    'canvas',\n    'elementRegistry'\n  ];\n\n\n  /**\n   * Returns the overlay with the specified ID or a list of overlays\n   * for an element with a given type.\n   *\n   * @example\n   *\n   * ```javascript\n   * // return the single overlay with the given ID\n   * overlays.get('some-id');\n   *\n   * // return all overlays for the shape\n   * overlays.get({ element: someShape });\n   *\n   * // return all overlays on shape with type 'badge'\n   * overlays.get({ element: someShape, type: 'badge' });\n   *\n   * // shape can also be specified as ID\n   * overlays.get({ element: 'element-id', type: 'badge' });\n   * ```\n   *\n   * @param {OverlaysFilter} search The filter to be used to find the overlay(s).\n   *\n   * @return {Overlay|Overlay[]} The overlay(s).\n   */\n  Overlays.prototype.get = function(search) {\n\n    if (isString(search)) {\n      search = { id: search };\n    }\n\n    if (isString(search.element)) {\n      search.element = this._elementRegistry.get(search.element);\n    }\n\n    if (search.element) {\n      var container = this._getOverlayContainer(search.element, true);\n\n      // return a list of overlays when searching by element (+type)\n      if (container) {\n        return search.type ? filter(container.overlays, matchPattern({ type: search.type })) : container.overlays.slice();\n      } else {\n        return [];\n      }\n    } else if (search.type) {\n      return filter(this._overlays, matchPattern({ type: search.type }));\n    } else {\n\n      // return single element when searching by id\n      return search.id ? this._overlays[search.id] : null;\n    }\n  };\n\n  /**\n   * Adds an HTML overlay to an element.\n   *\n   * @param {Element|string} element The element to add the overlay to.\n   * @param {string} [type] An optional type that can be used to filter.\n   * @param {OverlayAttrs} overlay The overlay.\n   *\n   * @return {string} The overlay's ID that can be used to get or remove it.\n   */\n  Overlays.prototype.add = function(element, type, overlay) {\n\n    if (isObject(type)) {\n      overlay = type;\n      type = null;\n    }\n\n    if (!element.id) {\n      element = this._elementRegistry.get(element);\n    }\n\n    if (!overlay.position) {\n      throw new Error('must specifiy overlay position');\n    }\n\n    if (!overlay.html) {\n      throw new Error('must specifiy overlay html');\n    }\n\n    if (!element) {\n      throw new Error('invalid element specified');\n    }\n\n    var id = this._ids.next();\n\n    overlay = assign$1({}, this._overlayDefaults, overlay, {\n      id: id,\n      type: type,\n      element: element,\n      html: overlay.html\n    });\n\n    this._addOverlay(overlay);\n\n    return id;\n  };\n\n\n  /**\n   * Remove an overlay with the given ID or all overlays matching the given filter.\n   *\n   * @see Overlays#get for filter options.\n   *\n   * @param {OverlaysFilter} filter The filter to be used to find the overlay.\n   */\n  Overlays.prototype.remove = function(filter) {\n\n    var overlays = this.get(filter) || [];\n\n    if (!isArray$2(overlays)) {\n      overlays = [ overlays ];\n    }\n\n    var self = this;\n\n    forEach$1(overlays, function(overlay) {\n\n      var container = self._getOverlayContainer(overlay.element, true);\n\n      if (overlay) {\n        remove$1(overlay.html);\n        remove$1(overlay.htmlContainer);\n\n        delete overlay.htmlContainer;\n        delete overlay.element;\n\n        delete self._overlays[overlay.id];\n      }\n\n      if (container) {\n        var idx = container.overlays.indexOf(overlay);\n        if (idx !== -1) {\n          container.overlays.splice(idx, 1);\n        }\n      }\n    });\n\n  };\n\n  /**\n   * Checks whether overlays are shown.\n   *\n   * @return {boolean} Whether overlays are shown.\n   */\n  Overlays.prototype.isShown = function() {\n    return this._overlayRoot.style.display !== 'none';\n  };\n\n  /**\n   * Show all overlays.\n   */\n  Overlays.prototype.show = function() {\n    setVisible(this._overlayRoot);\n  };\n\n  /**\n   * Hide all overlays.\n   */\n  Overlays.prototype.hide = function() {\n    setVisible(this._overlayRoot, false);\n  };\n\n  /**\n   * Remove all overlays and their container.\n   */\n  Overlays.prototype.clear = function() {\n    this._overlays = {};\n\n    this._overlayContainers = [];\n\n    clear(this._overlayRoot);\n  };\n\n  Overlays.prototype._updateOverlayContainer = function(container) {\n    var element = container.element,\n        html = container.html;\n\n    // update container left,top according to the elements x,y coordinates\n    // this ensures we can attach child elements relative to this container\n\n    var x = element.x,\n        y = element.y;\n\n    if (element.waypoints) {\n      var bbox = getBBox(element);\n      x = bbox.x;\n      y = bbox.y;\n    }\n\n    setPosition(html, x, y);\n\n    attr(container.html, 'data-container-id', element.id);\n  };\n\n\n  Overlays.prototype._updateOverlay = function(overlay) {\n\n    var position = overlay.position,\n        htmlContainer = overlay.htmlContainer,\n        element = overlay.element;\n\n    // update overlay html relative to shape because\n    // it is already positioned on the element\n\n    // update relative\n    var left = position.left,\n        top = position.top;\n\n    if (position.right !== undefined) {\n\n      var width;\n\n      if (element.waypoints) {\n        width = getBBox(element).width;\n      } else {\n        width = element.width;\n      }\n\n      left = position.right * -1 + width;\n    }\n\n    if (position.bottom !== undefined) {\n\n      var height;\n\n      if (element.waypoints) {\n        height = getBBox(element).height;\n      } else {\n        height = element.height;\n      }\n\n      top = position.bottom * -1 + height;\n    }\n\n    setPosition(htmlContainer, left || 0, top || 0);\n    this._updateOverlayVisibilty(overlay, this._canvas.viewbox());\n  };\n\n\n  Overlays.prototype._createOverlayContainer = function(element) {\n    var html = domify$1('<div class=\"djs-overlays\" />');\n    assign(html, { position: 'absolute' });\n\n    this._overlayRoot.appendChild(html);\n\n    var container = {\n      html: html,\n      element: element,\n      overlays: []\n    };\n\n    this._updateOverlayContainer(container);\n\n    this._overlayContainers.push(container);\n\n    return container;\n  };\n\n\n  Overlays.prototype._updateRoot = function(viewbox) {\n    var scale = viewbox.scale || 1;\n\n    var matrix = 'matrix(' +\n    [\n      scale,\n      0,\n      0,\n      scale,\n      -1 * viewbox.x * scale,\n      -1 * viewbox.y * scale\n    ].join(',') +\n    ')';\n\n    setTransform(this._overlayRoot, matrix);\n  };\n\n\n  Overlays.prototype._getOverlayContainer = function(element, raw) {\n    var container = find(this._overlayContainers, function(c) {\n      return c.element === element;\n    });\n\n\n    if (!container && !raw) {\n      return this._createOverlayContainer(element);\n    }\n\n    return container;\n  };\n\n\n  Overlays.prototype._addOverlay = function(overlay) {\n\n    var id = overlay.id,\n        element = overlay.element,\n        html = overlay.html,\n        htmlContainer,\n        overlayContainer;\n\n    // unwrap jquery (for those who need it)\n    if (html.get && html.constructor.prototype.jquery) {\n      html = html.get(0);\n    }\n\n    // create proper html elements from\n    // overlay HTML strings\n    if (isString(html)) {\n      html = domify$1(html);\n    }\n\n    overlayContainer = this._getOverlayContainer(element);\n\n    htmlContainer = domify$1('<div class=\"djs-overlay\" data-overlay-id=\"' + id + '\">');\n    assign(htmlContainer, { position: 'absolute' });\n\n    htmlContainer.appendChild(html);\n\n    if (overlay.type) {\n      classes(htmlContainer).add('djs-overlay-' + overlay.type);\n    }\n\n    var elementRoot = this._canvas.findRoot(element);\n    var activeRoot = this._canvas.getRootElement();\n\n    setVisible(htmlContainer, elementRoot === activeRoot);\n\n    overlay.htmlContainer = htmlContainer;\n\n    overlayContainer.overlays.push(overlay);\n    overlayContainer.html.appendChild(htmlContainer);\n\n    this._overlays[id] = overlay;\n\n    this._updateOverlay(overlay);\n    this._updateOverlayVisibilty(overlay, this._canvas.viewbox());\n  };\n\n\n  Overlays.prototype._updateOverlayVisibilty = function(overlay, viewbox) {\n    var show = overlay.show,\n        rootElement = this._canvas.findRoot(overlay.element),\n        minZoom = show && show.minZoom,\n        maxZoom = show && show.maxZoom,\n        htmlContainer = overlay.htmlContainer,\n        activeRootElement = this._canvas.getRootElement(),\n        visible = true;\n\n    if (rootElement !== activeRootElement) {\n      visible = false;\n    } else if (show) {\n      if (\n        (isDefined(minZoom) && minZoom > viewbox.scale) ||\n        (isDefined(maxZoom) && maxZoom < viewbox.scale)\n      ) {\n        visible = false;\n      }\n    }\n\n    setVisible(htmlContainer, visible);\n\n    this._updateOverlayScale(overlay, viewbox);\n  };\n\n\n  Overlays.prototype._updateOverlayScale = function(overlay, viewbox) {\n    var shouldScale = overlay.scale,\n        minScale,\n        maxScale,\n        htmlContainer = overlay.htmlContainer;\n\n    var scale, transform = '';\n\n    if (shouldScale !== true) {\n\n      if (shouldScale === false) {\n        minScale = 1;\n        maxScale = 1;\n      } else {\n        minScale = shouldScale.min;\n        maxScale = shouldScale.max;\n      }\n\n      if (isDefined(minScale) && viewbox.scale < minScale) {\n        scale = (1 / viewbox.scale || 1) * minScale;\n      }\n\n      if (isDefined(maxScale) && viewbox.scale > maxScale) {\n        scale = (1 / viewbox.scale || 1) * maxScale;\n      }\n    }\n\n    if (isDefined(scale)) {\n      transform = 'scale(' + scale + ',' + scale + ')';\n    }\n\n    setTransform(htmlContainer, transform);\n  };\n\n\n  Overlays.prototype._updateOverlaysVisibilty = function(viewbox) {\n\n    var self = this;\n\n    forEach$1(this._overlays, function(overlay) {\n      self._updateOverlayVisibilty(overlay, viewbox);\n    });\n  };\n\n\n  Overlays.prototype._init = function() {\n\n    var eventBus = this._eventBus;\n\n    var self = this;\n\n\n    // scroll/zoom integration\n\n    function updateViewbox(viewbox) {\n      self._updateRoot(viewbox);\n      self._updateOverlaysVisibilty(viewbox);\n\n      self.show();\n    }\n\n    eventBus.on('canvas.viewbox.changing', function(event) {\n      self.hide();\n    });\n\n    eventBus.on('canvas.viewbox.changed', function(event) {\n      updateViewbox(event.viewbox);\n    });\n\n\n    // remove integration\n\n    eventBus.on([ 'shape.remove', 'connection.remove' ], function(e) {\n      var element = e.element;\n      var overlays = self.get({ element: element });\n\n      forEach$1(overlays, function(o) {\n        self.remove(o.id);\n      });\n\n      var container = self._getOverlayContainer(element);\n\n      if (container) {\n        remove$1(container.html);\n        var i = self._overlayContainers.indexOf(container);\n        if (i !== -1) {\n          self._overlayContainers.splice(i, 1);\n        }\n      }\n    });\n\n\n    // move integration\n\n    eventBus.on('element.changed', LOW_PRIORITY$3, function(e) {\n      var element = e.element;\n\n      var container = self._getOverlayContainer(element, true);\n\n      if (container) {\n        forEach$1(container.overlays, function(overlay) {\n          self._updateOverlay(overlay);\n        });\n\n        self._updateOverlayContainer(container);\n      }\n    });\n\n\n    // marker integration, simply add them on the overlays as classes, too.\n\n    eventBus.on('element.marker.update', function(e) {\n      var container = self._getOverlayContainer(e.element, true);\n      if (container) {\n        classes(container.html)[e.add ? 'add' : 'remove'](e.marker);\n      }\n    });\n\n\n    eventBus.on('root.set', function() {\n      self._updateOverlaysVisibilty(self._canvas.viewbox());\n    });\n\n    // clear overlays with diagram\n\n    eventBus.on('diagram.clear', this.clear, this);\n  };\n\n\n\n  // helpers /////////////////////////////\n\n  function createRoot(parentNode) {\n    var root = domify$1(\n      '<div class=\"djs-overlay-container\" />'\n    );\n\n    assign(root, {\n      position: 'absolute',\n      width: 0,\n      height: 0\n    });\n\n    parentNode.insertBefore(root, parentNode.firstChild);\n\n    return root;\n  }\n\n  function setPosition(el, x, y) {\n    assign(el, { left: x + 'px', top: y + 'px' });\n  }\n\n  /**\n   * Set element visible\n   *\n   * @param {DOMElement} el\n   * @param {boolean} [visible=true]\n   */\n  function setVisible(el, visible) {\n    el.style.display = visible === false ? 'none' : '';\n  }\n\n  function setTransform(el, transform) {\n\n    el.style['transform-origin'] = 'top left';\n\n    [ '', '-ms-', '-webkit-' ].forEach(function(prefix) {\n      el.style[prefix + 'transform'] = transform;\n    });\n  }\n\n  /**\n   * @type { import('didi').ModuleDeclaration }\n   */\n  var OverlaysModule = {\n    __init__: [ 'overlays' ],\n    overlays: [ 'type', Overlays ]\n  };\n\n  /**\n   * @typedef {import('../../core/Canvas').default} Canvas\n   * @typedef {import('../../core/ElementRegistry').default} ElementRegistry\n   * @typedef {import('../../core/EventBus').default} EventBus\n   * @typedef {import('../../core/GraphicsFactory').default} GraphicsFactory\n   */\n\n  /**\n   * Adds change support to the diagram, including\n   *\n   * <ul>\n   *   <li>redrawing shapes and connections on change</li>\n   * </ul>\n   *\n   * @param {EventBus} eventBus\n   * @param {Canvas} canvas\n   * @param {ElementRegistry} elementRegistry\n   * @param {GraphicsFactory} graphicsFactory\n   */\n  function ChangeSupport(\n      eventBus, canvas, elementRegistry,\n      graphicsFactory) {\n\n\n    // redraw shapes / connections on change\n\n    eventBus.on('element.changed', function(event) {\n\n      var element = event.element;\n\n      // element might have been deleted and replaced by new element with same ID\n      // thus check for parent of element except for root element\n      if (element.parent || element === canvas.getRootElement()) {\n        event.gfx = elementRegistry.getGraphics(element);\n      }\n\n      // shape + gfx may have been deleted\n      if (!event.gfx) {\n        return;\n      }\n\n      eventBus.fire(getType(element) + '.changed', event);\n    });\n\n    eventBus.on('elements.changed', function(event) {\n\n      var elements = event.elements;\n\n      elements.forEach(function(e) {\n        eventBus.fire('element.changed', { element: e });\n      });\n\n      graphicsFactory.updateContainments(elements);\n    });\n\n    eventBus.on('shape.changed', function(event) {\n      graphicsFactory.update('shape', event.element, event.gfx);\n    });\n\n    eventBus.on('connection.changed', function(event) {\n      graphicsFactory.update('connection', event.element, event.gfx);\n    });\n  }\n\n  ChangeSupport.$inject = [\n    'eventBus',\n    'canvas',\n    'elementRegistry',\n    'graphicsFactory'\n  ];\n\n  /**\n   * @type { import('didi').ModuleDeclaration }\n   */\n  var ChangeSupportModule = {\n    __init__: [ 'changeSupport' ],\n    changeSupport: [ 'type', ChangeSupport ]\n  };\n\n  /**\n   * @typedef {import('../core/Types').ElementLike} ElementLike\n   * @typedef {import('../core/EventBus').default} EventBus\n   * @typedef {import('./CommandStack').CommandContext} CommandContext\n   *\n   * @typedef {string|string[]} Events\n   * @typedef { (context: CommandContext) => ElementLike[] | void } HandlerFunction\n   * @typedef { (context: CommandContext) => void } ComposeHandlerFunction\n   */\n\n  var DEFAULT_PRIORITY$2 = 1000;\n\n  /**\n   * A utility that can be used to plug into the command execution for\n   * extension and/or validation.\n   *\n   * @class\n   * @constructor\n   *\n   * @example\n   *\n   * ```javascript\n   * import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n   *\n   * class CommandLogger extends CommandInterceptor {\n   *   constructor(eventBus) {\n   *     super(eventBus);\n   *\n   *   this.preExecute('shape.create', (event) => {\n   *     console.log('commandStack.shape-create.preExecute', event);\n   *   });\n   * }\n   * ```\n   *\n   * @param {EventBus} eventBus\n   */\n  function CommandInterceptor(eventBus) {\n\n    /**\n     * @type {EventBus}\n     */\n    this._eventBus = eventBus;\n  }\n\n  CommandInterceptor.$inject = [ 'eventBus' ];\n\n  function unwrapEvent(fn, that) {\n    return function(event) {\n      return fn.call(that || null, event.context, event.command, event);\n    };\n  }\n\n\n  /**\n   * Intercept a command during one of the phases.\n   *\n   * @param {Events} [events] command(s) to intercept\n   * @param {string} [hook] phase to intercept\n   * @param {number} [priority]\n   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n   * @param {boolean} [unwrap] whether the event should be unwrapped\n   * @param {any} [that]\n   */\n  CommandInterceptor.prototype.on = function(events, hook, priority, handlerFn, unwrap, that) {\n\n    if (isFunction(hook) || isNumber(hook)) {\n      that = unwrap;\n      unwrap = handlerFn;\n      handlerFn = priority;\n      priority = hook;\n      hook = null;\n    }\n\n    if (isFunction(priority)) {\n      that = unwrap;\n      unwrap = handlerFn;\n      handlerFn = priority;\n      priority = DEFAULT_PRIORITY$2;\n    }\n\n    if (isObject(unwrap)) {\n      that = unwrap;\n      unwrap = false;\n    }\n\n    if (!isFunction(handlerFn)) {\n      throw new Error('handlerFn must be a function');\n    }\n\n    if (!isArray$2(events)) {\n      events = [ events ];\n    }\n\n    var eventBus = this._eventBus;\n\n    forEach$1(events, function(event) {\n\n      // concat commandStack(.event)?(.hook)?\n      var fullEvent = [ 'commandStack', event, hook ].filter(function(e) { return e; }).join('.');\n\n      eventBus.on(fullEvent, priority, unwrap ? unwrapEvent(handlerFn, that) : handlerFn, that);\n    });\n  };\n\n  /**\n   * Add a <canExecute> phase of command interceptor.\n   *\n   * @param {Events} [events] command(s) to intercept\n   * @param {number} [priority]\n   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n   * @param {boolean} [unwrap] whether the event should be unwrapped\n   * @param {any} [that]\n   */\n  CommandInterceptor.prototype.canExecute = createHook('canExecute');\n\n  /**\n   * Add a <preExecute> phase of command interceptor.\n   *\n   * @param {Events} [events] command(s) to intercept\n   * @param {number} [priority]\n   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n   * @param {boolean} [unwrap] whether the event should be unwrapped\n   * @param {any} [that]\n   */\n  CommandInterceptor.prototype.preExecute = createHook('preExecute');\n\n  /**\n   * Add a <preExecuted> phase of command interceptor.\n   *\n   * @param {Events} [events] command(s) to intercept\n   * @param {number} [priority]\n   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n   * @param {boolean} [unwrap] whether the event should be unwrapped\n   * @param {any} [that]\n   */\n  CommandInterceptor.prototype.preExecuted = createHook('preExecuted');\n\n  /**\n   * Add a <execute> phase of command interceptor.\n   *\n   * @param {Events} [events] command(s) to intercept\n   * @param {number} [priority]\n   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n   * @param {boolean} [unwrap] whether the event should be unwrapped\n   * @param {any} [that]\n   */\n  CommandInterceptor.prototype.execute = createHook('execute');\n\n  /**\n   * Add a <executed> phase of command interceptor.\n   *\n   * @param {Events} [events] command(s) to intercept\n   * @param {number} [priority]\n   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n   * @param {boolean} [unwrap] whether the event should be unwrapped\n   * @param {any} [that]\n   */\n  CommandInterceptor.prototype.executed = createHook('executed');\n\n  /**\n   * Add a <postExecute> phase of command interceptor.\n   *\n   * @param {Events} [events] command(s) to intercept\n   * @param {number} [priority]\n   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n   * @param {boolean} [unwrap] whether the event should be unwrapped\n   * @param {any} [that]\n   */\n  CommandInterceptor.prototype.postExecute = createHook('postExecute');\n\n  /**\n   * Add a <postExecuted> phase of command interceptor.\n   *\n   * @param {Events} [events] command(s) to intercept\n   * @param {number} [priority]\n   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n   * @param {boolean} [unwrap] whether the event should be unwrapped\n   * @param {any} [that]\n   */\n  CommandInterceptor.prototype.postExecuted = createHook('postExecuted');\n\n  /**\n   * Add a <revert> phase of command interceptor.\n   *\n   * @param {Events} [events] command(s) to intercept\n   * @param {number} [priority]\n   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n   * @param {boolean} [unwrap] whether the event should be unwrapped\n   * @param {any} [that]\n   */\n  CommandInterceptor.prototype.revert = createHook('revert');\n\n  /**\n   * Add a <reverted> phase of command interceptor.\n   *\n   * @param {Events} [events] command(s) to intercept\n   * @param {number} [priority]\n   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n   * @param {boolean} [unwrap] whether the event should be unwrapped\n   * @param {any} [that]\n   */\n  CommandInterceptor.prototype.reverted = createHook('reverted');\n\n  /*\n   * Add prototype methods for each phase of command execution (e.g. execute,\n   * revert).\n   *\n   * @param {string} hook\n   *\n   * @return { (\n   *   events?: Events,\n   *   priority?: number,\n   *   handlerFn: ComposeHandlerFunction|HandlerFunction,\n   *   unwrap?: boolean\n   * ) => any }\n   */\n  function createHook(hook) {\n\n    /**\n     * @this {CommandInterceptor}\n     *\n     * @param {Events} [events]\n     * @param {number} [priority]\n     * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n     * @param {boolean} [unwrap]\n     * @param {any} [that]\n     */\n    const hookFn = function(events, priority, handlerFn, unwrap, that) {\n\n      if (isFunction(events) || isNumber(events)) {\n        that = unwrap;\n        unwrap = handlerFn;\n        handlerFn = priority;\n        priority = events;\n        events = null;\n      }\n\n      this.on(events, hook, priority, handlerFn, unwrap, that);\n    };\n\n    return hookFn;\n  }\n\n  /**\n   * @typedef {import('didi').Injector} Injector\n   *\n   * @typedef {import('../../core/Canvas').default} Canvas\n   */\n\n  /**\n   * A modeling behavior that ensures we set the correct root element\n   * as we undo and redo commands.\n   *\n   * @param {Canvas} canvas\n   * @param {Injector} injector\n   */\n  function RootElementsBehavior(canvas, injector) {\n\n    injector.invoke(CommandInterceptor, this);\n\n    this.executed(function(event) {\n      var context = event.context;\n\n      if (context.rootElement) {\n        canvas.setRootElement(context.rootElement);\n      } else {\n        context.rootElement = canvas.getRootElement();\n      }\n    });\n\n    this.revert(function(event) {\n      var context = event.context;\n\n      if (context.rootElement) {\n        canvas.setRootElement(context.rootElement);\n      }\n    });\n  }\n\n  e(RootElementsBehavior, CommandInterceptor);\n\n  RootElementsBehavior.$inject = [ 'canvas', 'injector' ];\n\n  /**\n   * @type { import('didi').ModuleDeclaration }\n   */\n  var RootElementsModule = {\n    __init__: [ 'rootElementsBehavior' ],\n    rootElementsBehavior: [ 'type', RootElementsBehavior ]\n  };\n\n  /**\n   * @param {string} str\n   *\n   * @return {string}\n   */\n\n  var HTML_ESCAPE_MAP = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    '\\'': '&#39;'\n  };\n\n  /**\n   * @param {string} str\n   *\n   * @return {string}\n   */\n  function escapeHTML(str) {\n    str = '' + str;\n\n    return str && str.replace(/[&<>\"']/g, function(match) {\n      return HTML_ESCAPE_MAP[match];\n    });\n  }\n\n  /**\r\n   * @typedef {import('../model/Types').Element} Element\r\n   * @typedef {import('../model/Types').ModdleElement} ModdleElement\r\n   */\r\n\r\n  var planeSuffix = '_plane';\r\n\r\n  /**\r\n   * Get plane ID for a primary shape.\r\n   *\r\n   * @param  {Element|ModdleElement} element\r\n   *\r\n   * @return {string}\r\n   */\r\n  function getPlaneIdFromShape(element) {\r\n    var id = element.id;\r\n\r\n    if (is$1(element, 'bpmn:SubProcess')) {\r\n      return addPlaneSuffix(id);\r\n    }\r\n\r\n    return id;\r\n  }\r\n\r\n  function addPlaneSuffix(id) {\r\n    return id + planeSuffix;\r\n  }\n\n  /**\r\n   * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas\r\n   * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry\r\n   * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\r\n   *\r\n   * @typedef {import('../../model/Types').Element} Element\r\n   * @typedef {import('../../model/Types').Shape} Shape\r\n   */\r\n\r\n  var OPEN_CLASS = 'bjs-breadcrumbs-shown';\r\n\r\n\r\n  /**\r\n   * Adds overlays that allow switching planes on collapsed subprocesses.\r\n   *\r\n   * @param {EventBus} eventBus\r\n   * @param {ElementRegistry} elementRegistry\r\n   * @param {Canvas} canvas\r\n   */\r\n  function DrilldownBreadcrumbs(eventBus, elementRegistry, canvas) {\r\n    var breadcrumbs = domify$1('<ul class=\"bjs-breadcrumbs\"></ul>');\r\n    var container = canvas.getContainer();\r\n    var containerClasses = classes(container);\r\n    container.appendChild(breadcrumbs);\r\n\r\n    var businessObjectParents = [];\r\n\r\n    // update breadcrumbs if name or ID of the primary shape changes\r\n    eventBus.on('element.changed', function(event) {\r\n      var shape = event.element,\r\n          businessObject = getBusinessObject(shape);\r\n\r\n      var isPresent = find(businessObjectParents, function(element) {\r\n        return element === businessObject;\r\n      });\r\n\r\n      if (!isPresent) {\r\n        return;\r\n      }\r\n\r\n      updateBreadcrumbs();\r\n    });\r\n\r\n    /**\r\n     * Updates the displayed breadcrumbs. If no element is provided, only the\r\n     * labels are updated.\r\n     *\r\n     * @param {Element} [element]\r\n     */\r\n    function updateBreadcrumbs(element) {\r\n      if (element) {\r\n        businessObjectParents = getBusinessObjectParentChain(element);\r\n      }\r\n\r\n      var path = businessObjectParents.flatMap(function(parent) {\r\n        var parentPlane =\r\n          canvas.findRoot(getPlaneIdFromShape(parent)) ||\r\n          canvas.findRoot(parent.id);\r\n\r\n        // when the root is a collaboration, the process does not have a\r\n        // corresponding element in the elementRegisty. Instead, we search\r\n        // for the corresponding participant\r\n        if (!parentPlane && is$1(parent, 'bpmn:Process')) {\r\n          var participant = elementRegistry.find(function(element) {\r\n            var businessObject = getBusinessObject(element);\r\n\r\n            return businessObject && businessObject.get('processRef') === parent;\r\n          });\r\n\r\n          parentPlane = participant && canvas.findRoot(participant.id);\r\n        }\r\n\r\n        if (!parentPlane) {\r\n          return [];\r\n        }\r\n\r\n        var title = escapeHTML(parent.name || parent.id);\r\n        var link = domify$1('<li><span class=\"bjs-crumb\"><a title=\"' + title + '\">' + title + '</a></span></li>');\r\n\r\n        link.addEventListener('click', function() {\r\n          canvas.setRootElement(parentPlane);\r\n        });\r\n\r\n        return link;\r\n      });\r\n\r\n      breadcrumbs.innerHTML = '';\r\n\r\n      // show breadcrumbs and expose state to .djs-container\r\n      var visible = path.length > 1;\r\n\r\n      containerClasses.toggle(OPEN_CLASS, visible);\r\n\r\n      path.forEach(function(element) {\r\n        breadcrumbs.appendChild(element);\r\n      });\r\n    }\r\n\r\n    eventBus.on('root.set', function(event) {\r\n      updateBreadcrumbs(event.element);\r\n    });\r\n\r\n  }\r\n\r\n  DrilldownBreadcrumbs.$inject = [ 'eventBus', 'elementRegistry', 'canvas' ];\r\n\r\n\r\n  // helpers //////////\r\n\r\n  /**\r\n   * Returns the parents for the element using the business object chain,\r\n   * starting with the root element.\r\n   *\r\n   * @param {Shape} child\r\n   *\r\n   * @return {Shape}\r\n   */\r\n  function getBusinessObjectParentChain(child) {\r\n    var businessObject = getBusinessObject(child);\r\n\r\n    var parents = [];\r\n\r\n    for (var element = businessObject; element; element = element.$parent) {\r\n      if (is$1(element, 'bpmn:SubProcess') || is$1(element, 'bpmn:Process')) {\r\n        parents.push(element);\r\n      }\r\n    }\r\n\r\n    return parents.reverse();\r\n  }\n\n  /**\r\n   * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas\r\n   * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\r\n   */\r\n\r\n  /**\r\n   * Move collapsed subprocesses into view when drilling down.\r\n   *\r\n   * Zoom and scroll are saved in a session.\r\n   *\r\n   * @param {EventBus} eventBus\r\n   * @param {Canvas} canvas\r\n   */\r\n  function DrilldownCentering(eventBus, canvas) {\r\n\r\n    var currentRoot = null;\r\n    var positionMap = new Map();\r\n\r\n    eventBus.on('root.set', function(event) {\r\n      var newRoot = event.element;\r\n      var currentViewbox = canvas.viewbox();\r\n      var storedViewbox = positionMap.get(newRoot);\r\n\r\n      positionMap.set(currentRoot, {\r\n        x: currentViewbox.x,\r\n        y: currentViewbox.y,\r\n        zoom: currentViewbox.scale\r\n      });\r\n\r\n      currentRoot = newRoot;\r\n\r\n      // Keep viewbox when replacing root elements\r\n      if (!is$1(newRoot, 'bpmn:SubProcess') && !storedViewbox) {\r\n        return;\r\n      }\r\n\r\n      storedViewbox = storedViewbox || { x: 0, y: 0, zoom: 1 };\r\n\r\n      var dx = (currentViewbox.x - storedViewbox.x) * currentViewbox.scale,\r\n          dy = (currentViewbox.y - storedViewbox.y) * currentViewbox.scale;\r\n\r\n      if (dx !== 0 || dy !== 0) {\r\n        canvas.scroll({\r\n          dx: dx,\r\n          dy: dy\r\n        });\r\n      }\r\n\r\n      if (storedViewbox.zoom !== currentViewbox.scale) {\r\n        canvas.zoom(storedViewbox.zoom, { x: 0, y: 0 });\r\n      }\r\n    });\r\n\r\n    eventBus.on('diagram.clear', function() {\r\n      positionMap.clear();\r\n      currentRoot = null;\r\n    });\r\n\r\n  }\r\n\r\n  DrilldownCentering.$inject = [ 'eventBus', 'canvas' ];\r\n\r\n\r\n  /**\r\n   * ES5 Map implementation. Works.\r\n   */\r\n  function Map() {\r\n\r\n    this._entries = [];\r\n\r\n    this.set = function(key, value) {\r\n\r\n      var found = false;\r\n\r\n      for (var k in this._entries) {\r\n        if (this._entries[k][0] === key) {\r\n          this._entries[k][1] = value;\r\n\r\n          found = true;\r\n\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (!found) {\r\n        this._entries.push([ key, value ]);\r\n      }\r\n    };\r\n\r\n    this.get = function(key) {\r\n\r\n      for (var k in this._entries) {\r\n        if (this._entries[k][0] === key) {\r\n          return this._entries[k][1];\r\n        }\r\n      }\r\n\r\n      return null;\r\n    };\r\n\r\n    this.clear = function() {\r\n      this._entries.length = 0;\r\n    };\r\n\r\n    this.remove = function(key) {\r\n\r\n      var idx = -1;\r\n\r\n      for (var k in this._entries) {\r\n        if (this._entries[k][0] === key) {\r\n          idx = k;\r\n\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (idx !== -1) {\r\n        this._entries.splice(idx, 1);\r\n      }\r\n    };\r\n  }\n\n  /**\r\n   * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\r\n   * @typedef {import('../../model/Types').Moddle} Moddle\r\n   *\r\n   * @typedef {import('../../model/Types').Element} Element\r\n   * @typedef {import('../../model/Types').Shape} Shape\r\n   *\r\n   * @typedef {import('diagram-js/lib/core/Canvas').CanvasPlane} CanvasPlane\r\n   *\r\n   * @typedef {import('diagram-js/lib/util/Types').Rect} Rect\r\n   */\r\n\r\n  var DEFAULT_POSITION = {\r\n    x: 180,\r\n    y: 160\r\n  };\r\n\r\n  /**\r\n   * Hook into `import.render.start` and create new planes for diagrams with\r\n   * collapsed subprocesses and all DI elements on the same plane.\r\n   *\r\n   * @param {EventBus} eventBus\r\n   * @param {Moddle} moddle\r\n   */\r\n  function SubprocessCompatibility(eventBus, moddle) {\r\n    this._eventBus = eventBus;\r\n    this._moddle = moddle;\r\n\r\n    var self = this;\r\n\r\n    eventBus.on('import.render.start', 1500, function(e, context) {\r\n      self._handleImport(context.definitions);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @param {ModdleElement} definitions\r\n   */\r\n  SubprocessCompatibility.prototype._handleImport = function(definitions) {\r\n    if (!definitions.diagrams) {\r\n      return;\r\n    }\r\n\r\n    var self = this;\r\n    this._definitions = definitions;\r\n    this._processToDiagramMap = {};\r\n\r\n    definitions.diagrams.forEach(function(diagram) {\r\n      if (!diagram.plane || !diagram.plane.bpmnElement) {\r\n        return;\r\n      }\r\n\r\n      self._processToDiagramMap[diagram.plane.bpmnElement.id] = diagram;\r\n    });\r\n\r\n    var newDiagrams = definitions.diagrams\r\n      .filter(diagram => diagram.plane)\r\n      .flatMap(diagram => self._createNewDiagrams(diagram.plane));\r\n\r\n    newDiagrams.forEach(function(diagram) {\r\n      self._movePlaneElementsToOrigin(diagram.plane);\r\n    });\r\n  };\r\n\r\n\r\n  /**\r\n   * Moves all DI elements from collapsed subprocesses to a new plane.\r\n   *\r\n   * @param {CanvasPlane} plane\r\n   *\r\n   * @return {ModdleElement[]} new diagrams created for the collapsed subprocesses\r\n   */\r\n  SubprocessCompatibility.prototype._createNewDiagrams = function(plane) {\r\n    var self = this;\r\n\r\n    var collapsedElements = [];\r\n    var elementsToMove = [];\r\n\r\n    plane.get('planeElement').forEach(function(diElement) {\r\n      var businessObject = diElement.bpmnElement;\r\n\r\n      if (!businessObject) {\r\n        return;\r\n      }\r\n\r\n      var parent = businessObject.$parent;\r\n\r\n      if (is$1(businessObject, 'bpmn:SubProcess') && !diElement.isExpanded) {\r\n        collapsedElements.push(businessObject);\r\n      }\r\n\r\n      if (shouldMoveToPlane(businessObject, plane)) {\r\n\r\n        // don't change the array while we iterate over it\r\n        elementsToMove.push({ diElement: diElement, parent: parent });\r\n      }\r\n    });\r\n\r\n    var newDiagrams = [];\r\n\r\n    // create new planes for all collapsed subprocesses, even when they are empty\r\n    collapsedElements.forEach(function(element) {\r\n      if (!self._processToDiagramMap[ element.id ]) {\r\n        var diagram = self._createDiagram(element);\r\n\r\n        self._processToDiagramMap[element.id] = diagram;\r\n\r\n        newDiagrams.push(diagram);\r\n      }\r\n    });\r\n\r\n    elementsToMove.forEach(function(element) {\r\n      var diElement = element.diElement;\r\n      var parent = element.parent;\r\n\r\n      // parent is expanded, get nearest collapsed parent\r\n      while (parent && collapsedElements.indexOf(parent) === -1) {\r\n        parent = parent.$parent;\r\n      }\r\n\r\n      // false positive, all parents are expanded\r\n      if (!parent) {\r\n        return;\r\n      }\r\n\r\n      var diagram = self._processToDiagramMap[ parent.id ];\r\n\r\n      self._moveToDiPlane(diElement, diagram.plane);\r\n    });\r\n\r\n    return newDiagrams;\r\n  };\r\n\r\n  /**\r\n   * @param {CanvasPlane} plane\r\n   */\r\n  SubprocessCompatibility.prototype._movePlaneElementsToOrigin = function(plane) {\r\n    var elements = plane.get('planeElement');\r\n\r\n    // get bounding box of all elements\r\n    var planeBounds = getPlaneBounds(plane);\r\n\r\n    var offset = {\r\n      x: planeBounds.x - DEFAULT_POSITION.x,\r\n      y: planeBounds.y - DEFAULT_POSITION.y\r\n    };\r\n\r\n    elements.forEach(function(diElement) {\r\n      if (diElement.waypoint) {\r\n        diElement.waypoint.forEach(function(waypoint) {\r\n          waypoint.x = waypoint.x - offset.x;\r\n          waypoint.y = waypoint.y - offset.y;\r\n        });\r\n      } else if (diElement.bounds) {\r\n        diElement.bounds.x = diElement.bounds.x - offset.x;\r\n        diElement.bounds.y = diElement.bounds.y - offset.y;\r\n      }\r\n    });\r\n  };\r\n\r\n  /**\r\n   * @param {ModdleElement} diElement\r\n   * @param {CanvasPlane} newPlane\r\n   */\r\n  SubprocessCompatibility.prototype._moveToDiPlane = function(diElement, newPlane) {\r\n    var containingDiagram = findRootDiagram(diElement);\r\n\r\n    // remove DI from old Plane and add it to the new one\r\n    var parentPlaneElement = containingDiagram.plane.get('planeElement');\r\n\r\n    parentPlaneElement.splice(parentPlaneElement.indexOf(diElement), 1);\r\n\r\n    newPlane.get('planeElement').push(diElement);\r\n  };\r\n\r\n  /**\r\n   * @param {ModdleElement} businessObject\r\n   *\r\n   * @return {ModdleElement}\r\n   */\r\n  SubprocessCompatibility.prototype._createDiagram = function(businessObject) {\r\n    var plane = this._moddle.create('bpmndi:BPMNPlane', {\r\n      bpmnElement: businessObject\r\n    });\r\n\r\n    var diagram = this._moddle.create('bpmndi:BPMNDiagram', {\r\n      plane: plane\r\n    });\r\n\r\n    plane.$parent = diagram;\r\n\r\n    plane.bpmnElement = businessObject;\r\n\r\n    diagram.$parent = this._definitions;\r\n\r\n    this._definitions.diagrams.push(diagram);\r\n\r\n    return diagram;\r\n  };\r\n\r\n  SubprocessCompatibility.$inject = [ 'eventBus', 'moddle' ];\r\n\r\n\r\n  // helpers //////////\r\n\r\n  function findRootDiagram(element) {\r\n    if (is$1(element, 'bpmndi:BPMNDiagram')) {\r\n      return element;\r\n    } else {\r\n      return findRootDiagram(element.$parent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {CanvasPlane} plane\r\n   *\r\n   * @return {Rect}\r\n   */\r\n  function getPlaneBounds(plane) {\r\n    var planeTrbl = {\r\n      top: Infinity,\r\n      right: -Infinity,\r\n      bottom: -Infinity,\r\n      left: Infinity\r\n    };\r\n\r\n    plane.planeElement.forEach(function(element) {\r\n      if (!element.bounds) {\r\n        return;\r\n      }\r\n\r\n      var trbl = asTRBL(element.bounds);\r\n\r\n      planeTrbl.top = Math.min(trbl.top, planeTrbl.top);\r\n      planeTrbl.left = Math.min(trbl.left, planeTrbl.left);\r\n    });\r\n\r\n    return asBounds(planeTrbl);\r\n  }\r\n\r\n  /**\r\n   * @param {ModdleElement} businessObject\r\n   * @param {CanvasPlane} plane\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  function shouldMoveToPlane(businessObject, plane) {\r\n    var parent = businessObject.$parent;\r\n\r\n    // don't move elements that are already on the plane\r\n    if (!is$1(parent, 'bpmn:SubProcess') || parent === plane.bpmnElement) {\r\n      return false;\r\n    }\r\n\r\n    // dataAssociations are children of the subprocess but rendered on process level\r\n    // cf. https://github.com/bpmn-io/bpmn-js/issues/1619\r\n    if (isAny(businessObject, [ 'bpmn:DataInputAssociation', 'bpmn:DataOutputAssociation' ])) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\n\n  /**\r\n   * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas\r\n   * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry\r\n   * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus\r\n   * @typedef {import('diagram-js/lib/features/overlays/Overlays').default} Overlays\r\n   * @typedef {import('diagram-js/lib/i18n/translate/translate').default} Translate\r\n   *\r\n   * @typedef {import('../../model/Types').Element} Element\r\n   * @typedef {import('../../model/Types').Parent} Parent\r\n   * @typedef {import('../../model/Types').Shape} Shape\r\n   */\r\n\r\n  var LOW_PRIORITY$2 = 250;\r\n  var ARROW_DOWN_SVG = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4.81801948,3.50735931 L10.4996894,9.1896894 L10.5,4 L12,4 L12,12 L4,12 L4,10.5 L9.6896894,10.4996894 L3.75735931,4.56801948 C3.46446609,4.27512627 3.46446609,3.80025253 3.75735931,3.50735931 C4.05025253,3.21446609 4.52512627,3.21446609 4.81801948,3.50735931 Z\"/></svg>';\r\n\r\n  var EMPTY_MARKER = 'bjs-drilldown-empty';\r\n\r\n  /**\r\n   * @param {Canvas} canvas\r\n   * @param {EventBus} eventBus\r\n   * @param {ElementRegistry} elementRegistry\r\n   * @param {Overlays} overlays\r\n   * @param {Translate} translate\r\n   */\r\n  function DrilldownOverlayBehavior(\r\n      canvas, eventBus, elementRegistry, overlays, translate\r\n  ) {\r\n    CommandInterceptor.call(this, eventBus);\r\n\r\n    this._canvas = canvas;\r\n    this._eventBus = eventBus;\r\n    this._elementRegistry = elementRegistry;\r\n    this._overlays = overlays;\r\n    this._translate = translate;\r\n\r\n    var self = this;\r\n\r\n    this.executed('shape.toggleCollapse', LOW_PRIORITY$2, function(context) {\r\n      var shape = context.shape;\r\n\r\n      // Add overlay to the collapsed shape\r\n      if (self._canDrillDown(shape)) {\r\n        self._addOverlay(shape);\r\n      } else {\r\n        self._removeOverlay(shape);\r\n      }\r\n    }, true);\r\n\r\n\r\n    this.reverted('shape.toggleCollapse', LOW_PRIORITY$2, function(context) {\r\n      var shape = context.shape;\r\n\r\n      // Add overlay to the collapsed shape\r\n      if (self._canDrillDown(shape)) {\r\n        self._addOverlay(shape);\r\n      } else {\r\n        self._removeOverlay(shape);\r\n      }\r\n    }, true);\r\n\r\n\r\n    this.executed([ 'shape.create', 'shape.move', 'shape.delete' ], LOW_PRIORITY$2,\r\n      function(context) {\r\n        var oldParent = context.oldParent,\r\n            newParent = context.newParent || context.parent,\r\n            shape = context.shape;\r\n\r\n        // Add overlay to the collapsed shape\r\n        if (self._canDrillDown(shape)) {\r\n          self._addOverlay(shape);\r\n        }\r\n\r\n        self._updateDrilldownOverlay(oldParent);\r\n        self._updateDrilldownOverlay(newParent);\r\n        self._updateDrilldownOverlay(shape);\r\n      }, true);\r\n\r\n\r\n    this.reverted([ 'shape.create', 'shape.move', 'shape.delete' ], LOW_PRIORITY$2,\r\n      function(context) {\r\n        var oldParent = context.oldParent,\r\n            newParent = context.newParent || context.parent,\r\n            shape = context.shape;\r\n\r\n        // Add overlay to the collapsed shape\r\n        if (self._canDrillDown(shape)) {\r\n          self._addOverlay(shape);\r\n        }\r\n\r\n        self._updateDrilldownOverlay(oldParent);\r\n        self._updateDrilldownOverlay(newParent);\r\n        self._updateDrilldownOverlay(shape);\r\n      }, true);\r\n\r\n\r\n    eventBus.on('import.render.complete', function() {\r\n      elementRegistry.filter(function(e) {\r\n        return self._canDrillDown(e);\r\n      }).map(function(el) {\r\n        self._addOverlay(el);\r\n      });\r\n    });\r\n\r\n  }\r\n\r\n  e(DrilldownOverlayBehavior, CommandInterceptor);\r\n\r\n  /**\r\n   * @param {Shape} shape\r\n   */\r\n  DrilldownOverlayBehavior.prototype._updateDrilldownOverlay = function(shape) {\r\n    var canvas = this._canvas;\r\n\r\n    if (!shape) {\r\n      return;\r\n    }\r\n\r\n    var root = canvas.findRoot(shape);\r\n\r\n    if (root) {\r\n      this._updateOverlayVisibility(root);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @param {Element} element\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  DrilldownOverlayBehavior.prototype._canDrillDown = function(element) {\r\n    var canvas = this._canvas;\r\n\r\n    return is$1(element, 'bpmn:SubProcess') && canvas.findRoot(getPlaneIdFromShape(element));\r\n  };\r\n\r\n  /**\r\n   * Update the visibility of the drilldown overlay. If the plane has no elements,\r\n   * the drilldown will only be shown when the element is selected.\r\n   *\r\n   * @param {Parent} element The collapsed root or shape.\r\n   */\r\n  DrilldownOverlayBehavior.prototype._updateOverlayVisibility = function(element) {\r\n    var overlays = this._overlays;\r\n\r\n    var businessObject = getBusinessObject(element);\r\n\r\n    var overlay = overlays.get({ element: businessObject.id, type: 'drilldown' })[0];\r\n\r\n    if (!overlay) {\r\n      return;\r\n    }\r\n\r\n    var hasFlowElements = businessObject\r\n      && businessObject.get('flowElements')\r\n      && businessObject.get('flowElements').length;\r\n\r\n    classes(overlay.html).toggle(EMPTY_MARKER, !hasFlowElements);\r\n  };\r\n\r\n  /**\r\n   * Add a drilldown button to the given element assuming the plane has the same\r\n   * ID as the element.\r\n   *\r\n   * @param {Shape} element The collapsed shape.\r\n   */\r\n  DrilldownOverlayBehavior.prototype._addOverlay = function(element) {\r\n    var canvas = this._canvas,\r\n        overlays = this._overlays,\r\n        bo = getBusinessObject(element);\r\n\r\n    var existingOverlays = overlays.get({ element: element, type: 'drilldown' });\r\n\r\n    if (existingOverlays.length) {\r\n      this._removeOverlay(element);\r\n    }\r\n\r\n    var button = domify$1('<button type=\"button\" class=\"bjs-drilldown\">' + ARROW_DOWN_SVG + '</button>'),\r\n        elementName = bo.get('name') || bo.get('id'),\r\n        title = this._translate('Open {element}', { element: elementName });\r\n    button.setAttribute('title', title);\r\n\r\n    button.addEventListener('click', function() {\r\n      canvas.setRootElement(canvas.findRoot(getPlaneIdFromShape(element)));\r\n    });\r\n\r\n    overlays.add(element, 'drilldown', {\r\n      position: {\r\n        bottom: -7,\r\n        right: -8\r\n      },\r\n      html: button\r\n    });\r\n\r\n    this._updateOverlayVisibility(element);\r\n  };\r\n\r\n  DrilldownOverlayBehavior.prototype._removeOverlay = function(element) {\r\n    var overlays = this._overlays;\r\n\r\n    overlays.remove({\r\n      element: element,\r\n      type: 'drilldown'\r\n    });\r\n  };\r\n\r\n  DrilldownOverlayBehavior.$inject = [\r\n    'canvas',\r\n    'eventBus',\r\n    'elementRegistry',\r\n    'overlays',\r\n    'translate'\r\n  ];\n\n  var DrilldownModdule = {\r\n    __depends__: [ OverlaysModule, ChangeSupportModule, RootElementsModule ],\r\n    __init__: [ 'drilldownBreadcrumbs', 'drilldownOverlayBehavior', 'drilldownCentering', 'subprocessCompatibility' ],\r\n    drilldownBreadcrumbs: [ 'type', DrilldownBreadcrumbs ],\r\n    drilldownCentering: [ 'type', DrilldownCentering ],\r\n    drilldownOverlayBehavior: [ 'type', DrilldownOverlayBehavior ],\r\n    subprocessCompatibility: [ 'type', SubprocessCompatibility ]\r\n  };\n\n  /**\n   * @typedef {import('../util/Types').Point} Point\n   */\n\n\n  /**\n   * @param {import('../core/EventBus').Event} event\n   *\n   * @return {Event}\n   */\n  function getOriginal(event) {\n    return event.originalEvent || event.srcEvent;\n  }\n\n  /**\n   * @param {Event} event\n   *\n   * @return {Point|null}\n   */\n  function toPoint(event) {\n\n    if (event.pointers && event.pointers.length) {\n      event = event.pointers[0];\n    }\n\n    if (event.touches && event.touches.length) {\n      event = event.touches[0];\n    }\n\n    return event ? {\n      x: event.clientX,\n      y: event.clientY\n    } : null;\n  }\n\n  function isMac() {\n    return (/mac/i).test(navigator.platform);\n  }\n\n  /**\n   * @param {MouseEvent} event\n   * @param {string} button\n   *\n   * @return {boolean}\n   */\n  function isButton(event, button) {\n    return (getOriginal(event) || event).button === button;\n  }\n\n  /**\n   * @param {MouseEvent} event\n   *\n   * @return {boolean}\n   */\n  function isPrimaryButton(event) {\n\n    // button === 0 -> left ka primary mouse button\n    return isButton(event, 0);\n  }\n\n  /**\n   * @param {MouseEvent} event\n   *\n   * @return {boolean}\n   */\n  function isAuxiliaryButton(event) {\n\n    // button === 1 -> auxiliary ka wheel button\n    return isButton(event, 1);\n  }\n\n  /**\n   * @param {MouseEvent} event\n   *\n   * @return {boolean}\n   */\n  function hasSecondaryModifier(event) {\n    var originalEvent = getOriginal(event) || event;\n\n    return isPrimaryButton(event) && originalEvent.shiftKey;\n  }\n\n  /**\n   * @typedef {import('../../model/Types').Element} Element\n   *\n   * @typedef {import('../../core/ElementRegistry').default} ElementRegistry\n   * @typedef {import('../../core/EventBus').default} EventBus\n   * @typedef {import('../../draw/Styles').default} Styles\n   *\n   * @typedef {import('../../util/Types').Point} Point\n   */\n\n  function allowAll(event) { return true; }\n\n  function allowPrimaryAndAuxiliary(event) {\n    return isPrimaryButton(event) || isAuxiliaryButton(event);\n  }\n\n  var LOW_PRIORITY$1 = 500;\n\n\n  /**\n   * A plugin that provides interaction events for diagram elements.\n   *\n   * It emits the following events:\n   *\n   *   * element.click\n   *   * element.contextmenu\n   *   * element.dblclick\n   *   * element.hover\n   *   * element.mousedown\n   *   * element.mousemove\n   *   * element.mouseup\n   *   * element.out\n   *\n   * Each event is a tuple { element, gfx, originalEvent }.\n   *\n   * Canceling the event via Event#preventDefault()\n   * prevents the original DOM operation.\n   *\n   * @param {EventBus} eventBus\n   * @param {ElementRegistry} elementRegistry\n   * @param {Styles} styles\n   */\n  function InteractionEvents(eventBus, elementRegistry, styles) {\n\n    var self = this;\n\n    /**\n     * Fire an interaction event.\n     *\n     * @param {string} type local event name, e.g. element.click.\n     * @param {MouseEvent|TouchEvent} event native event\n     * @param {Element} [element] the diagram element to emit the event on;\n     *                                   defaults to the event target\n     */\n    function fire(type, event, element) {\n\n      if (isIgnored(type, event)) {\n        return;\n      }\n\n      var target, gfx, returnValue;\n\n      if (!element) {\n        target = event.delegateTarget || event.target;\n\n        if (target) {\n          gfx = target;\n          element = elementRegistry.get(gfx);\n        }\n      } else {\n        gfx = elementRegistry.getGraphics(element);\n      }\n\n      if (!gfx || !element) {\n        return;\n      }\n\n      returnValue = eventBus.fire(type, {\n        element: element,\n        gfx: gfx,\n        originalEvent: event\n      });\n\n      if (returnValue === false) {\n        event.stopPropagation();\n        event.preventDefault();\n      }\n    }\n\n    // TODO(nikku): document this\n    var handlers = {};\n\n    function mouseHandler(localEventName) {\n      return handlers[localEventName];\n    }\n\n    function isIgnored(localEventName, event) {\n\n      var filter = ignoredFilters[localEventName] || isPrimaryButton;\n\n      // only react on left mouse button interactions\n      // except for interaction events that are enabled\n      // for secundary mouse button\n      return !filter(event);\n    }\n\n    var bindings = {\n      click: 'element.click',\n      contextmenu: 'element.contextmenu',\n      dblclick: 'element.dblclick',\n      mousedown: 'element.mousedown',\n      mousemove: 'element.mousemove',\n      mouseover: 'element.hover',\n      mouseout: 'element.out',\n      mouseup: 'element.mouseup',\n    };\n\n    var ignoredFilters = {\n      'element.contextmenu': allowAll,\n      'element.mousedown': allowPrimaryAndAuxiliary,\n      'element.mouseup': allowPrimaryAndAuxiliary,\n      'element.click': allowPrimaryAndAuxiliary,\n      'element.dblclick': allowPrimaryAndAuxiliary\n    };\n\n\n    // manual event trigger //////////\n\n    /**\n     * Trigger an interaction event (based on a native dom event)\n     * on the target shape or connection.\n     *\n     * @param {string} eventName the name of the triggered DOM event\n     * @param {MouseEvent|TouchEvent} event\n     * @param {Element} targetElement\n     */\n    function triggerMouseEvent(eventName, event, targetElement) {\n\n      // i.e. element.mousedown...\n      var localEventName = bindings[eventName];\n\n      if (!localEventName) {\n        throw new Error('unmapped DOM event name <' + eventName + '>');\n      }\n\n      return fire(localEventName, event, targetElement);\n    }\n\n\n    var ELEMENT_SELECTOR = 'svg, .djs-element';\n\n    // event handling ///////\n\n    function registerEvent(node, event, localEvent, ignoredFilter) {\n\n      var handler = handlers[localEvent] = function(event) {\n        fire(localEvent, event);\n      };\n\n      if (ignoredFilter) {\n        ignoredFilters[localEvent] = ignoredFilter;\n      }\n\n      handler.$delegate = delegate.bind(node, ELEMENT_SELECTOR, event, handler);\n    }\n\n    function unregisterEvent(node, event, localEvent) {\n\n      var handler = mouseHandler(localEvent);\n\n      if (!handler) {\n        return;\n      }\n\n      delegate.unbind(node, event, handler.$delegate);\n    }\n\n    function registerEvents(svg) {\n      forEach$1(bindings, function(val, key) {\n        registerEvent(svg, key, val);\n      });\n    }\n\n    function unregisterEvents(svg) {\n      forEach$1(bindings, function(val, key) {\n        unregisterEvent(svg, key, val);\n      });\n    }\n\n    eventBus.on('canvas.destroy', function(event) {\n      unregisterEvents(event.svg);\n    });\n\n    eventBus.on('canvas.init', function(event) {\n      registerEvents(event.svg);\n    });\n\n\n    // hit box updating ////////////////\n\n    eventBus.on([ 'shape.added', 'connection.added' ], function(event) {\n      var element = event.element,\n          gfx = event.gfx;\n\n      eventBus.fire('interactionEvents.createHit', { element: element, gfx: gfx });\n    });\n\n    // Update djs-hit on change.\n    // A low priortity is necessary, because djs-hit of labels has to be updated\n    // after the label bounds have been updated in the renderer.\n    eventBus.on([\n      'shape.changed',\n      'connection.changed'\n    ], LOW_PRIORITY$1, function(event) {\n\n      var element = event.element,\n          gfx = event.gfx;\n\n      eventBus.fire('interactionEvents.updateHit', { element: element, gfx: gfx });\n    });\n\n    eventBus.on('interactionEvents.createHit', LOW_PRIORITY$1, function(event) {\n      var element = event.element,\n          gfx = event.gfx;\n\n      self.createDefaultHit(element, gfx);\n    });\n\n    eventBus.on('interactionEvents.updateHit', function(event) {\n      var element = event.element,\n          gfx = event.gfx;\n\n      self.updateDefaultHit(element, gfx);\n    });\n\n\n    // hit styles ////////////\n\n    var STROKE_HIT_STYLE = createHitStyle('djs-hit djs-hit-stroke');\n\n    var CLICK_STROKE_HIT_STYLE = createHitStyle('djs-hit djs-hit-click-stroke');\n\n    var ALL_HIT_STYLE = createHitStyle('djs-hit djs-hit-all');\n\n    var NO_MOVE_HIT_STYLE = createHitStyle('djs-hit djs-hit-no-move');\n\n    var HIT_TYPES = {\n      'all': ALL_HIT_STYLE,\n      'click-stroke': CLICK_STROKE_HIT_STYLE,\n      'stroke': STROKE_HIT_STYLE,\n      'no-move': NO_MOVE_HIT_STYLE\n    };\n\n    function createHitStyle(classNames, attrs) {\n\n      attrs = assign$1({\n        stroke: 'white',\n        strokeWidth: 15\n      }, attrs || {});\n\n      return styles.cls(classNames, [ 'no-fill', 'no-border' ], attrs);\n    }\n\n\n    // style helpers ///////////////\n\n    function applyStyle(hit, type) {\n\n      var attrs = HIT_TYPES[type];\n\n      if (!attrs) {\n        throw new Error('invalid hit type <' + type + '>');\n      }\n\n      attr$1(hit, attrs);\n\n      return hit;\n    }\n\n    function appendHit(gfx, hit) {\n      append(gfx, hit);\n    }\n\n\n    // API\n\n    /**\n     * Remove hints on the given graphics.\n     *\n     * @param {SVGElement} gfx\n     */\n    this.removeHits = function(gfx) {\n      var hits = all('.djs-hit', gfx);\n\n      forEach$1(hits, remove$2);\n    };\n\n    /**\n     * Create default hit for the given element.\n     *\n     * @param {Element} element\n     * @param {SVGElement} gfx\n     *\n     * @return {SVGElement} created hit\n     */\n    this.createDefaultHit = function(element, gfx) {\n      var waypoints = element.waypoints,\n          isFrame = element.isFrame,\n          boxType;\n\n      if (waypoints) {\n        return this.createWaypointsHit(gfx, waypoints);\n      } else {\n\n        boxType = isFrame ? 'stroke' : 'all';\n\n        return this.createBoxHit(gfx, boxType, {\n          width: element.width,\n          height: element.height\n        });\n      }\n    };\n\n    /**\n     * Create hits for the given waypoints.\n     *\n     * @param {SVGElement} gfx\n     * @param {Point[]} waypoints\n     *\n     * @return {SVGElement}\n     */\n    this.createWaypointsHit = function(gfx, waypoints) {\n\n      var hit = createLine(waypoints);\n\n      applyStyle(hit, 'stroke');\n\n      appendHit(gfx, hit);\n\n      return hit;\n    };\n\n    /**\n     * Create hits for a box.\n     *\n     * @param {SVGElement} gfx\n     * @param {string} type\n     * @param {Object} attrs\n     *\n     * @return {SVGElement}\n     */\n    this.createBoxHit = function(gfx, type, attrs) {\n\n      attrs = assign$1({\n        x: 0,\n        y: 0\n      }, attrs);\n\n      var hit = create$1('rect');\n\n      applyStyle(hit, type);\n\n      attr$1(hit, attrs);\n\n      appendHit(gfx, hit);\n\n      return hit;\n    };\n\n    /**\n     * Update default hit of the element.\n     *\n     * @param {Element} element\n     * @param {SVGElement} gfx\n     *\n     * @return {SVGElement} updated hit\n     */\n    this.updateDefaultHit = function(element, gfx) {\n\n      var hit = query('.djs-hit', gfx);\n\n      if (!hit) {\n        return;\n      }\n\n      if (element.waypoints) {\n        updateLine(hit, element.waypoints);\n      } else {\n        attr$1(hit, {\n          width: element.width,\n          height: element.height\n        });\n      }\n\n      return hit;\n    };\n\n    this.fire = fire;\n\n    this.triggerMouseEvent = triggerMouseEvent;\n\n    this.mouseHandler = mouseHandler;\n\n    this.registerEvent = registerEvent;\n    this.unregisterEvent = unregisterEvent;\n  }\n\n\n  InteractionEvents.$inject = [\n    'eventBus',\n    'elementRegistry',\n    'styles'\n  ];\n\n\n  /**\n   * An event indicating that the mouse hovered over an element\n   *\n   * @event element.hover\n   *\n   * @type {Object}\n   * @property {Element} element\n   * @property {SVGElement} gfx\n   * @property {Event} originalEvent\n   */\n\n  /**\n   * An event indicating that the mouse has left an element\n   *\n   * @event element.out\n   *\n   * @type {Object}\n   * @property {Element} element\n   * @property {SVGElement} gfx\n   * @property {Event} originalEvent\n   */\n\n  /**\n   * An event indicating that the mouse has clicked an element\n   *\n   * @event element.click\n   *\n   * @type {Object}\n   * @property {Element} element\n   * @property {SVGElement} gfx\n   * @property {Event} originalEvent\n   */\n\n  /**\n   * An event indicating that the mouse has double clicked an element\n   *\n   * @event element.dblclick\n   *\n   * @type {Object}\n   * @property {Element} element\n   * @property {SVGElement} gfx\n   * @property {Event} originalEvent\n   */\n\n  /**\n   * An event indicating that the mouse has gone down on an element.\n   *\n   * @event element.mousedown\n   *\n   * @type {Object}\n   * @property {Element} element\n   * @property {SVGElement} gfx\n   * @property {Event} originalEvent\n   */\n\n  /**\n   * An event indicating that the mouse has gone up on an element.\n   *\n   * @event element.mouseup\n   *\n   * @type {Object}\n   * @property {Element} element\n   * @property {SVGElement} gfx\n   * @property {Event} originalEvent\n   */\n\n  /**\n   * An event indicating that the context menu action is triggered\n   * via mouse or touch controls.\n   *\n   * @event element.contextmenu\n   *\n   * @type {Object}\n   * @property {Element} element\n   * @property {SVGElement} gfx\n   * @property {Event} originalEvent\n   */\n\n  /**\n   * @type { import('didi').ModuleDeclaration }\n   */\n  var InteractionEventsModule = {\n    __init__: [ 'interactionEvents' ],\n    interactionEvents: [ 'type', InteractionEvents ]\n  };\n\n  /**\n   * @typedef {import('../../core/Canvas').default} Canvas\n   * @typedef {import('../../core/EventBus').default} EventBus\n   */\n\n  /**\n   * A service that offers the current selection in a diagram.\n   * Offers the api to control the selection, too.\n   *\n   * @param {EventBus} eventBus\n   * @param {Canvas} canvas\n   */\n  function Selection(eventBus, canvas) {\n\n    this._eventBus = eventBus;\n    this._canvas = canvas;\n\n    /**\n     * @type {Object[]}\n     */\n    this._selectedElements = [];\n\n    var self = this;\n\n    eventBus.on([ 'shape.remove', 'connection.remove' ], function(e) {\n      var element = e.element;\n      self.deselect(element);\n    });\n\n    eventBus.on([ 'diagram.clear', 'root.set' ], function(e) {\n      self.select(null);\n    });\n  }\n\n  Selection.$inject = [ 'eventBus', 'canvas' ];\n\n  /**\n   * Deselect an element.\n   *\n   * @param {Object} element The element to deselect.\n   */\n  Selection.prototype.deselect = function(element) {\n    var selectedElements = this._selectedElements;\n\n    var idx = selectedElements.indexOf(element);\n\n    if (idx !== -1) {\n      var oldSelection = selectedElements.slice();\n\n      selectedElements.splice(idx, 1);\n\n      this._eventBus.fire('selection.changed', { oldSelection: oldSelection, newSelection: selectedElements });\n    }\n  };\n\n  /**\n   * Get the selected elements.\n   *\n   * @return {Object[]} The selected elements.\n   */\n  Selection.prototype.get = function() {\n    return this._selectedElements;\n  };\n\n  /**\n   * Check whether an element is selected.\n   *\n   * @param {Object} element The element.\n   *\n   * @return {boolean} Whether the element is selected.\n   */\n  Selection.prototype.isSelected = function(element) {\n    return this._selectedElements.indexOf(element) !== -1;\n  };\n\n\n  /**\n   * Select one or many elements.\n   *\n   * @param {Object|Object[]} elements The element(s) to select.\n   * @param {boolean} [add] Whether to add the element(s) to the selected elements.\n   * Defaults to `false`.\n   */\n  Selection.prototype.select = function(elements, add) {\n    var selectedElements = this._selectedElements,\n        oldSelection = selectedElements.slice();\n\n    if (!isArray$2(elements)) {\n      elements = elements ? [ elements ] : [];\n    }\n\n    var canvas = this._canvas;\n\n    var rootElement = canvas.getRootElement();\n\n    elements = elements.filter(function(element) {\n      var elementRoot = canvas.findRoot(element);\n\n      return rootElement === elementRoot;\n    });\n\n    // selection may be cleared by passing an empty array or null\n    // to the method\n    if (add) {\n      forEach$1(elements, function(element) {\n        if (selectedElements.indexOf(element) !== -1) {\n\n          // already selected\n          return;\n        } else {\n          selectedElements.push(element);\n        }\n      });\n    } else {\n      this._selectedElements = selectedElements = elements.slice();\n    }\n\n    this._eventBus.fire('selection.changed', { oldSelection: oldSelection, newSelection: selectedElements });\n  };\n\n  /**\n   * @typedef {import('../../core/Canvas').default} Canvas\n   * @typedef {import('../../core/EventBus').default} EventBus\n   */\n\n  var MARKER_HOVER = 'hover',\n      MARKER_SELECTED = 'selected';\n\n  /**\n   * A plugin that adds a visible selection UI to shapes and connections\n   * by appending the <code>hover</code> and <code>selected</code> classes to them.\n   *\n   * @class\n   *\n   * Makes elements selectable, too.\n   *\n   * @param {Canvas} canvas\n   * @param {EventBus} eventBus\n   */\n  function SelectionVisuals(canvas, eventBus) {\n    this._canvas = canvas;\n\n    function addMarker(e, cls) {\n      canvas.addMarker(e, cls);\n    }\n\n    function removeMarker(e, cls) {\n      canvas.removeMarker(e, cls);\n    }\n\n    eventBus.on('element.hover', function(event) {\n      addMarker(event.element, MARKER_HOVER);\n    });\n\n    eventBus.on('element.out', function(event) {\n      removeMarker(event.element, MARKER_HOVER);\n    });\n\n    eventBus.on('selection.changed', function(event) {\n\n      function deselect(s) {\n        removeMarker(s, MARKER_SELECTED);\n      }\n\n      function select(s) {\n        addMarker(s, MARKER_SELECTED);\n      }\n\n      var oldSelection = event.oldSelection,\n          newSelection = event.newSelection;\n\n      forEach$1(oldSelection, function(e) {\n        if (newSelection.indexOf(e) === -1) {\n          deselect(e);\n        }\n      });\n\n      forEach$1(newSelection, function(e) {\n        if (oldSelection.indexOf(e) === -1) {\n          select(e);\n        }\n      });\n    });\n  }\n\n  SelectionVisuals.$inject = [\n    'canvas',\n    'eventBus'\n  ];\n\n  /**\n   * @typedef {import('../../core/Canvas').default} Canvas\n   * @typedef {import('../../core/ElementRegistry').default} ElementRegistry\n   * @typedef {import('../../core/EventBus').default} EventBus\n   * @typedef {import('./Selection').default} Selection\n   */\n\n  /**\n   * @param {EventBus} eventBus\n   * @param {Selection} selection\n   * @param {Canvas} canvas\n   * @param {ElementRegistry} elementRegistry\n   */\n  function SelectionBehavior(eventBus, selection, canvas, elementRegistry) {\n\n    // Select elements on create\n    eventBus.on('create.end', 500, function(event) {\n      var context = event.context,\n          canExecute = context.canExecute,\n          elements = context.elements,\n          hints = context.hints || {},\n          autoSelect = hints.autoSelect;\n\n      if (canExecute) {\n        if (autoSelect === false) {\n\n          // Select no elements\n          return;\n        }\n\n        if (isArray$2(autoSelect)) {\n          selection.select(autoSelect);\n        } else {\n\n          // Select all elements by default\n          selection.select(elements.filter(isShown));\n        }\n      }\n    });\n\n    // Select connection targets on connect\n    eventBus.on('connect.end', 500, function(event) {\n      var context = event.context,\n          connection = context.connection;\n\n      if (connection) {\n        selection.select(connection);\n      }\n    });\n\n    // Select shapes on move\n    eventBus.on('shape.move.end', 500, function(event) {\n      var previousSelection = event.previousSelection || [];\n\n      var shape = elementRegistry.get(event.context.shape.id);\n\n      // Always select main shape on move\n      var isSelected = find(previousSelection, function(selectedShape) {\n        return shape.id === selectedShape.id;\n      });\n\n      if (!isSelected) {\n        selection.select(shape);\n      }\n    });\n\n    // Select elements on click\n    eventBus.on('element.click', function(event) {\n\n      if (!isPrimaryButton(event)) {\n        return;\n      }\n\n      var element = event.element;\n\n      if (element === canvas.getRootElement()) {\n        element = null;\n      }\n\n      var isSelected = selection.isSelected(element),\n          isMultiSelect = selection.get().length > 1;\n\n      // Add to selection if SHIFT pressed\n      var add = hasSecondaryModifier(event);\n\n      if (isSelected && isMultiSelect) {\n        if (add) {\n\n          // Deselect element\n          return selection.deselect(element);\n        } else {\n\n          // Select element only\n          return selection.select(element);\n        }\n      } else if (!isSelected) {\n\n        // Select element\n        selection.select(element, add);\n      } else {\n\n        // Deselect element\n        selection.deselect(element);\n      }\n    });\n  }\n\n  SelectionBehavior.$inject = [\n    'eventBus',\n    'selection',\n    'canvas',\n    'elementRegistry'\n  ];\n\n\n  function isShown(element) {\n    return !element.hidden;\n  }\n\n  /**\n   * @type { import('didi').ModuleDeclaration }\n   */\n  var SelectionModule = {\n    __init__: [ 'selectionVisuals', 'selectionBehavior' ],\n    __depends__: [\n      InteractionEventsModule,\n    ],\n    selection: [ 'type', Selection ],\n    selectionVisuals: [ 'type', SelectionVisuals ],\n    selectionBehavior: [ 'type', SelectionBehavior ]\n  };\n\n  const CLASS_PATTERN = /^class[ {]/;\n\n\n  /**\n   * @param {function} fn\n   *\n   * @return {boolean}\n   */\n  function isClass(fn) {\n    return CLASS_PATTERN.test(fn.toString());\n  }\n\n  /**\n   * @param {any} obj\n   *\n   * @return {boolean}\n   */\n  function isArray(obj) {\n    return Array.isArray(obj);\n  }\n\n  /**\n   * @param {any} obj\n   * @param {string} prop\n   *\n   * @return {boolean}\n   */\n  function hasOwnProp(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n\n  /**\n   * @typedef {import('./index.js').InjectAnnotated } InjectAnnotated\n   */\n\n  /**\n   * @template T\n   *\n   * @params {[...string[], T] | ...string[], T} args\n   *\n   * @return {T & InjectAnnotated}\n   */\n  function annotate(...args) {\n\n    if (args.length === 1 && isArray(args[0])) {\n      args = args[0];\n    }\n\n    args = [ ...args ];\n\n    const fn = args.pop();\n\n    fn.$inject = args;\n\n    return fn;\n  }\n\n\n  // Current limitations:\n  // - can't put into \"function arg\" comments\n  // function /* (no parenthesis like this) */ (){}\n  // function abc( /* xx (no parenthesis like this) */ a, b) {}\n  //\n  // Just put the comment before function or inside:\n  // /* (((this is fine))) */ function(a, b) {}\n  // function abc(a) { /* (((this is fine))) */}\n  //\n  // - can't reliably auto-annotate constructor; we'll match the\n  // first constructor(...) pattern found which may be the one\n  // of a nested class, too.\n\n  const CONSTRUCTOR_ARGS = /constructor\\s*[^(]*\\(\\s*([^)]*)\\)/m;\n  const FN_ARGS = /^(?:async\\s+)?(?:function\\s*[^(]*)?(?:\\(\\s*([^)]*)\\)|(\\w+))/m;\n  const FN_ARG = /\\/\\*([^*]*)\\*\\//m;\n\n  /**\n   * @param {unknown} fn\n   *\n   * @return {string[]}\n   */\n  function parseAnnotations(fn) {\n\n    if (typeof fn !== 'function') {\n      throw new Error(`Cannot annotate \"${fn}\". Expected a function!`);\n    }\n\n    const match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);\n\n    // may parse class without constructor\n    if (!match) {\n      return [];\n    }\n\n    const args = match[1] || match[2];\n\n    return args && args.split(',').map(arg => {\n      const argMatch = arg.match(FN_ARG);\n      return (argMatch && argMatch[1] || arg).trim();\n    }) || [];\n  }\n\n  /**\n   * @typedef { import('./index.js').ModuleDeclaration } ModuleDeclaration\n   * @typedef { import('./index.js').ModuleDefinition } ModuleDefinition\n   * @typedef { import('./index.js').InjectorContext } InjectorContext\n   *\n   * @typedef { import('./index.js').TypedDeclaration<any, any> } TypedDeclaration\n   */\n\n  /**\n   * Create a new injector with the given modules.\n   *\n   * @param {ModuleDefinition[]} modules\n   * @param {InjectorContext} [_parent]\n   */\n  function Injector(modules, _parent) {\n\n    const parent = _parent || /** @type InjectorContext */ ({\n      get: function(name, strict) {\n        currentlyResolving.push(name);\n\n        if (strict === false) {\n          return null;\n        } else {\n          throw error(`No provider for \"${ name }\"!`);\n        }\n      }\n    });\n\n    const currentlyResolving = [];\n    const providers = this._providers = Object.create(parent._providers || null);\n    const instances = this._instances = Object.create(null);\n\n    const self = instances.injector = this;\n\n    const error = function(msg) {\n      const stack = currentlyResolving.join(' -> ');\n      currentlyResolving.length = 0;\n      return new Error(stack ? `${ msg } (Resolving: ${ stack })` : msg);\n    };\n\n    /**\n     * Return a named service.\n     *\n     * @param {string} name\n     * @param {boolean} [strict=true] if false, resolve missing services to null\n     *\n     * @return {any}\n     */\n    function get(name, strict) {\n      if (!providers[name] && name.includes('.')) {\n\n        const parts = name.split('.');\n        let pivot = get(/** @type { string } */ (parts.shift()));\n\n        while (parts.length) {\n          pivot = pivot[/** @type { string } */ (parts.shift())];\n        }\n\n        return pivot;\n      }\n\n      if (hasOwnProp(instances, name)) {\n        return instances[name];\n      }\n\n      if (hasOwnProp(providers, name)) {\n        if (currentlyResolving.indexOf(name) !== -1) {\n          currentlyResolving.push(name);\n          throw error('Cannot resolve circular dependency!');\n        }\n\n        currentlyResolving.push(name);\n        instances[name] = providers[name][0](providers[name][1]);\n        currentlyResolving.pop();\n\n        return instances[name];\n      }\n\n      return parent.get(name, strict);\n    }\n\n    function fnDef(fn, locals) {\n\n      if (typeof locals === 'undefined') {\n        locals = {};\n      }\n\n      if (typeof fn !== 'function') {\n        if (isArray(fn)) {\n          fn = annotate(fn.slice());\n        } else {\n          throw error(`Cannot invoke \"${ fn }\". Expected a function!`);\n        }\n      }\n\n      /**\n       * @type {string[]}\n       */\n      const inject = fn.$inject || parseAnnotations(fn);\n      const dependencies = inject.map(dep => {\n        if (hasOwnProp(locals, dep)) {\n          return locals[dep];\n        } else {\n          return get(dep);\n        }\n      });\n\n      return {\n        fn: fn,\n        dependencies\n      };\n    }\n\n    /**\n     * Instantiate the given type, injecting dependencies.\n     *\n     * @template T\n     *\n     * @param { Function | [...string[], Function ]} type\n     *\n     * @return T\n     */\n    function instantiate(type) {\n      const {\n        fn,\n        dependencies\n      } = fnDef(type);\n\n      // instantiate var args constructor\n      const Constructor = Function.prototype.bind.call(fn, null, ...dependencies);\n\n      return new Constructor();\n    }\n\n    /**\n     * Invoke the given function, injecting dependencies. Return the result.\n     *\n     * @template T\n     *\n     * @param { Function | [...string[], Function ]} func\n     * @param { Object } [context]\n     * @param { Object } [locals]\n     *\n     * @return {T} invocation result\n     */\n    function invoke(func, context, locals) {\n      const {\n        fn,\n        dependencies\n      } = fnDef(func, locals);\n\n      return fn.apply(context, dependencies);\n    }\n\n    /**\n     * @param {Injector} childInjector\n     *\n     * @return {Function}\n     */\n    function createPrivateInjectorFactory(childInjector) {\n      return annotate(key => childInjector.get(key));\n    }\n\n    /**\n     * @param {ModuleDefinition[]} modules\n     * @param {string[]} [forceNewInstances]\n     *\n     * @return {Injector}\n     */\n    function createChild(modules, forceNewInstances) {\n      if (forceNewInstances && forceNewInstances.length) {\n        const fromParentModule = Object.create(null);\n        const matchedScopes = Object.create(null);\n\n        const privateInjectorsCache = [];\n        const privateChildInjectors = [];\n        const privateChildFactories = [];\n\n        let provider;\n        let cacheIdx;\n        let privateChildInjector;\n        let privateChildInjectorFactory;\n\n        for (let name in providers) {\n          provider = providers[name];\n\n          if (forceNewInstances.indexOf(name) !== -1) {\n            if (provider[2] === 'private') {\n              cacheIdx = privateInjectorsCache.indexOf(provider[3]);\n              if (cacheIdx === -1) {\n                privateChildInjector = provider[3].createChild([], forceNewInstances);\n                privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);\n                privateInjectorsCache.push(provider[3]);\n                privateChildInjectors.push(privateChildInjector);\n                privateChildFactories.push(privateChildInjectorFactory);\n                fromParentModule[name] = [ privateChildInjectorFactory, name, 'private', privateChildInjector ];\n              } else {\n                fromParentModule[name] = [ privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx] ];\n              }\n            } else {\n              fromParentModule[name] = [ provider[2], provider[1] ];\n            }\n            matchedScopes[name] = true;\n          }\n\n          if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {\n            /* jshint -W083 */\n            forceNewInstances.forEach(scope => {\n              if (provider[1].$scope.indexOf(scope) !== -1) {\n                fromParentModule[name] = [ provider[2], provider[1] ];\n                matchedScopes[scope] = true;\n              }\n            });\n          }\n        }\n\n        forceNewInstances.forEach(scope => {\n          if (!matchedScopes[scope]) {\n            throw new Error('No provider for \"' + scope + '\". Cannot use provider from the parent!');\n          }\n        });\n\n        modules.unshift(fromParentModule);\n      }\n\n      return new Injector(modules, self);\n    }\n\n    const factoryMap = {\n      factory: invoke,\n      type: instantiate,\n      value: function(value) {\n        return value;\n      }\n    };\n\n    /**\n     * @param {ModuleDefinition} moduleDefinition\n     * @param {Injector} injector\n     */\n    function createInitializer(moduleDefinition, injector) {\n\n      const initializers = moduleDefinition.__init__ || [];\n\n      return function() {\n        initializers.forEach(initializer => {\n\n          // eagerly resolve component (fn or string)\n          if (typeof initializer === 'string') {\n            injector.get(initializer);\n          } else {\n            injector.invoke(initializer);\n          }\n        });\n      };\n    }\n\n    /**\n     * @param {ModuleDefinition} moduleDefinition\n     */\n    function loadModule(moduleDefinition) {\n\n      const moduleExports = moduleDefinition.__exports__;\n\n      // private module\n      if (moduleExports) {\n        const nestedModules = moduleDefinition.__modules__;\n\n        const clonedModule = Object.keys(moduleDefinition).reduce((clonedModule, key) => {\n\n          if (key !== '__exports__' && key !== '__modules__' && key !== '__init__' && key !== '__depends__') {\n            clonedModule[key] = moduleDefinition[key];\n          }\n\n          return clonedModule;\n        }, Object.create(null));\n\n        const childModules = (nestedModules || []).concat(clonedModule);\n\n        const privateInjector = createChild(childModules);\n        const getFromPrivateInjector = annotate(function(key) {\n          return privateInjector.get(key);\n        });\n\n        moduleExports.forEach(function(key) {\n          providers[key] = [ getFromPrivateInjector, key, 'private', privateInjector ];\n        });\n\n        // ensure child injector initializes\n        const initializers = (moduleDefinition.__init__ || []).slice();\n\n        initializers.unshift(function() {\n          privateInjector.init();\n        });\n\n        moduleDefinition = Object.assign({}, moduleDefinition, {\n          __init__: initializers\n        });\n\n        return createInitializer(moduleDefinition, privateInjector);\n      }\n\n      // normal module\n      Object.keys(moduleDefinition).forEach(function(key) {\n\n        if (key === '__init__' || key === '__depends__') {\n          return;\n        }\n\n        const typeDeclaration = /** @type { TypedDeclaration } */ (\n          moduleDefinition[key]\n        );\n\n        if (typeDeclaration[2] === 'private') {\n          providers[key] = typeDeclaration;\n          return;\n        }\n\n        const type = typeDeclaration[0];\n        const value = typeDeclaration[1];\n\n        providers[key] = [ factoryMap[type], arrayUnwrap(type, value), type ];\n      });\n\n      return createInitializer(moduleDefinition, self);\n    }\n\n    /**\n     * @param {ModuleDefinition[]} moduleDefinitions\n     * @param {ModuleDefinition} moduleDefinition\n     *\n     * @return {ModuleDefinition[]}\n     */\n    function resolveDependencies(moduleDefinitions, moduleDefinition) {\n\n      if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {\n        return moduleDefinitions;\n      }\n\n      moduleDefinitions = (moduleDefinition.__depends__ || []).reduce(resolveDependencies, moduleDefinitions);\n\n      if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {\n        return moduleDefinitions;\n      }\n\n      return moduleDefinitions.concat(moduleDefinition);\n    }\n\n    /**\n     * @param {ModuleDefinition[]} moduleDefinitions\n     *\n     * @return { () => void } initializerFn\n     */\n    function bootstrap(moduleDefinitions) {\n\n      const initializers = moduleDefinitions\n        .reduce(resolveDependencies, [])\n        .map(loadModule);\n\n      let initialized = false;\n\n      return function() {\n\n        if (initialized) {\n          return;\n        }\n\n        initialized = true;\n\n        initializers.forEach(initializer => initializer());\n      };\n    }\n\n    // public API\n    this.get = get;\n    this.invoke = invoke;\n    this.instantiate = instantiate;\n    this.createChild = createChild;\n\n    // setup\n    this.init = bootstrap(modules);\n  }\n\n\n  // helpers ///////////////\n\n  function arrayUnwrap(type, value) {\n    if (type !== 'value' && isArray(value)) {\n      value = annotate(value.slice());\n    }\n\n    return value;\n  }\n\n  /**\n   * @typedef {import('../core/EventBus').default} EventBus\n   * @typedef {import('./Styles').default} Styles\n   */\n\n  // apply default renderer with lowest possible priority\n  // so that it only kicks in if noone else could render\n  var DEFAULT_RENDER_PRIORITY = 1;\n\n  /**\n   * The default renderer used for shapes and connections.\n   *\n   * @param {EventBus} eventBus\n   * @param {Styles} styles\n   */\n  function DefaultRenderer(eventBus, styles) {\n\n    BaseRenderer.call(this, eventBus, DEFAULT_RENDER_PRIORITY);\n\n    this.CONNECTION_STYLE = styles.style([ 'no-fill' ], { strokeWidth: 5, stroke: 'fuchsia' });\n    this.SHAPE_STYLE = styles.style({ fill: 'white', stroke: 'fuchsia', strokeWidth: 2 });\n    this.FRAME_STYLE = styles.style([ 'no-fill' ], { stroke: 'fuchsia', strokeDasharray: 4, strokeWidth: 2 });\n  }\n\n  e(DefaultRenderer, BaseRenderer);\n\n\n  /**\n   * @private\n   */\n  DefaultRenderer.prototype.canRender = function() {\n    return true;\n  };\n\n  /**\n   * @private\n   */\n  DefaultRenderer.prototype.drawShape = function drawShape(visuals, element, attrs) {\n    var rect = create$1('rect');\n\n    attr$1(rect, {\n      x: 0,\n      y: 0,\n      width: element.width || 0,\n      height: element.height || 0\n    });\n\n    if (isFrameElement(element)) {\n      attr$1(rect, assign$1({}, this.FRAME_STYLE, attrs || {}));\n    } else {\n      attr$1(rect, assign$1({}, this.SHAPE_STYLE, attrs || {}));\n    }\n\n    append(visuals, rect);\n\n    return rect;\n  };\n\n  /**\n   * @private\n   */\n  DefaultRenderer.prototype.drawConnection = function drawConnection(visuals, connection, attrs) {\n\n    var line = createLine(connection.waypoints, assign$1({}, this.CONNECTION_STYLE, attrs || {}));\n    append(visuals, line);\n\n    return line;\n  };\n\n  /**\n   * @private\n   */\n  DefaultRenderer.prototype.getShapePath = function getShapePath(shape) {\n\n    var x = shape.x,\n        y = shape.y,\n        width = shape.width,\n        height = shape.height;\n\n    var shapePath = [\n      [ 'M', x, y ],\n      [ 'l', width, 0 ],\n      [ 'l', 0, height ],\n      [ 'l', -width, 0 ],\n      [ 'z' ]\n    ];\n\n    return componentsToPath(shapePath);\n  };\n\n  /**\n   * @private\n   */\n  DefaultRenderer.prototype.getConnectionPath = function getConnectionPath(connection) {\n    var waypoints = connection.waypoints;\n\n    var idx, point, connectionPath = [];\n\n    for (idx = 0; (point = waypoints[idx]); idx++) {\n\n      // take invisible docking into account\n      // when creating the path\n      point = point.original || point;\n\n      connectionPath.push([ idx === 0 ? 'M' : 'L', point.x, point.y ]);\n    }\n\n    return componentsToPath(connectionPath);\n  };\n\n  DefaultRenderer.$inject = [ 'eventBus', 'styles' ];\n\n  /**\n   * A component that manages shape styles\n   */\n  function Styles() {\n\n    var defaultTraits = {\n\n      'no-fill': {\n        fill: 'none'\n      },\n      'no-border': {\n        strokeOpacity: 0.0\n      },\n      'no-events': {\n        pointerEvents: 'none'\n      }\n    };\n\n    var self = this;\n\n    /**\n     * Builds a style definition from a className, a list of traits and an object\n     * of additional attributes.\n     *\n     * @param {string} className\n     * @param {string[]} [traits]\n     * @param {Object} [additionalAttrs]\n     *\n     * @return {Object} the style definition\n     */\n    this.cls = function(className, traits, additionalAttrs) {\n      var attrs = this.style(traits, additionalAttrs);\n\n      return assign$1(attrs, { 'class': className });\n    };\n\n    /**\n     * Builds a style definition from a list of traits and an object of additional\n     * attributes.\n     *\n     * @param {string[]} [traits]\n     * @param {Object} additionalAttrs\n     *\n     * @return {Object} the style definition\n     */\n    this.style = function(traits, additionalAttrs) {\n\n      if (!isArray$2(traits) && !additionalAttrs) {\n        additionalAttrs = traits;\n        traits = [];\n      }\n\n      var attrs = reduce(traits, function(attrs, t) {\n        return assign$1(attrs, defaultTraits[t] || {});\n      }, {});\n\n      return additionalAttrs ? assign$1(attrs, additionalAttrs) : attrs;\n    };\n\n\n    /**\n     * Computes a style definition from a list of traits and an object of\n     * additional attributes, with custom style definition object.\n     *\n     * @param {Object} custom\n     * @param {string[]} [traits]\n     * @param {Object} defaultStyles\n     *\n     * @return {Object} the style definition\n     */\n    this.computeStyle = function(custom, traits, defaultStyles) {\n      if (!isArray$2(traits)) {\n        defaultStyles = traits;\n        traits = [];\n      }\n\n      return self.style(traits || [], assign$1({}, defaultStyles, custom || {}));\n    };\n  }\n\n  /**\n   * @type { import('didi').ModuleDeclaration }\n   */\n  var DrawModule = {\n    __init__: [ 'defaultRenderer' ],\n    defaultRenderer: [ 'type', DefaultRenderer ],\n    styles: [ 'type', Styles ]\n  };\n\n  /**\n   * Failsafe remove an element from a collection\n   *\n   * @param {Array<Object>} [collection]\n   * @param {Object} [element]\n   *\n   * @return {number} the previous index of the element\n   */\n  function remove(collection, element) {\n\n    if (!collection || !element) {\n      return -1;\n    }\n\n    var idx = collection.indexOf(element);\n\n    if (idx !== -1) {\n      collection.splice(idx, 1);\n    }\n\n    return idx;\n  }\n\n  /**\n   * Fail save add an element to the given connection, ensuring\n   * it does not yet exist.\n   *\n   * @param {Array<Object>} collection\n   * @param {Object} element\n   * @param {number} [idx]\n   */\n  function add(collection, element, idx) {\n\n    if (!collection || !element) {\n      return;\n    }\n\n    if (typeof idx !== 'number') {\n      idx = -1;\n    }\n\n    var currentIdx = collection.indexOf(element);\n\n    if (currentIdx !== -1) {\n\n      if (currentIdx === idx) {\n\n        // nothing to do, position has not changed\n        return;\n      } else {\n\n        if (idx !== -1) {\n\n          // remove from current position\n          collection.splice(currentIdx, 1);\n        } else {\n\n          // already exists in collection\n          return;\n        }\n      }\n    }\n\n    if (idx !== -1) {\n\n      // insert at specified position\n      collection.splice(idx, 0, element);\n    } else {\n\n      // push to end\n      collection.push(element);\n    }\n  }\n\n  /**\n   * @typedef {import('./Types').ConnectionLike} ConnectionLike\n   * @typedef {import('./Types').RootLike} RootLike\n   * @typedef {import('./Types').ParentLike } ParentLike\n   * @typedef {import('./Types').ShapeLike} ShapeLike\n   *\n   * @typedef { {\n   *   container?: HTMLElement;\n   *   deferUpdate?: boolean;\n   *   width?: number;\n   *   height?: number;\n   *   autoFocus?: boolean;\n   * } } CanvasConfig\n   * @typedef { {\n   *   group: SVGElement;\n   *   index: number;\n   *   visible: boolean;\n   * } } CanvasLayer\n   * @typedef { {\n   *   [key: string]: CanvasLayer;\n   * } } CanvasLayers\n   * @typedef { {\n   *   rootElement: ShapeLike;\n   *   layer: CanvasLayer;\n   * } } CanvasPlane\n   * @typedef { {\n   *   scale: number;\n   *   inner: Rect;\n   *   outer: Dimensions;\n   * } & Rect } CanvasViewbox\n   *\n   * @typedef {import('./ElementRegistry').default} ElementRegistry\n   * @typedef {import('./EventBus').default} EventBus\n   * @typedef {import('./GraphicsFactory').default} GraphicsFactory\n   *\n   * @typedef {import('../util/Types').Dimensions} Dimensions\n   * @typedef {import('../util/Types').Point} Point\n   * @typedef {import('../util/Types').Rect} Rect\n   * @typedef {import('../util/Types').RectTRBL} RectTRBL\n   * @typedef {import('../util/Types').ScrollDelta} ScrollDelta\n   */\n\n  function round(number, resolution) {\n    return Math.round(number * resolution) / resolution;\n  }\n\n  function ensurePx(number) {\n    return isNumber(number) ? number + 'px' : number;\n  }\n\n  function findRoot(element) {\n    while (element.parent) {\n      element = element.parent;\n    }\n\n    return element;\n  }\n\n  /**\n   * Creates a HTML container element for a SVG element with\n   * the given configuration\n   *\n   * @param {CanvasConfig} options\n   *\n   * @return {HTMLElement} the container element\n   */\n  function createContainer(options) {\n\n    options = assign$1({}, { width: '100%', height: '100%' }, options);\n\n    const container = options.container || document.body;\n\n    // create a <div> around the svg element with the respective size\n    // this way we can always get the correct container size\n    // (this is impossible for <svg> elements at the moment)\n    const parent = document.createElement('div');\n    parent.setAttribute('class', 'djs-container djs-parent');\n\n    assign(parent, {\n      position: 'relative',\n      overflow: 'hidden',\n      width: ensurePx(options.width),\n      height: ensurePx(options.height)\n    });\n\n    container.appendChild(parent);\n\n    return parent;\n  }\n\n  function createGroup(parent, cls, childIndex) {\n    const group = create$1('g');\n    classes$1(group).add(cls);\n\n    const index = childIndex !== undefined ? childIndex : parent.childNodes.length - 1;\n\n    // must ensure second argument is node or _null_\n    // cf. https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore\n    parent.insertBefore(group, parent.childNodes[index] || null);\n\n    return group;\n  }\n\n  const BASE_LAYER = 'base';\n\n  // render plane contents behind utility layers\n  const PLANE_LAYER_INDEX = 0;\n  const UTILITY_LAYER_INDEX = 1;\n\n\n  const REQUIRED_MODEL_ATTRS = {\n    shape: [ 'x', 'y', 'width', 'height' ],\n    connection: [ 'waypoints' ]\n  };\n\n  /**\n   * The main drawing canvas.\n   *\n   * @class\n   * @constructor\n   *\n   * @emits Canvas#canvas.init\n   *\n   * @param {CanvasConfig|null} config\n   * @param {EventBus} eventBus\n   * @param {GraphicsFactory} graphicsFactory\n   * @param {ElementRegistry} elementRegistry\n   */\n  function Canvas(config, eventBus, graphicsFactory, elementRegistry) {\n    this._eventBus = eventBus;\n    this._elementRegistry = elementRegistry;\n    this._graphicsFactory = graphicsFactory;\n\n    /**\n     * @type {number}\n     */\n    this._rootsIdx = 0;\n\n    /**\n     * @type {CanvasLayers}\n     */\n    this._layers = {};\n\n    /**\n     * @type {CanvasPlane[]}\n     */\n    this._planes = [];\n\n    /**\n     * @type {RootLike|null}\n     */\n    this._rootElement = null;\n\n    /**\n     * @type {boolean}\n     */\n    this._focused = false;\n\n    this._init(config || {});\n  }\n\n  Canvas.$inject = [\n    'config.canvas',\n    'eventBus',\n    'graphicsFactory',\n    'elementRegistry'\n  ];\n\n  /**\n   * Creates a <svg> element that is wrapped into a <div>.\n   * This way we are always able to correctly figure out the size of the svg element\n   * by querying the parent node.\n\n   * (It is not possible to get the size of a svg element cross browser @ 2014-04-01)\n\n   * <div class=\"djs-container\" style=\"width: {desired-width}, height: {desired-height}\">\n   *   <svg width=\"100%\" height=\"100%\">\n   *    ...\n   *   </svg>\n   * </div>\n   *\n   * @param {CanvasConfig} config\n   */\n  Canvas.prototype._init = function(config) {\n    const eventBus = this._eventBus;\n\n    // html container\n    const container = this._container = createContainer(config);\n\n    const svg = this._svg = create$1('svg');\n\n    attr$1(svg, {\n      width: '100%',\n      height: '100%'\n    });\n\n    attr(svg, 'tabindex', 0);\n\n    config.autoFocus && eventBus.on('element.hover', () => {\n      this.restoreFocus();\n    });\n\n    eventBus.on('element.mousedown', 500, (event) => {\n      this.focus();\n    });\n\n    svg.addEventListener('focusin', () => {\n      this._setFocused(true);\n    });\n\n    svg.addEventListener('focusout', () => {\n      this._setFocused(false);\n    });\n\n    append(container, svg);\n\n    const viewport = this._viewport = createGroup(svg, 'viewport');\n\n    // debounce canvas.viewbox.changed events when deferUpdate is set\n    // to help with potential performance issues\n    if (config.deferUpdate) {\n      this._viewboxChanged = debounce(bind$2(this._viewboxChanged, this), 300);\n    }\n\n    eventBus.on('diagram.init', () => {\n\n      /**\n       * An event indicating that the canvas is ready to be drawn on.\n       *\n       * @memberOf Canvas\n       *\n       * @event canvas.init\n       *\n       * @type {Object}\n       * @property {SVGElement} svg the created svg element\n       * @property {SVGElement} viewport the direct parent of diagram elements and shapes\n       */\n      eventBus.fire('canvas.init', {\n        svg: svg,\n        viewport: viewport\n      });\n\n    });\n\n    // reset viewbox on shape changes to\n    // recompute the viewbox\n    eventBus.on([\n      'shape.added',\n      'connection.added',\n      'shape.removed',\n      'connection.removed',\n      'elements.changed',\n      'root.set'\n    ], () => {\n      delete this._cachedViewbox;\n    });\n\n    eventBus.on('diagram.destroy', 500, this._destroy, this);\n    eventBus.on('diagram.clear', 500, this._clear, this);\n  };\n\n  Canvas.prototype._destroy = function() {\n    this._eventBus.fire('canvas.destroy', {\n      svg: this._svg,\n      viewport: this._viewport\n    });\n\n    const parent = this._container.parentNode;\n\n    if (parent) {\n      parent.removeChild(this._container);\n    }\n\n    delete this._svg;\n    delete this._container;\n    delete this._layers;\n    delete this._planes;\n    delete this._rootElement;\n    delete this._viewport;\n  };\n\n  Canvas.prototype._setFocused = function(focused) {\n\n    if (focused == this._focused) {\n      return;\n    }\n\n    this._focused = focused;\n\n    this._eventBus.fire('canvas.focus.changed', { focused });\n  };\n\n  Canvas.prototype._clear = function() {\n\n    const allElements = this._elementRegistry.getAll();\n\n    // remove all elements\n    allElements.forEach(element => {\n      const type = getType(element);\n\n      if (type === 'root') {\n        this.removeRootElement(element);\n      } else {\n        this._removeElement(element, type);\n      }\n    });\n\n    // remove all planes\n    this._planes = [];\n    this._rootElement = null;\n\n    // force recomputation of view box\n    delete this._cachedViewbox;\n  };\n\n  /**\n   * Sets focus on the canvas SVG element.\n   */\n  Canvas.prototype.focus = function() {\n    this._svg.focus({ preventScroll: true });\n\n    this._setFocused(true);\n  };\n\n  /**\n  * Sets focus on the canvas SVG element if `document.body` is currently focused.\n  */\n  Canvas.prototype.restoreFocus = function() {\n    if (document.activeElement === document.body) {\n      this.focus();\n    }\n  };\n\n  /**\n  * Returns true if the canvas is focused.\n  *\n  * @return {boolean}\n  */\n  Canvas.prototype.isFocused = function() {\n    return this._focused;\n  };\n\n  /**\n   * Returns the default layer on which\n   * all elements are drawn.\n   *\n   * @return {SVGElement}  The SVG element of the layer.\n   */\n  Canvas.prototype.getDefaultLayer = function() {\n    return this.getLayer(BASE_LAYER, PLANE_LAYER_INDEX);\n  };\n\n  /**\n   * Returns a layer that is used to draw elements\n   * or annotations on it.\n   *\n   * Non-existing layers retrieved through this method\n   * will be created. During creation, the optional index\n   * may be used to create layers below or above existing layers.\n   * A layer with a certain index is always created above all\n   * existing layers with the same index.\n   *\n   * @param {string} name The name of the layer.\n   * @param {number} [index] The index of the layer.\n   *\n   * @return {SVGElement} The SVG element of the layer.\n   */\n  Canvas.prototype.getLayer = function(name, index) {\n\n    if (!name) {\n      throw new Error('must specify a name');\n    }\n\n    let layer = this._layers[name];\n\n    if (!layer) {\n      layer = this._layers[name] = this._createLayer(name, index);\n    }\n\n    // throw an error if layer creation / retrival is\n    // requested on different index\n    if (typeof index !== 'undefined' && layer.index !== index) {\n      throw new Error('layer <' + name + '> already created at index <' + index + '>');\n    }\n\n    return layer.group;\n  };\n\n  /**\n   * For a given index, return the number of layers that have a higher index and\n   * are visible.\n   *\n   * This is used to determine the node a layer should be inserted at.\n   *\n   * @param {number} index\n   *\n   * @return {number}\n   */\n  Canvas.prototype._getChildIndex = function(index) {\n    return reduce(this._layers, function(childIndex, layer) {\n      if (layer.visible && index >= layer.index) {\n        childIndex++;\n      }\n\n      return childIndex;\n    }, 0);\n  };\n\n  /**\n   * Creates a given layer and returns it.\n   *\n   * @param {string} name\n   * @param {number} [index=0]\n   *\n   * @return {CanvasLayer}\n   */\n  Canvas.prototype._createLayer = function(name, index) {\n\n    if (typeof index === 'undefined') {\n      index = UTILITY_LAYER_INDEX;\n    }\n\n    const childIndex = this._getChildIndex(index);\n\n    return {\n      group: createGroup(this._viewport, 'layer-' + name, childIndex),\n      index: index,\n      visible: true\n    };\n  };\n\n\n  /**\n   * Shows a given layer.\n   *\n   * @param {string} name The name of the layer.\n   *\n   * @return {SVGElement} The SVG element of the layer.\n   */\n  Canvas.prototype.showLayer = function(name) {\n\n    if (!name) {\n      throw new Error('must specify a name');\n    }\n\n    const layer = this._layers[name];\n\n    if (!layer) {\n      throw new Error('layer <' + name + '> does not exist');\n    }\n\n    const viewport = this._viewport;\n    const group = layer.group;\n    const index = layer.index;\n\n    if (layer.visible) {\n      return group;\n    }\n\n    const childIndex = this._getChildIndex(index);\n\n    viewport.insertBefore(group, viewport.childNodes[childIndex] || null);\n\n    layer.visible = true;\n\n    return group;\n  };\n\n  /**\n   * Hides a given layer.\n   *\n   * @param {string} name The name of the layer.\n   *\n   * @return {SVGElement} The SVG element of the layer.\n   */\n  Canvas.prototype.hideLayer = function(name) {\n\n    if (!name) {\n      throw new Error('must specify a name');\n    }\n\n    const layer = this._layers[name];\n\n    if (!layer) {\n      throw new Error('layer <' + name + '> does not exist');\n    }\n\n    const group = layer.group;\n\n    if (!layer.visible) {\n      return group;\n    }\n\n    remove$2(group);\n\n    layer.visible = false;\n\n    return group;\n  };\n\n\n  Canvas.prototype._removeLayer = function(name) {\n\n    const layer = this._layers[name];\n\n    if (layer) {\n      delete this._layers[name];\n\n      remove$2(layer.group);\n    }\n  };\n\n  /**\n   * Returns the currently active layer. Can be null.\n   *\n   * @return {CanvasLayer|null} The active layer of `null`.\n   */\n  Canvas.prototype.getActiveLayer = function() {\n    const plane = this._findPlaneForRoot(this.getRootElement());\n\n    if (!plane) {\n      return null;\n    }\n\n    return plane.layer;\n  };\n\n\n  /**\n   * Returns the plane which contains the given element.\n   *\n   * @param {ShapeLike|ConnectionLike|string} element The element or its ID.\n   *\n   * @return {RootLike|undefined} The root of the element.\n   */\n  Canvas.prototype.findRoot = function(element) {\n    if (typeof element === 'string') {\n      element = this._elementRegistry.get(element);\n    }\n\n    if (!element) {\n      return;\n    }\n\n    const plane = this._findPlaneForRoot(\n      findRoot(element)\n    ) || {};\n\n    return plane.rootElement;\n  };\n\n  /**\n   * Return a list of all root elements on the diagram.\n   *\n   * @return {(RootLike)[]} The list of root elements.\n   */\n  Canvas.prototype.getRootElements = function() {\n    return this._planes.map(function(plane) {\n      return plane.rootElement;\n    });\n  };\n\n  Canvas.prototype._findPlaneForRoot = function(rootElement) {\n    return find(this._planes, function(plane) {\n      return plane.rootElement === rootElement;\n    });\n  };\n\n\n  /**\n   * Returns the html element that encloses the\n   * drawing canvas.\n   *\n   * @return {HTMLElement} The HTML element of the container.\n   */\n  Canvas.prototype.getContainer = function() {\n    return this._container;\n  };\n\n\n  // markers //////////////////////\n\n  Canvas.prototype._updateMarker = function(element, marker, add) {\n    let container;\n\n    if (!element.id) {\n      element = this._elementRegistry.get(element);\n    }\n\n    element.markers = element.markers || new Set();\n\n    // we need to access all\n    container = this._elementRegistry._elements[element.id];\n\n    if (!container) {\n      return;\n    }\n\n    forEach$1([ container.gfx, container.secondaryGfx ], function(gfx) {\n      if (gfx) {\n\n        // invoke either addClass or removeClass based on mode\n        if (add) {\n          element.markers.add(marker);\n          classes$1(gfx).add(marker);\n        } else {\n          element.markers.delete(marker);\n          classes$1(gfx).remove(marker);\n        }\n      }\n    });\n\n    /**\n     * An event indicating that a marker has been updated for an element\n     *\n     * @event element.marker.update\n     * @type {Object}\n     * @property {Element} element the shape\n     * @property {SVGElement} gfx the graphical representation of the shape\n     * @property {string} marker\n     * @property {boolean} add true if the marker was added, false if it got removed\n     */\n    this._eventBus.fire('element.marker.update', { element: element, gfx: container.gfx, marker: marker, add: !!add });\n  };\n\n\n  /**\n   * Adds a marker to an element (basically a css class).\n   *\n   * Fires the element.marker.update event, making it possible to\n   * integrate extension into the marker life-cycle, too.\n   *\n   * @example\n   *\n   * ```javascript\n   * canvas.addMarker('foo', 'some-marker');\n   *\n   * const fooGfx = canvas.getGraphics('foo');\n   *\n   * fooGfx; // <g class=\"... some-marker\"> ... </g>\n   * ```\n   *\n   * @param {ShapeLike|ConnectionLike|string} element The element or its ID.\n   * @param {string} marker The marker.\n   */\n  Canvas.prototype.addMarker = function(element, marker) {\n    this._updateMarker(element, marker, true);\n  };\n\n\n  /**\n   * Remove a marker from an element.\n   *\n   * Fires the element.marker.update event, making it possible to\n   * integrate extension into the marker life-cycle, too.\n   *\n   * @param {ShapeLike|ConnectionLike|string} element The element or its ID.\n   * @param {string} marker The marker.\n   */\n  Canvas.prototype.removeMarker = function(element, marker) {\n    this._updateMarker(element, marker, false);\n  };\n\n  /**\n   * Check whether an element has a given marker.\n   *\n   * @param {ShapeLike|ConnectionLike|string} element The element or its ID.\n   * @param {string} marker The marker.\n   */\n  Canvas.prototype.hasMarker = function(element, marker) {\n    if (!element.id) {\n      element = this._elementRegistry.get(element);\n    }\n\n    if (!element.markers) {\n      return false;\n    }\n\n    return element.markers.has(marker);\n  };\n\n  /**\n   * Toggles a marker on an element.\n   *\n   * Fires the element.marker.update event, making it possible to\n   * integrate extension into the marker life-cycle, too.\n   *\n   * @param {ShapeLike|ConnectionLike|string} element The element or its ID.\n   * @param {string} marker The marker.\n   */\n  Canvas.prototype.toggleMarker = function(element, marker) {\n    if (this.hasMarker(element, marker)) {\n      this.removeMarker(element, marker);\n    } else {\n      this.addMarker(element, marker);\n    }\n  };\n\n  /**\n   * Returns the current root element.\n   *\n   * Supports two different modes for handling root elements:\n   *\n   * 1. if no root element has been added before, an implicit root will be added\n   * and returned. This is used in applications that don't require explicit\n   * root elements.\n   *\n   * 2. when root elements have been added before calling `getRootElement`,\n   * root elements can be null. This is used for applications that want to manage\n   * root elements themselves.\n   *\n   * @return {RootLike} The current root element.\n   */\n  Canvas.prototype.getRootElement = function() {\n    const rootElement = this._rootElement;\n\n    // can return null if root elements are present but none was set yet\n    if (rootElement || this._planes.length) {\n      return rootElement;\n    }\n\n    return this.setRootElement(this.addRootElement(null));\n  };\n\n  /**\n   * Adds a given root element and returns it.\n   *\n   * @param {RootLike} [rootElement] The root element to be added.\n   *\n   * @return {RootLike} The added root element or an implicit root element.\n   */\n  Canvas.prototype.addRootElement = function(rootElement) {\n    const idx = this._rootsIdx++;\n\n    if (!rootElement) {\n      rootElement = {\n        id: '__implicitroot_' + idx,\n        children: [],\n        isImplicit: true\n      };\n    }\n\n    const layerName = rootElement.layer = 'root-' + idx;\n\n    this._ensureValid('root', rootElement);\n\n    const layer = this.getLayer(layerName, PLANE_LAYER_INDEX);\n\n    this.hideLayer(layerName);\n\n    this._addRoot(rootElement, layer);\n\n    this._planes.push({\n      rootElement: rootElement,\n      layer: layer\n    });\n\n    return rootElement;\n  };\n\n  /**\n   * Removes a given root element and returns it.\n   *\n   * @param {RootLike|string} rootElement element or element ID\n   *\n   * @return {RootLike|undefined} removed element\n   */\n  Canvas.prototype.removeRootElement = function(rootElement) {\n\n    if (typeof rootElement === 'string') {\n      rootElement = this._elementRegistry.get(rootElement);\n    }\n\n    const plane = this._findPlaneForRoot(rootElement);\n\n    if (!plane) {\n      return;\n    }\n\n    // hook up life-cycle events\n    this._removeRoot(rootElement);\n\n    // clean up layer\n    this._removeLayer(rootElement.layer);\n\n    // clean up plane\n    this._planes = this._planes.filter(function(plane) {\n      return plane.rootElement !== rootElement;\n    });\n\n    // clean up active root\n    if (this._rootElement === rootElement) {\n      this._rootElement = null;\n    }\n\n    return rootElement;\n  };\n\n\n  /**\n   * Sets a given element as the new root element for the canvas\n   * and returns the new root element.\n   *\n   * @param {RootLike} rootElement The root element to be set.\n   *\n   * @return {RootLike} The set root element.\n   */\n  Canvas.prototype.setRootElement = function(rootElement) {\n\n    if (rootElement === this._rootElement) {\n      return rootElement;\n    }\n\n    let plane;\n\n    if (!rootElement) {\n      throw new Error('rootElement required');\n    }\n\n    plane = this._findPlaneForRoot(rootElement);\n\n    // give set add semantics for backwards compatibility\n    if (!plane) {\n      rootElement = this.addRootElement(rootElement);\n    }\n\n    this._setRoot(rootElement);\n\n    return rootElement;\n  };\n\n\n  Canvas.prototype._removeRoot = function(element) {\n    const elementRegistry = this._elementRegistry,\n          eventBus = this._eventBus;\n\n    // simulate element remove event sequence\n    eventBus.fire('root.remove', { element: element });\n    eventBus.fire('root.removed', { element: element });\n\n    elementRegistry.remove(element);\n  };\n\n\n  Canvas.prototype._addRoot = function(element, gfx) {\n    const elementRegistry = this._elementRegistry,\n          eventBus = this._eventBus;\n\n    // resemble element add event sequence\n    eventBus.fire('root.add', { element: element });\n\n    elementRegistry.add(element, gfx);\n\n    eventBus.fire('root.added', { element: element, gfx: gfx });\n  };\n\n\n  Canvas.prototype._setRoot = function(rootElement, layer) {\n\n    const currentRoot = this._rootElement;\n\n    if (currentRoot) {\n\n      // un-associate previous root element <svg>\n      this._elementRegistry.updateGraphics(currentRoot, null, true);\n\n      // hide previous layer\n      this.hideLayer(currentRoot.layer);\n    }\n\n    if (rootElement) {\n\n      if (!layer) {\n        layer = this._findPlaneForRoot(rootElement).layer;\n      }\n\n      // associate element with <svg>\n      this._elementRegistry.updateGraphics(rootElement, this._svg, true);\n\n      // show root layer\n      this.showLayer(rootElement.layer);\n    }\n\n    this._rootElement = rootElement;\n\n    this._eventBus.fire('root.set', { element: rootElement });\n  };\n\n  Canvas.prototype._ensureValid = function(type, element) {\n    if (!element.id) {\n      throw new Error('element must have an id');\n    }\n\n    if (this._elementRegistry.get(element.id)) {\n      throw new Error('element <' + element.id + '> already exists');\n    }\n\n    const requiredAttrs = REQUIRED_MODEL_ATTRS[type];\n\n    const valid = every(requiredAttrs, function(attr) {\n      return typeof element[attr] !== 'undefined';\n    });\n\n    if (!valid) {\n      throw new Error(\n        'must supply { ' + requiredAttrs.join(', ') + ' } with ' + type);\n    }\n  };\n\n  Canvas.prototype._setParent = function(element, parent, parentIndex) {\n    add(parent.children, element, parentIndex);\n    element.parent = parent;\n  };\n\n  /**\n   * Adds an element to the canvas.\n   *\n   * This wires the parent <-> child relationship between the element and\n   * a explicitly specified parent or an implicit root element.\n   *\n   * During add it emits the events\n   *\n   *  * <{type}.add> (element, parent)\n   *  * <{type}.added> (element, gfx)\n   *\n   * Extensions may hook into these events to perform their magic.\n   *\n   * @param {string} type\n   * @param {ConnectionLike|ShapeLike} element\n   * @param {ShapeLike} [parent]\n   * @param {number} [parentIndex]\n   *\n   * @return {ConnectionLike|ShapeLike} The added element.\n   */\n  Canvas.prototype._addElement = function(type, element, parent, parentIndex) {\n\n    parent = parent || this.getRootElement();\n\n    const eventBus = this._eventBus,\n          graphicsFactory = this._graphicsFactory;\n\n    this._ensureValid(type, element);\n\n    eventBus.fire(type + '.add', { element: element, parent: parent });\n\n    this._setParent(element, parent, parentIndex);\n\n    // create graphics\n    const gfx = graphicsFactory.create(type, element, parentIndex);\n\n    this._elementRegistry.add(element, gfx);\n\n    // update its visual\n    graphicsFactory.update(type, element, gfx);\n\n    eventBus.fire(type + '.added', { element: element, gfx: gfx });\n\n    return element;\n  };\n\n  /**\n   * Adds a shape to the canvas.\n   *\n   * @param {ShapeLike} shape The shape to be added\n   * @param {ParentLike} [parent] The shape's parent.\n   * @param {number} [parentIndex] The index at which to add the shape to the parent's children.\n   *\n   * @return {ShapeLike} The added shape.\n   */\n  Canvas.prototype.addShape = function(shape, parent, parentIndex) {\n    return this._addElement('shape', shape, parent, parentIndex);\n  };\n\n  /**\n   * Adds a connection to the canvas.\n   *\n   * @param {ConnectionLike} connection The connection to be added.\n   * @param {ParentLike} [parent] The connection's parent.\n   * @param {number} [parentIndex] The index at which to add the connection to the parent's children.\n   *\n   * @return {ConnectionLike} The added connection.\n   */\n  Canvas.prototype.addConnection = function(connection, parent, parentIndex) {\n    return this._addElement('connection', connection, parent, parentIndex);\n  };\n\n\n  /**\n   * Internal remove element\n   */\n  Canvas.prototype._removeElement = function(element, type) {\n\n    const elementRegistry = this._elementRegistry,\n          graphicsFactory = this._graphicsFactory,\n          eventBus = this._eventBus;\n\n    element = elementRegistry.get(element.id || element);\n\n    if (!element) {\n\n      // element was removed already\n      return;\n    }\n\n    eventBus.fire(type + '.remove', { element: element });\n\n    graphicsFactory.remove(element);\n\n    // unset parent <-> child relationship\n    remove(element.parent && element.parent.children, element);\n    element.parent = null;\n\n    eventBus.fire(type + '.removed', { element: element });\n\n    elementRegistry.remove(element);\n\n    return element;\n  };\n\n\n  /**\n   * Removes a shape from the canvas.\n   *\n   * @fires ShapeRemoveEvent\n   * @fires ShapeRemovedEvent\n   *\n   * @param {ShapeLike|string} shape The shape or its ID.\n   *\n   * @return {ShapeLike} The removed shape.\n   */\n  Canvas.prototype.removeShape = function(shape) {\n\n    /**\n     * An event indicating that a shape is about to be removed from the canvas.\n     *\n     * @memberOf Canvas\n     *\n     * @event ShapeRemoveEvent\n     * @type {Object}\n     * @property {ShapeLike} element The shape.\n     * @property {SVGElement} gfx The graphical element.\n     */\n\n    /**\n     * An event indicating that a shape has been removed from the canvas.\n     *\n     * @memberOf Canvas\n     *\n     * @event ShapeRemovedEvent\n     * @type {Object}\n     * @property {ShapeLike} element The shape.\n     * @property {SVGElement} gfx The graphical element.\n     */\n    return this._removeElement(shape, 'shape');\n  };\n\n\n  /**\n   * Removes a connection from the canvas.\n   *\n   * @fires ConnectionRemoveEvent\n   * @fires ConnectionRemovedEvent\n   *\n   * @param {ConnectionLike|string} connection The connection or its ID.\n   *\n   * @return {ConnectionLike} The removed connection.\n   */\n  Canvas.prototype.removeConnection = function(connection) {\n\n    /**\n     * An event indicating that a connection is about to be removed from the canvas.\n     *\n     * @memberOf Canvas\n     *\n     * @event ConnectionRemoveEvent\n     * @type {Object}\n     * @property {ConnectionLike} element The connection.\n     * @property {SVGElement} gfx The graphical element.\n     */\n\n    /**\n     * An event indicating that a connection has been removed from the canvas.\n     *\n     * @memberOf Canvas\n     *\n     * @event ConnectionRemovedEvent\n     * @type {Object}\n     * @property {ConnectionLike} element The connection.\n     * @property {SVGElement} gfx The graphical element.\n     */\n    return this._removeElement(connection, 'connection');\n  };\n\n\n  /**\n   * Returns the graphical element of an element.\n   *\n   * @param {ShapeLike|ConnectionLike|string} element The element or its ID.\n   * @param {boolean} [secondary=false] Whether to return the secondary graphical element.\n   *\n   * @return {SVGElement} The graphical element.\n   */\n  Canvas.prototype.getGraphics = function(element, secondary) {\n    return this._elementRegistry.getGraphics(element, secondary);\n  };\n\n\n  /**\n   * Perform a viewbox update via a given change function.\n   *\n   * @param {Function} changeFn\n   */\n  Canvas.prototype._changeViewbox = function(changeFn) {\n\n    // notify others of the upcoming viewbox change\n    this._eventBus.fire('canvas.viewbox.changing');\n\n    // perform actual change\n    changeFn.apply(this);\n\n    // reset the cached viewbox so that\n    // a new get operation on viewbox or zoom\n    // triggers a viewbox re-computation\n    this._cachedViewbox = null;\n\n    // notify others of the change; this step\n    // may or may not be debounced\n    this._viewboxChanged();\n  };\n\n  Canvas.prototype._viewboxChanged = function() {\n    this._eventBus.fire('canvas.viewbox.changed', { viewbox: this.viewbox() });\n  };\n\n\n  /**\n   * Gets or sets the view box of the canvas, i.e. the\n   * area that is currently displayed.\n   *\n   * The getter may return a cached viewbox (if it is currently\n   * changing). To force a recomputation, pass `false` as the first argument.\n   *\n   * @example\n   *\n   * ```javascript\n   * canvas.viewbox({ x: 100, y: 100, width: 500, height: 500 })\n   *\n   * // sets the visible area of the diagram to (100|100) -> (600|100)\n   * // and and scales it according to the diagram width\n   *\n   * const viewbox = canvas.viewbox(); // pass `false` to force recomputing the box.\n   *\n   * console.log(viewbox);\n   * // {\n   * //   inner: Dimensions,\n   * //   outer: Dimensions,\n   * //   scale,\n   * //   x, y,\n   * //   width, height\n   * // }\n   *\n   * // if the current diagram is zoomed and scrolled, you may reset it to the\n   * // default zoom via this method, too:\n   *\n   * const zoomedAndScrolledViewbox = canvas.viewbox();\n   *\n   * canvas.viewbox({\n   *   x: 0,\n   *   y: 0,\n   *   width: zoomedAndScrolledViewbox.outer.width,\n   *   height: zoomedAndScrolledViewbox.outer.height\n   * });\n   * ```\n   *\n   * @param {Rect} [box] The viewbox to be set.\n   *\n   * @return {CanvasViewbox} The set viewbox.\n   */\n  Canvas.prototype.viewbox = function(box) {\n\n    if (box === undefined && this._cachedViewbox) {\n      return structuredClone(this._cachedViewbox);\n    }\n\n    const viewport = this._viewport,\n          outerBox = this.getSize();\n    let innerBox,\n        matrix,\n        activeLayer,\n        transform,\n        scale,\n        x, y;\n\n    if (!box) {\n\n      // compute the inner box based on the\n      // diagrams active layer. This allows us to exclude\n      // external components, such as overlays\n\n      activeLayer = this._rootElement ? this.getActiveLayer() : null;\n      innerBox = activeLayer && activeLayer.getBBox() || {};\n\n      transform = transform$1(viewport);\n      matrix = transform ? transform.matrix : createMatrix();\n      scale = round(matrix.a, 1000);\n\n      x = round(-matrix.e || 0, 1000);\n      y = round(-matrix.f || 0, 1000);\n\n      box = this._cachedViewbox = {\n        x: x ? x / scale : 0,\n        y: y ? y / scale : 0,\n        width: outerBox.width / scale,\n        height: outerBox.height / scale,\n        scale: scale,\n        inner: {\n          width: innerBox.width || 0,\n          height: innerBox.height || 0,\n          x: innerBox.x || 0,\n          y: innerBox.y || 0\n        },\n        outer: outerBox\n      };\n\n      return box;\n    } else {\n\n      this._changeViewbox(function() {\n        scale = Math.min(outerBox.width / box.width, outerBox.height / box.height);\n\n        const matrix = this._svg.createSVGMatrix()\n          .scale(scale)\n          .translate(-box.x, -box.y);\n\n        transform$1(viewport, matrix);\n      });\n    }\n\n    return box;\n  };\n\n\n  /**\n   * Gets or sets the scroll of the canvas.\n   *\n   * @param {ScrollDelta} [delta] The scroll to be set.\n   *\n   * @return {Point}\n   */\n  Canvas.prototype.scroll = function(delta) {\n\n    const node = this._viewport;\n    let matrix = node.getCTM();\n\n    if (delta) {\n      this._changeViewbox(function() {\n        delta = assign$1({ dx: 0, dy: 0 }, delta || {});\n\n        matrix = this._svg.createSVGMatrix().translate(delta.dx, delta.dy).multiply(matrix);\n\n        setCTM(node, matrix);\n      });\n    }\n\n    return { x: matrix.e, y: matrix.f };\n  };\n\n  /**\n   * Scrolls the viewbox to contain the given element.\n   * Optionally specify a padding to be applied to the edges.\n   *\n   * @param {ShapeLike|ConnectionLike|string} element The element to scroll to or its ID.\n   * @param {RectTRBL|number} [padding=100] The padding to be applied. Can also specify top, bottom, left and right.\n   */\n  Canvas.prototype.scrollToElement = function(element, padding) {\n    let defaultPadding = 100;\n\n    if (typeof element === 'string') {\n      element = this._elementRegistry.get(element);\n    }\n\n    // set to correct rootElement\n    const rootElement = this.findRoot(element);\n\n    if (rootElement !== this.getRootElement()) {\n      this.setRootElement(rootElement);\n    }\n\n    // element is rootElement, do not change viewport\n    if (rootElement === element) {\n      return;\n    }\n\n    if (!padding) {\n      padding = {};\n    }\n    if (typeof padding === 'number') {\n      defaultPadding = padding;\n    }\n\n    padding = {\n      top: padding.top || defaultPadding,\n      right: padding.right || defaultPadding,\n      bottom: padding.bottom || defaultPadding,\n      left: padding.left || defaultPadding\n    };\n\n    const elementBounds = getBBox(element),\n          elementTrbl = asTRBL(elementBounds),\n          viewboxBounds = this.viewbox(),\n          zoom = this.zoom();\n    let dx, dy;\n\n    // shrink viewboxBounds with padding\n    viewboxBounds.y += padding.top / zoom;\n    viewboxBounds.x += padding.left / zoom;\n    viewboxBounds.width -= (padding.right + padding.left) / zoom;\n    viewboxBounds.height -= (padding.bottom + padding.top) / zoom;\n\n    const viewboxTrbl = asTRBL(viewboxBounds);\n\n    const canFit = elementBounds.width < viewboxBounds.width && elementBounds.height < viewboxBounds.height;\n\n    if (!canFit) {\n\n      // top-left when element can't fit\n      dx = elementBounds.x - viewboxBounds.x;\n      dy = elementBounds.y - viewboxBounds.y;\n\n    } else {\n\n      const dRight = Math.max(0, elementTrbl.right - viewboxTrbl.right),\n            dLeft = Math.min(0, elementTrbl.left - viewboxTrbl.left),\n            dBottom = Math.max(0, elementTrbl.bottom - viewboxTrbl.bottom),\n            dTop = Math.min(0, elementTrbl.top - viewboxTrbl.top);\n\n      dx = dRight || dLeft;\n      dy = dBottom || dTop;\n\n    }\n\n    this.scroll({ dx: -dx * zoom, dy: -dy * zoom });\n  };\n\n  /**\n   * Gets or sets the current zoom of the canvas, optionally zooming to the\n   * specified position.\n   *\n   * The getter may return a cached zoom level. Call it with `false` as the first\n   * argument to force recomputation of the current level.\n   *\n   * @param {number|'fit-viewport'} [newScale] The new zoom level, either a number,\n   * i.e. 0.9, or `fit-viewport` to adjust the size to fit the current viewport.\n   * @param {Point} [center] The reference point { x: ..., y: ...} to zoom to.\n   *\n   * @return {number} The set zoom level.\n   */\n  Canvas.prototype.zoom = function(newScale, center) {\n\n    if (!newScale) {\n      return this.viewbox(newScale).scale;\n    }\n\n    if (newScale === 'fit-viewport') {\n      return this._fitViewport(center);\n    }\n\n    let outer,\n        matrix;\n\n    this._changeViewbox(function() {\n\n      if (typeof center !== 'object') {\n        outer = this.viewbox().outer;\n\n        center = {\n          x: outer.width / 2,\n          y: outer.height / 2\n        };\n      }\n\n      matrix = this._setZoom(newScale, center);\n    });\n\n    return round(matrix.a, 1000);\n  };\n\n  function setCTM(node, m) {\n    const mstr = 'matrix(' + m.a + ',' + m.b + ',' + m.c + ',' + m.d + ',' + m.e + ',' + m.f + ')';\n    node.setAttribute('transform', mstr);\n  }\n\n  Canvas.prototype._fitViewport = function(center) {\n\n    const vbox = this.viewbox(),\n          outer = vbox.outer,\n          inner = vbox.inner;\n    let newScale,\n        newViewbox;\n\n    // display the complete diagram without zooming in.\n    // instead of relying on internal zoom, we perform a\n    // hard reset on the canvas viewbox to realize this\n    //\n    // if diagram does not need to be zoomed in, we focus it around\n    // the diagram origin instead\n\n    if (inner.x >= 0 &&\n        inner.y >= 0 &&\n        inner.x + inner.width <= outer.width &&\n        inner.y + inner.height <= outer.height &&\n        !center) {\n\n      newViewbox = {\n        x: 0,\n        y: 0,\n        width: Math.max(inner.width + inner.x, outer.width),\n        height: Math.max(inner.height + inner.y, outer.height)\n      };\n    } else {\n\n      newScale = Math.min(1, outer.width / inner.width, outer.height / inner.height);\n      newViewbox = {\n        x: inner.x + (center ? inner.width / 2 - outer.width / newScale / 2 : 0),\n        y: inner.y + (center ? inner.height / 2 - outer.height / newScale / 2 : 0),\n        width: outer.width / newScale,\n        height: outer.height / newScale\n      };\n    }\n\n    this.viewbox(newViewbox);\n\n    return this.viewbox(false).scale;\n  };\n\n\n  Canvas.prototype._setZoom = function(scale, center) {\n\n    const svg = this._svg,\n          viewport = this._viewport;\n\n    const matrix = svg.createSVGMatrix();\n    const point = svg.createSVGPoint();\n\n    let centerPoint,\n        originalPoint,\n        currentMatrix,\n        scaleMatrix,\n        newMatrix;\n\n    currentMatrix = viewport.getCTM();\n\n    const currentScale = currentMatrix.a;\n\n    if (center) {\n      centerPoint = assign$1(point, center);\n\n      // revert applied viewport transformations\n      originalPoint = centerPoint.matrixTransform(currentMatrix.inverse());\n\n      // create scale matrix\n      scaleMatrix = matrix\n        .translate(originalPoint.x, originalPoint.y)\n        .scale(1 / currentScale * scale)\n        .translate(-originalPoint.x, -originalPoint.y);\n\n      newMatrix = currentMatrix.multiply(scaleMatrix);\n    } else {\n      newMatrix = matrix.scale(scale);\n    }\n\n    setCTM(this._viewport, newMatrix);\n\n    return newMatrix;\n  };\n\n\n  /**\n   * Returns the size of the canvas.\n   *\n   * @return {Dimensions} The size of the canvas.\n   */\n  Canvas.prototype.getSize = function() {\n    return {\n      width: this._container.clientWidth,\n      height: this._container.clientHeight\n    };\n  };\n\n\n  /**\n   * Returns the absolute bounding box of an element.\n   *\n   * The absolute bounding box may be used to display overlays in the callers\n   * (browser) coordinate system rather than the zoomed in/out canvas coordinates.\n   *\n   * @param {ShapeLike|ConnectionLike} element The element.\n   *\n   * @return {Rect} The element's absolute bounding box.\n   */\n  Canvas.prototype.getAbsoluteBBox = function(element) {\n    const vbox = this.viewbox();\n    let bbox;\n\n    // connection\n    // use svg bbox\n    if (element.waypoints) {\n      const gfx = this.getGraphics(element);\n\n      bbox = gfx.getBBox();\n    }\n\n    // shapes\n    // use data\n    else {\n      bbox = element;\n    }\n\n    const x = bbox.x * vbox.scale - vbox.x * vbox.scale;\n    const y = bbox.y * vbox.scale - vbox.y * vbox.scale;\n\n    const width = bbox.width * vbox.scale;\n    const height = bbox.height * vbox.scale;\n\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  };\n\n  /**\n   * Fires an event so other modules can react to the canvas resizing.\n   */\n  Canvas.prototype.resized = function() {\n\n    // force recomputation of view box\n    delete this._cachedViewbox;\n\n    this._eventBus.fire('canvas.resized');\n  };\n\n  var ELEMENT_ID = 'data-element-id';\n\n  /**\n   * @typedef {import('./Types').ElementLike} ElementLike\n   *\n   * @typedef {import('./EventBus').default} EventBus\n   *\n   * @typedef { (element: ElementLike, gfx: SVGElement) => boolean|any } ElementRegistryFilterCallback\n   * @typedef { (element: ElementLike, gfx: SVGElement) => any } ElementRegistryForEachCallback\n   */\n\n  /**\n   * A registry that keeps track of all shapes in the diagram.\n   *\n   * @class\n   * @constructor\n   *\n   * @param {EventBus} eventBus\n   */\n  function ElementRegistry(eventBus) {\n\n    /**\n     * @type { {\n     *   [id: string]: {\n     *     element: ElementLike;\n     *     gfx?: SVGElement;\n     *     secondaryGfx?: SVGElement;\n     *   }\n     * } }\n     */\n    this._elements = {};\n\n    this._eventBus = eventBus;\n  }\n\n  ElementRegistry.$inject = [ 'eventBus' ];\n\n  /**\n   * Add an element and its graphical representation(s) to the registry.\n   *\n   * @param {ElementLike} element The element to be added.\n   * @param {SVGElement} gfx The primary graphical representation.\n   * @param {SVGElement} [secondaryGfx] The secondary graphical representation.\n   */\n  ElementRegistry.prototype.add = function(element, gfx, secondaryGfx) {\n\n    var id = element.id;\n\n    this._validateId(id);\n\n    // associate dom node with element\n    attr$1(gfx, ELEMENT_ID, id);\n\n    if (secondaryGfx) {\n      attr$1(secondaryGfx, ELEMENT_ID, id);\n    }\n\n    this._elements[id] = { element: element, gfx: gfx, secondaryGfx: secondaryGfx };\n  };\n\n  /**\n   * Remove an element from the registry.\n   *\n   * @param {ElementLike|string} element\n   */\n  ElementRegistry.prototype.remove = function(element) {\n    var elements = this._elements,\n        id = element.id || element,\n        container = id && elements[id];\n\n    if (container) {\n\n      // unset element id on gfx\n      attr$1(container.gfx, ELEMENT_ID, '');\n\n      if (container.secondaryGfx) {\n        attr$1(container.secondaryGfx, ELEMENT_ID, '');\n      }\n\n      delete elements[id];\n    }\n  };\n\n  /**\n   * Update an elements ID.\n   *\n   * @param {ElementLike|string} element The element or its ID.\n   * @param {string} newId The new ID.\n   */\n  ElementRegistry.prototype.updateId = function(element, newId) {\n\n    this._validateId(newId);\n\n    if (typeof element === 'string') {\n      element = this.get(element);\n    }\n\n    this._eventBus.fire('element.updateId', {\n      element: element,\n      newId: newId\n    });\n\n    var gfx = this.getGraphics(element),\n        secondaryGfx = this.getGraphics(element, true);\n\n    this.remove(element);\n\n    element.id = newId;\n\n    this.add(element, gfx, secondaryGfx);\n  };\n\n  /**\n   * Update the graphical representation of an element.\n   *\n   * @param {ElementLike|string} filter The element or its ID.\n   * @param {SVGElement} gfx The new graphical representation.\n   * @param {boolean} [secondary=false] Whether to update the secondary graphical representation.\n   */\n  ElementRegistry.prototype.updateGraphics = function(filter, gfx, secondary) {\n    var id = filter.id || filter;\n\n    var container = this._elements[id];\n\n    if (secondary) {\n      container.secondaryGfx = gfx;\n    } else {\n      container.gfx = gfx;\n    }\n\n    if (gfx) {\n      attr$1(gfx, ELEMENT_ID, id);\n    }\n\n    return gfx;\n  };\n\n  /**\n   * Get the element with the given ID or graphical representation.\n   *\n   * @example\n   *\n   * ```javascript\n   * elementRegistry.get('SomeElementId_1');\n   *\n   * elementRegistry.get(gfx);\n   * ```\n   *\n   * @param {string|SVGElement} filter The elements ID or graphical representation.\n   *\n   * @return {ElementLike|undefined} The element.\n   */\n  ElementRegistry.prototype.get = function(filter) {\n    var id;\n\n    if (typeof filter === 'string') {\n      id = filter;\n    } else {\n      id = filter && attr$1(filter, ELEMENT_ID);\n    }\n\n    var container = this._elements[id];\n    return container && container.element;\n  };\n\n  /**\n   * Return all elements that match a given filter function.\n   *\n   * @param {ElementRegistryFilterCallback} fn The filter function.\n   *\n   * @return {ElementLike[]} The matching elements.\n   */\n  ElementRegistry.prototype.filter = function(fn) {\n\n    var filtered = [];\n\n    this.forEach(function(element, gfx) {\n      if (fn(element, gfx)) {\n        filtered.push(element);\n      }\n    });\n\n    return filtered;\n  };\n\n  /**\n   * Return the first element that matches the given filter function.\n   *\n   * @param {ElementRegistryFilterCallback} fn The filter function.\n   *\n   * @return {ElementLike|undefined} The matching element.\n   */\n  ElementRegistry.prototype.find = function(fn) {\n    var map = this._elements,\n        keys = Object.keys(map);\n\n    for (var i = 0; i < keys.length; i++) {\n      var id = keys[i],\n          container = map[id],\n          element = container.element,\n          gfx = container.gfx;\n\n      if (fn(element, gfx)) {\n        return element;\n      }\n    }\n  };\n\n  /**\n   * Get all elements.\n   *\n   * @return {ElementLike[]} All elements.\n   */\n  ElementRegistry.prototype.getAll = function() {\n    return this.filter(function(e) { return e; });\n  };\n\n  /**\n   * Execute a given function for each element.\n   *\n   * @param {ElementRegistryForEachCallback} fn The function to execute.\n   */\n  ElementRegistry.prototype.forEach = function(fn) {\n\n    var map = this._elements;\n\n    Object.keys(map).forEach(function(id) {\n      var container = map[id],\n          element = container.element,\n          gfx = container.gfx;\n\n      return fn(element, gfx);\n    });\n  };\n\n  /**\n   * Return the graphical representation of an element.\n   *\n   * @example\n   *\n   * ```javascript\n   * elementRegistry.getGraphics('SomeElementId_1');\n   *\n   * elementRegistry.getGraphics(rootElement); // <g ...>\n   *\n   * elementRegistry.getGraphics(rootElement, true); // <svg ...>\n   * ```\n   *\n   * @param {ElementLike|string} filter The element or its ID.\n   * @param {boolean} [secondary=false] Whether to return the secondary graphical representation.\n   *\n   * @return {SVGElement} The graphical representation.\n   */\n  ElementRegistry.prototype.getGraphics = function(filter, secondary) {\n    var id = filter.id || filter;\n\n    var container = this._elements[id];\n    return container && (secondary ? container.secondaryGfx : container.gfx);\n  };\n\n  /**\n   * Validate an ID and throw an error if invalid.\n   *\n   * @param {string} id\n   *\n   * @throws {Error} Error indicating that the ID is invalid or already assigned.\n   */\n  ElementRegistry.prototype._validateId = function(id) {\n    if (!id) {\n      throw new Error('element must have an id');\n    }\n\n    if (this._elements[id]) {\n      throw new Error('element with id ' + id + ' already added');\n    }\n  };\n\n  /**\n   * Extends a collection with {@link Refs} aware methods\n   *\n   * @param {Array<Object>} collection\n   * @param {Refs} refs instance\n   * @param {Object} property represented by the collection\n   * @param {Object} target object the collection is attached to\n   *\n   * @return {RefsCollection<Object>} the extended array\n   */\n  function extend(collection, refs, property, target) {\n    var inverseProperty = property.inverse;\n\n    /**\n     * Removes the given element from the array and returns it.\n     *\n     * @method RefsCollection#remove\n     *\n     * @param {Object} element the element to remove\n     */\n    Object.defineProperty(collection, 'remove', {\n      value: function (element) {\n        var idx = this.indexOf(element);\n        if (idx !== -1) {\n          this.splice(idx, 1);\n\n          // unset inverse\n          refs.unset(element, inverseProperty, target);\n        }\n        return element;\n      }\n    });\n\n    /**\n     * Returns true if the collection contains the given element\n     *\n     * @method RefsCollection#contains\n     *\n     * @param {Object} element the element to check for\n     */\n    Object.defineProperty(collection, 'contains', {\n      value: function (element) {\n        return this.indexOf(element) !== -1;\n      }\n    });\n\n    /**\n     * Adds an element to the array, unless it exists already (set semantics).\n     *\n     * @method RefsCollection#add\n     *\n     * @param {Object} element the element to add\n     * @param {Number} optional index to add element to\n     *                 (possibly moving other elements around)\n     */\n    Object.defineProperty(collection, 'add', {\n      value: function (element, idx) {\n        var currentIdx = this.indexOf(element);\n        if (typeof idx === 'undefined') {\n          if (currentIdx !== -1) {\n            // element already in collection (!)\n            return;\n          }\n\n          // add to end of array, as no idx is specified\n          idx = this.length;\n        }\n\n        // handle already in collection\n        if (currentIdx !== -1) {\n          // remove element from currentIdx\n          this.splice(currentIdx, 1);\n        }\n\n        // add element at idx\n        this.splice(idx, 0, element);\n        if (currentIdx === -1) {\n          // set inverse, unless element was\n          // in collection already\n          refs.set(element, inverseProperty, target);\n        }\n      }\n    });\n\n    // a simple marker, identifying this element\n    // as being a refs collection\n    Object.defineProperty(collection, '__refs_collection', {\n      value: true\n    });\n    return collection;\n  }\n\n  /**\n   * Checks if a given collection is extended\n   *\n   * @param {Array<Object>} collection\n   *\n   * @return {boolean}\n   */\n  function isExtended(collection) {\n    return collection.__refs_collection === true;\n  }\n\n  function hasOwnProperty$1(e, property) {\n    return Object.prototype.hasOwnProperty.call(e, property.name || property);\n  }\n  function defineCollectionProperty(ref, property, target) {\n    var collection = extend(target[property.name] || [], ref, property, target);\n    Object.defineProperty(target, property.name, {\n      enumerable: property.enumerable,\n      value: collection\n    });\n    if (collection.length) {\n      collection.forEach(function (o) {\n        ref.set(o, property.inverse, target);\n      });\n    }\n  }\n  function defineProperty$1(ref, property, target) {\n    var inverseProperty = property.inverse;\n    var _value = target[property.name];\n    Object.defineProperty(target, property.name, {\n      configurable: property.configurable,\n      enumerable: property.enumerable,\n      get: function () {\n        return _value;\n      },\n      set: function (value) {\n        // return if we already performed all changes\n        if (value === _value) {\n          return;\n        }\n        var old = _value;\n\n        // temporary set null\n        _value = null;\n        if (old) {\n          ref.unset(old, inverseProperty, target);\n        }\n\n        // set new value\n        _value = value;\n\n        // set inverse value\n        ref.set(_value, inverseProperty, target);\n      }\n    });\n  }\n\n  /**\n   * Creates a new references object defining two inversly related\n   * attribute descriptors a and b.\n   *\n   * <p>\n   *   When bound to an object using {@link Refs#bind} the references\n   *   get activated and ensure that add and remove operations are applied\n   *   reversely, too.\n   * </p>\n   *\n   * <p>\n   *   For attributes represented as collections {@link Refs} provides the\n   *   {@link RefsCollection#add}, {@link RefsCollection#remove} and {@link RefsCollection#contains} extensions\n   *   that must be used to properly hook into the inverse change mechanism.\n   * </p>\n   *\n   * @class Refs\n   *\n   * @classdesc A bi-directional reference between two attributes.\n   *\n   * @param {Refs.AttributeDescriptor} a property descriptor\n   * @param {Refs.AttributeDescriptor} b property descriptor\n   *\n   * @example\n   *\n   * var refs = Refs({ name: 'wheels', collection: true, enumerable: true }, { name: 'car' });\n   *\n   * var car = { name: 'toyota' };\n   * var wheels = [{ pos: 'front-left' }, { pos: 'front-right' }];\n   *\n   * refs.bind(car, 'wheels');\n   *\n   * car.wheels // []\n   * car.wheels.add(wheels[0]);\n   * car.wheels.add(wheels[1]);\n   *\n   * car.wheels // [{ pos: 'front-left' }, { pos: 'front-right' }]\n   *\n   * wheels[0].car // { name: 'toyota' };\n   * car.wheels.remove(wheels[0]);\n   *\n   * wheels[0].car // undefined\n   */\n  function Refs(a, b) {\n    if (!(this instanceof Refs)) {\n      return new Refs(a, b);\n    }\n\n    // link\n    a.inverse = b;\n    b.inverse = a;\n    this.props = {};\n    this.props[a.name] = a;\n    this.props[b.name] = b;\n  }\n\n  /**\n   * Binds one side of a bi-directional reference to a\n   * target object.\n   *\n   * @memberOf Refs\n   *\n   * @param  {Object} target\n   * @param  {String} property\n   */\n  Refs.prototype.bind = function (target, property) {\n    if (typeof property === 'string') {\n      if (!this.props[property]) {\n        throw new Error('no property <' + property + '> in ref');\n      }\n      property = this.props[property];\n    }\n    if (property.collection) {\n      defineCollectionProperty(this, property, target);\n    } else {\n      defineProperty$1(this, property, target);\n    }\n  };\n  Refs.prototype.ensureRefsCollection = function (target, property) {\n    var collection = target[property.name];\n    if (!isExtended(collection)) {\n      defineCollectionProperty(this, property, target);\n    }\n    return collection;\n  };\n  Refs.prototype.ensureBound = function (target, property) {\n    if (!hasOwnProperty$1(target, property)) {\n      this.bind(target, property);\n    }\n  };\n  Refs.prototype.unset = function (target, property, value) {\n    if (target) {\n      this.ensureBound(target, property);\n      if (property.collection) {\n        this.ensureRefsCollection(target, property).remove(value);\n      } else {\n        target[property.name] = undefined;\n      }\n    }\n  };\n  Refs.prototype.set = function (target, property, value) {\n    if (target) {\n      this.ensureBound(target, property);\n      if (property.collection) {\n        this.ensureRefsCollection(target, property).add(value);\n      } else {\n        target[property.name] = value;\n      }\n    }\n  };\n\n  var parentRefs = new Refs({ name: 'children', enumerable: true, collection: true }, { name: 'parent' }),\n      labelRefs = new Refs({ name: 'labels', enumerable: true, collection: true }, { name: 'labelTarget' }),\n      attacherRefs = new Refs({ name: 'attachers', collection: true }, { name: 'host' }),\n      outgoingRefs = new Refs({ name: 'outgoing', collection: true }, { name: 'source' }),\n      incomingRefs = new Refs({ name: 'incoming', collection: true }, { name: 'target' });\n\n  /**\n   * @typedef {import('./Types').Element} Element\n   * @typedef {import('./Types').Shape} Shape\n   * @typedef {import('./Types').Root} Root\n   * @typedef {import('./Types').Label} Label\n   * @typedef {import('./Types').Connection} Connection\n   */\n\n  /**\n   * The basic graphical representation\n   *\n   * @class\n   * @constructor\n   */\n  function ElementImpl() {\n\n    /**\n     * The object that backs up the shape\n     *\n     * @name Element#businessObject\n     * @type Object\n     */\n    Object.defineProperty(this, 'businessObject', {\n      writable: true\n    });\n\n\n    /**\n     * Single label support, will mapped to multi label array\n     *\n     * @name Element#label\n     * @type Object\n     */\n    Object.defineProperty(this, 'label', {\n      get: function() {\n        return this.labels[0];\n      },\n      set: function(newLabel) {\n\n        var label = this.label,\n            labels = this.labels;\n\n        if (!newLabel && label) {\n          labels.remove(label);\n        } else {\n          labels.add(newLabel, 0);\n        }\n      }\n    });\n\n    /**\n     * The parent shape\n     *\n     * @name Element#parent\n     * @type Shape\n     */\n    parentRefs.bind(this, 'parent');\n\n    /**\n     * The list of labels\n     *\n     * @name Element#labels\n     * @type Label\n     */\n    labelRefs.bind(this, 'labels');\n\n    /**\n     * The list of outgoing connections\n     *\n     * @name Element#outgoing\n     * @type Array<Connection>\n     */\n    outgoingRefs.bind(this, 'outgoing');\n\n    /**\n     * The list of incoming connections\n     *\n     * @name Element#incoming\n     * @type Array<Connection>\n     */\n    incomingRefs.bind(this, 'incoming');\n  }\n\n\n  /**\n   * A graphical object\n   *\n   * @class\n   * @constructor\n   *\n   * @extends ElementImpl\n   */\n  function ShapeImpl() {\n    ElementImpl.call(this);\n\n    /**\n     * Indicates frame shapes\n     *\n     * @name ShapeImpl#isFrame\n     * @type boolean\n     */\n\n    /**\n     * The list of children\n     *\n     * @name ShapeImpl#children\n     * @type Element[]\n     */\n    parentRefs.bind(this, 'children');\n\n    /**\n     * @name ShapeImpl#host\n     * @type Shape\n     */\n    attacherRefs.bind(this, 'host');\n\n    /**\n     * @name ShapeImpl#attachers\n     * @type Shape\n     */\n    attacherRefs.bind(this, 'attachers');\n  }\n\n  e(ShapeImpl, ElementImpl);\n\n\n  /**\n   * A root graphical object\n   *\n   * @class\n   * @constructor\n   *\n   * @extends ElementImpl\n   */\n  function RootImpl() {\n    ElementImpl.call(this);\n\n    /**\n     * The list of children\n     *\n     * @name RootImpl#children\n     * @type Element[]\n     */\n    parentRefs.bind(this, 'children');\n  }\n\n  e(RootImpl, ShapeImpl);\n\n\n  /**\n   * A label for an element\n   *\n   * @class\n   * @constructor\n   *\n   * @extends ShapeImpl\n   */\n  function LabelImpl() {\n    ShapeImpl.call(this);\n\n    /**\n     * The labeled element\n     *\n     * @name LabelImpl#labelTarget\n     * @type Element\n     */\n    labelRefs.bind(this, 'labelTarget');\n  }\n\n  e(LabelImpl, ShapeImpl);\n\n\n  /**\n   * A connection between two elements\n   *\n   * @class\n   * @constructor\n   *\n   * @extends ElementImpl\n   */\n  function ConnectionImpl() {\n    ElementImpl.call(this);\n\n    /**\n     * The element this connection originates from\n     *\n     * @name ConnectionImpl#source\n     * @type Element\n     */\n    outgoingRefs.bind(this, 'source');\n\n    /**\n     * The element this connection points to\n     *\n     * @name ConnectionImpl#target\n     * @type Element\n     */\n    incomingRefs.bind(this, 'target');\n  }\n\n  e(ConnectionImpl, ElementImpl);\n\n\n  var types$6 = {\n    connection: ConnectionImpl,\n    shape: ShapeImpl,\n    label: LabelImpl,\n    root: RootImpl\n  };\n\n  /**\n   * Creates a root element.\n   *\n   * @overlord\n   *\n   * @example\n   *\n   * ```javascript\n   * import * as Model from 'diagram-js/lib/model';\n   *\n   * const root = Model.create('root', {\n   *   x: 100,\n   *   y: 100,\n   *   width: 100,\n   *   height: 100\n   * });\n   * ```\n   *\n   * @param {'root'} type\n   * @param {any} [attrs]\n   *\n   * @return {Root}\n   */\n\n  /**\n   * Creates a connection.\n   *\n   * @overlord\n   *\n   * @example\n   *\n   * ```javascript\n   * import * as Model from 'diagram-js/lib/model';\n   *\n   * const connection = Model.create('connection', {\n   *   waypoints: [\n   *     { x: 100, y: 100 },\n   *     { x: 200, y: 100 }\n   *   ]\n   * });\n   * ```\n   *\n   * @param {'connection'} type\n   * @param {any} [attrs]\n   *\n   * @return {Connection}\n   */\n\n  /**\n   * Creates a shape.\n   *\n   * @overlord\n   *\n   * @example\n   *\n   * ```javascript\n   * import * as Model from 'diagram-js/lib/model';\n   *\n   * const shape = Model.create('shape', {\n   *   x: 100,\n   *   y: 100,\n   *   width: 100,\n   *   height: 100\n   * });\n   * ```\n   *\n   * @param {'shape'} type\n   * @param {any} [attrs]\n   *\n   * @return {Shape}\n   */\n\n  /**\n   * Creates a label.\n   *\n   * @example\n   *\n   * ```javascript\n   * import * as Model from 'diagram-js/lib/model';\n   *\n   * const label = Model.create('label', {\n   *   x: 100,\n   *   y: 100,\n   *   width: 100,\n   *   height: 100,\n   *   labelTarget: shape\n   * });\n   * ```\n   *\n   * @param {'label'} type\n   * @param {Object} [attrs]\n   *\n   * @return {Label}\n   */\n  function create(type, attrs) {\n    var Type = types$6[type];\n    if (!Type) {\n      throw new Error('unknown type: <' + type + '>');\n    }\n    return assign$1(new Type(), attrs);\n  }\n\n  /**\n   * @typedef {import('../model/Types').Element} Element\n   * @typedef {import('../model/Types').Connection} Connection\n   * @typedef {import('../model/Types').Label} Label\n   * @typedef {import('../model/Types').Root} Root\n   * @typedef {import('../model/Types').Shape} Shape\n   */\n\n  /**\n   * A factory for model elements.\n   *\n   * @template {Connection} [T=Connection]\n   * @template {Label} [U=Label]\n   * @template {Root} [V=Root]\n   * @template {Shape} [W=Shape]\n   */\n  function ElementFactory() {\n    this._uid = 12;\n  }\n\n  /**\n   * Create a root element.\n   *\n   * @param {Partial<Root>} [attrs]\n   *\n   * @return {V} The created root element.\n   */\n  ElementFactory.prototype.createRoot = function(attrs) {\n    return this.create('root', attrs);\n  };\n\n  /**\n   * Create a label.\n   *\n   * @param {Partial<Label>} [attrs]\n   *\n   * @return {U} The created label.\n   */\n  ElementFactory.prototype.createLabel = function(attrs) {\n    return this.create('label', attrs);\n  };\n\n  /**\n   * Create a shape.\n   *\n   * @param {Partial<Shape>} [attrs]\n   *\n   * @return {W} The created shape.\n   */\n  ElementFactory.prototype.createShape = function(attrs) {\n    return this.create('shape', attrs);\n  };\n\n  /**\n   * Create a connection.\n   *\n   * @param {Partial<Connection>} [attrs]\n   *\n   * @return {T} The created connection.\n   */\n  ElementFactory.prototype.createConnection = function(attrs) {\n    return this.create('connection', attrs);\n  };\n\n  /**\n   * Create a root element.\n   *\n   * @overlord\n   * @param {'root'} type\n   * @param {Partial<Root>} [attrs]\n   * @return {V}\n   */\n  /**\n   * Create a shape.\n   *\n   * @overlord\n   * @param {'shape'} type\n   * @param {Partial<Shape>} [attrs]\n   * @return {W}\n   */\n  /**\n   * Create a connection.\n   *\n   * @overlord\n   * @param {'connection'} type\n   * @param {Partial<Connection>} [attrs]\n   * @return {T}\n   */\n  /**\n   * Create a label.\n   *\n   * @param {'label'} type\n   * @param {Partial<Label>} [attrs]\n   * @return {U}\n   */\n  ElementFactory.prototype.create = function(type, attrs) {\n\n    attrs = assign$1({}, attrs || {});\n\n    if (!attrs.id) {\n      attrs.id = type + '_' + (this._uid++);\n    }\n\n    return create(type, attrs);\n  };\n\n  var FN_REF = '__fn';\n\n  var DEFAULT_PRIORITY$1 = 1000;\n\n  var slice = Array.prototype.slice;\n\n  /**\n   * @typedef { {\n   *   stopPropagation(): void;\n   *   preventDefault(): void;\n   *   cancelBubble: boolean;\n   *   defaultPrevented: boolean;\n   *   returnValue: any;\n   * } } Event\n   */\n\n  /**\n   * @template E\n   *\n   * @typedef { (event: E & Event, ...any) => any } EventBusEventCallback\n   */\n\n  /**\n   * @typedef { {\n   *  priority: number;\n   *  next: EventBusListener | null;\n   *  callback: EventBusEventCallback<any>;\n   * } } EventBusListener\n   */\n\n  /**\n   * A general purpose event bus.\n   *\n   * This component is used to communicate across a diagram instance.\n   * Other parts of a diagram can use it to listen to and broadcast events.\n   *\n   *\n   * ## Registering for Events\n   *\n   * The event bus provides the {@link EventBus#on} and {@link EventBus#once}\n   * methods to register for events. {@link EventBus#off} can be used to\n   * remove event registrations. Listeners receive an instance of {@link Event}\n   * as the first argument. It allows them to hook into the event execution.\n   *\n   * ```javascript\n   *\n   * // listen for event\n   * eventBus.on('foo', function(event) {\n   *\n   *   // access event type\n   *   event.type; // 'foo'\n   *\n   *   // stop propagation to other listeners\n   *   event.stopPropagation();\n   *\n   *   // prevent event default\n   *   event.preventDefault();\n   * });\n   *\n   * // listen for event with custom payload\n   * eventBus.on('bar', function(event, payload) {\n   *   console.log(payload);\n   * });\n   *\n   * // listen for event returning value\n   * eventBus.on('foobar', function(event) {\n   *\n   *   // stop event propagation + prevent default\n   *   return false;\n   *\n   *   // stop event propagation + return custom result\n   *   return {\n   *     complex: 'listening result'\n   *   };\n   * });\n   *\n   *\n   * // listen with custom priority (default=1000, higher is better)\n   * eventBus.on('priorityfoo', 1500, function(event) {\n   *   console.log('invoked first!');\n   * });\n   *\n   *\n   * // listen for event and pass the context (`this`)\n   * eventBus.on('foobar', function(event) {\n   *   this.foo();\n   * }, this);\n   * ```\n   *\n   *\n   * ## Emitting Events\n   *\n   * Events can be emitted via the event bus using {@link EventBus#fire}.\n   *\n   * ```javascript\n   *\n   * // false indicates that the default action\n   * // was prevented by listeners\n   * if (eventBus.fire('foo') === false) {\n   *   console.log('default has been prevented!');\n   * };\n   *\n   *\n   * // custom args + return value listener\n   * eventBus.on('sum', function(event, a, b) {\n   *   return a + b;\n   * });\n   *\n   * // you can pass custom arguments + retrieve result values.\n   * var sum = eventBus.fire('sum', 1, 2);\n   * console.log(sum); // 3\n   * ```\n   *\n   * @template [EventMap=null]\n   */\n  function EventBus() {\n\n    /**\n     * @type { Record<string, EventBusListener> }\n     */\n    this._listeners = {};\n\n    // cleanup on destroy on lowest priority to allow\n    // message passing until the bitter end\n    this.on('diagram.destroy', 1, this._destroy, this);\n  }\n\n  /**\n   * @overlord\n   *\n   * Register an event listener for events with the given name.\n   *\n   * The callback will be invoked with `event, ...additionalArguments`\n   * that have been passed to {@link EventBus#fire}.\n   *\n   * Returning false from a listener will prevent the events default action\n   * (if any is specified). To stop an event from being processed further in\n   * other listeners execute {@link Event#stopPropagation}.\n   *\n   * Returning anything but `undefined` from a listener will stop the listener propagation.\n   *\n   * @template T\n   *\n   * @param {string|string[]} events to subscribe to\n   * @param {number} [priority=1000] listen priority\n   * @param {EventBusEventCallback<T>} callback\n   * @param {any} [that] callback context\n   */\n  /**\n   * Register an event listener for events with the given name.\n   *\n   * The callback will be invoked with `event, ...additionalArguments`\n   * that have been passed to {@link EventBus#fire}.\n   *\n   * Returning false from a listener will prevent the events default action\n   * (if any is specified). To stop an event from being processed further in\n   * other listeners execute {@link Event#stopPropagation}.\n   *\n   * Returning anything but `undefined` from a listener will stop the listener propagation.\n   *\n   * @template {keyof EventMap} EventName\n   *\n   * @param {EventName} events to subscribe to\n   * @param {number} [priority=1000] listen priority\n   * @param {EventBusEventCallback<EventMap[EventName]>} callback\n   * @param {any} [that] callback context\n   */\n  EventBus.prototype.on = function(events, priority, callback, that) {\n\n    events = isArray$2(events) ? events : [ events ];\n\n    if (isFunction(priority)) {\n      that = callback;\n      callback = priority;\n      priority = DEFAULT_PRIORITY$1;\n    }\n\n    if (!isNumber(priority)) {\n      throw new Error('priority must be a number');\n    }\n\n    var actualCallback = callback;\n\n    if (that) {\n      actualCallback = bind$2(callback, that);\n\n      // make sure we remember and are able to remove\n      // bound callbacks via {@link #off} using the original\n      // callback\n      actualCallback[FN_REF] = callback[FN_REF] || callback;\n    }\n\n    var self = this;\n\n    events.forEach(function(e) {\n      self._addListener(e, {\n        priority: priority,\n        callback: actualCallback,\n        next: null\n      });\n    });\n  };\n\n  /**\n   * @overlord\n   *\n   * Register an event listener that is called only once.\n   *\n   * @template T\n   *\n   * @param {string|string[]} events to subscribe to\n   * @param {number} [priority=1000] the listen priority\n   * @param {EventBusEventCallback<T>} callback\n   * @param {any} [that] callback context\n   */\n  /**\n   * Register an event listener that is called only once.\n   *\n   * @template {keyof EventMap} EventName\n   *\n   * @param {EventName} events to subscribe to\n   * @param {number} [priority=1000] listen priority\n   * @param {EventBusEventCallback<EventMap[EventName]>} callback\n   * @param {any} [that] callback context\n   */\n  EventBus.prototype.once = function(events, priority, callback, that) {\n    var self = this;\n\n    if (isFunction(priority)) {\n      that = callback;\n      callback = priority;\n      priority = DEFAULT_PRIORITY$1;\n    }\n\n    if (!isNumber(priority)) {\n      throw new Error('priority must be a number');\n    }\n\n    function wrappedCallback() {\n      wrappedCallback.__isTomb = true;\n\n      var result = callback.apply(that, arguments);\n\n      self.off(events, wrappedCallback);\n\n      return result;\n    }\n\n    // make sure we remember and are able to remove\n    // bound callbacks via {@link #off} using the original\n    // callback\n    wrappedCallback[FN_REF] = callback;\n\n    this.on(events, priority, wrappedCallback);\n  };\n\n\n  /**\n   * Removes event listeners by event and callback.\n   *\n   * If no callback is given, all listeners for a given event name are being removed.\n   *\n   * @param {string|string[]} events\n   * @param {EventBusEventCallback<unknown>} [callback]\n   */\n  EventBus.prototype.off = function(events, callback) {\n\n    events = isArray$2(events) ? events : [ events ];\n\n    var self = this;\n\n    events.forEach(function(event) {\n      self._removeListener(event, callback);\n    });\n\n  };\n\n\n  /**\n   * Create an event recognized be the event bus.\n   *\n   * @param {Object} data Event data.\n   *\n   * @return {Event} An event that will be recognized by the event bus.\n   */\n  EventBus.prototype.createEvent = function(data) {\n    var event = new InternalEvent();\n\n    event.init(data);\n\n    return event;\n  };\n\n\n  /**\n   * Fires an event.\n   *\n   * @example\n   *\n   * ```javascript\n   * // fire event by name\n   * events.fire('foo');\n   *\n   * // fire event object with nested type\n   * var event = { type: 'foo' };\n   * events.fire(event);\n   *\n   * // fire event with explicit type\n   * var event = { x: 10, y: 20 };\n   * events.fire('element.moved', event);\n   *\n   * // pass additional arguments to the event\n   * events.on('foo', function(event, bar) {\n   *   alert(bar);\n   * });\n   *\n   * events.fire({ type: 'foo' }, 'I am bar!');\n   * ```\n   *\n   * @param {string} [type] event type\n   * @param {Object} [data] event or event data\n   * @param {...any} [args] additional arguments the callback will be called with.\n   *\n   * @return {any} The return value. Will be set to `false` if the default was prevented.\n   */\n  EventBus.prototype.fire = function(type, data) {\n    var event,\n        firstListener,\n        returnValue,\n        args;\n\n    args = slice.call(arguments);\n\n    if (typeof type === 'object') {\n      data = type;\n      type = data.type;\n    }\n\n    if (!type) {\n      throw new Error('no event type specified');\n    }\n\n    firstListener = this._listeners[type];\n\n    if (!firstListener) {\n      return;\n    }\n\n    // we make sure we fire instances of our home made\n    // events here. We wrap them only once, though\n    if (data instanceof InternalEvent) {\n\n      // we are fine, we alread have an event\n      event = data;\n    } else {\n      event = this.createEvent(data);\n    }\n\n    // ensure we pass the event as the first parameter\n    args[0] = event;\n\n    // original event type (in case we delegate)\n    var originalType = event.type;\n\n    // update event type before delegation\n    if (type !== originalType) {\n      event.type = type;\n    }\n\n    try {\n      returnValue = this._invokeListeners(event, args, firstListener);\n    } finally {\n\n      // reset event type after delegation\n      if (type !== originalType) {\n        event.type = originalType;\n      }\n    }\n\n    // set the return value to false if the event default\n    // got prevented and no other return value exists\n    if (returnValue === undefined && event.defaultPrevented) {\n      returnValue = false;\n    }\n\n    return returnValue;\n  };\n\n  /**\n   * Handle an error by firing an event.\n   *\n   * @param {Error} error The error to be handled.\n   *\n   * @return {boolean} Whether the error was handled.\n   */\n  EventBus.prototype.handleError = function(error) {\n    return this.fire('error', { error: error }) === false;\n  };\n\n\n  EventBus.prototype._destroy = function() {\n    this._listeners = {};\n  };\n\n  /**\n   * @param {Event} event\n   * @param {any[]} args\n   * @param {EventBusListener} listener\n   *\n   * @return {any}\n   */\n  EventBus.prototype._invokeListeners = function(event, args, listener) {\n\n    var returnValue;\n\n    while (listener) {\n\n      // handle stopped propagation\n      if (event.cancelBubble) {\n        break;\n      }\n\n      returnValue = this._invokeListener(event, args, listener);\n\n      listener = listener.next;\n    }\n\n    return returnValue;\n  };\n\n  /**\n   * @param {Event} event\n   * @param {any[]} args\n   * @param {EventBusListener} listener\n   *\n   * @return {any}\n   */\n  EventBus.prototype._invokeListener = function(event, args, listener) {\n\n    var returnValue;\n\n    if (listener.callback.__isTomb) {\n      return returnValue;\n    }\n\n    try {\n\n      // returning false prevents the default action\n      returnValue = invokeFunction(listener.callback, args);\n\n      // stop propagation on return value\n      if (returnValue !== undefined) {\n        event.returnValue = returnValue;\n        event.stopPropagation();\n      }\n\n      // prevent default on return false\n      if (returnValue === false) {\n        event.preventDefault();\n      }\n    } catch (error) {\n      if (!this.handleError(error)) {\n        console.error('unhandled error in event listener', error);\n\n        throw error;\n      }\n    }\n\n    return returnValue;\n  };\n\n  /**\n   * Add new listener with a certain priority to the list\n   * of listeners (for the given event).\n   *\n   * The semantics of listener registration / listener execution are\n   * first register, first serve: New listeners will always be inserted\n   * after existing listeners with the same priority.\n   *\n   * Example: Inserting two listeners with priority 1000 and 1300\n   *\n   *    * before: [ 1500, 1500, 1000, 1000 ]\n   *    * after: [ 1500, 1500, (new=1300), 1000, 1000, (new=1000) ]\n   *\n   * @param {string} event\n   * @param {EventBusListener} newListener\n   */\n  EventBus.prototype._addListener = function(event, newListener) {\n\n    var listener = this._getListeners(event),\n        previousListener;\n\n    // no prior listeners\n    if (!listener) {\n      this._setListeners(event, newListener);\n\n      return;\n    }\n\n    // ensure we order listeners by priority from\n    // 0 (high) to n > 0 (low)\n    while (listener) {\n\n      if (listener.priority < newListener.priority) {\n\n        newListener.next = listener;\n\n        if (previousListener) {\n          previousListener.next = newListener;\n        } else {\n          this._setListeners(event, newListener);\n        }\n\n        return;\n      }\n\n      previousListener = listener;\n      listener = listener.next;\n    }\n\n    // add new listener to back\n    previousListener.next = newListener;\n  };\n\n\n  /**\n   * @param {string} name\n   *\n   * @return {EventBusListener}\n   */\n  EventBus.prototype._getListeners = function(name) {\n    return this._listeners[name];\n  };\n\n  /**\n   * @param {string} name\n   * @param {EventBusListener} listener\n   */\n  EventBus.prototype._setListeners = function(name, listener) {\n    this._listeners[name] = listener;\n  };\n\n  EventBus.prototype._removeListener = function(event, callback) {\n\n    var listener = this._getListeners(event),\n        nextListener,\n        previousListener,\n        listenerCallback;\n\n    if (!callback) {\n\n      // clear listeners\n      this._setListeners(event, null);\n\n      return;\n    }\n\n    while (listener) {\n\n      nextListener = listener.next;\n\n      listenerCallback = listener.callback;\n\n      if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {\n        if (previousListener) {\n          previousListener.next = nextListener;\n        } else {\n\n          // new first listener\n          this._setListeners(event, nextListener);\n        }\n      }\n\n      previousListener = listener;\n      listener = nextListener;\n    }\n  };\n\n  /**\n   * A event that is emitted via the event bus.\n   */\n  function InternalEvent() { }\n\n  InternalEvent.prototype.stopPropagation = function() {\n    this.cancelBubble = true;\n  };\n\n  InternalEvent.prototype.preventDefault = function() {\n    this.defaultPrevented = true;\n  };\n\n  InternalEvent.prototype.init = function(data) {\n    assign$1(this, data || {});\n  };\n\n\n  /**\n   * Invoke function. Be fast...\n   *\n   * @param {Function} fn\n   * @param {any[]} args\n   *\n   * @return {any}\n   */\n  function invokeFunction(fn, args) {\n    return fn.apply(null, args);\n  }\n\n  /**\n   * SVGs for elements are generated by the {@link GraphicsFactory}.\n   *\n   * This utility gives quick access to the important semantic\n   * parts of an element.\n   */\n\n  /**\n   * Returns the visual part of a diagram element.\n   *\n   * @param {SVGElement} gfx\n   *\n   * @return {SVGElement}\n   */\n  function getVisual(gfx) {\n    return gfx.childNodes[0];\n  }\n\n  /**\n   * Returns the children for a given diagram element.\n   *\n   * @param {SVGElement} gfx\n   * @return {SVGElement}\n   */\n  function getChildren(gfx) {\n    return gfx.parentNode.childNodes[1];\n  }\n\n  /**\n   * @typedef {import('./Types').ConnectionLike} ConnectionLike\n   * @typedef {import('./Types').ElementLike} ElementLike\n   * @typedef {import('./Types').ShapeLike} ShapeLike\n   *\n   * @typedef {import('./ElementRegistry').default} ElementRegistry\n   * @typedef {import('./EventBus').default} EventBus\n   */\n\n  /**\n   * A factory that creates graphical elements.\n   *\n   * @param {EventBus} eventBus\n   * @param {ElementRegistry} elementRegistry\n   */\n  function GraphicsFactory(eventBus, elementRegistry) {\n    this._eventBus = eventBus;\n    this._elementRegistry = elementRegistry;\n  }\n\n  GraphicsFactory.$inject = [ 'eventBus' , 'elementRegistry' ];\n\n  /**\n   * @param { { parent?: any } } element\n   * @return {SVGElement}\n   */\n  GraphicsFactory.prototype._getChildrenContainer = function(element) {\n\n    var gfx = this._elementRegistry.getGraphics(element);\n\n    var childrenGfx;\n\n    // root element\n    if (!element.parent) {\n      childrenGfx = gfx;\n    } else {\n      childrenGfx = getChildren(gfx);\n      if (!childrenGfx) {\n        childrenGfx = create$1('g');\n        classes$1(childrenGfx).add('djs-children');\n\n        append(gfx.parentNode, childrenGfx);\n      }\n    }\n\n    return childrenGfx;\n  };\n\n  /**\n   * Clears the graphical representation of the element and returns the\n   * cleared visual (the <g class=\"djs-visual\" /> element).\n   */\n  GraphicsFactory.prototype._clear = function(gfx) {\n    var visual = getVisual(gfx);\n\n    clear(visual);\n\n    return visual;\n  };\n\n  /**\n   * Creates a gfx container for shapes and connections\n   *\n   * The layout is as follows:\n   *\n   * <g class=\"djs-group\">\n   *\n   *   <!-- the gfx -->\n   *   <g class=\"djs-element djs-(shape|connection|frame)\">\n   *     <g class=\"djs-visual\">\n   *       <!-- the renderer draws in here -->\n   *     </g>\n   *\n   *     <!-- extensions (overlays, click box, ...) goes here\n   *   </g>\n   *\n   *   <!-- the gfx child nodes -->\n   *   <g class=\"djs-children\"></g>\n   * </g>\n   *\n   * @param {string} type the type of the element, i.e. shape | connection\n   * @param {SVGElement} childrenGfx\n   * @param {number} [parentIndex] position to create container in parent\n   * @param {boolean} [isFrame] is frame element\n   *\n   * @return {SVGElement}\n   */\n  GraphicsFactory.prototype._createContainer = function(\n      type, childrenGfx, parentIndex, isFrame\n  ) {\n    var outerGfx = create$1('g');\n    classes$1(outerGfx).add('djs-group');\n\n    // insert node at position\n    if (typeof parentIndex !== 'undefined') {\n      prependTo(outerGfx, childrenGfx, childrenGfx.childNodes[parentIndex]);\n    } else {\n      append(childrenGfx, outerGfx);\n    }\n\n    var gfx = create$1('g');\n    classes$1(gfx).add('djs-element');\n    classes$1(gfx).add('djs-' + type);\n\n    if (isFrame) {\n      classes$1(gfx).add('djs-frame');\n    }\n\n    append(outerGfx, gfx);\n\n    // create visual\n    var visual = create$1('g');\n    classes$1(visual).add('djs-visual');\n\n    append(gfx, visual);\n\n    return gfx;\n  };\n\n  /**\n   * Create a graphical element.\n   *\n   * @param { 'shape' | 'connection' | 'label' | 'root' } type The type of the element.\n   * @param {ElementLike} element The element.\n   * @param {number} [parentIndex] The index at which to add the graphical element to its parent's children.\n   *\n   * @return {SVGElement} The graphical element.\n   */\n  GraphicsFactory.prototype.create = function(type, element, parentIndex) {\n    var childrenGfx = this._getChildrenContainer(element.parent);\n    return this._createContainer(type, childrenGfx, parentIndex, isFrameElement(element));\n  };\n\n  /**\n   * Update the containments of the given elements.\n   *\n   * @param {ElementLike[]} elements The elements.\n   */\n  GraphicsFactory.prototype.updateContainments = function(elements) {\n\n    var self = this,\n        elementRegistry = this._elementRegistry,\n        parents;\n\n    parents = reduce(elements, function(map, e) {\n\n      if (e.parent) {\n        map[e.parent.id] = e.parent;\n      }\n\n      return map;\n    }, {});\n\n    // update all parents of changed and reorganized their children\n    // in the correct order (as indicated in our model)\n    forEach$1(parents, function(parent) {\n\n      var children = parent.children;\n\n      if (!children) {\n        return;\n      }\n\n      var childrenGfx = self._getChildrenContainer(parent);\n\n      forEach$1(children.slice().reverse(), function(child) {\n        var childGfx = elementRegistry.getGraphics(child);\n\n        prependTo(childGfx.parentNode, childrenGfx);\n      });\n    });\n  };\n\n  /**\n   * Draw a shape.\n   *\n   * @param {SVGElement} visual The graphical element.\n   * @param {ShapeLike} element The shape.\n   * @param {Object} attrs Optional attributes.\n   *\n   * @return {SVGElement}\n   */\n  GraphicsFactory.prototype.drawShape = function(visual, element, attrs = {}) {\n    var eventBus = this._eventBus;\n\n    return eventBus.fire('render.shape', { gfx: visual, element, attrs });\n  };\n\n  /**\n   * Get the path of a shape.\n   *\n   * @param {ShapeLike} element The shape.\n   *\n   * @return {string} The path of the shape.\n   */\n  GraphicsFactory.prototype.getShapePath = function(element) {\n    var eventBus = this._eventBus;\n\n    return eventBus.fire('render.getShapePath', element);\n  };\n\n  /**\n   * Draw a connection.\n   *\n   * @param {SVGElement} visual The graphical element.\n   * @param {ConnectionLike} element The connection.\n   * @param {Object} attrs Optional attributes.\n   *\n   * @return {SVGElement}\n   */\n  GraphicsFactory.prototype.drawConnection = function(visual, element, attrs = {}) {\n    var eventBus = this._eventBus;\n\n    return eventBus.fire('render.connection', { gfx: visual, element, attrs });\n  };\n\n  /**\n   * Get the path of a connection.\n   *\n   * @param {ConnectionLike} connection The connection.\n   *\n   * @return {string} The path of the connection.\n   */\n  GraphicsFactory.prototype.getConnectionPath = function(connection) {\n    var eventBus = this._eventBus;\n\n    return eventBus.fire('render.getConnectionPath', connection);\n  };\n\n  /**\n   * Update an elements graphical representation.\n   *\n   * @param {'shape'|'connection'} type\n   * @param {ElementLike} element\n   * @param {SVGElement} gfx\n   */\n  GraphicsFactory.prototype.update = function(type, element, gfx) {\n\n    // do NOT update root element\n    if (!element.parent) {\n      return;\n    }\n\n    var visual = this._clear(gfx);\n\n    // redraw\n    if (type === 'shape') {\n      this.drawShape(visual, element);\n\n      // update positioning\n      translate$1(gfx, element.x, element.y);\n    } else if (type === 'connection') {\n      this.drawConnection(visual, element);\n    } else {\n      throw new Error('unknown type: ' + type);\n    }\n\n    if (element.hidden) {\n      attr$1(gfx, 'display', 'none');\n    } else {\n      attr$1(gfx, 'display', 'block');\n    }\n  };\n\n  /**\n   * Remove a graphical element.\n   *\n   * @param {ElementLike} element The element.\n   */\n  GraphicsFactory.prototype.remove = function(element) {\n    var gfx = this._elementRegistry.getGraphics(element);\n\n    // remove\n    remove$2(gfx.parentNode);\n  };\n\n\n  // helpers //////////\n\n  function prependTo(newNode, parentNode, siblingNode) {\n    var node = siblingNode || parentNode.firstChild;\n\n    // do not prepend node to itself to prevent IE from crashing\n    // https://github.com/bpmn-io/bpmn-js/issues/746\n    if (newNode === node) {\n      return;\n    }\n\n    parentNode.insertBefore(newNode, node);\n  }\n\n  /**\n   * @type { import('didi').ModuleDeclaration }\n   */\n  var CoreModule = {\n    __depends__: [ DrawModule ],\n    __init__: [ 'canvas' ],\n    canvas: [ 'type', Canvas ],\n    elementRegistry: [ 'type', ElementRegistry ],\n    elementFactory: [ 'type', ElementFactory ],\n    eventBus: [ 'type', EventBus ],\n    graphicsFactory: [ 'type', GraphicsFactory ]\n  };\n\n  /**\n   * @typedef {import('didi').InjectionContext} InjectionContext\n   * @typedef {import('didi').LocalsMap} LocalsMap\n   * @typedef {import('didi').ModuleDeclaration} ModuleDeclaration\n   *\n   * @typedef { {\n   *   modules?: ModuleDeclaration[];\n   * } & Record<string, any> } DiagramOptions\n   */\n\n  /**\n   * @template T\n   * @typedef {import('didi').FactoryFunction<T>} FactoryFunction\n   */\n\n  /**\n   * @template T\n   * @typedef {import('didi').ArrayFunc<T>} ArrayFunc\n   */\n\n  /**\n   * Bootstrap an injector from a list of modules, instantiating a number of default components\n   *\n   * @param {ModuleDeclaration[]} modules\n   *\n   * @return {Injector} a injector to use to access the components\n   */\n  function bootstrap(modules) {\n    var injector = new Injector(modules);\n\n    injector.init();\n\n    return injector;\n  }\n\n  /**\n   * Creates an injector from passed options.\n   *\n   * @template ServiceMap\n   * @param {DiagramOptions} [options]\n   *\n   * @return {Injector<ServiceMap>}\n   */\n  function createInjector(options) {\n\n    options = options || {};\n\n    /**\n     * @type { ModuleDeclaration }\n     */\n    var configModule = {\n      'config': [ 'value', options ]\n    };\n\n    var modules = [ configModule, CoreModule ].concat(options.modules || []);\n\n    return bootstrap(modules);\n  }\n\n\n  /**\n   * The main diagram-js entry point that bootstraps the diagram with the given\n   * configuration.\n   *\n   * To register extensions with the diagram, pass them as Array<Module> to the constructor.\n   *\n   * @class\n   * @constructor\n   * @template [ServiceMap=null]\n   *\n   * @example Creating a plug-in that logs whenever a shape is added to the canvas.\n   *\n   * ```javascript\n   * // plug-in implementation\n   * function MyLoggingPlugin(eventBus) {\n   *   eventBus.on('shape.added', function(event) {\n   *     console.log('shape ', event.shape, ' was added to the diagram');\n   *   });\n   * }\n   *\n   * // export as module\n   * export default {\n   *   __init__: [ 'myLoggingPlugin' ],\n   *     myLoggingPlugin: [ 'type', MyLoggingPlugin ]\n   * };\n   * ```\n   *\n   * Use the plug-in in a Diagram instance:\n   *\n   * ```javascript\n   * import MyLoggingModule from 'path-to-my-logging-plugin';\n   *\n   * var diagram = new Diagram({\n   *   modules: [\n   *     MyLoggingModule\n   *   ]\n   * });\n   *\n   * diagram.invoke([ 'canvas', function(canvas) {\n   *   // add shape to drawing canvas\n   *   canvas.addShape({ x: 10, y: 10 });\n   * });\n   *\n   * // 'shape ... was added to the diagram' logged to console\n   * ```\n   *\n   * @param {DiagramOptions} [options]\n   * @param {Injector<ServiceMap>} [injector] An (optional) injector to bootstrap the diagram with.\n   */\n  function Diagram(options, injector) {\n\n    /**\n     * @type {Injector<ServiceMap>}\n     */\n    this._injector = injector || createInjector(options);\n\n    // init\n\n    /**\n     * An event indicating that all plug-ins are loaded.\n     *\n     * Use this event to fire other events to interested plug-ins\n     *\n     * @memberOf Diagram\n     *\n     * @event diagram.init\n     *\n     * @example\n     *\n     * ```javascript\n     * eventBus.on('diagram.init', function() {\n     *   eventBus.fire('my-custom-event', { foo: 'BAR' });\n     * });\n     * ```\n     *\n     * @type {Object}\n     */\n    this.get('eventBus').fire('diagram.init');\n  }\n\n  /**\n   * @overlord\n   *\n   * Resolves a diagram service.\n   *\n   * @template T\n   *\n   * @param {string} name The name of the service to get.\n   *\n   * @return {T}\n   */\n  /**\n   * @overlord\n   *\n   * Resolves a diagram service.\n   *\n   * @template T\n   *\n   * @param {string} name The name of the service to get.\n   * @param {true} strict If false, resolve missing services to null.\n   *\n   * @return {T}\n   */\n  /**\n   * @overlord\n   *\n   * Resolves a diagram service.\n   *\n   * @template T\n   *\n   * @param {string} name The name of the service to get.\n   * @param {boolean} strict If false, resolve missing services to null.\n   *\n   * @return {T|null}\n   */\n  /**\n   * Resolves a diagram service.\n   *\n   * @template {keyof ServiceMap} Name\n   *\n   * @param {Name} name The name of the service to get.\n   *\n   * @return {ServiceMap[Name]}\n   */\n  Diagram.prototype.get = function(name, strict) {\n    return this._injector.get(name, strict);\n  };\n\n  /**\n   * @overlord\n   *\n   * Invoke the given function, injecting dependencies. Return the result.\n   *\n   * @template T\n   *\n   * @param {FactoryFunction<T>} func\n   * @param {InjectionContext} [context]\n   * @param {LocalsMap} [locals]\n   *\n   * @return {T}\n   */\n  /**\n   * Invoke the given function, injecting dependencies provided in\n   * array notation. Return the result.\n   *\n   * @template T\n   *\n   * @param {ArrayFunc<T>} func function to be invoked\n   * @param {InjectionContext} [context] context of the invocation\n   * @param {LocalsMap} [locals] locals provided\n   *\n   * @return {T}\n   */\n  Diagram.prototype.invoke = function(func, context, locals) {\n    return this._injector.invoke(func, context, locals);\n  };\n\n  /**\n   * Destroys the diagram\n   */\n  Diagram.prototype.destroy = function() {\n    this.get('eventBus').fire('diagram.destroy');\n  };\n\n  /**\n   * Clear the diagram, removing all contents.\n   */\n  Diagram.prototype.clear = function() {\n    this.get('eventBus').fire('diagram.clear');\n  };\n\n  /**\n   * Moddle base element.\n   */\n  function Base() { }\n\n  Base.prototype.get = function(name) {\n    return this.$model.properties.get(this, name);\n  };\n\n  Base.prototype.set = function(name, value) {\n    this.$model.properties.set(this, name, value);\n  };\n\n  /**\n   * A model element factory.\n   *\n   * @param {Moddle} model\n   * @param {Properties} properties\n   */\n  function Factory(model, properties) {\n    this.model = model;\n    this.properties = properties;\n  }\n\n\n  Factory.prototype.createType = function(descriptor) {\n\n    var model = this.model;\n\n    var props = this.properties,\n        prototype = Object.create(Base.prototype);\n\n    // initialize default values\n    forEach$1(descriptor.properties, function(p) {\n      if (!p.isMany && p.default !== undefined) {\n        prototype[p.name] = p.default;\n      }\n    });\n\n    props.defineModel(prototype, model);\n    props.defineDescriptor(prototype, descriptor);\n\n    var name = descriptor.ns.name;\n\n    /**\n     * The new type constructor\n     */\n    function ModdleElement(attrs) {\n      props.define(this, '$type', { value: name, enumerable: true });\n      props.define(this, '$attrs', { value: {} });\n      props.define(this, '$parent', { writable: true });\n\n      forEach$1(attrs, bind$2(function(val, key) {\n        this.set(key, val);\n      }, this));\n    }\n\n    ModdleElement.prototype = prototype;\n\n    ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;\n\n    // static links\n    props.defineModel(ModdleElement, model);\n    props.defineDescriptor(ModdleElement, descriptor);\n\n    return ModdleElement;\n  };\n\n  /**\n   * Built-in moddle types\n   */\n  var BUILTINS = {\n    String: true,\n    Boolean: true,\n    Integer: true,\n    Real: true,\n    Element: true\n  };\n\n  /**\n   * Converters for built in types from string representations\n   */\n  var TYPE_CONVERTERS = {\n    String: function(s) { return s; },\n    Boolean: function(s) { return s === 'true'; },\n    Integer: function(s) { return parseInt(s, 10); },\n    Real: function(s) { return parseFloat(s); }\n  };\n\n  /**\n   * Convert a type to its real representation\n   */\n  function coerceType(type, value) {\n\n    var converter = TYPE_CONVERTERS[type];\n\n    if (converter) {\n      return converter(value);\n    } else {\n      return value;\n    }\n  }\n\n  /**\n   * Return whether the given type is built-in\n   */\n  function isBuiltIn(type) {\n    return !!BUILTINS[type];\n  }\n\n  /**\n   * Return whether the given type is simple\n   */\n  function isSimple(type) {\n    return !!TYPE_CONVERTERS[type];\n  }\n\n  /**\n   * Parses a namespaced attribute name of the form (ns:)localName to an object,\n   * given a default prefix to assume in case no explicit namespace is given.\n   *\n   * @param {String} name\n   * @param {String} [defaultPrefix] the default prefix to take, if none is present.\n   *\n   * @return {Object} the parsed name\n   */\n  function parseName(name, defaultPrefix) {\n    var parts = name.split(/:/),\n        localName, prefix;\n\n    // no prefix (i.e. only local name)\n    if (parts.length === 1) {\n      localName = name;\n      prefix = defaultPrefix;\n    }\n\n    // prefix + local name\n    else if (parts.length === 2) {\n      localName = parts[1];\n      prefix = parts[0];\n    }\n\n    else {\n      throw new Error('expected <prefix:localName> or <localName>, got ' + name);\n    }\n\n    name = (prefix ? prefix + ':' : '') + localName;\n\n    return {\n      name: name,\n      prefix: prefix,\n      localName: localName\n    };\n  }\n\n  /**\n   * A utility to build element descriptors.\n   */\n  function DescriptorBuilder(nameNs) {\n    this.ns = nameNs;\n    this.name = nameNs.name;\n    this.allTypes = [];\n    this.allTypesByName = {};\n    this.properties = [];\n    this.propertiesByName = {};\n  }\n\n\n  DescriptorBuilder.prototype.build = function() {\n    return pick(this, [\n      'ns',\n      'name',\n      'allTypes',\n      'allTypesByName',\n      'properties',\n      'propertiesByName',\n      'bodyProperty',\n      'idProperty'\n    ]);\n  };\n\n  /**\n   * Add property at given index.\n   *\n   * @param {Object} p\n   * @param {Number} [idx]\n   * @param {Boolean} [validate=true]\n   */\n  DescriptorBuilder.prototype.addProperty = function(p, idx, validate) {\n\n    if (typeof idx === 'boolean') {\n      validate = idx;\n      idx = undefined;\n    }\n\n    this.addNamedProperty(p, validate !== false);\n\n    var properties = this.properties;\n\n    if (idx !== undefined) {\n      properties.splice(idx, 0, p);\n    } else {\n      properties.push(p);\n    }\n  };\n\n\n  DescriptorBuilder.prototype.replaceProperty = function(oldProperty, newProperty, replace) {\n    var oldNameNs = oldProperty.ns;\n\n    var props = this.properties,\n        propertiesByName = this.propertiesByName,\n        rename = oldProperty.name !== newProperty.name;\n\n    if (oldProperty.isId) {\n      if (!newProperty.isId) {\n        throw new Error(\n          'property <' + newProperty.ns.name + '> must be id property ' +\n          'to refine <' + oldProperty.ns.name + '>');\n      }\n\n      this.setIdProperty(newProperty, false);\n    }\n\n    if (oldProperty.isBody) {\n\n      if (!newProperty.isBody) {\n        throw new Error(\n          'property <' + newProperty.ns.name + '> must be body property ' +\n          'to refine <' + oldProperty.ns.name + '>');\n      }\n\n      // TODO: Check compatibility\n      this.setBodyProperty(newProperty, false);\n    }\n\n    // validate existence and get location of old property\n    var idx = props.indexOf(oldProperty);\n    if (idx === -1) {\n      throw new Error('property <' + oldNameNs.name + '> not found in property list');\n    }\n\n    // remove old property\n    props.splice(idx, 1);\n\n    // replacing the named property is intentional\n    //\n    //  * validate only if this is a \"rename\" operation\n    //  * add at specific index unless we \"replace\"\n    //\n    this.addProperty(newProperty, replace ? undefined : idx, rename);\n\n    // make new property available under old name\n    propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;\n  };\n\n\n  DescriptorBuilder.prototype.redefineProperty = function(p, targetPropertyName, replace) {\n\n    var nsPrefix = p.ns.prefix;\n    var parts = targetPropertyName.split('#');\n\n    var name = parseName(parts[0], nsPrefix);\n    var attrName = parseName(parts[1], name.prefix).name;\n\n    var redefinedProperty = this.propertiesByName[attrName];\n    if (!redefinedProperty) {\n      throw new Error('refined property <' + attrName + '> not found');\n    } else {\n      this.replaceProperty(redefinedProperty, p, replace);\n    }\n\n    delete p.redefines;\n  };\n\n  DescriptorBuilder.prototype.addNamedProperty = function(p, validate) {\n    var ns = p.ns,\n        propsByName = this.propertiesByName;\n\n    if (validate) {\n      this.assertNotDefined(p, ns.name);\n      this.assertNotDefined(p, ns.localName);\n    }\n\n    propsByName[ns.name] = propsByName[ns.localName] = p;\n  };\n\n  DescriptorBuilder.prototype.removeNamedProperty = function(p) {\n    var ns = p.ns,\n        propsByName = this.propertiesByName;\n\n    delete propsByName[ns.name];\n    delete propsByName[ns.localName];\n  };\n\n  DescriptorBuilder.prototype.setBodyProperty = function(p, validate) {\n\n    if (validate && this.bodyProperty) {\n      throw new Error(\n        'body property defined multiple times ' +\n        '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');\n    }\n\n    this.bodyProperty = p;\n  };\n\n  DescriptorBuilder.prototype.setIdProperty = function(p, validate) {\n\n    if (validate && this.idProperty) {\n      throw new Error(\n        'id property defined multiple times ' +\n        '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');\n    }\n\n    this.idProperty = p;\n  };\n\n  DescriptorBuilder.prototype.assertNotTrait = function(typeDescriptor) {\n\n    const _extends = typeDescriptor.extends || [];\n\n    if (_extends.length) {\n      throw new Error(\n        `cannot create <${ typeDescriptor.name }> extending <${ typeDescriptor.extends }>`\n      );\n    }\n  };\n\n  DescriptorBuilder.prototype.assertNotDefined = function(p, name) {\n    var propertyName = p.name,\n        definedProperty = this.propertiesByName[propertyName];\n\n    if (definedProperty) {\n      throw new Error(\n        'property <' + propertyName + '> already defined; ' +\n        'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' +\n        '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');\n    }\n  };\n\n  DescriptorBuilder.prototype.hasProperty = function(name) {\n    return this.propertiesByName[name];\n  };\n\n  DescriptorBuilder.prototype.addTrait = function(t, inherited) {\n\n    if (inherited) {\n      this.assertNotTrait(t);\n    }\n\n    var typesByName = this.allTypesByName,\n        types = this.allTypes;\n\n    var typeName = t.name;\n\n    if (typeName in typesByName) {\n      return;\n    }\n\n    forEach$1(t.properties, bind$2(function(p) {\n\n      // clone property to allow extensions\n      p = assign$1({}, p, {\n        name: p.ns.localName,\n        inherited: inherited\n      });\n\n      Object.defineProperty(p, 'definedBy', {\n        value: t\n      });\n\n      var replaces = p.replaces,\n          redefines = p.redefines;\n\n      // add replace/redefine support\n      if (replaces || redefines) {\n        this.redefineProperty(p, replaces || redefines, replaces);\n      } else {\n        if (p.isBody) {\n          this.setBodyProperty(p);\n        }\n        if (p.isId) {\n          this.setIdProperty(p);\n        }\n        this.addProperty(p);\n      }\n    }, this));\n\n    types.push(t);\n    typesByName[typeName] = t;\n  };\n\n  /**\n   * A registry of Moddle packages.\n   *\n   * @param {Array<Package>} packages\n   * @param {Properties} properties\n   */\n  function Registry(packages, properties) {\n    this.packageMap = {};\n    this.typeMap = {};\n\n    this.packages = [];\n\n    this.properties = properties;\n\n    forEach$1(packages, bind$2(this.registerPackage, this));\n  }\n\n\n  Registry.prototype.getPackage = function(uriOrPrefix) {\n    return this.packageMap[uriOrPrefix];\n  };\n\n  Registry.prototype.getPackages = function() {\n    return this.packages;\n  };\n\n\n  Registry.prototype.registerPackage = function(pkg) {\n\n    // copy package\n    pkg = assign$1({}, pkg);\n\n    var pkgMap = this.packageMap;\n\n    ensureAvailable(pkgMap, pkg, 'prefix');\n    ensureAvailable(pkgMap, pkg, 'uri');\n\n    // register types\n    forEach$1(pkg.types, bind$2(function(descriptor) {\n      this.registerType(descriptor, pkg);\n    }, this));\n\n    pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;\n    this.packages.push(pkg);\n  };\n\n\n  /**\n   * Register a type from a specific package with us\n   */\n  Registry.prototype.registerType = function(type, pkg) {\n\n    type = assign$1({}, type, {\n      superClass: (type.superClass || []).slice(),\n      extends: (type.extends || []).slice(),\n      properties: (type.properties || []).slice(),\n      meta: assign$1((type.meta || {}))\n    });\n\n    var ns = parseName(type.name, pkg.prefix),\n        name = ns.name,\n        propertiesByName = {};\n\n    // parse properties\n    forEach$1(type.properties, bind$2(function(p) {\n\n      // namespace property names\n      var propertyNs = parseName(p.name, ns.prefix),\n          propertyName = propertyNs.name;\n\n      // namespace property types\n      if (!isBuiltIn(p.type)) {\n        p.type = parseName(p.type, propertyNs.prefix).name;\n      }\n\n      assign$1(p, {\n        ns: propertyNs,\n        name: propertyName\n      });\n\n      propertiesByName[propertyName] = p;\n    }, this));\n\n    // update ns + name\n    assign$1(type, {\n      ns: ns,\n      name: name,\n      propertiesByName: propertiesByName\n    });\n\n    forEach$1(type.extends, bind$2(function(extendsName) {\n      var extendsNameNs = parseName(extendsName, ns.prefix);\n\n      var extended = this.typeMap[extendsNameNs.name];\n\n      extended.traits = extended.traits || [];\n      extended.traits.push(name);\n    }, this));\n\n    // link to package\n    this.definePackage(type, pkg);\n\n    // register\n    this.typeMap[name] = type;\n  };\n\n\n  /**\n   * Traverse the type hierarchy from bottom to top,\n   * calling iterator with (type, inherited) for all elements in\n   * the inheritance chain.\n   *\n   * @param {Object} nsName\n   * @param {Function} iterator\n   * @param {Boolean} [trait=false]\n   */\n  Registry.prototype.mapTypes = function(nsName, iterator, trait) {\n\n    var type = isBuiltIn(nsName.name) ? { name: nsName.name } : this.typeMap[nsName.name];\n\n    var self = this;\n\n    /**\n     * Traverse the selected super type or trait\n     *\n     * @param {String} cls\n     * @param {Boolean} [trait=false]\n     */\n    function traverse(cls, trait) {\n      var parentNs = parseName(cls, isBuiltIn(cls) ? '' : nsName.prefix);\n      self.mapTypes(parentNs, iterator, trait);\n    }\n\n    /**\n     * Traverse the selected trait.\n     *\n     * @param {String} cls\n     */\n    function traverseTrait(cls) {\n      return traverse(cls, true);\n    }\n\n    /**\n     * Traverse the selected super type\n     *\n     * @param {String} cls\n     */\n    function traverseSuper(cls) {\n      return traverse(cls, false);\n    }\n\n    if (!type) {\n      throw new Error('unknown type <' + nsName.name + '>');\n    }\n\n    forEach$1(type.superClass, trait ? traverseTrait : traverseSuper);\n\n    // call iterator with (type, inherited=!trait)\n    iterator(type, !trait);\n\n    forEach$1(type.traits, traverseTrait);\n  };\n\n\n  /**\n   * Returns the effective descriptor for a type.\n   *\n   * @param  {String} type the namespaced name (ns:localName) of the type\n   *\n   * @return {Descriptor} the resulting effective descriptor\n   */\n  Registry.prototype.getEffectiveDescriptor = function(name) {\n\n    var nsName = parseName(name);\n\n    var builder = new DescriptorBuilder(nsName);\n\n    this.mapTypes(nsName, function(type, inherited) {\n      builder.addTrait(type, inherited);\n    });\n\n    var descriptor = builder.build();\n\n    // define package link\n    this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);\n\n    return descriptor;\n  };\n\n\n  Registry.prototype.definePackage = function(target, pkg) {\n    this.properties.define(target, '$pkg', { value: pkg });\n  };\n\n\n\n  // helpers ////////////////////////////\n\n  function ensureAvailable(packageMap, pkg, identifierKey) {\n\n    var value = pkg[identifierKey];\n\n    if (value in packageMap) {\n      throw new Error('package with ' + identifierKey + ' <' + value + '> already defined');\n    }\n  }\n\n  /**\n   * A utility that gets and sets properties of model elements.\n   *\n   * @param {Model} model\n   */\n  function Properties(model) {\n    this.model = model;\n  }\n\n\n  /**\n   * Sets a named property on the target element.\n   * If the value is undefined, the property gets deleted.\n   *\n   * @param {Object} target\n   * @param {String} name\n   * @param {Object} value\n   */\n  Properties.prototype.set = function(target, name, value) {\n\n    if (!isString(name) || !name.length) {\n      throw new TypeError('property name must be a non-empty string');\n    }\n\n    var property = this.getProperty(target, name);\n\n    var propertyName = property && property.name;\n\n    if (isUndefined(value)) {\n\n      // unset the property, if the specified value is undefined;\n      // delete from $attrs (for extensions) or the target itself\n      if (property) {\n        delete target[propertyName];\n      } else {\n        delete target.$attrs[stripGlobal(name)];\n      }\n    } else {\n\n      // set the property, defining well defined properties on the fly\n      // or simply updating them in target.$attrs (for extensions)\n      if (property) {\n        if (propertyName in target) {\n          target[propertyName] = value;\n        } else {\n          defineProperty(target, property, value);\n        }\n      } else {\n        target.$attrs[stripGlobal(name)] = value;\n      }\n    }\n  };\n\n  /**\n   * Returns the named property of the given element\n   *\n   * @param  {Object} target\n   * @param  {String} name\n   *\n   * @return {Object}\n   */\n  Properties.prototype.get = function(target, name) {\n\n    var property = this.getProperty(target, name);\n\n    if (!property) {\n      return target.$attrs[stripGlobal(name)];\n    }\n\n    var propertyName = property.name;\n\n    // check if access to collection property and lazily initialize it\n    if (!target[propertyName] && property.isMany) {\n      defineProperty(target, property, []);\n    }\n\n    return target[propertyName];\n  };\n\n\n  /**\n   * Define a property on the target element\n   *\n   * @param  {Object} target\n   * @param  {String} name\n   * @param  {Object} options\n   */\n  Properties.prototype.define = function(target, name, options) {\n\n    if (!options.writable) {\n\n      var value = options.value;\n\n      // use getters for read-only variables to support ES6 proxies\n      // cf. https://github.com/bpmn-io/internal-docs/issues/386\n      options = assign$1({}, options, {\n        get: function() { return value; }\n      });\n\n      delete options.value;\n    }\n\n    Object.defineProperty(target, name, options);\n  };\n\n\n  /**\n   * Define the descriptor for an element\n   */\n  Properties.prototype.defineDescriptor = function(target, descriptor) {\n    this.define(target, '$descriptor', { value: descriptor });\n  };\n\n  /**\n   * Define the model for an element\n   */\n  Properties.prototype.defineModel = function(target, model) {\n    this.define(target, '$model', { value: model });\n  };\n\n  /**\n   * Return property with the given name on the element.\n   *\n   * @param {any} target\n   * @param {string} name\n   *\n   * @return {object | null} property\n   */\n  Properties.prototype.getProperty = function(target, name) {\n\n    var model = this.model;\n\n    var property = model.getPropertyDescriptor(target, name);\n\n    if (property) {\n      return property;\n    }\n\n    if (name.includes(':')) {\n      return null;\n    }\n\n    const strict = model.config.strict;\n\n    if (typeof strict !== 'undefined') {\n      const error = new TypeError(`unknown property <${ name }> on <${ target.$type }>`);\n\n      if (strict) {\n        throw error;\n      } else {\n\n        // eslint-disable-next-line no-undef\n        typeof console !== 'undefined' && console.warn(error);\n      }\n    }\n\n    return null;\n  };\n\n  function isUndefined(val) {\n    return typeof val === 'undefined';\n  }\n\n  function defineProperty(target, property, value) {\n    Object.defineProperty(target, property.name, {\n      enumerable: !property.isReference,\n      writable: true,\n      value: value,\n      configurable: true\n    });\n  }\n\n  function stripGlobal(name) {\n    return name.replace(/^:/, '');\n  }\n\n  // Moddle implementation /////////////////////////////////////////////////\n\n  /**\n   * @class Moddle\n   *\n   * A model that can be used to create elements of a specific type.\n   *\n   * @example\n   *\n   * var Moddle = require('moddle');\n   *\n   * var pkg = {\n   *   name: 'mypackage',\n   *   prefix: 'my',\n   *   types: [\n   *     { name: 'Root' }\n   *   ]\n   * };\n   *\n   * var moddle = new Moddle([pkg]);\n   *\n   * @param {Array<Package>} packages the packages to contain\n   *\n   * @param { { strict?: boolean } } [config] moddle configuration\n   */\n  function Moddle(packages, config = {}) {\n\n    this.properties = new Properties(this);\n\n    this.factory = new Factory(this, this.properties);\n    this.registry = new Registry(packages, this.properties);\n\n    this.typeCache = {};\n\n    this.config = config;\n  }\n\n\n  /**\n   * Create an instance of the specified type.\n   *\n   * @method Moddle#create\n   *\n   * @example\n   *\n   * var foo = moddle.create('my:Foo');\n   * var bar = moddle.create('my:Bar', { id: 'BAR_1' });\n   *\n   * @param  {String|Object} descriptor the type descriptor or name know to the model\n   * @param  {Object} attrs   a number of attributes to initialize the model instance with\n   * @return {Object}         model instance\n   */\n  Moddle.prototype.create = function(descriptor, attrs) {\n    var Type = this.getType(descriptor);\n\n    if (!Type) {\n      throw new Error('unknown type <' + descriptor + '>');\n    }\n\n    return new Type(attrs);\n  };\n\n\n  /**\n   * Returns the type representing a given descriptor\n   *\n   * @method Moddle#getType\n   *\n   * @example\n   *\n   * var Foo = moddle.getType('my:Foo');\n   * var foo = new Foo({ 'id' : 'FOO_1' });\n   *\n   * @param  {String|Object} descriptor the type descriptor or name know to the model\n   * @return {Object}         the type representing the descriptor\n   */\n  Moddle.prototype.getType = function(descriptor) {\n\n    var cache = this.typeCache;\n\n    var name = isString(descriptor) ? descriptor : descriptor.ns.name;\n\n    var type = cache[name];\n\n    if (!type) {\n      descriptor = this.registry.getEffectiveDescriptor(name);\n      type = cache[name] = this.factory.createType(descriptor);\n    }\n\n    return type;\n  };\n\n\n  /**\n   * Creates an any-element type to be used within model instances.\n   *\n   * This can be used to create custom elements that lie outside the meta-model.\n   * The created element contains all the meta-data required to serialize it\n   * as part of meta-model elements.\n   *\n   * @method Moddle#createAny\n   *\n   * @example\n   *\n   * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {\n   *   value: 'bar'\n   * });\n   *\n   * var container = moddle.create('my:Container', 'http://my', {\n   *   any: [ foo ]\n   * });\n   *\n   * // go ahead and serialize the stuff\n   *\n   *\n   * @param  {String} name  the name of the element\n   * @param  {String} nsUri the namespace uri of the element\n   * @param  {Object} [properties] a map of properties to initialize the instance with\n   * @return {Object} the any type instance\n   */\n  Moddle.prototype.createAny = function(name, nsUri, properties) {\n\n    var nameNs = parseName(name);\n\n    var element = {\n      $type: name,\n      $instanceOf: function(type) {\n        return type === this.$type;\n      },\n      get: function(key) {\n        return this[key];\n      },\n      set: function(key, value) {\n        set$1(this, [ key ], value);\n      }\n    };\n\n    var descriptor = {\n      name: name,\n      isGeneric: true,\n      ns: {\n        prefix: nameNs.prefix,\n        localName: nameNs.localName,\n        uri: nsUri\n      }\n    };\n\n    this.properties.defineDescriptor(element, descriptor);\n    this.properties.defineModel(element, this);\n    this.properties.define(element, 'get', { enumerable: false, writable: true });\n    this.properties.define(element, 'set', { enumerable: false, writable: true });\n    this.properties.define(element, '$parent', { enumerable: false, writable: true });\n    this.properties.define(element, '$instanceOf', { enumerable: false, writable: true });\n\n    forEach$1(properties, function(a, key) {\n      if (isObject(a) && a.value !== undefined) {\n        element[a.name] = a.value;\n      } else {\n        element[key] = a;\n      }\n    });\n\n    return element;\n  };\n\n  /**\n   * Returns a registered package by uri or prefix\n   *\n   * @return {Object} the package\n   */\n  Moddle.prototype.getPackage = function(uriOrPrefix) {\n    return this.registry.getPackage(uriOrPrefix);\n  };\n\n  /**\n   * Returns a snapshot of all known packages\n   *\n   * @return {Object} the package\n   */\n  Moddle.prototype.getPackages = function() {\n    return this.registry.getPackages();\n  };\n\n  /**\n   * Returns the descriptor for an element\n   */\n  Moddle.prototype.getElementDescriptor = function(element) {\n    return element.$descriptor;\n  };\n\n  /**\n   * Returns true if the given descriptor or instance\n   * represents the given type.\n   *\n   * May be applied to this, if element is omitted.\n   */\n  Moddle.prototype.hasType = function(element, type) {\n    if (type === undefined) {\n      type = element;\n      element = this;\n    }\n\n    var descriptor = element.$model.getElementDescriptor(element);\n\n    return (type in descriptor.allTypesByName);\n  };\n\n  /**\n   * Returns the descriptor of an elements named property\n   */\n  Moddle.prototype.getPropertyDescriptor = function(element, property) {\n    return this.getElementDescriptor(element).propertiesByName[property];\n  };\n\n  /**\n   * Returns a mapped type's descriptor\n   */\n  Moddle.prototype.getTypeDescriptor = function(type) {\n    return this.registry.typeMap[type];\n  };\n\n  var fromCharCode = String.fromCharCode;\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  var ENTITY_PATTERN = /&#(\\d+);|&#x([0-9a-f]+);|&(\\w+);/ig;\n\n  var ENTITY_MAPPING = {\n    'amp': '&',\n    'apos': '\\'',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"'\n  };\n\n  // map UPPERCASE variants of supported special chars\n  Object.keys(ENTITY_MAPPING).forEach(function(k) {\n    ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];\n  });\n\n\n  function replaceEntities(_, d, x, z) {\n\n    // reserved names, i.e. &nbsp;\n    if (z) {\n      if (hasOwnProperty.call(ENTITY_MAPPING, z)) {\n        return ENTITY_MAPPING[z];\n      } else {\n\n        // fall back to original value\n        return '&' + z + ';';\n      }\n    }\n\n    // decimal encoded char\n    if (d) {\n      return fromCharCode(d);\n    }\n\n    // hex encoded char\n    return fromCharCode(parseInt(x, 16));\n  }\n\n\n  /**\n   * A basic entity decoder that can decode a minimal\n   * sub-set of reserved names (&amp;) as well as\n   * hex (&#xaaf;) and decimal (&#1231;) encoded characters.\n   *\n   * @param {string} s\n   *\n   * @return {string} decoded string\n   */\n  function decodeEntities(s) {\n    if (s.length > 3 && s.indexOf('&') !== -1) {\n      return s.replace(ENTITY_PATTERN, replaceEntities);\n    }\n\n    return s;\n  }\n\n  var NON_WHITESPACE_OUTSIDE_ROOT_NODE = 'non-whitespace outside of root node';\n\n  function error$1(msg) {\n    return new Error(msg);\n  }\n\n  function missingNamespaceForPrefix(prefix) {\n    return 'missing namespace for prefix <' + prefix + '>';\n  }\n\n  function getter(getFn) {\n    return {\n      'get': getFn,\n      'enumerable': true\n    };\n  }\n\n  function cloneNsMatrix(nsMatrix) {\n    var clone = {}, key;\n    for (key in nsMatrix) {\n      clone[key] = nsMatrix[key];\n    }\n    return clone;\n  }\n\n  function uriPrefix(prefix) {\n    return prefix + '$uri';\n  }\n\n  function buildNsMatrix(nsUriToPrefix) {\n    var nsMatrix = {},\n        uri,\n        prefix;\n\n    for (uri in nsUriToPrefix) {\n      prefix = nsUriToPrefix[uri];\n      nsMatrix[prefix] = prefix;\n      nsMatrix[uriPrefix(prefix)] = uri;\n    }\n\n    return nsMatrix;\n  }\n\n  function noopGetContext() {\n    return { line: 0, column: 0 };\n  }\n\n  function throwFunc(err) {\n    throw err;\n  }\n\n  /**\n   * Creates a new parser with the given options.\n   *\n   * @constructor\n   *\n   * @param  {!Object<string, ?>=} options\n   */\n  function Parser(options) {\n\n    if (!this) {\n      return new Parser(options);\n    }\n\n    var proxy = options && options['proxy'];\n\n    var onText,\n        onOpenTag,\n        onCloseTag,\n        onCDATA,\n        onError = throwFunc,\n        onWarning,\n        onComment,\n        onQuestion,\n        onAttention;\n\n    var getContext = noopGetContext;\n\n    /**\n     * Do we need to parse the current elements attributes for namespaces?\n     *\n     * @type {boolean}\n     */\n    var maybeNS = false;\n\n    /**\n     * Do we process namespaces at all?\n     *\n     * @type {boolean}\n     */\n    var isNamespace = false;\n\n    /**\n     * The caught error returned on parse end\n     *\n     * @type {Error}\n     */\n    var returnError = null;\n\n    /**\n     * Should we stop parsing?\n     *\n     * @type {boolean}\n     */\n    var parseStop = false;\n\n    /**\n     * A map of { uri: prefix } used by the parser.\n     *\n     * This map will ensure we can normalize prefixes during processing;\n     * for each uri, only one prefix will be exposed to the handlers.\n     *\n     * @type {!Object<string, string>}}\n     */\n    var nsUriToPrefix;\n\n    /**\n     * Handle parse error.\n     *\n     * @param  {string|Error} err\n     */\n    function handleError(err) {\n      if (!(err instanceof Error)) {\n        err = error$1(err);\n      }\n\n      returnError = err;\n\n      onError(err, getContext);\n    }\n\n    /**\n     * Handle parse error.\n     *\n     * @param  {string|Error} err\n     */\n    function handleWarning(err) {\n\n      if (!onWarning) {\n        return;\n      }\n\n      if (!(err instanceof Error)) {\n        err = error$1(err);\n      }\n\n      onWarning(err, getContext);\n    }\n\n    /**\n     * Register parse listener.\n     *\n     * @param  {string}   name\n     * @param  {Function} cb\n     *\n     * @return {Parser}\n     */\n    this['on'] = function(name, cb) {\n\n      if (typeof cb !== 'function') {\n        throw error$1('required args <name, cb>');\n      }\n\n      switch (name) {\n      case 'openTag': onOpenTag = cb; break;\n      case 'text': onText = cb; break;\n      case 'closeTag': onCloseTag = cb; break;\n      case 'error': onError = cb; break;\n      case 'warn': onWarning = cb; break;\n      case 'cdata': onCDATA = cb; break;\n      case 'attention': onAttention = cb; break; // <!XXXXX zzzz=\"eeee\">\n      case 'question': onQuestion = cb; break; // <? ....  ?>\n      case 'comment': onComment = cb; break;\n      default:\n        throw error$1('unsupported event: ' + name);\n      }\n\n      return this;\n    };\n\n    /**\n     * Set the namespace to prefix mapping.\n     *\n     * @example\n     *\n     * parser.ns({\n     *   'http://foo': 'foo',\n     *   'http://bar': 'bar'\n     * });\n     *\n     * @param  {!Object<string, string>} nsMap\n     *\n     * @return {Parser}\n     */\n    this['ns'] = function(nsMap) {\n\n      if (typeof nsMap === 'undefined') {\n        nsMap = {};\n      }\n\n      if (typeof nsMap !== 'object') {\n        throw error$1('required args <nsMap={}>');\n      }\n\n      var _nsUriToPrefix = {}, k;\n\n      for (k in nsMap) {\n        _nsUriToPrefix[k] = nsMap[k];\n      }\n\n      isNamespace = true;\n      nsUriToPrefix = _nsUriToPrefix;\n\n      return this;\n    };\n\n    /**\n     * Parse xml string.\n     *\n     * @param  {string} xml\n     *\n     * @return {Error} returnError, if not thrown\n     */\n    this['parse'] = function(xml) {\n      if (typeof xml !== 'string') {\n        throw error$1('required args <xml=string>');\n      }\n\n      returnError = null;\n\n      parse(xml);\n\n      getContext = noopGetContext;\n      parseStop = false;\n\n      return returnError;\n    };\n\n    /**\n     * Stop parsing.\n     */\n    this['stop'] = function() {\n      parseStop = true;\n    };\n\n    /**\n     * Parse string, invoking configured listeners on element.\n     *\n     * @param  {string} xml\n     */\n    function parse(xml) {\n      var nsMatrixStack = isNamespace ? [] : null,\n          nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,\n          _nsMatrix,\n          nodeStack = [],\n          anonymousNsCount = 0,\n          tagStart = false,\n          tagEnd = false,\n          i = 0, j = 0,\n          x, y, q, w, v,\n          xmlns,\n          elementName,\n          _elementName,\n          elementProxy\n          ;\n\n      var attrsString = '',\n          attrsStart = 0,\n          cachedAttrs // false = parsed with errors, null = needs parsing\n          ;\n\n      /**\n       * Parse attributes on demand and returns the parsed attributes.\n       *\n       * Return semantics: (1) `false` on attribute parse error,\n       * (2) object hash on extracted attrs.\n       *\n       * @return {boolean|Object}\n       */\n      function getAttrs() {\n        if (cachedAttrs !== null) {\n          return cachedAttrs;\n        }\n\n        var nsUri,\n            nsUriPrefix,\n            nsName,\n            defaultAlias = isNamespace && nsMatrix['xmlns'],\n            attrList = isNamespace && maybeNS ? [] : null,\n            i = attrsStart,\n            s = attrsString,\n            l = s.length,\n            hasNewMatrix,\n            newalias,\n            value,\n            alias,\n            name,\n            attrs = {},\n            seenAttrs = {},\n            skipAttr,\n            w,\n            j;\n\n        parseAttr:\n        for (; i < l; i++) {\n          skipAttr = false;\n          w = s.charCodeAt(i);\n\n          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE={ \\f\\n\\r\\t\\v}\n            continue;\n          }\n\n          // wait for non whitespace character\n          if (w < 65 || w > 122 || (w > 90 && w < 97)) {\n            if (w !== 95 && w !== 58) { // char 95\"_\" 58\":\"\n              handleWarning('illegal first char attribute name');\n              skipAttr = true;\n            }\n          }\n\n          // parse attribute name\n          for (j = i + 1; j < l; j++) {\n            w = s.charCodeAt(j);\n\n            if (\n              w > 96 && w < 123 ||\n              w > 64 && w < 91 ||\n              w > 47 && w < 59 ||\n              w === 46 || // '.'\n              w === 45 || // '-'\n              w === 95 // '_'\n            ) {\n              continue;\n            }\n\n            // unexpected whitespace\n            if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n              handleWarning('missing attribute value');\n              i = j;\n\n              continue parseAttr;\n            }\n\n            // expected \"=\"\n            if (w === 61) { // \"=\" == 61\n              break;\n            }\n\n            handleWarning('illegal attribute name char');\n            skipAttr = true;\n          }\n\n          name = s.substring(i, j);\n\n          if (name === 'xmlns:xmlns') {\n            handleWarning('illegal declaration of xmlns');\n            skipAttr = true;\n          }\n\n          w = s.charCodeAt(j + 1);\n\n          if (w === 34) { // '\"'\n            j = s.indexOf('\"', i = j + 2);\n\n            if (j === -1) {\n              j = s.indexOf('\\'', i);\n\n              if (j !== -1) {\n                handleWarning('attribute value quote missmatch');\n                skipAttr = true;\n              }\n            }\n\n          } else if (w === 39) { // \"'\"\n            j = s.indexOf('\\'', i = j + 2);\n\n            if (j === -1) {\n              j = s.indexOf('\"', i);\n\n              if (j !== -1) {\n                handleWarning('attribute value quote missmatch');\n                skipAttr = true;\n              }\n            }\n\n          } else {\n            handleWarning('missing attribute value quotes');\n            skipAttr = true;\n\n            // skip to next space\n            for (j = j + 1; j < l; j++) {\n              w = s.charCodeAt(j + 1);\n\n              if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n                break;\n              }\n            }\n\n          }\n\n          if (j === -1) {\n            handleWarning('missing closing quotes');\n\n            j = l;\n            skipAttr = true;\n          }\n\n          if (!skipAttr) {\n            value = s.substring(i, j);\n          }\n\n          i = j;\n\n          // ensure SPACE follows attribute\n          // skip illegal content otherwise\n          // example a=\"b\"c\n          for (; j + 1 < l; j++) {\n            w = s.charCodeAt(j + 1);\n\n            if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n              break;\n            }\n\n            // FIRST ILLEGAL CHAR\n            if (i === j) {\n              handleWarning('illegal character after attribute end');\n              skipAttr = true;\n            }\n          }\n\n          // advance cursor to next attribute\n          i = j + 1;\n\n          if (skipAttr) {\n            continue parseAttr;\n          }\n\n          // check attribute re-declaration\n          if (name in seenAttrs) {\n            handleWarning('attribute <' + name + '> already defined');\n            continue;\n          }\n\n          seenAttrs[name] = true;\n\n          if (!isNamespace) {\n            attrs[name] = value;\n            continue;\n          }\n\n          // try to extract namespace information\n          if (maybeNS) {\n            newalias = (\n              name === 'xmlns'\n                ? 'xmlns'\n                : (name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:')\n                  ? name.substr(6)\n                  : null\n            );\n\n            // handle xmlns(:alias) assignment\n            if (newalias !== null) {\n              nsUri = decodeEntities(value);\n              nsUriPrefix = uriPrefix(newalias);\n\n              alias = nsUriToPrefix[nsUri];\n\n              if (!alias) {\n\n                // no prefix defined or prefix collision\n                if (\n                  (newalias === 'xmlns') ||\n                  (nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri)\n                ) {\n\n                  // alocate free ns prefix\n                  do {\n                    alias = 'ns' + (anonymousNsCount++);\n                  } while (typeof nsMatrix[alias] !== 'undefined');\n                } else {\n                  alias = newalias;\n                }\n\n                nsUriToPrefix[nsUri] = alias;\n              }\n\n              if (nsMatrix[newalias] !== alias) {\n                if (!hasNewMatrix) {\n                  nsMatrix = cloneNsMatrix(nsMatrix);\n                  hasNewMatrix = true;\n                }\n\n                nsMatrix[newalias] = alias;\n                if (newalias === 'xmlns') {\n                  nsMatrix[uriPrefix(alias)] = nsUri;\n                  defaultAlias = alias;\n                }\n\n                nsMatrix[nsUriPrefix] = nsUri;\n              }\n\n              // expose xmlns(:asd)=\"...\" in attributes\n              attrs[name] = value;\n              continue;\n            }\n\n            // collect attributes until all namespace\n            // declarations are processed\n            attrList.push(name, value);\n            continue;\n\n          } /** end if (maybeNs) */\n\n          // handle attributes on element without\n          // namespace declarations\n          w = name.indexOf(':');\n          if (w === -1) {\n            attrs[name] = value;\n            continue;\n          }\n\n          // normalize ns attribute name\n          if (!(nsName = nsMatrix[name.substring(0, w)])) {\n            handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n            continue;\n          }\n\n          name = defaultAlias === nsName\n            ? name.substr(w + 1)\n            : nsName + name.substr(w);\n\n          // end: normalize ns attribute name\n\n          attrs[name] = value;\n        }\n\n\n        // handle deferred, possibly namespaced attributes\n        if (maybeNS) {\n\n          // normalize captured attributes\n          for (i = 0, l = attrList.length; i < l; i++) {\n\n            name = attrList[i++];\n            value = attrList[i];\n\n            w = name.indexOf(':');\n\n            if (w !== -1) {\n\n              // normalize ns attribute name\n              if (!(nsName = nsMatrix[name.substring(0, w)])) {\n                handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n                continue;\n              }\n\n              name = defaultAlias === nsName\n                ? name.substr(w + 1)\n                : nsName + name.substr(w);\n\n              // end: normalize ns attribute name\n            }\n\n            attrs[name] = value;\n          }\n\n          // end: normalize captured attributes\n        }\n\n        return cachedAttrs = attrs;\n      }\n\n      /**\n       * Extract the parse context { line, column, part }\n       * from the current parser position.\n       *\n       * @return {Object} parse context\n       */\n      function getParseContext() {\n        var splitsRe = /(\\r\\n|\\r|\\n)/g;\n\n        var line = 0;\n        var column = 0;\n        var startOfLine = 0;\n        var endOfLine = j;\n        var match;\n        var data;\n\n        while (i >= startOfLine) {\n\n          match = splitsRe.exec(xml);\n\n          if (!match) {\n            break;\n          }\n\n          // end of line = (break idx + break chars)\n          endOfLine = match[0].length + match.index;\n\n          if (endOfLine > i) {\n            break;\n          }\n\n          // advance to next line\n          line += 1;\n\n          startOfLine = endOfLine;\n        }\n\n        // EOF errors\n        if (i == -1) {\n          column = endOfLine;\n          data = xml.substring(j);\n        } else\n\n        // start errors\n        if (j === 0) {\n          data = xml.substring(j, i);\n        }\n\n        // other errors\n        else {\n          column = i - startOfLine;\n          data = (j == -1 ? xml.substring(i) : xml.substring(i, j + 1));\n        }\n\n        return {\n          'data': data,\n          'line': line,\n          'column': column\n        };\n      }\n\n      getContext = getParseContext;\n\n\n      if (proxy) {\n        elementProxy = Object.create({}, {\n          'name': getter(function() {\n            return elementName;\n          }),\n          'originalName': getter(function() {\n            return _elementName;\n          }),\n          'attrs': getter(getAttrs),\n          'ns': getter(function() {\n            return nsMatrix;\n          })\n        });\n      }\n\n      // actual parse logic\n      while (j !== -1) {\n\n        if (xml.charCodeAt(j) === 60) { // \"<\"\n          i = j;\n        } else {\n          i = xml.indexOf('<', j);\n        }\n\n        // parse end\n        if (i === -1) {\n          if (nodeStack.length) {\n            return handleError('unexpected end of file');\n          }\n\n          if (j === 0) {\n            return handleError('missing start tag');\n          }\n\n          if (j < xml.length) {\n            if (xml.substring(j).trim()) {\n              handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n            }\n          }\n\n          return;\n        }\n\n        // parse text\n        if (j !== i) {\n\n          if (nodeStack.length) {\n            if (onText) {\n              onText(xml.substring(j, i), decodeEntities, getContext);\n\n              if (parseStop) {\n                return;\n              }\n            }\n          } else {\n            if (xml.substring(j, i).trim()) {\n              handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n\n              if (parseStop) {\n                return;\n              }\n            }\n          }\n        }\n\n        w = xml.charCodeAt(i + 1);\n\n        // parse comments + CDATA\n        if (w === 33) { // \"!\"\n          q = xml.charCodeAt(i + 2);\n\n          // CDATA section\n          if (q === 91 && xml.substr(i + 3, 6) === 'CDATA[') { // 91 == \"[\"\n            j = xml.indexOf(']]>', i);\n            if (j === -1) {\n              return handleError('unclosed cdata');\n            }\n\n            if (onCDATA) {\n              onCDATA(xml.substring(i + 9, j), getContext);\n              if (parseStop) {\n                return;\n              }\n            }\n\n            j += 3;\n            continue;\n          }\n\n          // comment\n          if (q === 45 && xml.charCodeAt(i + 3) === 45) { // 45 == \"-\"\n            j = xml.indexOf('-->', i);\n            if (j === -1) {\n              return handleError('unclosed comment');\n            }\n\n\n            if (onComment) {\n              onComment(xml.substring(i + 4, j), decodeEntities, getContext);\n              if (parseStop) {\n                return;\n              }\n            }\n\n            j += 3;\n            continue;\n          }\n        }\n\n        // parse question <? ... ?>\n        if (w === 63) { // \"?\"\n          j = xml.indexOf('?>', i);\n          if (j === -1) {\n            return handleError('unclosed question');\n          }\n\n          if (onQuestion) {\n            onQuestion(xml.substring(i, j + 2), getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n\n          j += 2;\n          continue;\n        }\n\n        // find matching closing tag for attention or standard tags\n        // for that we must skip through attribute values\n        // (enclosed in single or double quotes)\n        for (x = i + 1; ; x++) {\n          v = xml.charCodeAt(x);\n          if (isNaN(v)) {\n            j = -1;\n            return handleError('unclosed tag');\n          }\n\n          // [10] AttValue ::= '\"' ([^<&\"] | Reference)* '\"' | \"'\" ([^<&'] | Reference)* \"'\"\n          // skips the quoted string\n          // (double quotes) does not appear in a literal enclosed by (double quotes)\n          // (single quote) does not appear in a literal enclosed by (single quote)\n          if (v === 34) { //  '\"'\n            q = xml.indexOf('\"', x + 1);\n            x = q !== -1 ? q : x;\n          } else if (v === 39) { // \"'\"\n            q = xml.indexOf(\"'\", x + 1);\n            x = q !== -1 ? q : x;\n          } else if (v === 62) { // '>'\n            j = x;\n            break;\n          }\n        }\n\n\n        // parse attention <! ...>\n        // previously comment and CDATA have already been parsed\n        if (w === 33) { // \"!\"\n\n          if (onAttention) {\n            onAttention(xml.substring(i, j + 1), decodeEntities, getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n\n          j += 1;\n          continue;\n        }\n\n        // don't process attributes;\n        // there are none\n        cachedAttrs = {};\n\n        // if (xml.charCodeAt(i+1) === 47) { // </...\n        if (w === 47) { // </...\n          tagStart = false;\n          tagEnd = true;\n\n          if (!nodeStack.length) {\n            return handleError('missing open tag');\n          }\n\n          // verify open <-> close tag match\n          x = elementName = nodeStack.pop();\n          q = i + 2 + x.length;\n\n          if (xml.substring(i + 2, q) !== x) {\n            return handleError('closing tag mismatch');\n          }\n\n          // verify chars in close tag\n          for (; q < j; q++) {\n            w = xml.charCodeAt(q);\n\n            if (w === 32 || (w > 8 && w < 14)) { // \\f\\n\\r\\t\\v space\n              continue;\n            }\n\n            return handleError('close tag');\n          }\n\n        } else {\n          if (xml.charCodeAt(j - 1) === 47) { // .../>\n            x = elementName = xml.substring(i + 1, j - 1);\n\n            tagStart = true;\n            tagEnd = true;\n\n          } else {\n            x = elementName = xml.substring(i + 1, j);\n\n            tagStart = true;\n            tagEnd = false;\n          }\n\n          if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) { // char 95\"_\" 58\":\"\n            return handleError('illegal first char nodeName');\n          }\n\n          for (q = 1, y = x.length; q < y; q++) {\n            w = x.charCodeAt(q);\n\n            if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {\n              continue;\n            }\n\n            if (w === 32 || (w < 14 && w > 8)) { // \\f\\n\\r\\t\\v space\n              elementName = x.substring(0, q);\n\n              // maybe there are attributes\n              cachedAttrs = null;\n              break;\n            }\n\n            return handleError('invalid nodeName');\n          }\n\n          if (!tagEnd) {\n            nodeStack.push(elementName);\n          }\n        }\n\n        if (isNamespace) {\n\n          _nsMatrix = nsMatrix;\n\n          if (tagStart) {\n\n            // remember old namespace\n            // unless we're self-closing\n            if (!tagEnd) {\n              nsMatrixStack.push(_nsMatrix);\n            }\n\n            if (cachedAttrs === null) {\n\n              // quick check, whether there may be namespace\n              // declarations on the node; if that is the case\n              // we need to eagerly parse the node attributes\n              if ((maybeNS = x.indexOf('xmlns', q) !== -1)) {\n                attrsStart = q;\n                attrsString = x;\n\n                getAttrs();\n\n                maybeNS = false;\n              }\n            }\n          }\n\n          _elementName = elementName;\n\n          w = elementName.indexOf(':');\n          if (w !== -1) {\n            xmlns = nsMatrix[elementName.substring(0, w)];\n\n            // prefix given; namespace must exist\n            if (!xmlns) {\n              return handleError('missing namespace on <' + _elementName + '>');\n            }\n\n            elementName = elementName.substr(w + 1);\n          } else {\n            xmlns = nsMatrix['xmlns'];\n\n            // if no default namespace is defined,\n            // we'll import the element as anonymous.\n            //\n            // it is up to users to correct that to the document defined\n            // targetNamespace, or whatever their undersanding of the\n            // XML spec mandates.\n          }\n\n          // adjust namespace prefixs as configured\n          if (xmlns) {\n            elementName = xmlns + ':' + elementName;\n          }\n\n        }\n\n        if (tagStart) {\n          attrsStart = q;\n          attrsString = x;\n\n          if (onOpenTag) {\n            if (proxy) {\n              onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);\n            } else {\n              onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);\n            }\n\n            if (parseStop) {\n              return;\n            }\n          }\n\n        }\n\n        if (tagEnd) {\n\n          if (onCloseTag) {\n            onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);\n\n            if (parseStop) {\n              return;\n            }\n          }\n\n          // restore old namespace\n          if (isNamespace) {\n            if (!tagStart) {\n              nsMatrix = nsMatrixStack.pop();\n            } else {\n              nsMatrix = _nsMatrix;\n            }\n          }\n        }\n\n        j += 1;\n      }\n    } /** end parse */\n\n  }\n\n  function hasLowerCaseAlias(pkg) {\n    return pkg.xml && pkg.xml.tagAlias === 'lowerCase';\n  }\n\n  var DEFAULT_NS_MAP = {\n    'xsi': 'http://www.w3.org/2001/XMLSchema-instance',\n    'xml': 'http://www.w3.org/XML/1998/namespace'\n  };\n\n  var SERIALIZE_PROPERTY = 'property';\n\n  function getSerialization(element) {\n    return element.xml && element.xml.serialize;\n  }\n\n  function getSerializationType(element) {\n    const type = getSerialization(element);\n\n    return type !== SERIALIZE_PROPERTY && (type || null);\n  }\n\n  function capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  }\n\n  function aliasToName(aliasNs, pkg) {\n\n    if (!hasLowerCaseAlias(pkg)) {\n      return aliasNs.name;\n    }\n\n    return aliasNs.prefix + ':' + capitalize(aliasNs.localName);\n  }\n\n  /**\n   * Un-prefix a potentially prefixed type name.\n   *\n   * @param {NsName} nameNs\n   * @param {Object} [pkg]\n   *\n   * @return {string}\n   */\n  function prefixedToName(nameNs, pkg) {\n\n    var name = nameNs.name,\n        localName = nameNs.localName;\n\n    var typePrefix = pkg && pkg.xml && pkg.xml.typePrefix;\n\n    if (typePrefix && localName.indexOf(typePrefix) === 0) {\n      return nameNs.prefix + ':' + localName.slice(typePrefix.length);\n    } else {\n      return name;\n    }\n  }\n\n  function normalizeTypeName(name, nsMap, model) {\n\n    // normalize against actual NS\n    const nameNs = parseName(name, nsMap.xmlns);\n\n    const normalizedName = `${ nsMap[nameNs.prefix] || nameNs.prefix }:${ nameNs.localName }`;\n\n    const normalizedNameNs = parseName(normalizedName);\n\n    // determine actual type name, based on package-defined prefix\n    var pkg = model.getPackage(normalizedNameNs.prefix);\n\n    return prefixedToName(normalizedNameNs, pkg);\n  }\n\n  function error(message) {\n    return new Error(message);\n  }\n\n  /**\n   * Get the moddle descriptor for a given instance or type.\n   *\n   * @param  {ModdleElement|Function} element\n   *\n   * @return {Object} the moddle descriptor\n   */\n  function getModdleDescriptor(element) {\n    return element.$descriptor;\n  }\n\n\n  /**\n   * A parse context.\n   *\n   * @class\n   *\n   * @param {Object} options\n   * @param {ElementHandler} options.rootHandler the root handler for parsing a document\n   * @param {boolean} [options.lax=false] whether or not to ignore invalid elements\n   */\n  function Context(options) {\n\n    /**\n     * @property {ElementHandler} rootHandler\n     */\n\n    /**\n     * @property {Boolean} lax\n     */\n\n    assign$1(this, options);\n\n    this.elementsById = {};\n    this.references = [];\n    this.warnings = [];\n\n    /**\n     * Add an unresolved reference.\n     *\n     * @param {Object} reference\n     */\n    this.addReference = function(reference) {\n      this.references.push(reference);\n    };\n\n    /**\n     * Add a processed element.\n     *\n     * @param {ModdleElement} element\n     */\n    this.addElement = function(element) {\n\n      if (!element) {\n        throw error('expected element');\n      }\n\n      var elementsById = this.elementsById;\n\n      var descriptor = getModdleDescriptor(element);\n\n      var idProperty = descriptor.idProperty,\n          id;\n\n      if (idProperty) {\n        id = element.get(idProperty.name);\n\n        if (id) {\n\n          // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar\n          if (!/^([a-z][\\w-.]*:)?[a-z_][\\w-.]*$/i.test(id)) {\n            throw new Error('illegal ID <' + id + '>');\n          }\n\n          if (elementsById[id]) {\n            throw error('duplicate ID <' + id + '>');\n          }\n\n          elementsById[id] = element;\n        }\n      }\n    };\n\n    /**\n     * Add an import warning.\n     *\n     * @param {Object} warning\n     * @param {String} warning.message\n     * @param {Error} [warning.error]\n     */\n    this.addWarning = function(warning) {\n      this.warnings.push(warning);\n    };\n  }\n\n  function BaseHandler() {}\n\n  BaseHandler.prototype.handleEnd = function() {};\n  BaseHandler.prototype.handleText = function() {};\n  BaseHandler.prototype.handleNode = function() {};\n\n\n  /**\n   * A simple pass through handler that does nothing except for\n   * ignoring all input it receives.\n   *\n   * This is used to ignore unknown elements and\n   * attributes.\n   */\n  function NoopHandler() { }\n\n  NoopHandler.prototype = Object.create(BaseHandler.prototype);\n\n  NoopHandler.prototype.handleNode = function() {\n    return this;\n  };\n\n  function BodyHandler() {}\n\n  BodyHandler.prototype = Object.create(BaseHandler.prototype);\n\n  BodyHandler.prototype.handleText = function(text) {\n    this.body = (this.body || '') + text;\n  };\n\n  function ReferenceHandler(property, context) {\n    this.property = property;\n    this.context = context;\n  }\n\n  ReferenceHandler.prototype = Object.create(BodyHandler.prototype);\n\n  ReferenceHandler.prototype.handleNode = function(node) {\n\n    if (this.element) {\n      throw error('expected no sub nodes');\n    } else {\n      this.element = this.createReference(node);\n    }\n\n    return this;\n  };\n\n  ReferenceHandler.prototype.handleEnd = function() {\n    this.element.id = this.body;\n  };\n\n  ReferenceHandler.prototype.createReference = function(node) {\n    return {\n      property: this.property.ns.name,\n      id: ''\n    };\n  };\n\n  function ValueHandler(propertyDesc, element) {\n    this.element = element;\n    this.propertyDesc = propertyDesc;\n  }\n\n  ValueHandler.prototype = Object.create(BodyHandler.prototype);\n\n  ValueHandler.prototype.handleEnd = function() {\n\n    var value = this.body || '',\n        element = this.element,\n        propertyDesc = this.propertyDesc;\n\n    value = coerceType(propertyDesc.type, value);\n\n    if (propertyDesc.isMany) {\n      element.get(propertyDesc.name).push(value);\n    } else {\n      element.set(propertyDesc.name, value);\n    }\n  };\n\n\n  function BaseElementHandler() {}\n\n  BaseElementHandler.prototype = Object.create(BodyHandler.prototype);\n\n  BaseElementHandler.prototype.handleNode = function(node) {\n    var parser = this,\n        element = this.element;\n\n    if (!element) {\n      element = this.element = this.createElement(node);\n\n      this.context.addElement(element);\n    } else {\n      parser = this.handleChild(node);\n    }\n\n    return parser;\n  };\n\n  /**\n   * @class Reader.ElementHandler\n   *\n   */\n  function ElementHandler(model, typeName, context) {\n    this.model = model;\n    this.type = model.getType(typeName);\n    this.context = context;\n  }\n\n  ElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\n  ElementHandler.prototype.addReference = function(reference) {\n    this.context.addReference(reference);\n  };\n\n  ElementHandler.prototype.handleText = function(text) {\n\n    var element = this.element,\n        descriptor = getModdleDescriptor(element),\n        bodyProperty = descriptor.bodyProperty;\n\n    if (!bodyProperty) {\n      throw error('unexpected body text <' + text + '>');\n    }\n\n    BodyHandler.prototype.handleText.call(this, text);\n  };\n\n  ElementHandler.prototype.handleEnd = function() {\n\n    var value = this.body,\n        element = this.element,\n        descriptor = getModdleDescriptor(element),\n        bodyProperty = descriptor.bodyProperty;\n\n    if (bodyProperty && value !== undefined) {\n      value = coerceType(bodyProperty.type, value);\n      element.set(bodyProperty.name, value);\n    }\n  };\n\n  /**\n   * Create an instance of the model from the given node.\n   *\n   * @param  {Element} node the xml node\n   */\n  ElementHandler.prototype.createElement = function(node) {\n    var attributes = node.attributes,\n        Type = this.type,\n        descriptor = getModdleDescriptor(Type),\n        context = this.context,\n        instance = new Type({}),\n        model = this.model,\n        propNameNs;\n\n    forEach$1(attributes, function(value, name) {\n\n      var prop = descriptor.propertiesByName[name],\n          values;\n\n      if (prop && prop.isReference) {\n\n        if (!prop.isMany) {\n          context.addReference({\n            element: instance,\n            property: prop.ns.name,\n            id: value\n          });\n        } else {\n\n          // IDREFS: parse references as whitespace-separated list\n          values = value.split(' ');\n\n          forEach$1(values, function(v) {\n            context.addReference({\n              element: instance,\n              property: prop.ns.name,\n              id: v\n            });\n          });\n        }\n\n      } else {\n        if (prop) {\n          value = coerceType(prop.type, value);\n        } else if (name === 'xmlns') {\n          name = ':' + name;\n        } else {\n          propNameNs = parseName(name, descriptor.ns.prefix);\n\n          // check whether attribute is defined in a well-known namespace\n          // if that is the case we emit a warning to indicate potential misuse\n          if (model.getPackage(propNameNs.prefix)) {\n\n            context.addWarning({\n              message: 'unknown attribute <' + name + '>',\n              element: instance,\n              property: name,\n              value: value\n            });\n          }\n        }\n\n        instance.set(name, value);\n      }\n    });\n\n    return instance;\n  };\n\n  ElementHandler.prototype.getPropertyForNode = function(node) {\n\n    var name = node.name;\n    var nameNs = parseName(name);\n\n    var type = this.type,\n        model = this.model,\n        descriptor = getModdleDescriptor(type);\n\n    var propertyName = nameNs.name,\n        property = descriptor.propertiesByName[propertyName];\n\n    // search for properties by name first\n\n    if (property && !property.isAttr) {\n\n      const serializationType = getSerializationType(property);\n\n      if (serializationType) {\n        const elementTypeName = node.attributes[serializationType];\n\n        // type is optional, if it does not exists the\n        // default type is assumed\n        if (elementTypeName) {\n\n          // convert the prefix used to the mapped form, but also\n          // take possible type prefixes from XML\n          // into account, i.e.: xsi:type=\"t{ActualType}\",\n          const normalizedTypeName = normalizeTypeName(elementTypeName, node.ns, model);\n\n          const elementType = model.getType(normalizedTypeName);\n\n          return assign$1({}, property, {\n            effectiveType: getModdleDescriptor(elementType).name\n          });\n        }\n      }\n\n      // search for properties by name first\n      return property;\n    }\n\n    var pkg = model.getPackage(nameNs.prefix);\n\n    if (pkg) {\n      const elementTypeName = aliasToName(nameNs, pkg);\n      const elementType = model.getType(elementTypeName);\n\n      // search for collection members later\n      property = find(descriptor.properties, function(p) {\n        return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);\n      });\n\n      if (property) {\n        return assign$1({}, property, {\n          effectiveType: getModdleDescriptor(elementType).name\n        });\n      }\n    } else {\n\n      // parse unknown element (maybe extension)\n      property = find(descriptor.properties, function(p) {\n        return !p.isReference && !p.isAttribute && p.type === 'Element';\n      });\n\n      if (property) {\n        return property;\n      }\n    }\n\n    throw error('unrecognized element <' + nameNs.name + '>');\n  };\n\n  ElementHandler.prototype.toString = function() {\n    return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';\n  };\n\n  ElementHandler.prototype.valueHandler = function(propertyDesc, element) {\n    return new ValueHandler(propertyDesc, element);\n  };\n\n  ElementHandler.prototype.referenceHandler = function(propertyDesc) {\n    return new ReferenceHandler(propertyDesc, this.context);\n  };\n\n  ElementHandler.prototype.handler = function(type) {\n    if (type === 'Element') {\n      return new GenericElementHandler(this.model, type, this.context);\n    } else {\n      return new ElementHandler(this.model, type, this.context);\n    }\n  };\n\n  /**\n   * Handle the child element parsing\n   *\n   * @param  {Element} node the xml node\n   */\n  ElementHandler.prototype.handleChild = function(node) {\n    var propertyDesc, type, element, childHandler;\n\n    propertyDesc = this.getPropertyForNode(node);\n    element = this.element;\n\n    type = propertyDesc.effectiveType || propertyDesc.type;\n\n    if (isSimple(type)) {\n      return this.valueHandler(propertyDesc, element);\n    }\n\n    if (propertyDesc.isReference) {\n      childHandler = this.referenceHandler(propertyDesc).handleNode(node);\n    } else {\n      childHandler = this.handler(type).handleNode(node);\n    }\n\n    var newElement = childHandler.element;\n\n    // child handles may decide to skip elements\n    // by not returning anything\n    if (newElement !== undefined) {\n\n      if (propertyDesc.isMany) {\n        element.get(propertyDesc.name).push(newElement);\n      } else {\n        element.set(propertyDesc.name, newElement);\n      }\n\n      if (propertyDesc.isReference) {\n        assign$1(newElement, {\n          element: element\n        });\n\n        this.context.addReference(newElement);\n      } else {\n\n        // establish child -> parent relationship\n        newElement.$parent = element;\n      }\n    }\n\n    return childHandler;\n  };\n\n  /**\n   * An element handler that performs special validation\n   * to ensure the node it gets initialized with matches\n   * the handlers type (namespace wise).\n   *\n   * @param {Moddle} model\n   * @param {String} typeName\n   * @param {Context} context\n   */\n  function RootElementHandler(model, typeName, context) {\n    ElementHandler.call(this, model, typeName, context);\n  }\n\n  RootElementHandler.prototype = Object.create(ElementHandler.prototype);\n\n  RootElementHandler.prototype.createElement = function(node) {\n\n    var name = node.name,\n        nameNs = parseName(name),\n        model = this.model,\n        type = this.type,\n        pkg = model.getPackage(nameNs.prefix),\n        typeName = pkg && aliasToName(nameNs, pkg) || name;\n\n    // verify the correct namespace if we parse\n    // the first element in the handler tree\n    //\n    // this ensures we don't mistakenly import wrong namespace elements\n    if (!type.hasType(typeName)) {\n      throw error('unexpected element <' + node.originalName + '>');\n    }\n\n    return ElementHandler.prototype.createElement.call(this, node);\n  };\n\n\n  function GenericElementHandler(model, typeName, context) {\n    this.model = model;\n    this.context = context;\n  }\n\n  GenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\n  GenericElementHandler.prototype.createElement = function(node) {\n\n    var name = node.name,\n        ns = parseName(name),\n        prefix = ns.prefix,\n        uri = node.ns[prefix + '$uri'],\n        attributes = node.attributes;\n\n    return this.model.createAny(name, uri, attributes);\n  };\n\n  GenericElementHandler.prototype.handleChild = function(node) {\n\n    var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),\n        element = this.element;\n\n    var newElement = handler.element,\n        children;\n\n    if (newElement !== undefined) {\n      children = element.$children = element.$children || [];\n      children.push(newElement);\n\n      // establish child -> parent relationship\n      newElement.$parent = element;\n    }\n\n    return handler;\n  };\n\n  GenericElementHandler.prototype.handleEnd = function() {\n    if (this.body) {\n      this.element.$body = this.body;\n    }\n  };\n\n  /**\n   * A reader for a meta-model\n   *\n   * @param {Object} options\n   * @param {Model} options.model used to read xml files\n   * @param {Boolean} options.lax whether to make parse errors warnings\n   */\n  function Reader(options) {\n\n    if (options instanceof Moddle) {\n      options = {\n        model: options\n      };\n    }\n\n    assign$1(this, { lax: false }, options);\n  }\n\n  /**\n   * The fromXML result.\n   *\n   * @typedef {Object} ParseResult\n   *\n   * @property {ModdleElement} rootElement\n   * @property {Array<Object>} references\n   * @property {Array<Error>} warnings\n   * @property {Object} elementsById - a mapping containing each ID -> ModdleElement\n   */\n\n  /**\n   * The fromXML result.\n   *\n   * @typedef {Error} ParseError\n   *\n   * @property {Array<Error>} warnings\n   */\n\n  /**\n   * Parse the given XML into a moddle document tree.\n   *\n   * @param {String} xml\n   * @param {ElementHandler|Object} options or rootHandler\n   *\n   * @returns {Promise<ParseResult, ParseError>}\n   */\n  Reader.prototype.fromXML = function(xml, options, done) {\n\n    var rootHandler = options.rootHandler;\n\n    if (options instanceof ElementHandler) {\n\n      // root handler passed via (xml, { rootHandler: ElementHandler }, ...)\n      rootHandler = options;\n      options = {};\n    } else {\n      if (typeof options === 'string') {\n\n        // rootHandler passed via (xml, 'someString', ...)\n        rootHandler = this.handler(options);\n        options = {};\n      } else if (typeof rootHandler === 'string') {\n\n        // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)\n        rootHandler = this.handler(rootHandler);\n      }\n    }\n\n    var model = this.model,\n        lax = this.lax;\n\n    var context = new Context(assign$1({}, options, { rootHandler: rootHandler })),\n        parser = new Parser({ proxy: true }),\n        stack = createStack();\n\n    rootHandler.context = context;\n\n    // push root handler\n    stack.push(rootHandler);\n\n\n    /**\n     * Handle error.\n     *\n     * @param  {Error} err\n     * @param  {Function} getContext\n     * @param  {boolean} lax\n     *\n     * @return {boolean} true if handled\n     */\n    function handleError(err, getContext, lax) {\n\n      var ctx = getContext();\n\n      var line = ctx.line,\n          column = ctx.column,\n          data = ctx.data;\n\n      // we receive the full context data here,\n      // for elements trim down the information\n      // to the tag name, only\n      if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {\n        data = data.slice(0, data.indexOf(' ')) + '>';\n      }\n\n      var message =\n        'unparsable content ' + (data ? data + ' ' : '') + 'detected\\n\\t' +\n          'line: ' + line + '\\n\\t' +\n          'column: ' + column + '\\n\\t' +\n          'nested error: ' + err.message;\n\n      if (lax) {\n        context.addWarning({\n          message: message,\n          error: err\n        });\n\n        return true;\n      } else {\n        throw error(message);\n      }\n    }\n\n    function handleWarning(err, getContext) {\n\n      // just like handling errors in <lax=true> mode\n      return handleError(err, getContext, true);\n    }\n\n    /**\n     * Resolve collected references on parse end.\n     */\n    function resolveReferences() {\n\n      var elementsById = context.elementsById;\n      var references = context.references;\n\n      var i, r;\n\n      for (i = 0; (r = references[i]); i++) {\n        var element = r.element;\n        var reference = elementsById[r.id];\n        var property = getModdleDescriptor(element).propertiesByName[r.property];\n\n        if (!reference) {\n          context.addWarning({\n            message: 'unresolved reference <' + r.id + '>',\n            element: r.element,\n            property: r.property,\n            value: r.id\n          });\n        }\n\n        if (property.isMany) {\n          var collection = element.get(property.name),\n              idx = collection.indexOf(r);\n\n          // we replace an existing place holder (idx != -1) or\n          // append to the collection instead\n          if (idx === -1) {\n            idx = collection.length;\n          }\n\n          if (!reference) {\n\n            // remove unresolvable reference\n            collection.splice(idx, 1);\n          } else {\n\n            // add or update reference in collection\n            collection[idx] = reference;\n          }\n        } else {\n          element.set(property.name, reference);\n        }\n      }\n    }\n\n    function handleClose() {\n      stack.pop().handleEnd();\n    }\n\n    var PREAMBLE_START_PATTERN = /^<\\?xml /i;\n\n    var ENCODING_PATTERN = / encoding=\"([^\"]+)\"/i;\n\n    var UTF_8_PATTERN = /^utf-8$/i;\n\n    function handleQuestion(question) {\n\n      if (!PREAMBLE_START_PATTERN.test(question)) {\n        return;\n      }\n\n      var match = ENCODING_PATTERN.exec(question);\n      var encoding = match && match[1];\n\n      if (!encoding || UTF_8_PATTERN.test(encoding)) {\n        return;\n      }\n\n      context.addWarning({\n        message:\n          'unsupported document encoding <' + encoding + '>, ' +\n          'falling back to UTF-8'\n      });\n    }\n\n    function handleOpen(node, getContext) {\n      var handler = stack.peek();\n\n      try {\n        stack.push(handler.handleNode(node));\n      } catch (err) {\n\n        if (handleError(err, getContext, lax)) {\n          stack.push(new NoopHandler());\n        }\n      }\n    }\n\n    function handleCData(text, getContext) {\n\n      try {\n        stack.peek().handleText(text);\n      } catch (err) {\n        handleWarning(err, getContext);\n      }\n    }\n\n    function handleText(text, getContext) {\n\n      // strip whitespace only nodes, i.e. before\n      // <!CDATA[ ... ]> sections and in between tags\n\n      if (!text.trim()) {\n        return;\n      }\n\n      handleCData(text, getContext);\n    }\n\n    var uriMap = model.getPackages().reduce(function(uriMap, p) {\n      uriMap[p.uri] = p.prefix;\n\n      return uriMap;\n    }, Object.entries(DEFAULT_NS_MAP).reduce(function(map, [ prefix, url ]) {\n      map[url] = prefix;\n\n      return map;\n    }, model.config && model.config.nsMap || {}));\n\n    parser\n      .ns(uriMap)\n      .on('openTag', function(obj, decodeStr, selfClosing, getContext) {\n\n        // gracefully handle unparsable attributes (attrs=false)\n        var attrs = obj.attrs || {};\n\n        var decodedAttrs = Object.keys(attrs).reduce(function(d, key) {\n          var value = decodeStr(attrs[key]);\n\n          d[key] = value;\n\n          return d;\n        }, {});\n\n        var node = {\n          name: obj.name,\n          originalName: obj.originalName,\n          attributes: decodedAttrs,\n          ns: obj.ns\n        };\n\n        handleOpen(node, getContext);\n      })\n      .on('question', handleQuestion)\n      .on('closeTag', handleClose)\n      .on('cdata', handleCData)\n      .on('text', function(text, decodeEntities, getContext) {\n        handleText(decodeEntities(text), getContext);\n      })\n      .on('error', handleError)\n      .on('warn', handleWarning);\n\n    // async XML parsing to make sure the execution environment\n    // (node or brower) is kept responsive and that certain optimization\n    // strategies can kick in.\n    return new Promise(function(resolve, reject) {\n\n      var err;\n\n      try {\n        parser.parse(xml);\n\n        resolveReferences();\n      } catch (e) {\n        err = e;\n      }\n\n      var rootElement = rootHandler.element;\n\n      if (!err && !rootElement) {\n        err = error('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');\n      }\n\n      var warnings = context.warnings;\n      var references = context.references;\n      var elementsById = context.elementsById;\n\n      if (err) {\n        err.warnings = warnings;\n\n        return reject(err);\n      } else {\n        return resolve({\n          rootElement: rootElement,\n          elementsById: elementsById,\n          references: references,\n          warnings: warnings\n        });\n      }\n    });\n  };\n\n  Reader.prototype.handler = function(name) {\n    return new RootElementHandler(this.model, name);\n  };\n\n\n  // helpers //////////////////////////\n\n  function createStack() {\n    var stack = [];\n\n    Object.defineProperty(stack, 'peek', {\n      value: function() {\n        return this[this.length - 1];\n      }\n    });\n\n    return stack;\n  }\n\n  var XML_PREAMBLE = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n\n  var ESCAPE_ATTR_CHARS = /<|>|'|\"|&|\\n\\r|\\n/g;\n  var ESCAPE_CHARS = /<|>|&/g;\n\n\n  function Namespaces(parent) {\n\n    this.prefixMap = {};\n    this.uriMap = {};\n    this.used = {};\n\n    this.wellknown = [];\n    this.custom = [];\n    this.parent = parent;\n\n    this.defaultPrefixMap = parent && parent.defaultPrefixMap || {};\n  }\n\n  Namespaces.prototype.mapDefaultPrefixes = function(defaultPrefixMap) {\n    this.defaultPrefixMap = defaultPrefixMap;\n  };\n\n  Namespaces.prototype.defaultUriByPrefix = function(prefix) {\n    return this.defaultPrefixMap[prefix];\n  };\n\n  Namespaces.prototype.byUri = function(uri) {\n    return this.uriMap[uri] || (\n      this.parent && this.parent.byUri(uri)\n    );\n  };\n\n  Namespaces.prototype.add = function(ns, isWellknown) {\n\n    this.uriMap[ns.uri] = ns;\n\n    if (isWellknown) {\n      this.wellknown.push(ns);\n    } else {\n      this.custom.push(ns);\n    }\n\n    this.mapPrefix(ns.prefix, ns.uri);\n  };\n\n  Namespaces.prototype.uriByPrefix = function(prefix) {\n    return this.prefixMap[prefix || 'xmlns'] || (\n      this.parent && this.parent.uriByPrefix(prefix)\n    );\n  };\n\n  Namespaces.prototype.mapPrefix = function(prefix, uri) {\n    this.prefixMap[prefix || 'xmlns'] = uri;\n  };\n\n  Namespaces.prototype.getNSKey = function(ns) {\n    return (ns.prefix !== undefined) ? (ns.uri + '|' + ns.prefix) : ns.uri;\n  };\n\n  Namespaces.prototype.logUsed = function(ns) {\n\n    var uri = ns.uri;\n    var nsKey = this.getNSKey(ns);\n\n    this.used[nsKey] = this.byUri(uri);\n\n    // Inform parent recursively about the usage of this NS\n    if (this.parent) {\n      this.parent.logUsed(ns);\n    }\n  };\n\n  Namespaces.prototype.getUsed = function(ns) {\n\n    var allNs = [].concat(this.wellknown, this.custom);\n\n    return allNs.filter(ns => {\n      var nsKey = this.getNSKey(ns);\n\n      return this.used[nsKey];\n    });\n  };\n\n\n  function lower(string) {\n    return string.charAt(0).toLowerCase() + string.slice(1);\n  }\n\n  function nameToAlias(name, pkg) {\n    if (hasLowerCaseAlias(pkg)) {\n      return lower(name);\n    } else {\n      return name;\n    }\n  }\n\n  function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  }\n\n  function nsName(ns) {\n    if (isString(ns)) {\n      return ns;\n    } else {\n      return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;\n    }\n  }\n\n  function getNsAttrs(namespaces) {\n\n    return namespaces.getUsed().filter(function(ns) {\n\n      // do not serialize built in <xml> namespace\n      return ns.prefix !== 'xml';\n    }).map(function(ns) {\n      var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');\n      return { name: name, value: ns.uri };\n    });\n\n  }\n\n  function getElementNs(ns, descriptor) {\n    if (descriptor.isGeneric) {\n      return assign$1({ localName: descriptor.ns.localName }, ns);\n    } else {\n      return assign$1({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns);\n    }\n  }\n\n  function getPropertyNs(ns, descriptor) {\n    return assign$1({ localName: descriptor.ns.localName }, ns);\n  }\n\n  function getSerializableProperties(element) {\n    var descriptor = element.$descriptor;\n\n    return filter(descriptor.properties, function(p) {\n      var name = p.name;\n\n      if (p.isVirtual) {\n        return false;\n      }\n\n      // do not serialize defaults\n      if (!has$1(element, name)) {\n        return false;\n      }\n\n      var value = element[name];\n\n      // do not serialize default equals\n      if (value === p.default) {\n        return false;\n      }\n\n      // do not serialize null properties\n      if (value === null) {\n        return false;\n      }\n\n      return p.isMany ? value.length : true;\n    });\n  }\n\n  var ESCAPE_ATTR_MAP = {\n    '\\n': '#10',\n    '\\n\\r': '#10',\n    '\"': '#34',\n    '\\'': '#39',\n    '<': '#60',\n    '>': '#62',\n    '&': '#38'\n  };\n\n  var ESCAPE_MAP = {\n    '<': 'lt',\n    '>': 'gt',\n    '&': 'amp'\n  };\n\n  function escape(str, charPattern, replaceMap) {\n\n    // ensure we are handling strings here\n    str = isString(str) ? str : '' + str;\n\n    return str.replace(charPattern, function(s) {\n      return '&' + replaceMap[s] + ';';\n    });\n  }\n\n  /**\n   * Escape a string attribute to not contain any bad values (line breaks, '\"', ...)\n   *\n   * @param {String} str the string to escape\n   * @return {String} the escaped string\n   */\n  function escapeAttr(str) {\n    return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);\n  }\n\n  function escapeBody(str) {\n    return escape(str, ESCAPE_CHARS, ESCAPE_MAP);\n  }\n\n  function filterAttributes(props) {\n    return filter(props, function(p) { return p.isAttr; });\n  }\n\n  function filterContained(props) {\n    return filter(props, function(p) { return !p.isAttr; });\n  }\n\n\n  function ReferenceSerializer(tagName) {\n    this.tagName = tagName;\n  }\n\n  ReferenceSerializer.prototype.build = function(element) {\n    this.element = element;\n    return this;\n  };\n\n  ReferenceSerializer.prototype.serializeTo = function(writer) {\n    writer\n      .appendIndent()\n      .append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>')\n      .appendNewLine();\n  };\n\n  function BodySerializer() {}\n\n  BodySerializer.prototype.serializeValue =\n  BodySerializer.prototype.serializeTo = function(writer) {\n    writer.append(\n      this.escape\n        ? escapeBody(this.value)\n        : this.value\n    );\n  };\n\n  BodySerializer.prototype.build = function(prop, value) {\n    this.value = value;\n\n    if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {\n      this.escape = true;\n    }\n\n    return this;\n  };\n\n  function ValueSerializer(tagName) {\n    this.tagName = tagName;\n  }\n\n  inherits(ValueSerializer, BodySerializer);\n\n  ValueSerializer.prototype.serializeTo = function(writer) {\n\n    writer\n      .appendIndent()\n      .append('<' + this.tagName + '>');\n\n    this.serializeValue(writer);\n\n    writer\n      .append('</' + this.tagName + '>')\n      .appendNewLine();\n  };\n\n  function ElementSerializer(parent, propertyDescriptor) {\n    this.body = [];\n    this.attrs = [];\n\n    this.parent = parent;\n    this.propertyDescriptor = propertyDescriptor;\n  }\n\n  ElementSerializer.prototype.build = function(element) {\n    this.element = element;\n\n    var elementDescriptor = element.$descriptor,\n        propertyDescriptor = this.propertyDescriptor;\n\n    var otherAttrs,\n        properties;\n\n    var isGeneric = elementDescriptor.isGeneric;\n\n    if (isGeneric) {\n      otherAttrs = this.parseGenericNsAttributes(element);\n    } else {\n      otherAttrs = this.parseNsAttributes(element);\n    }\n\n    if (propertyDescriptor) {\n      this.ns = this.nsPropertyTagName(propertyDescriptor);\n    } else {\n      this.ns = this.nsTagName(elementDescriptor);\n    }\n\n    // compute tag name\n    this.tagName = this.addTagName(this.ns);\n\n    if (isGeneric) {\n      this.parseGenericContainments(element);\n    } else {\n      properties = getSerializableProperties(element);\n\n      this.parseAttributes(filterAttributes(properties));\n      this.parseContainments(filterContained(properties));\n    }\n\n    this.parseGenericAttributes(element, otherAttrs);\n\n    return this;\n  };\n\n  ElementSerializer.prototype.nsTagName = function(descriptor) {\n    var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n    return getElementNs(effectiveNs, descriptor);\n  };\n\n  ElementSerializer.prototype.nsPropertyTagName = function(descriptor) {\n    var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n    return getPropertyNs(effectiveNs, descriptor);\n  };\n\n  ElementSerializer.prototype.isLocalNs = function(ns) {\n    return ns.uri === this.ns.uri;\n  };\n\n  /**\n   * Get the actual ns attribute name for the given element.\n   *\n   * @param {Object} element\n   * @param {Boolean} [element.inherited=false]\n   *\n   * @return {Object} nsName\n   */\n  ElementSerializer.prototype.nsAttributeName = function(element) {\n\n    var ns;\n\n    if (isString(element)) {\n      ns = parseName(element);\n    } else {\n      ns = element.ns;\n    }\n\n    // return just local name for inherited attributes\n    if (element.inherited) {\n      return { localName: ns.localName };\n    }\n\n    // parse + log effective ns\n    var effectiveNs = this.logNamespaceUsed(ns);\n\n    // LOG ACTUAL namespace use\n    this.getNamespaces().logUsed(effectiveNs);\n\n    // strip prefix if same namespace like parent\n    if (this.isLocalNs(effectiveNs)) {\n      return { localName: ns.localName };\n    } else {\n      return assign$1({ localName: ns.localName }, effectiveNs);\n    }\n  };\n\n  ElementSerializer.prototype.parseGenericNsAttributes = function(element) {\n\n    return Object.entries(element).filter(\n      ([ key, value ]) => !key.startsWith('$') && this.parseNsAttribute(element, key, value)\n    ).map(\n      ([ key, value ]) => ({ name: key, value: value })\n    );\n  };\n\n  ElementSerializer.prototype.parseGenericContainments = function(element) {\n    var body = element.$body;\n\n    if (body) {\n      this.body.push(new BodySerializer().build({ type: 'String' }, body));\n    }\n\n    var children = element.$children;\n\n    if (children) {\n      forEach$1(children, child => {\n        this.body.push(new ElementSerializer(this).build(child));\n      });\n    }\n  };\n\n  ElementSerializer.prototype.parseNsAttribute = function(element, name, value) {\n    var model = element.$model;\n\n    var nameNs = parseName(name);\n\n    var ns;\n\n    // parse xmlns:foo=\"http://foo.bar\"\n    if (nameNs.prefix === 'xmlns') {\n      ns = { prefix: nameNs.localName, uri: value };\n    }\n\n    // parse xmlns=\"http://foo.bar\"\n    if (!nameNs.prefix && nameNs.localName === 'xmlns') {\n      ns = { uri: value };\n    }\n\n    if (!ns) {\n      return {\n        name: name,\n        value: value\n      };\n    }\n\n    if (model && model.getPackage(value)) {\n\n      // register well known namespace\n      this.logNamespace(ns, true, true);\n    } else {\n\n      // log custom namespace directly as used\n      var actualNs = this.logNamespaceUsed(ns, true);\n\n      this.getNamespaces().logUsed(actualNs);\n    }\n  };\n\n\n  /**\n   * Parse namespaces and return a list of left over generic attributes\n   *\n   * @param  {Object} element\n   * @return {Array<Object>}\n   */\n  ElementSerializer.prototype.parseNsAttributes = function(element) {\n    var self = this;\n\n    var genericAttrs = element.$attrs;\n\n    var attributes = [];\n\n    // parse namespace attributes first\n    // and log them. push non namespace attributes to a list\n    // and process them later\n    forEach$1(genericAttrs, function(value, name) {\n\n      var nonNsAttr = self.parseNsAttribute(element, name, value);\n\n      if (nonNsAttr) {\n        attributes.push(nonNsAttr);\n      }\n    });\n\n    return attributes;\n  };\n\n  ElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {\n\n    var self = this;\n\n    forEach$1(attributes, function(attr) {\n\n      try {\n        self.addAttribute(self.nsAttributeName(attr.name), attr.value);\n      } catch (e) {\n\n        // eslint-disable-next-line no-undef\n        typeof console !== 'undefined' && console.warn(\n          `missing namespace information for <${\n          attr.name\n        }=${ attr.value }> on`, element, e\n        );\n      }\n    });\n  };\n\n  ElementSerializer.prototype.parseContainments = function(properties) {\n\n    var self = this,\n        body = this.body,\n        element = this.element;\n\n    forEach$1(properties, function(p) {\n      var value = element.get(p.name),\n          isReference = p.isReference,\n          isMany = p.isMany;\n\n      if (!isMany) {\n        value = [ value ];\n      }\n\n      if (p.isBody) {\n        body.push(new BodySerializer().build(p, value[0]));\n      } else if (isSimple(p.type)) {\n        forEach$1(value, function(v) {\n          body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));\n        });\n      } else if (isReference) {\n        forEach$1(value, function(v) {\n          body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));\n        });\n      } else {\n\n        // allow serialization via type\n        // rather than element name\n        var serialization = getSerialization(p);\n\n        forEach$1(value, function(v) {\n          var serializer;\n\n          if (serialization) {\n            if (serialization === SERIALIZE_PROPERTY) {\n              serializer = new ElementSerializer(self, p);\n            } else {\n              serializer = new TypeSerializer(self, p, serialization);\n            }\n          } else {\n            serializer = new ElementSerializer(self);\n          }\n\n          body.push(serializer.build(v));\n        });\n      }\n    });\n  };\n\n  ElementSerializer.prototype.getNamespaces = function(local) {\n\n    var namespaces = this.namespaces,\n        parent = this.parent,\n        parentNamespaces;\n\n    if (!namespaces) {\n      parentNamespaces = parent && parent.getNamespaces();\n\n      if (local || !parentNamespaces) {\n        this.namespaces = namespaces = new Namespaces(parentNamespaces);\n      } else {\n        namespaces = parentNamespaces;\n      }\n    }\n\n    return namespaces;\n  };\n\n  ElementSerializer.prototype.logNamespace = function(ns, wellknown, local) {\n    var namespaces = this.getNamespaces(local);\n\n    var nsUri = ns.uri,\n        nsPrefix = ns.prefix;\n\n    var existing = namespaces.byUri(nsUri);\n\n    if (!existing || local) {\n      namespaces.add(ns, wellknown);\n    }\n\n    namespaces.mapPrefix(nsPrefix, nsUri);\n\n    return ns;\n  };\n\n  ElementSerializer.prototype.logNamespaceUsed = function(ns, local) {\n    var namespaces = this.getNamespaces(local);\n\n    // ns may be\n    //\n    //   * prefix only\n    //   * prefix:uri\n    //   * localName only\n\n    var prefix = ns.prefix,\n        uri = ns.uri,\n        newPrefix, idx,\n        wellknownUri;\n\n    // handle anonymous namespaces (elementForm=unqualified), cf. #23\n    if (!prefix && !uri) {\n      return { localName: ns.localName };\n    }\n\n    wellknownUri = namespaces.defaultUriByPrefix(prefix);\n\n    uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);\n\n    if (!uri) {\n      throw new Error('no namespace uri given for prefix <' + prefix + '>');\n    }\n\n    ns = namespaces.byUri(uri);\n\n    // register new default prefix <xmlns> in local scope\n    if (!ns && !prefix) {\n      ns = this.logNamespace({ uri }, wellknownUri === uri, true);\n    }\n\n    if (!ns) {\n      newPrefix = prefix;\n      idx = 1;\n\n      // find a prefix that is not mapped yet\n      while (namespaces.uriByPrefix(newPrefix)) {\n        newPrefix = prefix + '_' + idx++;\n      }\n\n      ns = this.logNamespace({ prefix: newPrefix, uri: uri }, wellknownUri === uri);\n    }\n\n    if (prefix) {\n      namespaces.mapPrefix(prefix, uri);\n    }\n\n    return ns;\n  };\n\n  ElementSerializer.prototype.parseAttributes = function(properties) {\n    var self = this,\n        element = this.element;\n\n    forEach$1(properties, function(p) {\n\n      var value = element.get(p.name);\n\n      if (p.isReference) {\n\n        if (!p.isMany) {\n          value = value.id;\n        } else {\n          var values = [];\n          forEach$1(value, function(v) {\n            values.push(v.id);\n          });\n\n          // IDREFS is a whitespace-separated list of references.\n          value = values.join(' ');\n        }\n\n      }\n\n      self.addAttribute(self.nsAttributeName(p), value);\n    });\n  };\n\n  ElementSerializer.prototype.addTagName = function(nsTagName) {\n    var actualNs = this.logNamespaceUsed(nsTagName);\n\n    this.getNamespaces().logUsed(actualNs);\n\n    return nsName(nsTagName);\n  };\n\n  ElementSerializer.prototype.addAttribute = function(name, value) {\n    var attrs = this.attrs;\n\n    if (isString(value)) {\n      value = escapeAttr(value);\n    }\n\n    // de-duplicate attributes\n    // https://github.com/bpmn-io/moddle-xml/issues/66\n    var idx = findIndex(attrs, function(element) {\n      return (\n        element.name.localName === name.localName &&\n        element.name.uri === name.uri &&\n        element.name.prefix === name.prefix\n      );\n    });\n\n    var attr = { name: name, value: value };\n\n    if (idx !== -1) {\n      attrs.splice(idx, 1, attr);\n    } else {\n      attrs.push(attr);\n    }\n  };\n\n  ElementSerializer.prototype.serializeAttributes = function(writer) {\n    var attrs = this.attrs,\n        namespaces = this.namespaces;\n\n    if (namespaces) {\n      attrs = getNsAttrs(namespaces).concat(attrs);\n    }\n\n    forEach$1(attrs, function(a) {\n      writer\n        .append(' ')\n        .append(nsName(a.name)).append('=\"').append(a.value).append('\"');\n    });\n  };\n\n  ElementSerializer.prototype.serializeTo = function(writer) {\n    var firstBody = this.body[0],\n        indent = firstBody && firstBody.constructor !== BodySerializer;\n\n    writer\n      .appendIndent()\n      .append('<' + this.tagName);\n\n    this.serializeAttributes(writer);\n\n    writer.append(firstBody ? '>' : ' />');\n\n    if (firstBody) {\n\n      if (indent) {\n        writer\n          .appendNewLine()\n          .indent();\n      }\n\n      forEach$1(this.body, function(b) {\n        b.serializeTo(writer);\n      });\n\n      if (indent) {\n        writer\n          .unindent()\n          .appendIndent();\n      }\n\n      writer.append('</' + this.tagName + '>');\n    }\n\n    writer.appendNewLine();\n  };\n\n  /**\n   * A serializer for types that handles serialization of data types\n   */\n  function TypeSerializer(parent, propertyDescriptor, serialization) {\n    ElementSerializer.call(this, parent, propertyDescriptor);\n\n    this.serialization = serialization;\n  }\n\n  inherits(TypeSerializer, ElementSerializer);\n\n  TypeSerializer.prototype.parseNsAttributes = function(element) {\n\n    // extracted attributes with serialization attribute\n    // <type=typeName> stripped; it may be later\n    var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element).filter(\n      attr => attr.name !== this.serialization\n    );\n\n    var descriptor = element.$descriptor;\n\n    // only serialize <type=typeName> if necessary\n    if (descriptor.name === this.propertyDescriptor.type) {\n      return attributes;\n    }\n\n    var typeNs = this.typeNs = this.nsTagName(descriptor);\n    this.getNamespaces().logUsed(this.typeNs);\n\n    // add xsi:type attribute to represent the elements\n    // actual type\n\n    var pkg = element.$model.getPackage(typeNs.uri),\n        typePrefix = (pkg.xml && pkg.xml.typePrefix) || '';\n\n    this.addAttribute(\n      this.nsAttributeName(this.serialization),\n      (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName\n    );\n\n    return attributes;\n  };\n\n  TypeSerializer.prototype.isLocalNs = function(ns) {\n    return ns.uri === (this.typeNs || this.ns).uri;\n  };\n\n  function SavingWriter() {\n    this.value = '';\n\n    this.write = function(str) {\n      this.value += str;\n    };\n  }\n\n  function FormatingWriter(out, format) {\n\n    var indent = [ '' ];\n\n    this.append = function(str) {\n      out.write(str);\n\n      return this;\n    };\n\n    this.appendNewLine = function() {\n      if (format) {\n        out.write('\\n');\n      }\n\n      return this;\n    };\n\n    this.appendIndent = function() {\n      if (format) {\n        out.write(indent.join('  '));\n      }\n\n      return this;\n    };\n\n    this.indent = function() {\n      indent.push('');\n      return this;\n    };\n\n    this.unindent = function() {\n      indent.pop();\n      return this;\n    };\n  }\n\n  /**\n   * A writer for meta-model backed document trees\n   *\n   * @param {Object} options output options to pass into the writer\n   */\n  function Writer(options) {\n\n    options = assign$1({ format: false, preamble: true }, options || {});\n\n    function toXML(tree, writer) {\n      var internalWriter = writer || new SavingWriter();\n      var formatingWriter = new FormatingWriter(internalWriter, options.format);\n\n      if (options.preamble) {\n        formatingWriter.append(XML_PREAMBLE);\n      }\n\n      var serializer = new ElementSerializer();\n\n      var model = tree.$model;\n\n      serializer.getNamespaces().mapDefaultPrefixes(getDefaultPrefixMappings(model));\n\n      serializer.build(tree).serializeTo(formatingWriter);\n\n      if (!writer) {\n        return internalWriter.value;\n      }\n    }\n\n    return {\n      toXML: toXML\n    };\n  }\n\n\n  // helpers ///////////\n\n  /**\n   * @param {Moddle} model\n   *\n   * @return { Record<string, string> } map from prefix to URI\n   */\n  function getDefaultPrefixMappings(model) {\n\n    const nsMap = model.config && model.config.nsMap || {};\n\n    const prefixMap = {};\n\n    // { prefix -> uri }\n    for (const prefix in DEFAULT_NS_MAP) {\n      prefixMap[prefix] = DEFAULT_NS_MAP[prefix];\n    }\n\n    // { uri -> prefix }\n    for (const uri in nsMap) {\n      const prefix = nsMap[uri];\n\n      prefixMap[prefix] = uri;\n    }\n\n    for (const pkg of model.getPackages()) {\n      prefixMap[pkg.prefix] = pkg.uri;\n    }\n\n    return prefixMap;\n  }\n\n  /**\r\n   * A sub class of {@link Moddle} with support for import and export of BPMN 2.0 xml files.\r\n   *\r\n   * @class BpmnModdle\r\n   * @extends Moddle\r\n   *\r\n   * @param {Object|Array} packages to use for instantiating the model\r\n   * @param {Object} [options] additional options to pass over\r\n   */\r\n  function BpmnModdle(packages, options) {\r\n    Moddle.call(this, packages, options);\r\n  }\r\n\r\n  BpmnModdle.prototype = Object.create(Moddle.prototype);\r\n\r\n  /**\r\n   * The fromXML result.\r\n   *\r\n   * @typedef {Object} ParseResult\r\n   *\r\n   * @property {ModdleElement} rootElement\r\n   * @property {Array<Object>} references\r\n   * @property {Array<Error>} warnings\r\n   * @property {Object} elementsById - a mapping containing each ID -> ModdleElement\r\n   */\r\n\r\n  /**\r\n   * The fromXML error.\r\n   *\r\n   * @typedef {Error} ParseError\r\n   *\r\n   * @property {Array<Error>} warnings\r\n   */\r\n\r\n  /**\r\n   * Instantiates a BPMN model tree from a given xml string.\r\n   *\r\n   * @param {String}   xmlStr\r\n   * @param {String}   [typeName='bpmn:Definitions'] name of the root element\r\n   * @param {Object}   [options]  options to pass to the underlying reader\r\n   *\r\n   * @returns {Promise<ParseResult, ParseError>}\r\n   */\r\n  BpmnModdle.prototype.fromXML = function(xmlStr, typeName, options) {\r\n\r\n    if (!isString(typeName)) {\r\n      options = typeName;\r\n      typeName = 'bpmn:Definitions';\r\n    }\r\n\r\n    var reader = new Reader(assign$1({ model: this, lax: true }, options));\r\n    var rootHandler = reader.handler(typeName);\r\n\r\n    return reader.fromXML(xmlStr, rootHandler);\r\n  };\r\n\r\n\r\n  /**\r\n   * The toXML result.\r\n   *\r\n   * @typedef {Object} SerializationResult\r\n   *\r\n   * @property {String} xml\r\n   */\r\n\r\n  /**\r\n   * Serializes a BPMN 2.0 object tree to XML.\r\n   *\r\n   * @param {String}   element    the root element, typically an instance of `bpmn:Definitions`\r\n   * @param {Object}   [options]  to pass to the underlying writer\r\n   *\r\n   * @returns {Promise<SerializationResult, Error>}\r\n   */\r\n  BpmnModdle.prototype.toXML = function(element, options) {\r\n\r\n    var writer = new Writer(options);\r\n\r\n    return new Promise(function(resolve, reject) {\r\n      try {\r\n        var result = writer.toXML(element);\r\n\r\n        return resolve({\r\n          xml: result\r\n        });\r\n      } catch (err) {\r\n        return reject(err);\r\n      }\r\n    });\r\n  };\n\n  var name$5 = \"BPMN20\";\n  var uri$5 = \"http://www.omg.org/spec/BPMN/20100524/MODEL\";\n  var prefix$5 = \"bpmn\";\n  var associations$5 = [\n  ];\n  var types$5 = [\n  \t{\n  \t\tname: \"Interface\",\n  \t\tsuperClass: [\n  \t\t\t\"RootElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"operations\",\n  \t\t\t\ttype: \"Operation\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"implementationRef\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Operation\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"inMessageRef\",\n  \t\t\t\ttype: \"Message\",\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"outMessageRef\",\n  \t\t\t\ttype: \"Message\",\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"errorRef\",\n  \t\t\t\ttype: \"Error\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"implementationRef\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"EndPoint\",\n  \t\tsuperClass: [\n  \t\t\t\"RootElement\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Auditing\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"GlobalTask\",\n  \t\tsuperClass: [\n  \t\t\t\"CallableElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"resources\",\n  \t\t\t\ttype: \"ResourceRole\",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Monitoring\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Performer\",\n  \t\tsuperClass: [\n  \t\t\t\"ResourceRole\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Process\",\n  \t\tsuperClass: [\n  \t\t\t\"FlowElementsContainer\",\n  \t\t\t\"CallableElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"processType\",\n  \t\t\t\ttype: \"ProcessType\",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"isClosed\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"auditing\",\n  \t\t\t\ttype: \"Auditing\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"monitoring\",\n  \t\t\t\ttype: \"Monitoring\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"properties\",\n  \t\t\t\ttype: \"Property\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"laneSets\",\n  \t\t\t\tisMany: true,\n  \t\t\t\treplaces: \"FlowElementsContainer#laneSets\",\n  \t\t\t\ttype: \"LaneSet\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"flowElements\",\n  \t\t\t\tisMany: true,\n  \t\t\t\treplaces: \"FlowElementsContainer#flowElements\",\n  \t\t\t\ttype: \"FlowElement\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"artifacts\",\n  \t\t\t\ttype: \"Artifact\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"resources\",\n  \t\t\t\ttype: \"ResourceRole\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"correlationSubscriptions\",\n  \t\t\t\ttype: \"CorrelationSubscription\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"supports\",\n  \t\t\t\ttype: \"Process\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"definitionalCollaborationRef\",\n  \t\t\t\ttype: \"Collaboration\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"isExecutable\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"LaneSet\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"lanes\",\n  \t\t\t\ttype: \"Lane\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Lane\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"partitionElementRef\",\n  \t\t\t\ttype: \"BaseElement\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"partitionElement\",\n  \t\t\t\ttype: \"BaseElement\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"flowNodeRef\",\n  \t\t\t\ttype: \"FlowNode\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"childLaneSet\",\n  \t\t\t\ttype: \"LaneSet\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"xsi:type\"\n  \t\t\t\t}\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"GlobalManualTask\",\n  \t\tsuperClass: [\n  \t\t\t\"GlobalTask\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ManualTask\",\n  \t\tsuperClass: [\n  \t\t\t\"Task\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"UserTask\",\n  \t\tsuperClass: [\n  \t\t\t\"Task\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"renderings\",\n  \t\t\t\ttype: \"Rendering\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"implementation\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Rendering\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"HumanPerformer\",\n  \t\tsuperClass: [\n  \t\t\t\"Performer\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"PotentialOwner\",\n  \t\tsuperClass: [\n  \t\t\t\"HumanPerformer\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"GlobalUserTask\",\n  \t\tsuperClass: [\n  \t\t\t\"GlobalTask\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"implementation\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"renderings\",\n  \t\t\t\ttype: \"Rendering\",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Gateway\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"FlowNode\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"gatewayDirection\",\n  \t\t\t\ttype: \"GatewayDirection\",\n  \t\t\t\t\"default\": \"Unspecified\",\n  \t\t\t\tisAttr: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"EventBasedGateway\",\n  \t\tsuperClass: [\n  \t\t\t\"Gateway\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"instantiate\",\n  \t\t\t\t\"default\": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"eventGatewayType\",\n  \t\t\t\ttype: \"EventBasedGatewayType\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\t\"default\": \"Exclusive\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ComplexGateway\",\n  \t\tsuperClass: [\n  \t\t\t\"Gateway\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"activationCondition\",\n  \t\t\t\ttype: \"Expression\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"xsi:type\"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"default\",\n  \t\t\t\ttype: \"SequenceFlow\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ExclusiveGateway\",\n  \t\tsuperClass: [\n  \t\t\t\"Gateway\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"default\",\n  \t\t\t\ttype: \"SequenceFlow\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"InclusiveGateway\",\n  \t\tsuperClass: [\n  \t\t\t\"Gateway\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"default\",\n  \t\t\t\ttype: \"SequenceFlow\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ParallelGateway\",\n  \t\tsuperClass: [\n  \t\t\t\"Gateway\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"RootElement\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Relationship\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"type\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"direction\",\n  \t\t\t\ttype: \"RelationshipDirection\",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"source\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\ttype: \"Element\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"target\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\ttype: \"Element\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"BaseElement\",\n  \t\tisAbstract: true,\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"id\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\",\n  \t\t\t\tisId: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"documentation\",\n  \t\t\t\ttype: \"Documentation\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"extensionDefinitions\",\n  \t\t\t\ttype: \"ExtensionDefinition\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"extensionElements\",\n  \t\t\t\ttype: \"ExtensionElements\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Extension\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"mustUnderstand\",\n  \t\t\t\t\"default\": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"definition\",\n  \t\t\t\ttype: \"ExtensionDefinition\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ExtensionDefinition\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"extensionAttributeDefinitions\",\n  \t\t\t\ttype: \"ExtensionAttributeDefinition\",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ExtensionAttributeDefinition\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"type\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"isReference\",\n  \t\t\t\t\"default\": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"extensionDefinition\",\n  \t\t\t\ttype: \"ExtensionDefinition\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ExtensionElements\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"valueRef\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\ttype: \"Element\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"values\",\n  \t\t\t\ttype: \"Element\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"extensionAttributeDefinition\",\n  \t\t\t\ttype: \"ExtensionAttributeDefinition\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Documentation\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"text\",\n  \t\t\t\ttype: \"String\",\n  \t\t\t\tisBody: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"textFormat\",\n  \t\t\t\t\"default\": \"text/plain\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Event\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"FlowNode\",\n  \t\t\t\"InteractionNode\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"properties\",\n  \t\t\t\ttype: \"Property\",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"IntermediateCatchEvent\",\n  \t\tsuperClass: [\n  \t\t\t\"CatchEvent\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"IntermediateThrowEvent\",\n  \t\tsuperClass: [\n  \t\t\t\"ThrowEvent\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"EndEvent\",\n  \t\tsuperClass: [\n  \t\t\t\"ThrowEvent\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"StartEvent\",\n  \t\tsuperClass: [\n  \t\t\t\"CatchEvent\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"isInterrupting\",\n  \t\t\t\t\"default\": true,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ThrowEvent\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"Event\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"dataInputs\",\n  \t\t\t\ttype: \"DataInput\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"dataInputAssociations\",\n  \t\t\t\ttype: \"DataInputAssociation\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"inputSet\",\n  \t\t\t\ttype: \"InputSet\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"eventDefinitions\",\n  \t\t\t\ttype: \"EventDefinition\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"eventDefinitionRef\",\n  \t\t\t\ttype: \"EventDefinition\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"CatchEvent\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"Event\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"parallelMultiple\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\",\n  \t\t\t\t\"default\": false\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"dataOutputs\",\n  \t\t\t\ttype: \"DataOutput\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"dataOutputAssociations\",\n  \t\t\t\ttype: \"DataOutputAssociation\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"outputSet\",\n  \t\t\t\ttype: \"OutputSet\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"eventDefinitions\",\n  \t\t\t\ttype: \"EventDefinition\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"eventDefinitionRef\",\n  \t\t\t\ttype: \"EventDefinition\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"BoundaryEvent\",\n  \t\tsuperClass: [\n  \t\t\t\"CatchEvent\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"cancelActivity\",\n  \t\t\t\t\"default\": true,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"attachedToRef\",\n  \t\t\t\ttype: \"Activity\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"EventDefinition\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"RootElement\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"CancelEventDefinition\",\n  \t\tsuperClass: [\n  \t\t\t\"EventDefinition\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ErrorEventDefinition\",\n  \t\tsuperClass: [\n  \t\t\t\"EventDefinition\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"errorRef\",\n  \t\t\t\ttype: \"Error\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"TerminateEventDefinition\",\n  \t\tsuperClass: [\n  \t\t\t\"EventDefinition\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"EscalationEventDefinition\",\n  \t\tsuperClass: [\n  \t\t\t\"EventDefinition\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"escalationRef\",\n  \t\t\t\ttype: \"Escalation\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Escalation\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"structureRef\",\n  \t\t\t\ttype: \"ItemDefinition\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"escalationCode\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t\"RootElement\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"CompensateEventDefinition\",\n  \t\tsuperClass: [\n  \t\t\t\"EventDefinition\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"waitForCompletion\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\",\n  \t\t\t\t\"default\": true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"activityRef\",\n  \t\t\t\ttype: \"Activity\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"TimerEventDefinition\",\n  \t\tsuperClass: [\n  \t\t\t\"EventDefinition\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"timeDate\",\n  \t\t\t\ttype: \"Expression\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"xsi:type\"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"timeCycle\",\n  \t\t\t\ttype: \"Expression\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"xsi:type\"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"timeDuration\",\n  \t\t\t\ttype: \"Expression\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"xsi:type\"\n  \t\t\t\t}\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"LinkEventDefinition\",\n  \t\tsuperClass: [\n  \t\t\t\"EventDefinition\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"target\",\n  \t\t\t\ttype: \"LinkEventDefinition\",\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"source\",\n  \t\t\t\ttype: \"LinkEventDefinition\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"MessageEventDefinition\",\n  \t\tsuperClass: [\n  \t\t\t\"EventDefinition\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"messageRef\",\n  \t\t\t\ttype: \"Message\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"operationRef\",\n  \t\t\t\ttype: \"Operation\",\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ConditionalEventDefinition\",\n  \t\tsuperClass: [\n  \t\t\t\"EventDefinition\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"condition\",\n  \t\t\t\ttype: \"Expression\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"xsi:type\"\n  \t\t\t\t}\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"SignalEventDefinition\",\n  \t\tsuperClass: [\n  \t\t\t\"EventDefinition\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"signalRef\",\n  \t\t\t\ttype: \"Signal\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Signal\",\n  \t\tsuperClass: [\n  \t\t\t\"RootElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"structureRef\",\n  \t\t\t\ttype: \"ItemDefinition\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ImplicitThrowEvent\",\n  \t\tsuperClass: [\n  \t\t\t\"ThrowEvent\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"DataState\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ItemAwareElement\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"itemSubjectRef\",\n  \t\t\t\ttype: \"ItemDefinition\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"dataState\",\n  \t\t\t\ttype: \"DataState\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"DataAssociation\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"sourceRef\",\n  \t\t\t\ttype: \"ItemAwareElement\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"targetRef\",\n  \t\t\t\ttype: \"ItemAwareElement\",\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"transformation\",\n  \t\t\t\ttype: \"FormalExpression\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"property\"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"assignment\",\n  \t\t\t\ttype: \"Assignment\",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"DataInput\",\n  \t\tsuperClass: [\n  \t\t\t\"ItemAwareElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"isCollection\",\n  \t\t\t\t\"default\": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"inputSetRef\",\n  \t\t\t\ttype: \"InputSet\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"inputSetWithOptional\",\n  \t\t\t\ttype: \"InputSet\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"inputSetWithWhileExecuting\",\n  \t\t\t\ttype: \"InputSet\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"DataOutput\",\n  \t\tsuperClass: [\n  \t\t\t\"ItemAwareElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"isCollection\",\n  \t\t\t\t\"default\": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"outputSetRef\",\n  \t\t\t\ttype: \"OutputSet\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"outputSetWithOptional\",\n  \t\t\t\ttype: \"OutputSet\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"outputSetWithWhileExecuting\",\n  \t\t\t\ttype: \"OutputSet\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"InputSet\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"dataInputRefs\",\n  \t\t\t\ttype: \"DataInput\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"optionalInputRefs\",\n  \t\t\t\ttype: \"DataInput\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"whileExecutingInputRefs\",\n  \t\t\t\ttype: \"DataInput\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"outputSetRefs\",\n  \t\t\t\ttype: \"OutputSet\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"OutputSet\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"dataOutputRefs\",\n  \t\t\t\ttype: \"DataOutput\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"inputSetRefs\",\n  \t\t\t\ttype: \"InputSet\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"optionalOutputRefs\",\n  \t\t\t\ttype: \"DataOutput\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"whileExecutingOutputRefs\",\n  \t\t\t\ttype: \"DataOutput\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Property\",\n  \t\tsuperClass: [\n  \t\t\t\"ItemAwareElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"DataInputAssociation\",\n  \t\tsuperClass: [\n  \t\t\t\"DataAssociation\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"DataOutputAssociation\",\n  \t\tsuperClass: [\n  \t\t\t\"DataAssociation\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"InputOutputSpecification\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"dataInputs\",\n  \t\t\t\ttype: \"DataInput\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"dataOutputs\",\n  \t\t\t\ttype: \"DataOutput\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"inputSets\",\n  \t\t\t\ttype: \"InputSet\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"outputSets\",\n  \t\t\t\ttype: \"OutputSet\",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"DataObject\",\n  \t\tsuperClass: [\n  \t\t\t\"FlowElement\",\n  \t\t\t\"ItemAwareElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"isCollection\",\n  \t\t\t\t\"default\": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"InputOutputBinding\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"inputDataRef\",\n  \t\t\t\ttype: \"InputSet\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"outputDataRef\",\n  \t\t\t\ttype: \"OutputSet\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"operationRef\",\n  \t\t\t\ttype: \"Operation\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Assignment\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"from\",\n  \t\t\t\ttype: \"Expression\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"xsi:type\"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"to\",\n  \t\t\t\ttype: \"Expression\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"xsi:type\"\n  \t\t\t\t}\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"DataStore\",\n  \t\tsuperClass: [\n  \t\t\t\"RootElement\",\n  \t\t\t\"ItemAwareElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"capacity\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Integer\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"isUnlimited\",\n  \t\t\t\t\"default\": true,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"DataStoreReference\",\n  \t\tsuperClass: [\n  \t\t\t\"ItemAwareElement\",\n  \t\t\t\"FlowElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"dataStoreRef\",\n  \t\t\t\ttype: \"DataStore\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"DataObjectReference\",\n  \t\tsuperClass: [\n  \t\t\t\"ItemAwareElement\",\n  \t\t\t\"FlowElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"dataObjectRef\",\n  \t\t\t\ttype: \"DataObject\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ConversationLink\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"sourceRef\",\n  \t\t\t\ttype: \"InteractionNode\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"targetRef\",\n  \t\t\t\ttype: \"InteractionNode\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ConversationAssociation\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"innerConversationNodeRef\",\n  \t\t\t\ttype: \"ConversationNode\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"outerConversationNodeRef\",\n  \t\t\t\ttype: \"ConversationNode\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"CallConversation\",\n  \t\tsuperClass: [\n  \t\t\t\"ConversationNode\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"calledCollaborationRef\",\n  \t\t\t\ttype: \"Collaboration\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"participantAssociations\",\n  \t\t\t\ttype: \"ParticipantAssociation\",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Conversation\",\n  \t\tsuperClass: [\n  \t\t\t\"ConversationNode\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"SubConversation\",\n  \t\tsuperClass: [\n  \t\t\t\"ConversationNode\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"conversationNodes\",\n  \t\t\t\ttype: \"ConversationNode\",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ConversationNode\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"InteractionNode\",\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"participantRef\",\n  \t\t\t\ttype: \"Participant\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"messageFlowRefs\",\n  \t\t\t\ttype: \"MessageFlow\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"correlationKeys\",\n  \t\t\t\ttype: \"CorrelationKey\",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"GlobalConversation\",\n  \t\tsuperClass: [\n  \t\t\t\"Collaboration\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"PartnerEntity\",\n  \t\tsuperClass: [\n  \t\t\t\"RootElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"participantRef\",\n  \t\t\t\ttype: \"Participant\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"PartnerRole\",\n  \t\tsuperClass: [\n  \t\t\t\"RootElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"participantRef\",\n  \t\t\t\ttype: \"Participant\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"CorrelationProperty\",\n  \t\tsuperClass: [\n  \t\t\t\"RootElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"correlationPropertyRetrievalExpression\",\n  \t\t\t\ttype: \"CorrelationPropertyRetrievalExpression\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"type\",\n  \t\t\t\ttype: \"ItemDefinition\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Error\",\n  \t\tsuperClass: [\n  \t\t\t\"RootElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"structureRef\",\n  \t\t\t\ttype: \"ItemDefinition\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"errorCode\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"CorrelationKey\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"correlationPropertyRef\",\n  \t\t\t\ttype: \"CorrelationProperty\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Expression\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tisAbstract: false,\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"body\",\n  \t\t\t\tisBody: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"FormalExpression\",\n  \t\tsuperClass: [\n  \t\t\t\"Expression\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"language\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"evaluatesToTypeRef\",\n  \t\t\t\ttype: \"ItemDefinition\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Message\",\n  \t\tsuperClass: [\n  \t\t\t\"RootElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"itemRef\",\n  \t\t\t\ttype: \"ItemDefinition\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ItemDefinition\",\n  \t\tsuperClass: [\n  \t\t\t\"RootElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"itemKind\",\n  \t\t\t\ttype: \"ItemKind\",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"structureRef\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"isCollection\",\n  \t\t\t\t\"default\": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"import\",\n  \t\t\t\ttype: \"Import\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"FlowElement\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"auditing\",\n  \t\t\t\ttype: \"Auditing\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"monitoring\",\n  \t\t\t\ttype: \"Monitoring\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"categoryValueRef\",\n  \t\t\t\ttype: \"CategoryValue\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"SequenceFlow\",\n  \t\tsuperClass: [\n  \t\t\t\"FlowElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"isImmediate\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"conditionExpression\",\n  \t\t\t\ttype: \"Expression\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"xsi:type\"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"sourceRef\",\n  \t\t\t\ttype: \"FlowNode\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"targetRef\",\n  \t\t\t\ttype: \"FlowNode\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"FlowElementsContainer\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"laneSets\",\n  \t\t\t\ttype: \"LaneSet\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"flowElements\",\n  \t\t\t\ttype: \"FlowElement\",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"CallableElement\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"RootElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"ioSpecification\",\n  \t\t\t\ttype: \"InputOutputSpecification\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"property\"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"supportedInterfaceRef\",\n  \t\t\t\ttype: \"Interface\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"ioBinding\",\n  \t\t\t\ttype: \"InputOutputBinding\",\n  \t\t\t\tisMany: true,\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"property\"\n  \t\t\t\t}\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"FlowNode\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"FlowElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"incoming\",\n  \t\t\t\ttype: \"SequenceFlow\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"outgoing\",\n  \t\t\t\ttype: \"SequenceFlow\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"lanes\",\n  \t\t\t\ttype: \"Lane\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"CorrelationPropertyRetrievalExpression\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"messagePath\",\n  \t\t\t\ttype: \"FormalExpression\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"messageRef\",\n  \t\t\t\ttype: \"Message\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"CorrelationPropertyBinding\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"dataPath\",\n  \t\t\t\ttype: \"FormalExpression\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"correlationPropertyRef\",\n  \t\t\t\ttype: \"CorrelationProperty\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Resource\",\n  \t\tsuperClass: [\n  \t\t\t\"RootElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"resourceParameters\",\n  \t\t\t\ttype: \"ResourceParameter\",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ResourceParameter\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"isRequired\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"type\",\n  \t\t\t\ttype: \"ItemDefinition\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"CorrelationSubscription\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"correlationKeyRef\",\n  \t\t\t\ttype: \"CorrelationKey\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"correlationPropertyBinding\",\n  \t\t\t\ttype: \"CorrelationPropertyBinding\",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"MessageFlow\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"sourceRef\",\n  \t\t\t\ttype: \"InteractionNode\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"targetRef\",\n  \t\t\t\ttype: \"InteractionNode\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"messageRef\",\n  \t\t\t\ttype: \"Message\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"MessageFlowAssociation\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"innerMessageFlowRef\",\n  \t\t\t\ttype: \"MessageFlow\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"outerMessageFlowRef\",\n  \t\t\t\ttype: \"MessageFlow\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"InteractionNode\",\n  \t\tisAbstract: true,\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"incomingConversationLinks\",\n  \t\t\t\ttype: \"ConversationLink\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"outgoingConversationLinks\",\n  \t\t\t\ttype: \"ConversationLink\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Participant\",\n  \t\tsuperClass: [\n  \t\t\t\"InteractionNode\",\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"interfaceRef\",\n  \t\t\t\ttype: \"Interface\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"participantMultiplicity\",\n  \t\t\t\ttype: \"ParticipantMultiplicity\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"endPointRefs\",\n  \t\t\t\ttype: \"EndPoint\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"processRef\",\n  \t\t\t\ttype: \"Process\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ParticipantAssociation\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"innerParticipantRef\",\n  \t\t\t\ttype: \"Participant\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"outerParticipantRef\",\n  \t\t\t\ttype: \"Participant\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ParticipantMultiplicity\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"minimum\",\n  \t\t\t\t\"default\": 0,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Integer\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"maximum\",\n  \t\t\t\t\"default\": 1,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Integer\"\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Collaboration\",\n  \t\tsuperClass: [\n  \t\t\t\"RootElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"isClosed\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"participants\",\n  \t\t\t\ttype: \"Participant\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"messageFlows\",\n  \t\t\t\ttype: \"MessageFlow\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"artifacts\",\n  \t\t\t\ttype: \"Artifact\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"conversations\",\n  \t\t\t\ttype: \"ConversationNode\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"conversationAssociations\",\n  \t\t\t\ttype: \"ConversationAssociation\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"participantAssociations\",\n  \t\t\t\ttype: \"ParticipantAssociation\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"messageFlowAssociations\",\n  \t\t\t\ttype: \"MessageFlowAssociation\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"correlationKeys\",\n  \t\t\t\ttype: \"CorrelationKey\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"choreographyRef\",\n  \t\t\t\ttype: \"Choreography\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"conversationLinks\",\n  \t\t\t\ttype: \"ConversationLink\",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ChoreographyActivity\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"FlowNode\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"participantRef\",\n  \t\t\t\ttype: \"Participant\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"initiatingParticipantRef\",\n  \t\t\t\ttype: \"Participant\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"correlationKeys\",\n  \t\t\t\ttype: \"CorrelationKey\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"loopType\",\n  \t\t\t\ttype: \"ChoreographyLoopType\",\n  \t\t\t\t\"default\": \"None\",\n  \t\t\t\tisAttr: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"CallChoreography\",\n  \t\tsuperClass: [\n  \t\t\t\"ChoreographyActivity\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"calledChoreographyRef\",\n  \t\t\t\ttype: \"Choreography\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"participantAssociations\",\n  \t\t\t\ttype: \"ParticipantAssociation\",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"SubChoreography\",\n  \t\tsuperClass: [\n  \t\t\t\"ChoreographyActivity\",\n  \t\t\t\"FlowElementsContainer\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"artifacts\",\n  \t\t\t\ttype: \"Artifact\",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ChoreographyTask\",\n  \t\tsuperClass: [\n  \t\t\t\"ChoreographyActivity\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"messageFlowRef\",\n  \t\t\t\ttype: \"MessageFlow\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Choreography\",\n  \t\tsuperClass: [\n  \t\t\t\"Collaboration\",\n  \t\t\t\"FlowElementsContainer\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"GlobalChoreographyTask\",\n  \t\tsuperClass: [\n  \t\t\t\"Choreography\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"initiatingParticipantRef\",\n  \t\t\t\ttype: \"Participant\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"TextAnnotation\",\n  \t\tsuperClass: [\n  \t\t\t\"Artifact\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"text\",\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"textFormat\",\n  \t\t\t\t\"default\": \"text/plain\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Group\",\n  \t\tsuperClass: [\n  \t\t\t\"Artifact\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"categoryValueRef\",\n  \t\t\t\ttype: \"CategoryValue\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Association\",\n  \t\tsuperClass: [\n  \t\t\t\"Artifact\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"associationDirection\",\n  \t\t\t\ttype: \"AssociationDirection\",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"sourceRef\",\n  \t\t\t\ttype: \"BaseElement\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"targetRef\",\n  \t\t\t\ttype: \"BaseElement\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Category\",\n  \t\tsuperClass: [\n  \t\t\t\"RootElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"categoryValue\",\n  \t\t\t\ttype: \"CategoryValue\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Artifact\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"CategoryValue\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"categorizedFlowElements\",\n  \t\t\t\ttype: \"FlowElement\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"value\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Activity\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"FlowNode\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"isForCompensation\",\n  \t\t\t\t\"default\": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"default\",\n  \t\t\t\ttype: \"SequenceFlow\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"ioSpecification\",\n  \t\t\t\ttype: \"InputOutputSpecification\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"property\"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"boundaryEventRefs\",\n  \t\t\t\ttype: \"BoundaryEvent\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"properties\",\n  \t\t\t\ttype: \"Property\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"dataInputAssociations\",\n  \t\t\t\ttype: \"DataInputAssociation\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"dataOutputAssociations\",\n  \t\t\t\ttype: \"DataOutputAssociation\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"startQuantity\",\n  \t\t\t\t\"default\": 1,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Integer\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"resources\",\n  \t\t\t\ttype: \"ResourceRole\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"completionQuantity\",\n  \t\t\t\t\"default\": 1,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Integer\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"loopCharacteristics\",\n  \t\t\t\ttype: \"LoopCharacteristics\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ServiceTask\",\n  \t\tsuperClass: [\n  \t\t\t\"Task\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"implementation\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"operationRef\",\n  \t\t\t\ttype: \"Operation\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"SubProcess\",\n  \t\tsuperClass: [\n  \t\t\t\"Activity\",\n  \t\t\t\"FlowElementsContainer\",\n  \t\t\t\"InteractionNode\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"triggeredByEvent\",\n  \t\t\t\t\"default\": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"artifacts\",\n  \t\t\t\ttype: \"Artifact\",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"LoopCharacteristics\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"MultiInstanceLoopCharacteristics\",\n  \t\tsuperClass: [\n  \t\t\t\"LoopCharacteristics\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"isSequential\",\n  \t\t\t\t\"default\": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"behavior\",\n  \t\t\t\ttype: \"MultiInstanceBehavior\",\n  \t\t\t\t\"default\": \"All\",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"loopCardinality\",\n  \t\t\t\ttype: \"Expression\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"xsi:type\"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"loopDataInputRef\",\n  \t\t\t\ttype: \"ItemAwareElement\",\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"loopDataOutputRef\",\n  \t\t\t\ttype: \"ItemAwareElement\",\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"inputDataItem\",\n  \t\t\t\ttype: \"DataInput\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"property\"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"outputDataItem\",\n  \t\t\t\ttype: \"DataOutput\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"property\"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"complexBehaviorDefinition\",\n  \t\t\t\ttype: \"ComplexBehaviorDefinition\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"completionCondition\",\n  \t\t\t\ttype: \"Expression\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"xsi:type\"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"oneBehaviorEventRef\",\n  \t\t\t\ttype: \"EventDefinition\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"noneBehaviorEventRef\",\n  \t\t\t\ttype: \"EventDefinition\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"StandardLoopCharacteristics\",\n  \t\tsuperClass: [\n  \t\t\t\"LoopCharacteristics\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"testBefore\",\n  \t\t\t\t\"default\": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"loopCondition\",\n  \t\t\t\ttype: \"Expression\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"xsi:type\"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"loopMaximum\",\n  \t\t\t\ttype: \"Integer\",\n  \t\t\t\tisAttr: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"CallActivity\",\n  \t\tsuperClass: [\n  \t\t\t\"Activity\",\n  \t\t\t\"InteractionNode\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"calledElement\",\n  \t\t\t\ttype: \"String\",\n  \t\t\t\tisAttr: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Task\",\n  \t\tsuperClass: [\n  \t\t\t\"Activity\",\n  \t\t\t\"InteractionNode\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"SendTask\",\n  \t\tsuperClass: [\n  \t\t\t\"Task\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"implementation\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"operationRef\",\n  \t\t\t\ttype: \"Operation\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"messageRef\",\n  \t\t\t\ttype: \"Message\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ReceiveTask\",\n  \t\tsuperClass: [\n  \t\t\t\"Task\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"implementation\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"instantiate\",\n  \t\t\t\t\"default\": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"operationRef\",\n  \t\t\t\ttype: \"Operation\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"messageRef\",\n  \t\t\t\ttype: \"Message\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ScriptTask\",\n  \t\tsuperClass: [\n  \t\t\t\"Task\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"scriptFormat\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"script\",\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"BusinessRuleTask\",\n  \t\tsuperClass: [\n  \t\t\t\"Task\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"implementation\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"AdHocSubProcess\",\n  \t\tsuperClass: [\n  \t\t\t\"SubProcess\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"completionCondition\",\n  \t\t\t\ttype: \"Expression\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"xsi:type\"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"ordering\",\n  \t\t\t\ttype: \"AdHocOrdering\",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"cancelRemainingInstances\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Transaction\",\n  \t\tsuperClass: [\n  \t\t\t\"SubProcess\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"protocol\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"method\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"GlobalScriptTask\",\n  \t\tsuperClass: [\n  \t\t\t\"GlobalTask\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"scriptLanguage\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"script\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"GlobalBusinessRuleTask\",\n  \t\tsuperClass: [\n  \t\t\t\"GlobalTask\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"implementation\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ComplexBehaviorDefinition\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"condition\",\n  \t\t\t\ttype: \"FormalExpression\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"event\",\n  \t\t\t\ttype: \"ImplicitThrowEvent\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ResourceRole\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"resourceRef\",\n  \t\t\t\ttype: \"Resource\",\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"resourceParameterBindings\",\n  \t\t\t\ttype: \"ResourceParameterBinding\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"resourceAssignmentExpression\",\n  \t\t\t\ttype: \"ResourceAssignmentExpression\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ResourceParameterBinding\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"expression\",\n  \t\t\t\ttype: \"Expression\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"xsi:type\"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"parameterRef\",\n  \t\t\t\ttype: \"ResourceParameter\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ResourceAssignmentExpression\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"expression\",\n  \t\t\t\ttype: \"Expression\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"xsi:type\"\n  \t\t\t\t}\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Import\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"importType\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"location\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"namespace\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Definitions\",\n  \t\tsuperClass: [\n  \t\t\t\"BaseElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"targetNamespace\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"expressionLanguage\",\n  \t\t\t\t\"default\": \"http://www.w3.org/1999/XPath\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"typeLanguage\",\n  \t\t\t\t\"default\": \"http://www.w3.org/2001/XMLSchema\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"imports\",\n  \t\t\t\ttype: \"Import\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"extensions\",\n  \t\t\t\ttype: \"Extension\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"rootElements\",\n  \t\t\t\ttype: \"RootElement\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"diagrams\",\n  \t\t\t\tisMany: true,\n  \t\t\t\ttype: \"bpmndi:BPMNDiagram\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"exporter\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"relationships\",\n  \t\t\t\ttype: \"Relationship\",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"exporterVersion\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t}\n  ];\n  var enumerations$3 = [\n  \t{\n  \t\tname: \"ProcessType\",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: \"None\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"Public\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"Private\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"GatewayDirection\",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: \"Unspecified\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"Converging\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"Diverging\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"Mixed\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"EventBasedGatewayType\",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: \"Parallel\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"Exclusive\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"RelationshipDirection\",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: \"None\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"Forward\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"Backward\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"Both\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ItemKind\",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: \"Physical\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"Information\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ChoreographyLoopType\",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: \"None\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"Standard\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"MultiInstanceSequential\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"MultiInstanceParallel\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"AssociationDirection\",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: \"None\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"One\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"Both\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"MultiInstanceBehavior\",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: \"None\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"One\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"All\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"Complex\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"AdHocOrdering\",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: \"Parallel\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"Sequential\"\n  \t\t\t}\n  \t\t]\n  \t}\n  ];\n  var xml$1 = {\n  \ttagAlias: \"lowerCase\",\n  \ttypePrefix: \"t\"\n  };\n  var BpmnPackage = {\n  \tname: name$5,\n  \turi: uri$5,\n  \tprefix: prefix$5,\n  \tassociations: associations$5,\n  \ttypes: types$5,\n  \tenumerations: enumerations$3,\n  \txml: xml$1\n  };\n\n  var name$4 = \"BPMNDI\";\n  var uri$4 = \"http://www.omg.org/spec/BPMN/20100524/DI\";\n  var prefix$4 = \"bpmndi\";\n  var types$4 = [\n  \t{\n  \t\tname: \"BPMNDiagram\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"plane\",\n  \t\t\t\ttype: \"BPMNPlane\",\n  \t\t\t\tredefines: \"di:Diagram#rootElement\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"labelStyle\",\n  \t\t\t\ttype: \"BPMNLabelStyle\",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t\"di:Diagram\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"BPMNPlane\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"bpmnElement\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\ttype: \"bpmn:BaseElement\",\n  \t\t\t\tredefines: \"di:DiagramElement#modelElement\"\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t\"di:Plane\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"BPMNShape\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"bpmnElement\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\ttype: \"bpmn:BaseElement\",\n  \t\t\t\tredefines: \"di:DiagramElement#modelElement\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"isHorizontal\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"isExpanded\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"isMarkerVisible\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"label\",\n  \t\t\t\ttype: \"BPMNLabel\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"isMessageVisible\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Boolean\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"participantBandKind\",\n  \t\t\t\ttype: \"ParticipantBandKind\",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"choreographyActivityShape\",\n  \t\t\t\ttype: \"BPMNShape\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t\"di:LabeledShape\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"BPMNEdge\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"label\",\n  \t\t\t\ttype: \"BPMNLabel\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"bpmnElement\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\ttype: \"bpmn:BaseElement\",\n  \t\t\t\tredefines: \"di:DiagramElement#modelElement\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"sourceElement\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\ttype: \"di:DiagramElement\",\n  \t\t\t\tredefines: \"di:Edge#source\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"targetElement\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\ttype: \"di:DiagramElement\",\n  \t\t\t\tredefines: \"di:Edge#target\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"messageVisibleKind\",\n  \t\t\t\ttype: \"MessageVisibleKind\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\t\"default\": \"initiating\"\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t\"di:LabeledEdge\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"BPMNLabel\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"labelStyle\",\n  \t\t\t\ttype: \"BPMNLabelStyle\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\tredefines: \"di:DiagramElement#style\"\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t\"di:Label\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"BPMNLabelStyle\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"font\",\n  \t\t\t\ttype: \"dc:Font\"\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t\"di:Style\"\n  \t\t]\n  \t}\n  ];\n  var enumerations$2 = [\n  \t{\n  \t\tname: \"ParticipantBandKind\",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: \"top_initiating\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"middle_initiating\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"bottom_initiating\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"top_non_initiating\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"middle_non_initiating\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"bottom_non_initiating\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"MessageVisibleKind\",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: \"initiating\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"non_initiating\"\n  \t\t\t}\n  \t\t]\n  \t}\n  ];\n  var associations$4 = [\n  ];\n  var BpmnDiPackage = {\n  \tname: name$4,\n  \turi: uri$4,\n  \tprefix: prefix$4,\n  \ttypes: types$4,\n  \tenumerations: enumerations$2,\n  \tassociations: associations$4\n  };\n\n  var name$3 = \"DC\";\n  var uri$3 = \"http://www.omg.org/spec/DD/20100524/DC\";\n  var prefix$3 = \"dc\";\n  var types$3 = [\n  \t{\n  \t\tname: \"Boolean\"\n  \t},\n  \t{\n  \t\tname: \"Integer\"\n  \t},\n  \t{\n  \t\tname: \"Real\"\n  \t},\n  \t{\n  \t\tname: \"String\"\n  \t},\n  \t{\n  \t\tname: \"Font\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\ttype: \"String\",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"size\",\n  \t\t\t\ttype: \"Real\",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"isBold\",\n  \t\t\t\ttype: \"Boolean\",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"isItalic\",\n  \t\t\t\ttype: \"Boolean\",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"isUnderline\",\n  \t\t\t\ttype: \"Boolean\",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"isStrikeThrough\",\n  \t\t\t\ttype: \"Boolean\",\n  \t\t\t\tisAttr: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Point\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"x\",\n  \t\t\t\ttype: \"Real\",\n  \t\t\t\t\"default\": \"0\",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"y\",\n  \t\t\t\ttype: \"Real\",\n  \t\t\t\t\"default\": \"0\",\n  \t\t\t\tisAttr: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Bounds\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"x\",\n  \t\t\t\ttype: \"Real\",\n  \t\t\t\t\"default\": \"0\",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"y\",\n  \t\t\t\ttype: \"Real\",\n  \t\t\t\t\"default\": \"0\",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"width\",\n  \t\t\t\ttype: \"Real\",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"height\",\n  \t\t\t\ttype: \"Real\",\n  \t\t\t\tisAttr: true\n  \t\t\t}\n  \t\t]\n  \t}\n  ];\n  var associations$3 = [\n  ];\n  var DcPackage = {\n  \tname: name$3,\n  \turi: uri$3,\n  \tprefix: prefix$3,\n  \ttypes: types$3,\n  \tassociations: associations$3\n  };\n\n  var name$2 = \"DI\";\n  var uri$2 = \"http://www.omg.org/spec/DD/20100524/DI\";\n  var prefix$2 = \"di\";\n  var types$2 = [\n  \t{\n  \t\tname: \"DiagramElement\",\n  \t\tisAbstract: true,\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"id\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisId: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"extension\",\n  \t\t\t\ttype: \"Extension\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"owningDiagram\",\n  \t\t\t\ttype: \"Diagram\",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"owningElement\",\n  \t\t\t\ttype: \"DiagramElement\",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"modelElement\",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\ttype: \"Element\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"style\",\n  \t\t\t\ttype: \"Style\",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"ownedElement\",\n  \t\t\t\ttype: \"DiagramElement\",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Node\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"DiagramElement\"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Edge\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"DiagramElement\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"source\",\n  \t\t\t\ttype: \"DiagramElement\",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"target\",\n  \t\t\t\ttype: \"DiagramElement\",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"waypoint\",\n  \t\t\t\tisUnique: false,\n  \t\t\t\tisMany: true,\n  \t\t\t\ttype: \"dc:Point\",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: \"xsi:type\"\n  \t\t\t\t}\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Diagram\",\n  \t\tisAbstract: true,\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"id\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisId: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"rootElement\",\n  \t\t\t\ttype: \"DiagramElement\",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tisVirtual: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"name\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"documentation\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"resolution\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"Real\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"ownedStyle\",\n  \t\t\t\ttype: \"Style\",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Shape\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"Node\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"bounds\",\n  \t\t\t\ttype: \"dc:Bounds\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Plane\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"Node\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"planeElement\",\n  \t\t\t\ttype: \"DiagramElement\",\n  \t\t\t\tsubsettedProperty: \"DiagramElement-ownedElement\",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"LabeledEdge\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"Edge\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"ownedLabel\",\n  \t\t\t\ttype: \"Label\",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tsubsettedProperty: \"DiagramElement-ownedElement\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"LabeledShape\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"Shape\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"ownedLabel\",\n  \t\t\t\ttype: \"Label\",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tsubsettedProperty: \"DiagramElement-ownedElement\",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Label\",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t\"Node\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"bounds\",\n  \t\t\t\ttype: \"dc:Bounds\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Style\",\n  \t\tisAbstract: true,\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"id\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisId: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"Extension\",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"values\",\n  \t\t\t\tisMany: true,\n  \t\t\t\ttype: \"Element\"\n  \t\t\t}\n  \t\t]\n  \t}\n  ];\n  var associations$2 = [\n  ];\n  var xml = {\n  \ttagAlias: \"lowerCase\"\n  };\n  var DiPackage = {\n  \tname: name$2,\n  \turi: uri$2,\n  \tprefix: prefix$2,\n  \ttypes: types$2,\n  \tassociations: associations$2,\n  \txml: xml\n  };\n\n  var name$1 = \"bpmn.io colors for BPMN\";\n  var uri$1 = \"http://bpmn.io/schema/bpmn/biocolor/1.0\";\n  var prefix$1 = \"bioc\";\n  var types$1 = [\n  \t{\n  \t\tname: \"ColoredShape\",\n  \t\t\"extends\": [\n  \t\t\t\"bpmndi:BPMNShape\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"stroke\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"fill\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ColoredEdge\",\n  \t\t\"extends\": [\n  \t\t\t\"bpmndi:BPMNEdge\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"stroke\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"fill\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t}\n  ];\n  var enumerations$1 = [\n  ];\n  var associations$1 = [\n  ];\n  var BiocPackage = {\n  \tname: name$1,\n  \turi: uri$1,\n  \tprefix: prefix$1,\n  \ttypes: types$1,\n  \tenumerations: enumerations$1,\n  \tassociations: associations$1\n  };\n\n  var name = \"BPMN in Color\";\n  var uri = \"http://www.omg.org/spec/BPMN/non-normative/color/1.0\";\n  var prefix = \"color\";\n  var types = [\n  \t{\n  \t\tname: \"ColoredLabel\",\n  \t\t\"extends\": [\n  \t\t\t\"bpmndi:BPMNLabel\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"color\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ColoredShape\",\n  \t\t\"extends\": [\n  \t\t\t\"bpmndi:BPMNShape\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"background-color\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: \"border-color\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: \"ColoredEdge\",\n  \t\t\"extends\": [\n  \t\t\t\"bpmndi:BPMNEdge\"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: \"border-color\",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: \"String\"\n  \t\t\t}\n  \t\t]\n  \t}\n  ];\n  var enumerations = [\n  ];\n  var associations = [\n  ];\n  var BpmnInColorPackage = {\n  \tname: name,\n  \turi: uri,\n  \tprefix: prefix,\n  \ttypes: types,\n  \tenumerations: enumerations,\n  \tassociations: associations\n  };\n\n  const packages = {\r\n    bpmn: BpmnPackage,\r\n    bpmndi: BpmnDiPackage,\r\n    dc: DcPackage,\r\n    di: DiPackage,\r\n    bioc: BiocPackage,\r\n    color: BpmnInColorPackage\r\n  };\r\n\r\n  function SimpleBpmnModdle(additionalPackages, options) {\r\n    const pks = assign$1({}, packages, additionalPackages);\r\n\r\n    return new BpmnModdle(pks, options);\r\n  }\n\n  /**\r\n   * @typedef {import('../model/Types').ModdleElement} ModdleElement\r\n   */\r\n\r\n\r\n  // TODO(nikku): remove with future bpmn-js version\r\n\r\n  var DI_ERROR_MESSAGE = 'Tried to access di from the businessObject. The di is available through the diagram element only. For more information, see https://github.com/bpmn-io/bpmn-js/issues/1472';\r\n\r\n  /**\r\n   * @private\r\n   *\r\n   * @param {ModdleElement} businessObject\r\n   */\r\n  function ensureCompatDiRef(businessObject) {\r\n\r\n    // bpmnElement can have multiple independent DIs\r\n    if (!has$1(businessObject, 'di')) {\r\n      Object.defineProperty(businessObject, 'di', {\r\n        enumerable: false,\r\n        get: function() {\r\n          throw new Error(DI_ERROR_MESSAGE);\r\n        }\r\n      });\r\n    }\r\n  }\n\n  /**\r\n   * @typedef {import('../model/Types').ModdleElement} ModdleElement\r\n   */\r\n\r\n  /**\r\n   * Returns true if an element is of the given meta-model type.\r\n   *\r\n   * @param {ModdleElement} element\r\n   * @param {string} type\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  function is(element, type) {\r\n    return element.$instanceOf(type);\r\n  }\r\n\r\n\r\n  /**\r\n   * Find a suitable display candidate for definitions where the DI does not\r\n   * correctly specify one.\r\n   *\r\n   * @param {ModdleElement} definitions\r\n   *\r\n   * @return {ModdleElement}\r\n   */\r\n  function findDisplayCandidate(definitions) {\r\n    return find(definitions.rootElements, function(e) {\r\n      return is(e, 'bpmn:Process') || is(e, 'bpmn:Collaboration');\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @param {Record<'element' | 'root' | 'error', Function>} handler\r\n   */\r\n  function BpmnTreeWalker(handler) {\r\n\r\n    // list of containers already walked\r\n    var handledElements = {};\r\n\r\n    // list of elements to handle deferred to ensure\r\n    // prerequisites are drawn\r\n    var deferred = [];\r\n\r\n    var diMap = {};\r\n\r\n    // Helpers //////////////////////\r\n\r\n    function contextual(fn, ctx) {\r\n      return function(e) {\r\n        fn(e, ctx);\r\n      };\r\n    }\r\n\r\n    function handled(element) {\r\n      handledElements[element.id] = element;\r\n    }\r\n\r\n    function isHandled(element) {\r\n      return handledElements[element.id];\r\n    }\r\n\r\n    function visit(element, ctx) {\r\n\r\n      var gfx = element.gfx;\r\n\r\n      // avoid multiple rendering of elements\r\n      if (gfx) {\r\n        throw new Error(\r\n          `already rendered ${ elementToString(element) }`\r\n        );\r\n      }\r\n\r\n      // call handler\r\n      return handler.element(element, diMap[element.id], ctx);\r\n    }\r\n\r\n    function visitRoot(element, diagram) {\r\n      return handler.root(element, diMap[element.id], diagram);\r\n    }\r\n\r\n    function visitIfDi(element, ctx) {\r\n\r\n      try {\r\n        var gfx = diMap[element.id] && visit(element, ctx);\r\n\r\n        handled(element);\r\n\r\n        return gfx;\r\n      } catch (error) {\r\n        logError(error.message, { element, error });\r\n\r\n        console.error(`failed to import ${ elementToString(element) }`, error);\r\n      }\r\n    }\r\n\r\n    function logError(message, context) {\r\n      handler.error(message, context);\r\n    }\r\n\r\n    // DI handling //////////////////////\r\n\r\n    var registerDi = this.registerDi = function registerDi(di) {\r\n      var bpmnElement = di.bpmnElement;\r\n\r\n      if (bpmnElement) {\r\n        if (diMap[bpmnElement.id]) {\r\n          logError(\r\n            `multiple DI elements defined for ${ elementToString(bpmnElement) }`,\r\n            { element: bpmnElement }\r\n          );\r\n        } else {\r\n          diMap[bpmnElement.id] = di;\r\n\r\n          ensureCompatDiRef(bpmnElement);\r\n        }\r\n      } else {\r\n        logError(\r\n          `no bpmnElement referenced in ${ elementToString(di) }`,\r\n          { element: di }\r\n        );\r\n      }\r\n    };\r\n\r\n    function handleDiagram(diagram) {\r\n      handlePlane(diagram.plane);\r\n    }\r\n\r\n    function handlePlane(plane) {\r\n      registerDi(plane);\r\n\r\n      forEach$1(plane.planeElement, handlePlaneElement);\r\n    }\r\n\r\n    function handlePlaneElement(planeElement) {\r\n      registerDi(planeElement);\r\n    }\r\n\r\n\r\n    // Semantic handling //////////////////////\r\n\r\n    /**\r\n     * Handle definitions and return the rendered diagram (if any).\r\n     *\r\n     * @param {ModdleElement} definitions to walk and import\r\n     * @param {ModdleElement} [diagram] specific diagram to import and display\r\n     *\r\n     * @throws {Error} if no diagram to display could be found\r\n     */\r\n    this.handleDefinitions = function handleDefinitions(definitions, diagram) {\r\n\r\n      // make sure we walk the correct bpmnElement\r\n\r\n      var diagrams = definitions.diagrams;\r\n\r\n      if (diagram && diagrams.indexOf(diagram) === -1) {\r\n        throw new Error('diagram not part of <bpmn:Definitions />');\r\n      }\r\n\r\n      if (!diagram && diagrams && diagrams.length) {\r\n        diagram = diagrams[0];\r\n      }\r\n\r\n      // no diagram -> nothing to import\r\n      if (!diagram) {\r\n        throw new Error('no diagram to display');\r\n      }\r\n\r\n      // load DI from selected diagram only\r\n      diMap = {};\r\n      handleDiagram(diagram);\r\n\r\n\r\n      var plane = diagram.plane;\r\n\r\n      if (!plane) {\r\n        throw new Error(\r\n          `no plane for ${ elementToString(diagram) }`\r\n        );\r\n      }\r\n\r\n      var rootElement = plane.bpmnElement;\r\n\r\n      // ensure we default to a suitable display candidate (process or collaboration),\r\n      // even if non is specified in DI\r\n      if (!rootElement) {\r\n        rootElement = findDisplayCandidate(definitions);\r\n\r\n        if (!rootElement) {\r\n          throw new Error('no process or collaboration to display');\r\n        } else {\r\n\r\n          logError(\r\n            `correcting missing bpmnElement on ${ elementToString(plane) } to ${ elementToString(rootElement) }`\r\n          );\r\n\r\n          // correct DI on the fly\r\n          plane.bpmnElement = rootElement;\r\n          registerDi(plane);\r\n        }\r\n      }\r\n\r\n\r\n      var ctx = visitRoot(rootElement, plane);\r\n\r\n      if (is(rootElement, 'bpmn:Process') || is(rootElement, 'bpmn:SubProcess')) {\r\n        handleProcess(rootElement, ctx);\r\n      } else if (is(rootElement, 'bpmn:Collaboration')) {\r\n        handleCollaboration(rootElement, ctx);\r\n\r\n        // force drawing of everything not yet drawn that is part of the target DI\r\n        handleUnhandledProcesses(definitions.rootElements, ctx);\r\n      } else {\r\n        throw new Error(\r\n          `unsupported bpmnElement for ${ elementToString(plane) }: ${ elementToString(rootElement) }`\r\n        );\r\n      }\r\n\r\n      // handle all deferred elements\r\n      handleDeferred(deferred);\r\n    };\r\n\r\n    var handleDeferred = this.handleDeferred = function handleDeferred() {\r\n\r\n      var fn;\r\n\r\n      // drain deferred until empty\r\n      while (deferred.length) {\r\n        fn = deferred.shift();\r\n\r\n        fn();\r\n      }\r\n    };\r\n\r\n    function handleProcess(process, context) {\r\n      handleFlowElementsContainer(process, context);\r\n      handleIoSpecification(process.ioSpecification, context);\r\n\r\n      handleArtifacts(process.artifacts, context);\r\n\r\n      // log process handled\r\n      handled(process);\r\n    }\r\n\r\n    function handleUnhandledProcesses(rootElements, ctx) {\r\n\r\n      // walk through all processes that have not yet been drawn and draw them\r\n      // if they contain lanes with DI information.\r\n      // we do this to pass the free-floating lane test cases in the MIWG test suite\r\n      var processes = filter(rootElements, function(e) {\r\n        return !isHandled(e) && is(e, 'bpmn:Process') && e.laneSets;\r\n      });\r\n\r\n      processes.forEach(contextual(handleProcess, ctx));\r\n    }\r\n\r\n    function handleMessageFlow(messageFlow, context) {\r\n      visitIfDi(messageFlow, context);\r\n    }\r\n\r\n    function handleMessageFlows(messageFlows, context) {\r\n      forEach$1(messageFlows, contextual(handleMessageFlow, context));\r\n    }\r\n\r\n    function handleDataAssociation(association, context) {\r\n      visitIfDi(association, context);\r\n    }\r\n\r\n    function handleDataInput(dataInput, context) {\r\n      visitIfDi(dataInput, context);\r\n    }\r\n\r\n    function handleDataOutput(dataOutput, context) {\r\n      visitIfDi(dataOutput, context);\r\n    }\r\n\r\n    function handleArtifact(artifact, context) {\r\n\r\n      // bpmn:TextAnnotation\r\n      // bpmn:Group\r\n      // bpmn:Association\r\n\r\n      visitIfDi(artifact, context);\r\n    }\r\n\r\n    function handleArtifacts(artifacts, context) {\r\n\r\n      forEach$1(artifacts, function(e) {\r\n        if (is(e, 'bpmn:Association')) {\r\n          deferred.push(function() {\r\n            handleArtifact(e, context);\r\n          });\r\n        } else {\r\n          handleArtifact(e, context);\r\n        }\r\n      });\r\n    }\r\n\r\n    function handleIoSpecification(ioSpecification, context) {\r\n\r\n      if (!ioSpecification) {\r\n        return;\r\n      }\r\n\r\n      forEach$1(ioSpecification.dataInputs, contextual(handleDataInput, context));\r\n      forEach$1(ioSpecification.dataOutputs, contextual(handleDataOutput, context));\r\n    }\r\n\r\n    var handleSubProcess = this.handleSubProcess = function handleSubProcess(subProcess, context) {\r\n      handleFlowElementsContainer(subProcess, context);\r\n      handleArtifacts(subProcess.artifacts, context);\r\n    };\r\n\r\n    function handleFlowNode(flowNode, context) {\r\n      var childCtx = visitIfDi(flowNode, context);\r\n\r\n      if (is(flowNode, 'bpmn:SubProcess')) {\r\n        handleSubProcess(flowNode, childCtx || context);\r\n      }\r\n\r\n      if (is(flowNode, 'bpmn:Activity')) {\r\n        handleIoSpecification(flowNode.ioSpecification, context);\r\n      }\r\n\r\n      // defer handling of associations\r\n      // affected types:\r\n      //\r\n      //   * bpmn:Activity\r\n      //   * bpmn:ThrowEvent\r\n      //   * bpmn:CatchEvent\r\n      //\r\n      deferred.push(function() {\r\n        forEach$1(flowNode.dataInputAssociations, contextual(handleDataAssociation, context));\r\n        forEach$1(flowNode.dataOutputAssociations, contextual(handleDataAssociation, context));\r\n      });\r\n    }\r\n\r\n    function handleSequenceFlow(sequenceFlow, context) {\r\n      visitIfDi(sequenceFlow, context);\r\n    }\r\n\r\n    function handleDataElement(dataObject, context) {\r\n      visitIfDi(dataObject, context);\r\n    }\r\n\r\n    function handleLane(lane, context) {\r\n\r\n      deferred.push(function() {\r\n\r\n        var newContext = visitIfDi(lane, context);\r\n\r\n        if (lane.childLaneSet) {\r\n          handleLaneSet(lane.childLaneSet, newContext || context);\r\n        }\r\n\r\n        wireFlowNodeRefs(lane);\r\n      });\r\n    }\r\n\r\n    function handleLaneSet(laneSet, context) {\r\n      forEach$1(laneSet.lanes, contextual(handleLane, context));\r\n    }\r\n\r\n    function handleLaneSets(laneSets, context) {\r\n      forEach$1(laneSets, contextual(handleLaneSet, context));\r\n    }\r\n\r\n    function handleFlowElementsContainer(container, context) {\r\n      handleFlowElements(container.flowElements, context);\r\n\r\n      if (container.laneSets) {\r\n        handleLaneSets(container.laneSets, context);\r\n      }\r\n    }\r\n\r\n    function handleFlowElements(flowElements, context) {\r\n      forEach$1(flowElements, function(flowElement) {\r\n        if (is(flowElement, 'bpmn:SequenceFlow')) {\r\n          deferred.push(function() {\r\n            handleSequenceFlow(flowElement, context);\r\n          });\r\n        } else if (is(flowElement, 'bpmn:BoundaryEvent')) {\r\n          deferred.unshift(function() {\r\n            handleFlowNode(flowElement, context);\r\n          });\r\n        } else if (is(flowElement, 'bpmn:FlowNode')) {\r\n          handleFlowNode(flowElement, context);\r\n        } else if (is(flowElement, 'bpmn:DataObject')) ; else if (is(flowElement, 'bpmn:DataStoreReference')) {\r\n          handleDataElement(flowElement, context);\r\n        } else if (is(flowElement, 'bpmn:DataObjectReference')) {\r\n          handleDataElement(flowElement, context);\r\n        } else {\r\n          logError(\r\n            `unrecognized flowElement ${ elementToString(flowElement) } in context ${ elementToString(context && context.businessObject) }`,\r\n            {\r\n              element: flowElement,\r\n              context\r\n            }\r\n          );\r\n        }\r\n      });\r\n    }\r\n\r\n    function handleParticipant(participant, context) {\r\n      var newCtx = visitIfDi(participant, context);\r\n\r\n      var process = participant.processRef;\r\n      if (process) {\r\n        handleProcess(process, newCtx || context);\r\n      }\r\n    }\r\n\r\n    function handleCollaboration(collaboration, context) {\r\n\r\n      forEach$1(collaboration.participants, contextual(handleParticipant, context));\r\n\r\n      deferred.push(function() {\r\n        handleMessageFlows(collaboration.messageFlows, context);\r\n      });\r\n\r\n      handleArtifacts(collaboration.artifacts, context);\r\n    }\r\n\r\n\r\n    function wireFlowNodeRefs(lane) {\r\n\r\n      // wire the virtual flowNodeRefs <-> relationship\r\n      forEach$1(lane.flowNodeRef, function(flowNode) {\r\n        var lanes = flowNode.get('lanes');\r\n\r\n        if (lanes) {\r\n          lanes.push(lane);\r\n        }\r\n      });\r\n    }\r\n  }\n\n  /**\r\n   * @typedef {import('../model/Types').ModdleElement} ModdleElement\r\n   *\r\n   * @typedef { {\r\n   *   warnings: string[];\r\n   * } } ImportBPMNDiagramResult\r\n   *\r\n   * @typedef {ImportBPMNDiagramResult & Error} ImportBPMNDiagramError\r\n   */\r\n\r\n  /**\r\n   * Import the definitions into a diagram.\r\n   *\r\n   * Errors and warnings are reported through the specified callback.\r\n   *\r\n   * @param {ModdleElement} diagram\r\n   * @param {ModdleElement} definitions\r\n   * @param {ModdleElement} [bpmnDiagram] The diagram to be rendered (if not\r\n   * provided, the first one will be rendered).\r\n   *\r\n   * @return {Promise<ImportBPMNDiagramResult>}\r\n   */\r\n  function importBpmnDiagram(diagram, definitions, bpmnDiagram) {\r\n\r\n    var importer,\r\n        eventBus,\r\n        canvas;\r\n\r\n    var error,\r\n        warnings = [];\r\n\r\n    /**\r\n     * Walk the diagram semantically, importing (=drawing)\r\n     * all elements you encounter.\r\n     *\r\n     * @param {ModdleElement} definitions\r\n     * @param {ModdleElement} bpmnDiagram\r\n     */\r\n    function render(definitions, bpmnDiagram) {\r\n\r\n      var visitor = {\r\n\r\n        root: function(element, di) {\r\n          return importer.add(element, di);\r\n        },\r\n\r\n        element: function(element, di, parentShape) {\r\n          return importer.add(element, di, parentShape);\r\n        },\r\n\r\n        error: function(message, context) {\r\n          warnings.push({ message: message, context: context });\r\n        }\r\n      };\r\n\r\n      var walker = new BpmnTreeWalker(visitor);\r\n\r\n\r\n      bpmnDiagram = bpmnDiagram || (definitions.diagrams && definitions.diagrams[0]);\r\n\r\n      var diagramsToImport = getDiagramsToImport(definitions, bpmnDiagram);\r\n\r\n      if (!diagramsToImport) {\r\n        throw new Error('no diagram to display');\r\n      }\r\n\r\n      // traverse BPMN 2.0 document model,\r\n      // starting at definitions\r\n      forEach$1(diagramsToImport, function(diagram) {\r\n        walker.handleDefinitions(definitions, diagram);\r\n      });\r\n\r\n      var rootId = bpmnDiagram.plane.bpmnElement.id;\r\n\r\n      // we do need to account for different ways we create root elements\r\n      // each nested imported <root> do have the `_plane` suffix, while\r\n      // the root <root> is found under the business object ID\r\n      canvas.setRootElement(\r\n        canvas.findRoot(rootId + '_plane') || canvas.findRoot(rootId)\r\n      );\r\n    }\r\n\r\n    return new Promise(function(resolve, reject) {\r\n      try {\r\n        importer = diagram.get('bpmnImporter');\r\n        eventBus = diagram.get('eventBus');\r\n        canvas = diagram.get('canvas');\r\n\r\n        eventBus.fire('import.render.start', { definitions: definitions });\r\n\r\n        render(definitions, bpmnDiagram);\r\n\r\n        eventBus.fire('import.render.complete', {\r\n          error: error,\r\n          warnings: warnings\r\n        });\r\n\r\n        return resolve({ warnings: warnings });\r\n      } catch (e) {\r\n\r\n        e.warnings = warnings;\r\n        return reject(e);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns all diagrams in the same hierarchy as the requested diagram.\r\n   * Includes all parent and sub process diagrams.\r\n   *\r\n   * @param {ModdleElement} definitions\r\n   * @param {ModdleElement} bpmnDiagram\r\n   *\r\n   * @return {ModdleElement[]}\r\n   */\r\n  function getDiagramsToImport(definitions, bpmnDiagram) {\r\n    if (!bpmnDiagram || !bpmnDiagram.plane) {\r\n      return;\r\n    }\r\n\r\n    var bpmnElement = bpmnDiagram.plane.bpmnElement,\r\n        rootElement = bpmnElement;\r\n\r\n    if (!is$1(bpmnElement, 'bpmn:Process') && !is$1(bpmnElement, 'bpmn:Collaboration')) {\r\n      rootElement = findRootProcess(bpmnElement);\r\n    }\r\n\r\n    // in case the process is part of a collaboration, the plane references the\r\n    // collaboration, not the process\r\n    var collaboration;\r\n\r\n    if (is$1(rootElement, 'bpmn:Collaboration')) {\r\n      collaboration = rootElement;\r\n    } else {\r\n      collaboration = find(definitions.rootElements, function(element) {\r\n        if (!is$1(element, 'bpmn:Collaboration')) {\r\n          return;\r\n        }\r\n\r\n        return find(element.participants, function(participant) {\r\n          return participant.processRef === rootElement;\r\n        });\r\n      });\r\n    }\r\n\r\n    var rootElements = [ rootElement ];\r\n\r\n    // all collaboration processes can contain sub-diagrams\r\n    if (collaboration) {\r\n      rootElements = map$1(collaboration.participants, function(participant) {\r\n        return participant.processRef;\r\n      });\r\n\r\n      rootElements.push(collaboration);\r\n    }\r\n\r\n    var allChildren = selfAndAllFlowElements(rootElements);\r\n\r\n    // if we have multiple diagrams referencing the same element, we\r\n    // use the first in the file\r\n    var diagramsToImport = [ bpmnDiagram ];\r\n    var handledElements = [ bpmnElement ];\r\n\r\n    forEach$1(definitions.diagrams, function(diagram) {\r\n\r\n      if (!diagram.plane) {\r\n        return;\r\n      }\r\n\r\n      var businessObject = diagram.plane.bpmnElement;\r\n\r\n      if (\r\n        allChildren.indexOf(businessObject) !== -1 &&\r\n        handledElements.indexOf(businessObject) === -1\r\n      ) {\r\n        diagramsToImport.push(diagram);\r\n        handledElements.push(businessObject);\r\n      }\r\n    });\r\n\r\n\r\n    return diagramsToImport;\r\n  }\r\n\r\n  function selfAndAllFlowElements(elements) {\r\n    var result = [];\r\n\r\n    forEach$1(elements, function(element) {\r\n      if (!element) {\r\n        return;\r\n      }\r\n\r\n      result.push(element);\r\n\r\n      result = result.concat(selfAndAllFlowElements(element.flowElements));\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  function findRootProcess(element) {\r\n    var parent = element;\r\n\r\n    while (parent) {\r\n      if (is$1(parent, 'bpmn:Process')) {\r\n        return parent;\r\n      }\r\n\r\n      parent = parent.$parent;\r\n    }\r\n  }\n\n  /**\r\n   * This file must not be changed or exchanged.\r\n   *\r\n   * @see http://bpmn.io/license for more information.\r\n   */\r\n\r\n\r\n\r\n  // inlined ../../resources/logo.svg\r\n  var BPMNIO_LOGO_SVG = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 14.02 5.57\" width=\"53\" height=\"21\"><path fill=\"currentColor\" d=\"M1.88.92v.14c0 .41-.13.68-.4.8.33.14.46.44.46.86v.33c0 .61-.33.95-.95.95H0V0h.95c.65 0 .93.3.93.92zM.63.57v1.06h.24c.24 0 .38-.1.38-.43V.98c0-.28-.1-.4-.32-.4zm0 1.63v1.22h.36c.2 0 .32-.1.32-.39v-.35c0-.37-.12-.48-.4-.48H.63zM4.18.99v.52c0 .64-.31.98-.94.98h-.3V4h-.62V0h.92c.63 0 .94.35.94.99zM2.94.57v1.35h.3c.2 0 .3-.09.3-.37v-.6c0-.29-.1-.38-.3-.38h-.3zm2.89 2.27L6.25 0h.88v4h-.6V1.12L6.1 3.99h-.6l-.46-2.82v2.82h-.55V0h.87zM8.14 1.1V4h-.56V0h.79L9 2.4V0h.56v4h-.64zm2.49 2.29v.6h-.6v-.6zM12.12 1c0-.63.33-1 .95-1 .61 0 .95.37.95 1v2.04c0 .64-.34 1-.95 1-.62 0-.95-.37-.95-1zm.62 2.08c0 .28.13.39.33.39s.32-.1.32-.4V.98c0-.29-.12-.4-.32-.4s-.33.11-.33.4z\"/><path fill=\"currentColor\" d=\"M0 4.53h14.02v1.04H0zM11.08 0h.63v.62h-.63zm.63 4V1h-.63v2.98z\"/></svg>';\r\n\r\n  var BPMNIO_IMG = BPMNIO_LOGO_SVG;\r\n\r\n  var LOGO_STYLES = {\r\n    verticalAlign: 'middle'\r\n  };\r\n\r\n  var LINK_STYLES = {\r\n    'color': '#404040'\r\n  };\r\n\r\n  var LIGHTBOX_STYLES = {\r\n    'zIndex': '1001',\r\n    'position': 'fixed',\r\n    'top': '0',\r\n    'left': '0',\r\n    'right': '0',\r\n    'bottom': '0'\r\n  };\r\n\r\n  var BACKDROP_STYLES = {\r\n    'width': '100%',\r\n    'height': '100%',\r\n    'background': 'rgba(40,40,40,0.2)'\r\n  };\r\n\r\n  var NOTICE_STYLES = {\r\n    'position': 'absolute',\r\n    'left': '50%',\r\n    'top': '40%',\r\n    'transform': 'translate(-50%)',\r\n    'width': '260px',\r\n    'padding': '10px',\r\n    'background': 'white',\r\n    'boxShadow': '0 1px 4px rgba(0,0,0,0.3)',\r\n    'fontFamily': 'Helvetica, Arial, sans-serif',\r\n    'fontSize': '14px',\r\n    'display': 'flex',\r\n    'lineHeight': '1.3'\r\n  };\r\n\r\n  var LIGHTBOX_MARKUP =\r\n    '<div class=\"bjs-powered-by-lightbox\">' +\r\n      '<div class=\"backdrop\"></div>' +\r\n      '<div class=\"notice\">' +\r\n        '<a href=\"https://bpmn.io\" target=\"_blank\" rel=\"noopener\" class=\"link\">' +\r\n          BPMNIO_IMG +\r\n        '</a>' +\r\n        '<span>' +\r\n          'Web-based tooling for BPMN, DMN and forms ' +\r\n          'powered by <a href=\"https://bpmn.io\" target=\"_blank\" rel=\"noopener\">bpmn.io</a>.' +\r\n        '</span>' +\r\n      '</div>' +\r\n    '</div>';\r\n\r\n\r\n  var lightbox;\r\n\r\n  function createLightbox() {\r\n    lightbox = domify$1(LIGHTBOX_MARKUP);\r\n\r\n    assign(lightbox, LIGHTBOX_STYLES);\r\n    assign(query('svg', lightbox), LOGO_STYLES);\r\n    assign(query('.backdrop', lightbox), BACKDROP_STYLES);\r\n    assign(query('.notice', lightbox), NOTICE_STYLES);\r\n    assign(query('.link', lightbox), LINK_STYLES, {\r\n      'margin': '15px 20px 15px 10px',\r\n      'alignSelf': 'center'\r\n    });\r\n  }\r\n\r\n  function open() {\r\n\r\n    if (!lightbox) {\r\n      createLightbox();\r\n\r\n      delegate.bind(lightbox, '.backdrop', 'click', function(event) {\r\n        document.body.removeChild(lightbox);\r\n      });\r\n    }\r\n\r\n    document.body.appendChild(lightbox);\r\n  }\n\n  /**\r\n   * The code in the <project-logo></project-logo> area\r\n   * must not be changed.\r\n   *\r\n   * @see http://bpmn.io/license for more information.\r\n   */\r\n\r\n  /**\r\n   * @template T\r\n   *\r\n   * @typedef { import('diagram-js/lib/core/EventBus').default<T> } EventBus\r\n   */\r\n\r\n  /**\r\n   * @template T\r\n   *\r\n   * @typedef {import('diagram-js/lib/core/EventBus').EventBusEventCallback<T>} EventBusEventCallback\r\n   */\r\n\r\n  /**\r\n   * @typedef {import('didi').ModuleDeclaration} ModuleDeclaration\r\n   *\r\n   * @typedef {import('./model/Types').Moddle} Moddle\r\n   * @typedef {import('./model/Types').ModdleElement} ModdleElement\r\n   * @typedef {import('./model/Types').ModdleExtension} ModdleExtension\r\n   *\r\n   * @typedef { {\r\n   *   width?: number|string;\r\n   *   height?: number|string;\r\n   *   position?: string;\r\n   *   container?: string|HTMLElement;\r\n   *   moddleExtensions?: ModdleExtensions;\r\n   *   additionalModules?: ModuleDeclaration[];\r\n   * } & Record<string, any> } BaseViewerOptions\r\n   *\r\n   * @typedef {Record<string, ModdleElement>} ModdleElementsById\r\n   *\r\n   * @typedef { {\r\n   *   [key: string]: ModdleExtension;\r\n   * } } ModdleExtensions\r\n   *\r\n   * @typedef { {\r\n   *   warnings: string[];\r\n   * } } ImportXMLResult\r\n   *\r\n   * @typedef {ImportXMLResult & Error} ImportXMLError\r\n   *\r\n   * @typedef {ImportXMLResult} ImportDefinitionsResult\r\n   *\r\n   * @typedef {ImportXMLError} ImportDefinitionsError\r\n   *\r\n   * @typedef {ImportXMLResult} OpenResult\r\n   *\r\n   * @typedef {ImportXMLError} OpenError\r\n   *\r\n   * @typedef { {\r\n   *   format?: boolean;\r\n   *   preamble?: boolean;\r\n   * } } SaveXMLOptions\r\n   *\r\n   * @typedef { {\r\n   *   xml?: string;\r\n   *   error?: Error;\r\n   * } } SaveXMLResult\r\n   *\r\n   * @typedef { {\r\n   *   svg: string;\r\n   * } } SaveSVGResult\r\n   *\r\n   * @typedef { {\r\n   *   xml: string;\r\n   * } } ImportParseStartEvent\r\n   *\r\n   * @typedef { {\r\n   *   error?: ImportXMLError;\r\n   *   definitions?: ModdleElement;\r\n   *   elementsById?: ModdleElementsById;\r\n   *   references?: ModdleElement[];\r\n   *   warnings: string[];\r\n   * } } ImportParseCompleteEvent\r\n   *\r\n   * @typedef { {\r\n   *   error?: ImportXMLError;\r\n   *   warnings: string[];\r\n   * } } ImportDoneEvent\r\n   *\r\n   * @typedef { {\r\n   *   definitions: ModdleElement;\r\n   * } } SaveXMLStartEvent\r\n   *\r\n   * @typedef {SaveXMLResult} SaveXMLDoneEvent\r\n   *\r\n   * @typedef { {\r\n   *   error?: Error;\r\n   *   svg: string;\r\n   * } } SaveSVGDoneEvent\r\n   */\r\n\r\n  /**\r\n   * @template Type\r\n   *\r\n   * @typedef { Type extends { eventBus: EventBus<infer X> } ? X : never } EventMap\r\n   */\r\n\r\n  /**\r\n   * A base viewer for BPMN 2.0 diagrams.\r\n   *\r\n   * Have a look at {@link bpmn-js/lib/Viewer}, {@link bpmn-js/lib/NavigatedViewer} or {@link bpmn-js/lib/Modeler} for\r\n   * bundles that include actual features.\r\n   *\r\n   * @template [ServiceMap=null]\r\n   *\r\n   * @extends Diagram<ServiceMap>\r\n   *\r\n   * @param {BaseViewerOptions} [options] The options to configure the viewer.\r\n   */\r\n  function BaseViewer(options) {\r\n\r\n    /**\r\n     * @type {BaseViewerOptions}\r\n     */\r\n    options = assign$1({}, DEFAULT_OPTIONS, options);\r\n\r\n    /**\r\n     * @type {Moddle}\r\n     */\r\n    this._moddle = this._createModdle(options);\r\n\r\n    /**\r\n     * @type {HTMLElement}\r\n     */\r\n    this._container = this._createContainer(options);\r\n\r\n    this._init(this._container, this._moddle, options);\r\n\r\n    /* <project-logo> */\r\n\r\n    addProjectLogo(this._container);\r\n\r\n    /* </project-logo> */\r\n  }\r\n\r\n  e(BaseViewer, Diagram);\r\n\r\n  /**\r\n   * Parse and render a BPMN 2.0 diagram.\r\n   *\r\n   * Once finished the viewer reports back the result to the\r\n   * provided callback function with (err, warnings).\r\n   *\r\n   * ## Life-Cycle Events\r\n   *\r\n   * During import the viewer will fire life-cycle events:\r\n   *\r\n   *   * import.parse.start (about to read model from XML)\r\n   *   * import.parse.complete (model read; may have worked or not)\r\n   *   * import.render.start (graphical import start)\r\n   *   * import.render.complete (graphical import finished)\r\n   *   * import.done (everything done)\r\n   *\r\n   * You can use these events to hook into the life-cycle.\r\n   *\r\n   * @throws {ImportXMLError} An error thrown during the import of the XML.\r\n   *\r\n   * @fires BaseViewer#ImportParseStartEvent\r\n   * @fires BaseViewer#ImportParseCompleteEvent\r\n   * @fires Importer#ImportRenderStartEvent\r\n   * @fires Importer#ImportRenderCompleteEvent\r\n   * @fires BaseViewer#ImportDoneEvent\r\n   *\r\n   * @param {string} xml The BPMN 2.0 XML to be imported.\r\n   * @param {ModdleElement|string} [bpmnDiagram] The optional diagram or Id of the BPMN diagram to open.\r\n   *\r\n   * @return {Promise<ImportXMLResult>} A promise resolving with warnings that were produced during the import.\r\n   */\r\n  BaseViewer.prototype.importXML = async function importXML(xml, bpmnDiagram) {\r\n\r\n    const self = this;\r\n\r\n    function ParseCompleteEvent(data) {\r\n      return self.get('eventBus').createEvent(data);\r\n    }\r\n\r\n    let aggregatedWarnings = [];\r\n    try {\r\n\r\n      // hook in pre-parse listeners +\r\n      // allow xml manipulation\r\n\r\n      /**\r\n       * A `import.parse.start` event.\r\n       *\r\n       * @event BaseViewer#ImportParseStartEvent\r\n       * @type {ImportParseStartEvent}\r\n       */\r\n      xml = this._emit('import.parse.start', { xml: xml }) || xml;\r\n\r\n      let parseResult;\r\n      try {\r\n        parseResult = await this._moddle.fromXML(xml, 'bpmn:Definitions');\r\n      } catch (error) {\r\n        this._emit('import.parse.complete', {\r\n          error\r\n        });\r\n\r\n        throw error;\r\n      }\r\n\r\n      let definitions = parseResult.rootElement;\r\n      const references = parseResult.references;\r\n      const parseWarnings = parseResult.warnings;\r\n      const elementsById = parseResult.elementsById;\r\n\r\n      aggregatedWarnings = aggregatedWarnings.concat(parseWarnings);\r\n\r\n      // hook in post parse listeners +\r\n      // allow definitions manipulation\r\n\r\n      /**\r\n       * A `import.parse.complete` event.\r\n       *\r\n       * @event BaseViewer#ImportParseCompleteEvent\r\n       * @type {ImportParseCompleteEvent}\r\n       */\r\n      definitions = this._emit('import.parse.complete', ParseCompleteEvent({\r\n        error: null,\r\n        definitions: definitions,\r\n        elementsById: elementsById,\r\n        references: references,\r\n        warnings: aggregatedWarnings\r\n      })) || definitions;\r\n\r\n      const importResult = await this.importDefinitions(definitions, bpmnDiagram);\r\n\r\n      aggregatedWarnings = aggregatedWarnings.concat(importResult.warnings);\r\n\r\n      /**\r\n       * A `import.parse.complete` event.\r\n       *\r\n       * @event BaseViewer#ImportDoneEvent\r\n       * @type {ImportDoneEvent}\r\n       */\r\n      this._emit('import.done', { error: null, warnings: aggregatedWarnings });\r\n\r\n      return { warnings: aggregatedWarnings };\r\n    } catch (err) {\r\n      let error = err;\r\n      aggregatedWarnings = aggregatedWarnings.concat(error.warnings || []);\r\n      addWarningsToError(error, aggregatedWarnings);\r\n\r\n      error = checkValidationError(error);\r\n\r\n      this._emit('import.done', { error, warnings: error.warnings });\r\n\r\n      throw error;\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Import parsed definitions and render a BPMN 2.0 diagram.\r\n   *\r\n   * Once finished the viewer reports back the result to the\r\n   * provided callback function with (err, warnings).\r\n   *\r\n   * ## Life-Cycle Events\r\n   *\r\n   * During import the viewer will fire life-cycle events:\r\n   *\r\n   *   * import.render.start (graphical import start)\r\n   *   * import.render.complete (graphical import finished)\r\n   *\r\n   * You can use these events to hook into the life-cycle.\r\n   *\r\n   * @throws {ImportDefinitionsError} An error thrown during the import of the definitions.\r\n   *\r\n   * @param {ModdleElement} definitions The definitions.\r\n   * @param {ModdleElement|string} [bpmnDiagram] The optional diagram or ID of the BPMN diagram to open.\r\n   *\r\n   * @return {Promise<ImportDefinitionsResult>} A promise resolving with warnings that were produced during the import.\r\n   */\r\n  BaseViewer.prototype.importDefinitions = async function importDefinitions(definitions, bpmnDiagram) {\r\n    this._setDefinitions(definitions);\r\n    const result = await this.open(bpmnDiagram);\r\n\r\n    return { warnings: result.warnings };\r\n  };\r\n\r\n\r\n  /**\r\n   * Open diagram of previously imported XML.\r\n   *\r\n   * Once finished the viewer reports back the result to the\r\n   * provided callback function with (err, warnings).\r\n   *\r\n   * ## Life-Cycle Events\r\n   *\r\n   * During switch the viewer will fire life-cycle events:\r\n   *\r\n   *   * import.render.start (graphical import start)\r\n   *   * import.render.complete (graphical import finished)\r\n   *\r\n   * You can use these events to hook into the life-cycle.\r\n   *\r\n   * @throws {OpenError} An error thrown during opening.\r\n   *\r\n   * @param {ModdleElement|string} bpmnDiagramOrId The diagram or Id of the BPMN diagram to open.\r\n   *\r\n   * @return {Promise<OpenResult>} A promise resolving with warnings that were produced during opening.\r\n   */\r\n  BaseViewer.prototype.open = async function open(bpmnDiagramOrId) {\r\n\r\n    const definitions = this._definitions;\r\n    let bpmnDiagram = bpmnDiagramOrId;\r\n\r\n    if (!definitions) {\r\n      const error = new Error('no XML imported');\r\n      addWarningsToError(error, []);\r\n\r\n      throw error;\r\n    }\r\n\r\n    if (typeof bpmnDiagramOrId === 'string') {\r\n      bpmnDiagram = findBPMNDiagram(definitions, bpmnDiagramOrId);\r\n\r\n      if (!bpmnDiagram) {\r\n        const error = new Error('BPMNDiagram <' + bpmnDiagramOrId + '> not found');\r\n        addWarningsToError(error, []);\r\n\r\n        throw error;\r\n      }\r\n    }\r\n\r\n    // clear existing rendered diagram\r\n    // catch synchronous exceptions during #clear()\r\n    try {\r\n      this.clear();\r\n    } catch (error) {\r\n      addWarningsToError(error, []);\r\n\r\n      throw error;\r\n    }\r\n\r\n    // perform graphical import\r\n    const { warnings } = await importBpmnDiagram(this, definitions, bpmnDiagram);\r\n\r\n    return { warnings };\r\n  };\r\n\r\n  /**\r\n   * Export the currently displayed BPMN 2.0 diagram as\r\n   * a BPMN 2.0 XML document.\r\n   *\r\n   * ## Life-Cycle Events\r\n   *\r\n   * During XML saving the viewer will fire life-cycle events:\r\n   *\r\n   *   * saveXML.start (before serialization)\r\n   *   * saveXML.serialized (after xml generation)\r\n   *   * saveXML.done (everything done)\r\n   *\r\n   * You can use these events to hook into the life-cycle.\r\n   *\r\n   * @throws {Error} An error thrown during export.\r\n   *\r\n   * @fires BaseViewer#SaveXMLStart\r\n   * @fires BaseViewer#SaveXMLDone\r\n   *\r\n   * @param {SaveXMLOptions} [options] The options.\r\n   *\r\n   * @return {Promise<SaveXMLResult>} A promise resolving with the XML.\r\n   */\r\n  BaseViewer.prototype.saveXML = async function saveXML(options) {\r\n\r\n    options = options || {};\r\n\r\n    let definitions = this._definitions,\r\n        error, xml;\r\n\r\n    try {\r\n      if (!definitions) {\r\n        throw new Error('no definitions loaded');\r\n      }\r\n\r\n      // allow to fiddle around with definitions\r\n\r\n      /**\r\n       * A `saveXML.start` event.\r\n       *\r\n       * @event BaseViewer#SaveXMLStartEvent\r\n       * @type {SaveXMLStartEvent}\r\n       */\r\n      definitions = this._emit('saveXML.start', {\r\n        definitions\r\n      }) || definitions;\r\n\r\n      const result = await this._moddle.toXML(definitions, options);\r\n      xml = result.xml;\r\n\r\n      xml = this._emit('saveXML.serialized', {\r\n        xml\r\n      }) || xml;\r\n    } catch (err) {\r\n      error = err;\r\n    }\r\n\r\n    const result = error ? { error } : { xml };\r\n\r\n    /**\r\n     * A `saveXML.done` event.\r\n     *\r\n     * @event BaseViewer#SaveXMLDoneEvent\r\n     * @type {SaveXMLDoneEvent}\r\n     */\r\n    this._emit('saveXML.done', result);\r\n\r\n    if (error) {\r\n      throw error;\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n\r\n  /**\r\n   * Export the currently displayed BPMN 2.0 diagram as\r\n   * an SVG image.\r\n   *\r\n   * ## Life-Cycle Events\r\n   *\r\n   * During SVG saving the viewer will fire life-cycle events:\r\n   *\r\n   *   * saveSVG.start (before serialization)\r\n   *   * saveSVG.done (everything done)\r\n   *\r\n   * You can use these events to hook into the life-cycle.\r\n   *\r\n   * @throws {Error} An error thrown during export.\r\n   *\r\n   * @fires BaseViewer#SaveSVGDone\r\n   *\r\n   * @return {Promise<SaveSVGResult>} A promise resolving with the SVG.\r\n   */\r\n  BaseViewer.prototype.saveSVG = async function saveSVG() {\r\n    this._emit('saveSVG.start');\r\n\r\n    let svg, err;\r\n\r\n    try {\r\n      const canvas = this.get('canvas');\r\n\r\n      const contentNode = canvas.getActiveLayer(),\r\n            defsNode = query(':scope > defs', canvas._svg);\r\n\r\n      const contents = innerSVG(contentNode),\r\n            defs = defsNode ? '<defs>' + innerSVG(defsNode) + '</defs>' : '';\r\n\r\n      const bbox = contentNode.getBBox();\r\n\r\n      svg =\r\n        '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n' +\r\n        '<!-- created with bpmn-js / http://bpmn.io -->\\n' +\r\n        '<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\\n' +\r\n        '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' +\r\n        'width=\"' + bbox.width + '\" height=\"' + bbox.height + '\" ' +\r\n        'viewBox=\"' + bbox.x + ' ' + bbox.y + ' ' + bbox.width + ' ' + bbox.height + '\" version=\"1.1\">' +\r\n        defs + contents +\r\n        '</svg>';\r\n    } catch (e) {\r\n      err = e;\r\n    }\r\n\r\n    /**\r\n     * A `saveSVG.done` event.\r\n     *\r\n     * @event BaseViewer#SaveSVGDoneEvent\r\n     * @type {SaveSVGDoneEvent}\r\n     */\r\n    this._emit('saveSVG.done', {\r\n      error: err,\r\n      svg: svg\r\n    });\r\n\r\n    if (err) {\r\n      throw err;\r\n    }\r\n\r\n    return { svg };\r\n  };\r\n\r\n  BaseViewer.prototype._setDefinitions = function(definitions) {\r\n    this._definitions = definitions;\r\n  };\r\n\r\n  /**\r\n   * Return modules to instantiate with.\r\n   *\r\n   * @return {ModuleDeclaration[]} The modules.\r\n   */\r\n  BaseViewer.prototype.getModules = function() {\r\n    return this._modules;\r\n  };\r\n\r\n  /**\r\n   * Remove all drawn elements from the viewer.\r\n   *\r\n   * After calling this method the viewer can still be reused for opening another\r\n   * diagram.\r\n   */\r\n  BaseViewer.prototype.clear = function() {\r\n    if (!this.getDefinitions()) {\r\n\r\n      // no diagram to clear\r\n      return;\r\n    }\r\n\r\n    // remove drawn elements\r\n    Diagram.prototype.clear.call(this);\r\n  };\r\n\r\n  /**\r\n   * Destroy the viewer instance and remove all its remainders from the document\r\n   * tree.\r\n   */\r\n  BaseViewer.prototype.destroy = function() {\r\n\r\n    // diagram destroy\r\n    Diagram.prototype.destroy.call(this);\r\n\r\n    // dom detach\r\n    remove$1(this._container);\r\n  };\r\n\r\n  /**\r\n   * @overlord\r\n   *\r\n   * Register an event listener for events with the given name.\r\n   *\r\n   * The callback will be invoked with `event, ...additionalArguments`\r\n   * that have been passed to {@link EventBus#fire}.\r\n   *\r\n   * Returning false from a listener will prevent the events default action\r\n   * (if any is specified). To stop an event from being processed further in\r\n   * other listeners execute {@link Event#stopPropagation}.\r\n   *\r\n   * Returning anything but `undefined` from a listener will stop the listener propagation.\r\n   *\r\n   * @template T\r\n   *\r\n   * @param {string|string[]} events The event(s) to listen to.\r\n   * @param {number} [priority] The priority with which to listen.\r\n   * @param {EventBusEventCallback<T>} callback The callback.\r\n   * @param {any} [that] Value of `this` the callback will be called with.\r\n   */\r\n  /**\r\n   * Register an event listener for events with the given name.\r\n   *\r\n   * The callback will be invoked with `event, ...additionalArguments`\r\n   * that have been passed to {@link EventBus#fire}.\r\n   *\r\n   * Returning false from a listener will prevent the events default action\r\n   * (if any is specified). To stop an event from being processed further in\r\n   * other listeners execute {@link Event#stopPropagation}.\r\n   *\r\n   * Returning anything but `undefined` from a listener will stop the listener propagation.\r\n   *\r\n   * @template {keyof EventMap<ServiceMap>} EventName\r\n   *\r\n   * @param {EventName} events to subscribe to\r\n   * @param {number} [priority=1000] listen priority\r\n   * @param {EventBusEventCallback<(EventMap<ServiceMap>)[EventName]>} callback\r\n   * @param {any} [that] callback context\r\n   */\r\n  BaseViewer.prototype.on = function(events, priority, callback, that) {\r\n    return this.get('eventBus').on(events, priority, callback, that);\r\n  };\r\n\r\n  /**\r\n   * Remove an event listener.\r\n   *\r\n   * @param {string|string[]} events The event(s).\r\n   * @param {Function} [callback] The callback.\r\n   */\r\n  BaseViewer.prototype.off = function(events, callback) {\r\n    this.get('eventBus').off(events, callback);\r\n  };\r\n\r\n  /**\r\n   * Attach the viewer to an HTML element.\r\n   *\r\n   * @param {HTMLElement} parentNode The parent node to attach to.\r\n   */\r\n  BaseViewer.prototype.attachTo = function(parentNode) {\r\n\r\n    if (!parentNode) {\r\n      throw new Error('parentNode required');\r\n    }\r\n\r\n    // ensure we detach from the\r\n    // previous, old parent\r\n    this.detach();\r\n\r\n    // unwrap jQuery if provided\r\n    if (parentNode.get && parentNode.constructor.prototype.jquery) {\r\n      parentNode = parentNode.get(0);\r\n    }\r\n\r\n    if (typeof parentNode === 'string') {\r\n      parentNode = query(parentNode);\r\n    }\r\n\r\n    parentNode.appendChild(this._container);\r\n\r\n    this._emit('attach', {});\r\n\r\n    this.get('canvas').resized();\r\n  };\r\n\r\n  /**\r\n   * Get the definitions model element.\r\n   *\r\n   * @return {ModdleElement} The definitions model element.\r\n   */\r\n  BaseViewer.prototype.getDefinitions = function() {\r\n    return this._definitions;\r\n  };\r\n\r\n  /**\r\n   * Detach the viewer.\r\n   *\r\n   * @fires BaseViewer#DetachEvent\r\n   */\r\n  BaseViewer.prototype.detach = function() {\r\n\r\n    const container = this._container,\r\n          parentNode = container.parentNode;\r\n\r\n    if (!parentNode) {\r\n      return;\r\n    }\r\n\r\n    /**\r\n     * A `detach` event.\r\n     *\r\n     * @event BaseViewer#DetachEvent\r\n     * @type {Object}\r\n     */\r\n    this._emit('detach', {});\r\n\r\n    parentNode.removeChild(container);\r\n  };\r\n\r\n  BaseViewer.prototype._init = function(container, moddle, options) {\r\n\r\n    const baseModules = options.modules || this.getModules(options),\r\n          additionalModules = options.additionalModules || [],\r\n          staticModules = [\r\n            {\r\n              bpmnjs: [ 'value', this ],\r\n              moddle: [ 'value', moddle ]\r\n            }\r\n          ];\r\n\r\n    const diagramModules = [].concat(staticModules, baseModules, additionalModules);\r\n\r\n    const diagramOptions = assign$1(omit(options, [ 'additionalModules' ]), {\r\n      canvas: assign$1({}, options.canvas, { container: container }),\r\n      modules: diagramModules\r\n    });\r\n\r\n    // invoke diagram constructor\r\n    Diagram.call(this, diagramOptions);\r\n\r\n    if (options && options.container) {\r\n      this.attachTo(options.container);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Emit an event on the underlying {@link EventBus}\r\n   *\r\n   * @param  {string} type\r\n   * @param  {Object} event\r\n   *\r\n   * @return {Object} The return value after calling all event listeners.\r\n   */\r\n  BaseViewer.prototype._emit = function(type, event) {\r\n    return this.get('eventBus').fire(type, event);\r\n  };\r\n\r\n  /**\r\n   * @param {BaseViewerOptions} options\r\n   *\r\n   * @return {HTMLElement}\r\n   */\r\n  BaseViewer.prototype._createContainer = function(options) {\r\n\r\n    const container = domify$1('<div class=\"bjs-container\"></div>');\r\n\r\n    assign(container, {\r\n      width: ensureUnit(options.width),\r\n      height: ensureUnit(options.height),\r\n      position: options.position\r\n    });\r\n\r\n    return container;\r\n  };\r\n\r\n  /**\r\n   * @param {BaseViewerOptions} options\r\n   *\r\n   * @return {Moddle}\r\n   */\r\n  BaseViewer.prototype._createModdle = function(options) {\r\n    const moddleOptions = assign$1({}, this._moddleExtensions, options.moddleExtensions);\r\n\r\n    return new SimpleBpmnModdle(moddleOptions);\r\n  };\r\n\r\n  BaseViewer.prototype._modules = [];\r\n\r\n  // helpers ///////////////\r\n\r\n  function addWarningsToError(err, warningsAry) {\r\n    err.warnings = warningsAry;\r\n    return err;\r\n  }\r\n\r\n  function checkValidationError(err) {\r\n\r\n    // check if we can help the user by indicating wrong BPMN 2.0 xml\r\n    // (in case he or the exporting tool did not get that right)\r\n\r\n    const pattern = /unparsable content <([^>]+)> detected([\\s\\S]*)$/;\r\n    const match = pattern.exec(err.message);\r\n\r\n    if (match) {\r\n      err.message =\r\n        'unparsable content <' + match[1] + '> detected; ' +\r\n        'this may indicate an invalid BPMN 2.0 diagram file' + match[2];\r\n    }\r\n\r\n    return err;\r\n  }\r\n\r\n  const DEFAULT_OPTIONS = {\r\n    width: '100%',\r\n    height: '100%',\r\n    position: 'relative'\r\n  };\r\n\r\n\r\n  /**\r\n   * Ensure the passed argument is a proper unit (defaulting to px)\r\n   */\r\n  function ensureUnit(val) {\r\n    return val + (isNumber(val) ? 'px' : '');\r\n  }\r\n\r\n\r\n  /**\r\n   * Find BPMNDiagram in definitions by ID\r\n   *\r\n   * @param {ModdleElement<Definitions>} definitions\r\n   * @param {string} diagramId\r\n   *\r\n   * @return {ModdleElement<BPMNDiagram>|null}\r\n   */\r\n  function findBPMNDiagram(definitions, diagramId) {\r\n    if (!diagramId) {\r\n      return null;\r\n    }\r\n\r\n    return find(definitions.diagrams, function(element) {\r\n      return element.id === diagramId;\r\n    }) || null;\r\n  }\r\n\r\n  /**\r\n   * Adds the project logo to the diagram container as\r\n   * required by the bpmn.io license.\r\n   *\r\n   * @see http://bpmn.io/license\r\n   *\r\n   * @param {Element} container\r\n   */\r\n  function addProjectLogo(container) {\r\n    const img = BPMNIO_IMG;\r\n\r\n    const linkMarkup =\r\n      '<a href=\"http://bpmn.io\" ' +\r\n      'target=\"_blank\" ' +\r\n      'class=\"bjs-powered-by\" ' +\r\n      'title=\"Powered by bpmn.io\" ' +\r\n      '>' +\r\n      img +\r\n      '</a>';\r\n\r\n    const linkElement = domify$1(linkMarkup);\r\n\r\n    assign(query('svg', linkElement), LOGO_STYLES);\r\n    assign(linkElement, LINK_STYLES, {\r\n      position: 'absolute',\r\n      bottom: '15px',\r\n      right: '15px',\r\n      zIndex: '100'\r\n    });\r\n\r\n    container.appendChild(linkElement);\r\n\r\n    event.bind(linkElement, 'click', function(event) {\r\n      open();\r\n\r\n      event.preventDefault();\r\n    });\r\n  }\r\n\r\n  /* </project-logo> */\n\n  /**\r\n   * @typedef { import('./BaseViewer').BaseViewerOptions } BaseViewerOptions\r\n   */\r\n\r\n  /**\r\n   * A viewer for BPMN 2.0 diagrams.\r\n   *\r\n   * Have a look at {@link bpmn-js/lib/NavigatedViewer} or {@link bpmn-js/lib/Modeler} for bundles that include\r\n   * additional features.\r\n   *\r\n   *\r\n   * ## Extending the Viewer\r\n   *\r\n   * In order to extend the viewer pass extension modules to bootstrap via the\r\n   * `additionalModules` option. An extension module is an object that exposes\r\n   * named services.\r\n   *\r\n   * The following example depicts the integration of a simple\r\n   * logging component that integrates with interaction events:\r\n   *\r\n   *\r\n   * ```javascript\r\n   *\r\n   * // logging component\r\n   * function InteractionLogger(eventBus) {\r\n   *   eventBus.on('element.hover', function(event) {\r\n   *     console.log()\r\n   *   })\r\n   * }\r\n   *\r\n   * InteractionLogger.$inject = [ 'eventBus' ]; // minification save\r\n   *\r\n   * // extension module\r\n   * var extensionModule = {\r\n   *   __init__: [ 'interactionLogger' ],\r\n   *   interactionLogger: [ 'type', InteractionLogger ]\r\n   * };\r\n   *\r\n   * // extend the viewer\r\n   * var bpmnViewer = new Viewer({ additionalModules: [ extensionModule ] });\r\n   * bpmnViewer.importXML(...);\r\n   * ```\r\n   *\r\n   * @template [ServiceMap=null]\r\n   *\r\n   * @extends BaseViewer<ServiceMap>\r\n   *\r\n   * @param {BaseViewerOptions} [options] The options to configure the viewer.\r\n   */\r\n  function Viewer(options) {\r\n    BaseViewer.call(this, options);\r\n  }\r\n\r\n  e(Viewer, BaseViewer);\r\n\r\n  // modules the viewer is composed of\r\n  Viewer.prototype._modules = [\r\n    CoreModule$1,\r\n    DrilldownModdule,\r\n    OverlaysModule,\r\n    SelectionModule,\r\n    TranslateModule\r\n  ];\r\n\r\n  // default moddle extensions the viewer is composed of\r\n  Viewer.prototype._moddleExtensions = {};\n\n  var KEYS_COPY = [ 'c', 'C' ];\r\n  var KEYS_PASTE = [ 'v', 'V' ];\r\n  var KEYS_REDO = [ 'y', 'Y' ];\r\n  var KEYS_UNDO = [ 'z', 'Z' ];\r\n\r\n  /**\r\n   * Returns true if event was triggered with any modifier\r\n   * @param {KeyboardEvent} event\r\n   */\r\n  function hasModifier(event) {\r\n    return (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey);\r\n  }\r\n\r\n  /**\r\n   * @param {KeyboardEvent} event\r\n   * @return {boolean}\r\n   */\r\n  function isCmd(event) {\r\n\r\n    // ensure we don't react to AltGr\r\n    // (mapped to CTRL + ALT)\r\n    if (event.altKey) {\r\n      return false;\r\n    }\r\n\r\n    return event.ctrlKey || event.metaKey;\r\n  }\r\n\r\n  /**\r\n   * Checks if key pressed is one of provided keys.\r\n   *\r\n   * @param {string|string[]} keys\r\n   * @param {KeyboardEvent} event\r\n   * @return {boolean}\r\n   */\r\n  function isKey(keys, event) {\r\n    keys = isArray$2(keys) ? keys : [ keys ];\r\n\r\n    return keys.indexOf(event.key) !== -1 || keys.indexOf(event.code) !== -1;\r\n  }\r\n\r\n  /**\r\n   * @param {KeyboardEvent} event\r\n   */\r\n  function isShift(event) {\r\n    return event.shiftKey;\r\n  }\r\n\r\n  /**\r\n   * @param {KeyboardEvent} event\r\n   */\r\n  function isCopy(event) {\r\n    return isCmd(event) && isKey(KEYS_COPY, event);\r\n  }\r\n\r\n  /**\r\n   * @param {KeyboardEvent} event\r\n   */\r\n  function isPaste(event) {\r\n    return isCmd(event) && isKey(KEYS_PASTE, event);\r\n  }\r\n\r\n  /**\r\n   * @param {KeyboardEvent} event\r\n   */\r\n  function isUndo(event) {\r\n    return isCmd(event) && !isShift(event) && isKey(KEYS_UNDO, event);\r\n  }\r\n\r\n  /**\r\n   * @param {KeyboardEvent} event\r\n   */\r\n  function isRedo(event) {\r\n    return isCmd(event) && (\r\n      isKey(KEYS_REDO, event) || (\r\n        isKey(KEYS_UNDO, event) && isShift(event)\r\n      )\r\n    );\r\n  }\n\n  /**\n   * @typedef {import('../../core/EventBus').default} EventBus\n   *\n   * @typedef {({ keyEvent: KeyboardEvent }) => any} Listener\n   */\n\n  var KEYDOWN_EVENT = 'keyboard.keydown',\n      KEYUP_EVENT = 'keyboard.keyup';\n\n  var DEFAULT_PRIORITY = 1000;\n\n  var compatMessage = 'Keyboard binding is now implicit; explicit binding to an element got removed. For more information, see https://github.com/bpmn-io/diagram-js/issues/661';\n\n\n  /**\n   * A keyboard abstraction that may be activated and\n   * deactivated by users at will, consuming global key events\n   * and triggering diagram actions.\n   *\n   * For keys pressed down, keyboard fires `keyboard.keydown` event.\n   * The event context contains one field which is `KeyboardEvent` event.\n   *\n   * The implementation fires the following key events that allow\n   * other components to hook into key handling:\n   *\n   *  - keyboard.bind\n   *  - keyboard.unbind\n   *  - keyboard.init\n   *  - keyboard.destroy\n   *\n   * All events contain one field which is node.\n   *\n   * Specify the initial keyboard binding state via the\n   * `keyboard.bind=true|false` configuration option.\n   *\n   * @param {Object} config\n   * @param {boolean} [config.bind]\n   * @param {EventBus} eventBus\n   */\n  function Keyboard(config, eventBus) {\n    var self = this;\n\n    this._config = config = config || {};\n\n    this._eventBus = eventBus;\n\n    this._keydownHandler = this._keydownHandler.bind(this);\n    this._keyupHandler = this._keyupHandler.bind(this);\n\n    // properly clean dom registrations\n    eventBus.on('diagram.destroy', function() {\n      self._fire('destroy');\n\n      self.unbind();\n    });\n\n    if (config.bindTo) {\n      console.error('unsupported configuration <keyboard.bindTo>', new Error(compatMessage));\n    }\n\n    var bind = config && config.bind !== false;\n\n    eventBus.on('canvas.init', function(event) {\n      self._target = event.svg;\n\n      if (bind) {\n        self.bind();\n      }\n\n      self._fire('init');\n    });\n\n  }\n\n  Keyboard.$inject = [\n    'config.keyboard',\n    'eventBus'\n  ];\n\n  Keyboard.prototype._keydownHandler = function(event) {\n    this._keyHandler(event, KEYDOWN_EVENT);\n  };\n\n  Keyboard.prototype._keyupHandler = function(event) {\n    this._keyHandler(event, KEYUP_EVENT);\n  };\n\n  Keyboard.prototype._keyHandler = function(event, type) {\n    var eventBusResult;\n\n    if (this._isEventIgnored(event)) {\n      return;\n    }\n\n    var context = {\n      keyEvent: event\n    };\n\n    eventBusResult = this._eventBus.fire(type || KEYDOWN_EVENT, context);\n\n    if (eventBusResult) {\n      event.preventDefault();\n    }\n  };\n\n  Keyboard.prototype._isEventIgnored = function(event) {\n    return false;\n  };\n\n  /**\n   * Bind keyboard events to the given DOM node.\n   *\n   * @overlord\n   * @deprecated No longer in use since version 15.0.0.\n   *\n   * @param {EventTarget} node\n   */\n  /**\n   * Bind keyboard events to the canvas node.\n   */\n  Keyboard.prototype.bind = function(node) {\n\n    // legacy <node> argument provided\n    if (node) {\n      console.error('unsupported argument <node>', new Error(compatMessage));\n    }\n\n    // make sure that the keyboard is only bound once to the DOM\n    this.unbind();\n\n    node = this._node = this._target;\n\n    // bind key events\n    event.bind(node, 'keydown', this._keydownHandler);\n    event.bind(node, 'keyup', this._keyupHandler);\n\n    this._fire('bind');\n  };\n\n  /**\n   * @return {EventTarget}\n   */\n  Keyboard.prototype.getBinding = function() {\n    return this._node;\n  };\n\n  Keyboard.prototype.unbind = function() {\n    var node = this._node;\n\n    if (node) {\n      this._fire('unbind');\n\n      // unbind key events\n      event.unbind(node, 'keydown', this._keydownHandler);\n      event.unbind(node, 'keyup', this._keyupHandler);\n    }\n\n    this._node = null;\n  };\n\n  /**\n   * @param {string} event\n   */\n  Keyboard.prototype._fire = function(event) {\n    this._eventBus.fire('keyboard.' + event, { node: this._node });\n  };\n\n  /**\n   * Add a listener function that is notified with `KeyboardEvent` whenever\n   * the keyboard is bound and the user presses a key. If no priority is\n   * provided, the default value of 1000 is used.\n   *\n   * @param {number} [priority]\n   * @param {Listener} listener\n   * @param {string} [type='keyboard.keydown']\n   */\n  Keyboard.prototype.addListener = function(priority, listener, type) {\n    if (isFunction(priority)) {\n      type = listener;\n      listener = priority;\n      priority = DEFAULT_PRIORITY;\n    }\n\n    this._eventBus.on(type || KEYDOWN_EVENT, priority, listener);\n  };\n\n  /**\n   * Remove a listener function.\n   *\n   * @param {Listener} listener\n   * @param {string} [type='keyboard.keydown']\n   */\n  Keyboard.prototype.removeListener = function(listener, type) {\n    this._eventBus.off(type || KEYDOWN_EVENT, listener);\n  };\n\n  Keyboard.prototype.hasModifier = hasModifier;\n  Keyboard.prototype.isCmd = isCmd;\n  Keyboard.prototype.isShift = isShift;\n  Keyboard.prototype.isKey = isKey;\n\n  var LOW_PRIORITY = 500;\n\n\n  /**\n   * Adds default keyboard bindings.\n   *\n   * This does not pull in any features will bind only actions that\n   * have previously been registered against the editorActions component.\n   *\n   * @param {EventBus} eventBus\n   * @param {Keyboard} keyboard\n   */\n  function KeyboardBindings(eventBus, keyboard) {\n\n    var self = this;\n\n    eventBus.on('editorActions.init', LOW_PRIORITY, function(event) {\n\n      var editorActions = event.editorActions;\n\n      self.registerBindings(keyboard, editorActions);\n    });\n  }\n\n  KeyboardBindings.$inject = [\n    'eventBus',\n    'keyboard'\n  ];\n\n\n  /**\n   * Register available keyboard bindings.\n   *\n   * @param {Keyboard} keyboard\n   * @param {EditorActions} editorActions\n   */\n  KeyboardBindings.prototype.registerBindings = function(keyboard, editorActions) {\n\n    /**\n     * Add keyboard binding if respective editor action\n     * is registered.\n     *\n     * @param {string} action name\n     * @param {Function} fn that implements the key binding\n     */\n    function addListener(action, fn) {\n\n      if (editorActions.isRegistered(action)) {\n        keyboard.addListener(fn);\n      }\n    }\n\n\n    // undo\n    // (CTRL|CMD) + Z\n    addListener('undo', function(context) {\n\n      var event = context.keyEvent;\n\n      if (isUndo(event)) {\n        editorActions.trigger('undo');\n\n        return true;\n      }\n    });\n\n    // redo\n    // CTRL + Y\n    // CMD + SHIFT + Z\n    addListener('redo', function(context) {\n\n      var event = context.keyEvent;\n\n      if (isRedo(event)) {\n        editorActions.trigger('redo');\n\n        return true;\n      }\n    });\n\n    // copy\n    // CTRL/CMD + C\n    addListener('copy', function(context) {\n\n      var event = context.keyEvent;\n\n      if (isCopy(event)) {\n        editorActions.trigger('copy');\n\n        return true;\n      }\n    });\n\n    // paste\n    // CTRL/CMD + V\n    addListener('paste', function(context) {\n\n      var event = context.keyEvent;\n\n      if (isPaste(event)) {\n        editorActions.trigger('paste');\n\n        return true;\n      }\n    });\n\n    // zoom in one step\n    // CTRL/CMD + +\n    addListener('stepZoom', function(context) {\n\n      var event = context.keyEvent;\n\n      // quirk: it has to be triggered by `=` as well to work on international keyboard layout\n      // cf: https://github.com/bpmn-io/bpmn-js/issues/1362#issuecomment-722989754\n      if (isKey([ '+', 'Add', '=' ], event) && isCmd(event)) {\n        editorActions.trigger('stepZoom', { value: 1 });\n\n        return true;\n      }\n    });\n\n    // zoom out one step\n    // CTRL + -\n    addListener('stepZoom', function(context) {\n\n      var event = context.keyEvent;\n\n      if (isKey([ '-', 'Subtract' ], event) && isCmd(event)) {\n        editorActions.trigger('stepZoom', { value: -1 });\n\n        return true;\n      }\n    });\n\n    // zoom to the default level\n    // CTRL + 0\n    addListener('zoom', function(context) {\n\n      var event = context.keyEvent;\n\n      if (isKey('0', event) && isCmd(event)) {\n        editorActions.trigger('zoom', { value: 1 });\n\n        return true;\n      }\n    });\n\n    // delete selected element\n    // DEL\n    addListener('removeSelection', function(context) {\n\n      var event = context.keyEvent;\n\n      if (isKey([ 'Backspace', 'Delete', 'Del' ], event)) {\n        editorActions.trigger('removeSelection');\n\n        return true;\n      }\n    });\n  };\n\n  /**\n   * @type { import('didi').ModuleDeclaration }\n   */\n  var KeyboardModule = {\n    __init__: [ 'keyboard', 'keyboardBindings' ],\n    keyboard: [ 'type', Keyboard ],\n    keyboardBindings: [ 'type', KeyboardBindings ]\n  };\n\n  /**\n   * @typedef {import('../../core/Canvas').default} Canvas\n   * @typedef {import('../../features/keyboard/Keyboard').default} Keyboard\n   */\n\n  var DEFAULT_CONFIG = {\n    moveSpeed: 50,\n    moveSpeedAccelerated: 200\n  };\n\n\n  /**\n   * A feature that allows users to move the canvas using the keyboard.\n   *\n   * @param {Object} config\n   * @param {number} [config.moveSpeed=50]\n   * @param {number} [config.moveSpeedAccelerated=200]\n   * @param {Keyboard} keyboard\n   * @param {Canvas} canvas\n   */\n  function KeyboardMove(\n      config,\n      keyboard,\n      canvas\n  ) {\n\n    var self = this;\n\n    this._config = assign$1({}, DEFAULT_CONFIG, config || {});\n\n    keyboard.addListener(arrowsListener);\n\n\n    function arrowsListener(context) {\n\n      var event = context.keyEvent,\n          config = self._config;\n\n      if (!keyboard.isCmd(event)) {\n        return;\n      }\n\n      if (keyboard.isKey([\n        'ArrowLeft', 'Left',\n        'ArrowUp', 'Up',\n        'ArrowDown', 'Down',\n        'ArrowRight', 'Right'\n      ], event)) {\n\n        var speed = (\n          keyboard.isShift(event) ?\n            config.moveSpeedAccelerated :\n            config.moveSpeed\n        );\n\n        var direction;\n\n        switch (event.key) {\n        case 'ArrowLeft':\n        case 'Left':\n          direction = 'left';\n          break;\n        case 'ArrowUp':\n        case 'Up':\n          direction = 'up';\n          break;\n        case 'ArrowRight':\n        case 'Right':\n          direction = 'right';\n          break;\n        case 'ArrowDown':\n        case 'Down':\n          direction = 'down';\n          break;\n        }\n\n        self.moveCanvas({\n          speed: speed,\n          direction: direction\n        });\n\n        return true;\n      }\n    }\n\n    /**\n     * @param {{\n     *   direction: 'up' | 'down' | 'left' | 'right';\n     *   speed: number;\n     * }} options\n     */\n    this.moveCanvas = function(options) {\n\n      var dx = 0,\n          dy = 0,\n          speed = options.speed;\n\n      var actualSpeed = speed / Math.min(Math.sqrt(canvas.viewbox().scale), 1);\n\n      switch (options.direction) {\n      case 'left': // Left\n        dx = actualSpeed;\n        break;\n      case 'up': // Up\n        dy = actualSpeed;\n        break;\n      case 'right': // Right\n        dx = -actualSpeed;\n        break;\n      case 'down': // Down\n        dy = -actualSpeed;\n        break;\n      }\n\n      canvas.scroll({\n        dx: dx,\n        dy: dy\n      });\n    };\n\n  }\n\n\n  KeyboardMove.$inject = [\n    'config.keyboardMove',\n    'keyboard',\n    'canvas'\n  ];\n\n  /**\n   * @type { import('didi').ModuleDeclaration }\n   */\n  var KeyboardMoveModule = {\n    __depends__: [\n      KeyboardModule\n    ],\n    __init__: [ 'keyboardMove' ],\n    keyboardMove: [ 'type', KeyboardMove ]\n  };\n\n  var CURSOR_CLS_PATTERN = /^djs-cursor-.*$/;\n\n  /**\n   * @param {string} mode\n   */\n  function set(mode) {\n    var classes$1 = classes(document.body);\n\n    classes$1.removeMatching(CURSOR_CLS_PATTERN);\n\n    if (mode) {\n      classes$1.add('djs-cursor-' + mode);\n    }\n  }\n\n  function unset() {\n    set(null);\n  }\n\n  /**\n   * @typedef {import('../core/EventBus').default} EventBus\n   */\n\n  var TRAP_PRIORITY = 5000;\n\n  /**\n   * Installs a click trap that prevents a ghost click following a dragging operation.\n   *\n   * @param {EventBus} eventBus\n   * @param {string} [eventName='element.click']\n   *\n   * @return {() => void} a function to immediately remove the installed trap.\n   */\n  function install(eventBus, eventName) {\n\n    eventName = eventName || 'element.click';\n\n    function trap() {\n      return false;\n    }\n\n    eventBus.once(eventName, TRAP_PRIORITY, trap);\n\n    return function() {\n      eventBus.off(eventName, trap);\n    };\n  }\n\n  /**\n   * @typedef {import('../util/Types').Point} Point\n   * @typedef {import('../util/Types').Rect} Rect\n   */\n\n\n\n  /**\n   * @param {Point} a\n   * @param {Point} b\n   * @return {Point}\n   */\n  function delta(a, b) {\n    return {\n      x: a.x - b.x,\n      y: a.y - b.y\n    };\n  }\n\n  /**\n   * @typedef {import('../../core/Canvas').default} Canvas\n   * @typedef {import('../../core/EventBus').default} EventBus\n   */\n\n  var THRESHOLD = 15;\n\n\n  /**\n   * Move the canvas via mouse.\n   *\n   * @param {EventBus} eventBus\n   * @param {Canvas} canvas\n   */\n  function MoveCanvas(eventBus, canvas) {\n\n    var context;\n\n    function handleMousedown(event) {\n      return handleStart(event.originalEvent);\n    }\n\n    // listen for move on element mouse down;\n    // allow others to hook into the event before us though\n    // (dragging / element moving will do this)\n    eventBus.on('canvas.focus.changed', function(event) {\n      if (event.focused) {\n        eventBus.on('element.mousedown', 500, handleMousedown);\n      } else {\n        eventBus.off('element.mousedown', handleMousedown);\n      }\n    });\n\n\n    function handleMove(event) {\n\n      var start = context.start,\n          button = context.button,\n          position = toPoint(event),\n          delta$1 = delta(position, start);\n\n      if (!context.dragging && length(delta$1) > THRESHOLD) {\n        context.dragging = true;\n\n        if (button === 0) {\n          install(eventBus);\n        }\n\n        set('grab');\n      }\n\n      if (context.dragging) {\n\n        var lastPosition = context.last || context.start;\n\n        delta$1 = delta(position, lastPosition);\n\n        canvas.scroll({\n          dx: delta$1.x,\n          dy: delta$1.y\n        });\n\n        context.last = position;\n      }\n\n      // prevent select\n      event.preventDefault();\n    }\n\n\n    function handleEnd(event$1) {\n      event.unbind(document, 'mousemove', handleMove);\n      event.unbind(document, 'mouseup', handleEnd);\n\n      context = null;\n\n      unset();\n    }\n\n    function handleStart(event$1) {\n\n      // event is already handled by '.djs-draggable'\n      if (closest(event$1.target, '.djs-draggable')) {\n        return;\n      }\n\n      var button = event$1.button;\n\n      // reject right mouse button or modifier key\n      if (button >= 2 || event$1.ctrlKey || event$1.shiftKey || event$1.altKey) {\n        return;\n      }\n\n      context = {\n        button: button,\n        start: toPoint(event$1)\n      };\n\n      event.bind(document, 'mousemove', handleMove);\n      event.bind(document, 'mouseup', handleEnd);\n\n      // we've handled the event\n      return true;\n    }\n\n    this.isActive = function() {\n      return !!context;\n    };\n\n  }\n\n\n  MoveCanvas.$inject = [\n    'eventBus',\n    'canvas'\n  ];\n\n\n\n  // helpers ///////\n\n  function length(point) {\n    return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));\n  }\n\n  /**\n   * @type { import('didi').ModuleDeclaration }\n   */\n  var MoveCanvasModule = {\n    __init__: [ 'moveCanvas' ],\n    moveCanvas: [ 'type', MoveCanvas ]\n  };\n\n  /**\n   * Get the logarithm of x with base 10.\n   *\n   * @param {number} x\n   */\n  function log10(x) {\n    return Math.log(x) / Math.log(10);\n  }\n\n  /**\n   * Get step size for given range and number of steps.\n   *\n   * @param {Object} range\n   * @param {number} range.min\n   * @param {number} range.max\n   * @param {number} steps\n   */\n  function getStepSize(range, steps) {\n\n    var minLinearRange = log10(range.min),\n        maxLinearRange = log10(range.max);\n\n    var absoluteLinearRange = Math.abs(minLinearRange) + Math.abs(maxLinearRange);\n\n    return absoluteLinearRange / steps;\n  }\n\n  /**\n   * @param {Object} range\n   * @param {number} range.min\n   * @param {number} range.max\n   * @param {number} scale\n   */\n  function cap(range, scale) {\n    return Math.max(range.min, Math.min(range.max, scale));\n  }\n\n  /**\n   * @typedef {import('../../core/Canvas').default} Canvas\n   * @typedef {import('../../core/EventBus').default} EventBus\n   *\n   * @typedef {import('../../util/Types').Point} Point\n   * @typedef {import('../../util/Types').ScrollDelta} ScrollDelta\n   */\n\n  var sign = Math.sign || function(n) {\n    return n >= 0 ? 1 : -1;\n  };\n\n  var RANGE = { min: 0.2, max: 4 },\n      NUM_STEPS = 10;\n\n  var DELTA_THRESHOLD = 0.1;\n\n  var DEFAULT_SCALE = 0.75;\n\n  /**\n   * An implementation of zooming and scrolling within the\n   * {@link Canvas} via the mouse wheel.\n   *\n   * Mouse wheel zooming / scrolling may be disabled using\n   * the {@link toggle(enabled)} method.\n   *\n   * @param {Object} [config]\n   * @param {boolean} [config.enabled=true] default enabled state\n   * @param {number} [config.scale=.75] scroll sensivity\n   * @param {EventBus} eventBus\n   * @param {Canvas} canvas\n   */\n  function ZoomScroll(config, eventBus, canvas) {\n\n    config = config || {};\n\n    this._enabled = false;\n\n    this._canvas = canvas;\n    this._container = canvas._container;\n\n    this._handleWheel = bind$2(this._handleWheel, this);\n\n    this._totalDelta = 0;\n    this._scale = config.scale || DEFAULT_SCALE;\n\n    var self = this;\n\n    eventBus.on('canvas.focus.changed', function(event) {\n      self._init(event.focused && config.enabled !== false);\n    });\n  }\n\n  ZoomScroll.$inject = [\n    'config.zoomScroll',\n    'eventBus',\n    'canvas'\n  ];\n\n  /**\n   * @param {ScrollDelta} delta\n   */\n  ZoomScroll.prototype.scroll = function scroll(delta) {\n    this._canvas.scroll(delta);\n  };\n\n\n  ZoomScroll.prototype.reset = function reset() {\n    this._canvas.zoom('fit-viewport');\n  };\n\n  /**\n   * Zoom depending on delta.\n   *\n   * @param {number} delta\n   * @param {Point} position\n   */\n  ZoomScroll.prototype.zoom = function zoom(delta, position) {\n\n    // zoom with half the step size of stepZoom\n    var stepSize = getStepSize(RANGE, NUM_STEPS * 2);\n\n    // add until threshold reached\n    this._totalDelta += delta;\n\n    if (Math.abs(this._totalDelta) > DELTA_THRESHOLD) {\n      this._zoom(delta, position, stepSize);\n\n      // reset\n      this._totalDelta = 0;\n    }\n  };\n\n\n  ZoomScroll.prototype._handleWheel = function handleWheel(event) {\n\n    if (!this._canvas.isFocused()) {\n      return;\n    }\n\n    var element = this._container;\n\n    event.preventDefault();\n\n    // pinch to zoom is mapped to wheel + ctrlKey = true\n    // in modern browsers (!)\n\n    var isZoom = event.ctrlKey || (isMac() && event.metaKey);\n\n    var isHorizontalScroll = event.shiftKey;\n\n    var factor = -1 * this._scale,\n        delta;\n\n    if (isZoom) {\n      factor *= event.deltaMode === 0 ? 0.020 : 0.32;\n    } else {\n      factor *= event.deltaMode === 0 ? 1.0 : 16.0;\n    }\n\n    if (isZoom) {\n      var elementRect = element.getBoundingClientRect();\n\n      var offset = {\n        x: event.clientX - elementRect.left,\n        y: event.clientY - elementRect.top\n      };\n\n      delta = (\n        Math.sqrt(\n          Math.pow(event.deltaY, 2) +\n          Math.pow(event.deltaX, 2)\n        ) * sign(event.deltaY) * factor\n      );\n\n      // zoom in relative to diagram {x,y} coordinates\n      this.zoom(delta, offset);\n    } else {\n\n      if (isHorizontalScroll) {\n        delta = {\n          dx: factor * event.deltaY,\n          dy: 0\n        };\n      } else {\n        delta = {\n          dx: factor * event.deltaX,\n          dy: factor * event.deltaY\n        };\n      }\n\n      this.scroll(delta);\n    }\n  };\n\n  /**\n   * Zoom with fixed step size.\n   *\n   * @param {number} delta Zoom delta (1 for zooming in, -1 for zooming out).\n   * @param {Point} [position]\n   */\n  ZoomScroll.prototype.stepZoom = function stepZoom(delta, position) {\n\n    var stepSize = getStepSize(RANGE, NUM_STEPS);\n\n    this._zoom(delta, position, stepSize);\n  };\n\n\n  /**\n   * Zoom in/out given a step size.\n   *\n   * @param {number} delta\n   * @param {Point} [position]\n   * @param {number} stepSize\n   */\n  ZoomScroll.prototype._zoom = function(delta, position, stepSize) {\n    var canvas = this._canvas;\n\n    var direction = delta > 0 ? 1 : -1;\n\n    var currentLinearZoomLevel = log10(canvas.zoom());\n\n    // snap to a proximate zoom step\n    var newLinearZoomLevel = Math.round(currentLinearZoomLevel / stepSize) * stepSize;\n\n    // increase or decrease one zoom step in the given direction\n    newLinearZoomLevel += stepSize * direction;\n\n    // calculate the absolute logarithmic zoom level based on the linear zoom level\n    // (e.g. 2 for an absolute x2 zoom)\n    var newLogZoomLevel = Math.pow(10, newLinearZoomLevel);\n\n    canvas.zoom(cap(RANGE, newLogZoomLevel), position);\n  };\n\n\n  /**\n   * Toggle the zoom scroll ability via mouse wheel.\n   *\n   * @param {boolean} [newEnabled] new enabled state\n   */\n  ZoomScroll.prototype.toggle = function toggle(newEnabled) {\n\n    var element = this._container;\n    var handleWheel = this._handleWheel;\n\n    var oldEnabled = this._enabled;\n\n    if (typeof newEnabled === 'undefined') {\n      newEnabled = !oldEnabled;\n    }\n\n    // only react on actual changes\n    if (oldEnabled !== newEnabled) {\n\n      // add or remove wheel listener based on\n      // changed enabled state\n      event[newEnabled ? 'bind' : 'unbind'](element, 'wheel', handleWheel, false);\n    }\n\n    this._enabled = newEnabled;\n\n    return newEnabled;\n  };\n\n\n  ZoomScroll.prototype._init = function(newEnabled) {\n    this.toggle(newEnabled);\n  };\n\n  /**\n   * @type { import('didi').ModuleDeclaration }\n   */\n  var ZoomScrollModule = {\n    __init__: [ 'zoomScroll' ],\n    zoomScroll: [ 'type', ZoomScroll ]\n  };\n\n  /**\r\n   * @typedef { import('./BaseViewer').BaseViewerOptions } BaseViewerOptions\r\n   */\r\n\r\n  /**\r\n   * A viewer with mouse and keyboard navigation features.\r\n   *\r\n   * @template [ServiceMap=null]\r\n   *\r\n   * @extends Viewer<ServiceMap>\r\n   *\r\n   * @param {BaseViewerOptions} [options]\r\n   */\r\n  function NavigatedViewer(options) {\r\n    Viewer.call(this, options);\r\n  }\r\n\r\n  e(NavigatedViewer, Viewer);\r\n\r\n\r\n  NavigatedViewer.prototype._navigationModules = [\r\n    KeyboardMoveModule,\r\n    MoveCanvasModule,\r\n    ZoomScrollModule\r\n  ];\r\n\r\n  NavigatedViewer.prototype._modules = [].concat(\r\n    Viewer.prototype._modules,\r\n    NavigatedViewer.prototype._navigationModules\r\n  );\n\n  return NavigatedViewer;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2JwbW4tanMvZGlzdC9icG1uLW5hdmlnYXRlZC12aWV3ZXIuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsQ0FDcUc7QUFDdkcsQ0FBQyx1QkFBdUI7O0FBRXhCLGtCQUFrQixzREFBc0QsYUFBYSwwREFBMEQ7O0FBRS9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLFNBQVM7QUFDVDs7O0FBR0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQSxn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YTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCLGNBQWMsWUFBWTtBQUMxQjtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQixjQUFjLFlBQVk7QUFDMUI7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtB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QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxlQUFlO0FBQzVCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLFNBQVM7QUFDdEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxTQUFTO0FBQ3RCLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxTQUFTO0FBQ3RCLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxTQUFTO0FBQ3RCLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBLDJEQUEyRDtBQUMzRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLHVDQUF1QztBQUNuRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzRUFBc0U7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxPQUFPO0FBQ1AsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7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QUFDQSxlQUFlLEdBQUcsRUFBRSxJQUFJLEdBQUcsS0FBSyxFQUFFLE1BQU0sSUFBSSxLQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsZUFBZSxHQUFHLEVBQUUsSUFBSSxHQUFHLEtBQUssRUFBRSxNQUFNLElBQUksS0FBSyxHQUFHLE1BQU0sSUFBSSxLQUFLLEVBQUUsTUFBTTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGVBQWUsS0FBSyxFQUFFLE1BQU0sR0FBRyxLQUFLLFFBQVEsTUFBTSxJQUFJLEtBQUs7QUFDM0QsZUFBZSxLQUFLLEVBQUUsTUFBTSxHQUFHLEtBQUs7QUFDcEMsZUFBZSxLQUFLLEVBQUUsTUFBTSxHQUFHLEtBQUs7QUFDcEMsZUFBZSxLQUFLLEVBQUUsTUFBTSxHQUFHLEtBQUs7QUFDcEMsZUFBZSxLQUFLLEVBQUUsTUFBTSxHQUFHLEtBQUs7QUFDcEMsZUFBZSxLQUFLLEVBQUUsTUFBTSxHQUFHLEtBQUs7QUFDcEMsZUFBZSxLQUFLLEVBQUUsTUFBTSxHQUFHLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxlQUFlLEdBQUcsRUFBRSxJQUFJLEdBQUcsTUFBTSxFQUFFLEtBQUssTUFBTSxPQUFPLEtBQUssTUFBTSxPQUFPLEtBQUssR0FBRyxNQUFNLEVBQUUsS0FBSyxHQUFHLE1BQU07QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxlQUFlLEdBQUcsRUFBRSxLQUFLLEtBQUssR0FBRyxPQUFPLEtBQUssR0FBRyxPQUFPLEtBQUssRUFBRSxPQUFPLEtBQUssR0FBRyxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEdBQUcsTUFBTTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGVBQWUsR0FBRyxFQUFFLElBQUksRUFBRSxLQUFLLE1BQU0sT0FBTyxLQUFLLE1BQU0sT0FBTyxLQUFLO0FBQ25FLGVBQWUsT0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFlBQVksMkJBQTJCLElBQUksT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsU0FBUztBQUN0QjtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QkFBNEIsc0JBQXNCOztBQUVsRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7O0FBRWxEO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUscUNBQXFDO0FBQ3BELGVBQWUsOENBQThDO0FBQzdELGVBQWUsdUNBQXVDO0FBQ3RELGVBQWUsOENBQThDO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQixhQUFhLGlCQUFpQjtBQUM5QixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RCxPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxxQ0FBcUM7QUFDcEQsZUFBZSxvQ0FBb0M7QUFDbkQsZUFBZSx5Q0FBeUM7QUFDeEQ7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxnQkFBZ0Isb0RBQW9EO0FBQ3BFLGdCQUFnQixvQ0FBb0M7QUFDcEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLHdDQUF3QztBQUNyRCxhQUFhLFNBQVM7QUFDdEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwyRUFBMkUsV0FBVzs7QUFFdEY7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLHdDQUF3QztBQUNyRCxhQUFhLFNBQVM7QUFDdEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLHdDQUF3QztBQUNyRCxhQUFhLFNBQVM7QUFDdEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLHdDQUF3QztBQUNyRCxhQUFhLFNBQVM7QUFDdEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLHdDQUF3QztBQUNyRCxhQUFhLFNB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QUFDQTtBQUNBLDhCQUE4QixzQ0FBc0M7QUFDcEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxhQUFh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QUFTO0FBQzNEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztB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OztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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O0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVOztBQUVWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7O0FBRUEsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxXQUFXO0FBQ3hEOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFlBQVk7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLDZCQUE2QjtBQUN0RTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVIsMENBQTBDLDJCQUEyQjtBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsYUFBYSwwQkFBMEI7QUFDaEYsOEJBQThCLGFBQWE7QUFDM0M7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLFVBQVU7QUFDMUIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsS0FBSywwQ0FBMEM7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTLElBQUk7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZTtBQUNmLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixvQ0FBb0M7QUFDNUQsTUFBTTtBQUNOLHdCQUF3QixrRUFBa0U7QUFDMUY7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixvQ0FBb0M7QUFDMUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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LElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQiwyQ0FBMkM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFkZHJhLXdlYi8uLi8uLi9ub2RlX21vZHVsZXMvYnBtbi1qcy9kaXN0L2JwbW4tbmF2aWdhdGVkLXZpZXdlci5kZXZlbG9wbWVudC5qcz9kYTBjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxyXG4gKiBicG1uLWpzIC0gYnBtbi1uYXZpZ2F0ZWQtdmlld2VyIHYxOC42LjNcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIGNhbXVuZGEgU2VydmljZXMgR21iSFxyXG4gKlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgYnBtbi5pbyBsaWNlbnNlXHJcbiAqIGh0dHA6Ly9icG1uLmlvL2xpY2Vuc2VcclxuICpcclxuICogU291cmNlIENvZGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9icG1uLWlvL2JwbW4tanNcclxuICpcclxuICogRGF0ZTogMjAyNS0wOC0xOVxyXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLkJwbW5KUyA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gZShlLHQpe3QmJihlLnN1cGVyXz10LGUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ZmFsc2Usd3JpdGFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZX19KSk7fVxuXG4gIC8qKlxuICAgKiBGbGF0dGVuIGFycmF5LCBvbmUgbGV2ZWwgZGVlcC5cbiAgICpcbiAgICogQHRlbXBsYXRlIFRcbiAgICpcbiAgICogQHBhcmFtIHtUW11bXSB8IFRbXSB8IG51bGx9IFthcnJdXG4gICAqXG4gICAqIEByZXR1cm4ge1RbXX1cbiAgICovXG5cbiAgY29uc3QgbmF0aXZlVG9TdHJpbmckMSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gIGNvbnN0IG5hdGl2ZUhhc093blByb3BlcnR5JDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIGZ1bmN0aW9uIGlzVW5kZWZpbmVkJDIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNEZWZpbmVkKG9iaikge1xuICAgIHJldHVybiBvYmogIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTmlsKG9iaikge1xuICAgIHJldHVybiBvYmogPT0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQXJyYXkkMihvYmopIHtcbiAgICByZXR1cm4gbmF0aXZlVG9TdHJpbmckMS5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH1cblxuICBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICByZXR1cm4gbmF0aXZlVG9TdHJpbmckMS5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XG4gICAgcmV0dXJuIG5hdGl2ZVRvU3RyaW5nJDEuY2FsbChvYmopID09PSAnW29iamVjdCBOdW1iZXJdJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gb2JqXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICAgIGNvbnN0IHRhZyA9IG5hdGl2ZVRvU3RyaW5nJDEuY2FsbChvYmopO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIHRhZyA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyB8fFxuICAgICAgdGFnID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScgfHxcbiAgICAgIHRhZyA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyB8fFxuICAgICAgdGFnID09PSAnW29iamVjdCBBc3luY0dlbmVyYXRvckZ1bmN0aW9uXScgfHxcbiAgICAgIHRhZyA9PT0gJ1tvYmplY3QgUHJveHldJ1xuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4gbmF0aXZlVG9TdHJpbmckMS5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlLCBpZiB0YXJnZXQgb3ducyBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBoYXMkMSh0YXJnZXQsIGtleSkge1xuICAgIHJldHVybiBuYXRpdmVIYXNPd25Qcm9wZXJ0eSQxLmNhbGwodGFyZ2V0LCBrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEB0eXBlZGVmIHsgKFxuICAgKiAgICgoZTogVCkgPT4gYm9vbGVhbikgfFxuICAgKiAgICgoZTogVCwgaWR4OiBudW1iZXIpID0+IGJvb2xlYW4pIHxcbiAgICogICAoKGU6IFQsIGtleTogc3RyaW5nKSA9PiBib29sZWFuKSB8XG4gICAqICAgc3RyaW5nIHxcbiAgICogICBudW1iZXJcbiAgICogKSB9IE1hdGNoZXJcbiAgICovXG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEB0ZW1wbGF0ZSBVXG4gICAqXG4gICAqIEB0eXBlZGVmIHsgKFxuICAgKiAgICgoZTogVCkgPT4gVSkgfCBzdHJpbmcgfCBudW1iZXJcbiAgICogKSB9IEV4dHJhY3RvclxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAdHlwZWRlZiB7ICh2YWw6IFQsIGtleTogYW55KSA9PiBib29sZWFuIH0gTWF0Y2hGblxuICAgKi9cblxuICAvKipcbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHR5cGVkZWYgeyBUW10gfSBBcnJheUNvbGxlY3Rpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEB0eXBlZGVmIHsgeyBba2V5OiBzdHJpbmddOiBUIH0gfSBTdHJpbmdLZXlWYWx1ZUNvbGxlY3Rpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEB0eXBlZGVmIHsgeyBba2V5OiBudW1iZXJdOiBUIH0gfSBOdW1iZXJLZXlWYWx1ZUNvbGxlY3Rpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEB0eXBlZGVmIHsgU3RyaW5nS2V5VmFsdWVDb2xsZWN0aW9uPFQ+IHwgTnVtYmVyS2V5VmFsdWVDb2xsZWN0aW9uPFQ+IH0gS2V5VmFsdWVDb2xsZWN0aW9uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAdHlwZWRlZiB7IEtleVZhbHVlQ29sbGVjdGlvbjxUPiB8IEFycmF5Q29sbGVjdGlvbjxUPiB9IENvbGxlY3Rpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIEZpbmQgZWxlbWVudCBpbiBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb248VD59IGNvbGxlY3Rpb25cbiAgICogQHBhcmFtIHtNYXRjaGVyPFQ+fSBtYXRjaGVyXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGZ1bmN0aW9uIGZpbmQoY29sbGVjdGlvbiwgbWF0Y2hlcikge1xuXG4gICAgY29uc3QgbWF0Y2hGbiA9IHRvTWF0Y2hlcihtYXRjaGVyKTtcblxuICAgIGxldCBtYXRjaDtcblxuICAgIGZvckVhY2gkMShjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgaWYgKG1hdGNoRm4odmFsLCBrZXkpKSB7XG4gICAgICAgIG1hdGNoID0gdmFsO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBtYXRjaDtcblxuICB9XG5cblxuICAvKipcbiAgICogRmluZCBlbGVtZW50IGluZGV4IGluIGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbjxUPn0gY29sbGVjdGlvblxuICAgKiBAcGFyYW0ge01hdGNoZXI8VD59IG1hdGNoZXJcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gZmluZEluZGV4KGNvbGxlY3Rpb24sIG1hdGNoZXIpIHtcblxuICAgIGNvbnN0IG1hdGNoRm4gPSB0b01hdGNoZXIobWF0Y2hlcik7XG5cbiAgICBsZXQgaWR4ID0gaXNBcnJheSQyKGNvbGxlY3Rpb24pID8gLTEgOiB1bmRlZmluZWQ7XG5cbiAgICBmb3JFYWNoJDEoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgIGlmIChtYXRjaEZuKHZhbCwga2V5KSkge1xuICAgICAgICBpZHggPSBrZXk7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGlkeDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEZpbHRlciBlbGVtZW50cyBpbiBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb248VD59IGNvbGxlY3Rpb25cbiAgICogQHBhcmFtIHtNYXRjaGVyPFQ+fSBtYXRjaGVyXG4gICAqXG4gICAqIEByZXR1cm4ge1RbXX0gcmVzdWx0XG4gICAqL1xuICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgbWF0Y2hlcikge1xuXG4gICAgY29uc3QgbWF0Y2hGbiA9IHRvTWF0Y2hlcihtYXRjaGVyKTtcblxuICAgIGxldCByZXN1bHQgPSBbXTtcblxuICAgIGZvckVhY2gkMShjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgaWYgKG1hdGNoRm4odmFsLCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGNvbGxlY3Rpb247IHJldHVybmluZyBzb21ldGhpbmdcbiAgICogKG5vbi11bmRlZmluZWQpIHdpbGwgc3RvcCBpdGVyYXRpb24uXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbjxUPn0gY29sbGVjdGlvblxuICAgKiBAcGFyYW0geyAoKGl0ZW06IFQsIGlkeDogbnVtYmVyKSA9PiAoYm9vbGVhbnx2b2lkKSkgfCAoKGl0ZW06IFQsIGtleTogc3RyaW5nKSA9PiAoYm9vbGVhbnx2b2lkKSkgfSBpdGVyYXRvclxuICAgKlxuICAgKiBAcmV0dXJuIHtUfSByZXR1cm4gcmVzdWx0IHRoYXQgc3RvcHBlZCB0aGUgaXRlcmF0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBmb3JFYWNoJDEoY29sbGVjdGlvbiwgaXRlcmF0b3IpIHtcblxuICAgIGxldCB2YWwsXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChpc1VuZGVmaW5lZCQyKGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29udmVydEtleSA9IGlzQXJyYXkkMihjb2xsZWN0aW9uKSA/IHRvTnVtJDEgOiBpZGVudGl0eSQxO1xuXG4gICAgZm9yIChsZXQga2V5IGluIGNvbGxlY3Rpb24pIHtcblxuICAgICAgaWYgKGhhcyQxKGNvbGxlY3Rpb24sIGtleSkpIHtcbiAgICAgICAgdmFsID0gY29sbGVjdGlvbltrZXldO1xuXG4gICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yKHZhbCwgY29udmVydEtleShrZXkpKTtcblxuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZWR1Y2UgY29sbGVjdGlvbiwgcmV0dXJuaW5nIGEgc2luZ2xlIHJlc3VsdC5cbiAgICpcbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHRlbXBsYXRlIFZcbiAgICpcbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uPFQ+fSBjb2xsZWN0aW9uXG4gICAqIEBwYXJhbSB7KHJlc3VsdDogViwgZW50cnk6IFQsIGluZGV4OiBhbnkpID0+IFZ9IGl0ZXJhdG9yXG4gICAqIEBwYXJhbSB7Vn0gcmVzdWx0XG4gICAqXG4gICAqIEByZXR1cm4ge1Z9IHJlc3VsdCByZXR1cm5lZCBmcm9tIGxhc3QgaXRlcmF0b3JcbiAgICovXG4gIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRvciwgcmVzdWx0KSB7XG5cbiAgICBmb3JFYWNoJDEoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGlkeCkge1xuICAgICAgcmVzdWx0ID0gaXRlcmF0b3IocmVzdWx0LCB2YWx1ZSwgaWR4KTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiBldmVyeSBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uXG4gICAqIG1hdGNoZXMgdGhlIGNyaXRlcmlhLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9IGNvbGxlY3Rpb25cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IG1hdGNoZXJcbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIG1hdGNoZXIpIHtcblxuICAgIHJldHVybiAhIXJlZHVjZShjb2xsZWN0aW9uLCBmdW5jdGlvbihtYXRjaGVzLCB2YWwsIGtleSkge1xuICAgICAgcmV0dXJuIG1hdGNoZXMgJiYgbWF0Y2hlcih2YWwsIGtleSk7XG4gICAgfSwgdHJ1ZSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiBzb21lIGVsZW1lbnRzIGluIHRoZSBjb2xsZWN0aW9uXG4gICAqIG1hdGNoIHRoZSBjcml0ZXJpYS5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fEFycmF5fSBjb2xsZWN0aW9uXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBtYXRjaGVyXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIG1hdGNoZXIpIHtcblxuICAgIHJldHVybiAhIWZpbmQoY29sbGVjdGlvbiwgbWF0Y2hlcik7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gYSBjb2xsZWN0aW9uIGludG8gYW5vdGhlciBjb2xsZWN0aW9uXG4gICAqIGJ5IHBpcGluZyBlYWNoIG1lbWJlciB0aHJvdWdoIHRoZSBnaXZlbiBmbi5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fEFycmF5fSAgIGNvbGxlY3Rpb25cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSB0cmFuc2Zvcm1lZCBjb2xsZWN0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBtYXAkMShjb2xsZWN0aW9uLCBmbikge1xuXG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yRWFjaCQxKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICByZXN1bHQucHVzaChmbih2YWwsIGtleSkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBvYmplY3QgcGF0dGVybiBtYXRjaGVyLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNvbnN0IG1hdGNoZXIgPSBtYXRjaFBhdHRlcm4oeyBpZDogMSB9KTtcbiAgICpcbiAgICogbGV0IGVsZW1lbnQgPSBmaW5kKGVsZW1lbnRzLCBtYXRjaGVyKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqXG4gICAqIEBwYXJhbSB7VH0gcGF0dGVyblxuICAgKlxuICAgKiBAcmV0dXJuIHsgKGVsOiBhbnkpID0+ICBib29sZWFuIH0gbWF0Y2hlckZuXG4gICAqL1xuICBmdW5jdGlvbiBtYXRjaFBhdHRlcm4ocGF0dGVybikge1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XG5cbiAgICAgIHJldHVybiBldmVyeShwYXR0ZXJuLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgICByZXR1cm4gZWxba2V5XSA9PT0gdmFsO1xuICAgICAgfSk7XG5cbiAgICB9O1xuICB9XG5cblxuICAvKipcbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHBhcmFtIHtNYXRjaGVyPFQ+fSBtYXRjaGVyXG4gICAqXG4gICAqIEByZXR1cm4ge01hdGNoRm48VD59XG4gICAqL1xuICBmdW5jdGlvbiB0b01hdGNoZXIobWF0Y2hlcikge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKG1hdGNoZXIpID8gbWF0Y2hlciA6IChlKSA9PiB7XG4gICAgICByZXR1cm4gZSA9PT0gbWF0Y2hlcjtcbiAgICB9O1xuICB9XG5cblxuICBmdW5jdGlvbiBpZGVudGl0eSQxKGFyZykge1xuICAgIHJldHVybiBhcmc7XG4gIH1cblxuICBmdW5jdGlvbiB0b051bSQxKGFyZykge1xuICAgIHJldHVybiBOdW1iZXIoYXJnKTtcbiAgfVxuXG4gIC8qIGdsb2JhbCBzZXRUaW1lb3V0IGNsZWFyVGltZW91dCAqL1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7IHtcbiAgICogICAoLi4uYXJnczogYW55W10pOiBhbnk7XG4gICAqICAgZmx1c2g6ICgpID0+IHZvaWQ7XG4gICAqICAgY2FuY2VsOiAoKSA9PiB2b2lkO1xuICAgKiB9IH0gRGVib3VuY2VkRnVuY3Rpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIERlYm91bmNlIGZuLCBjYWxsaW5nIGl0IG9ubHkgb25jZSBpZiB0aGUgZ2l2ZW4gdGltZVxuICAgKiBlbGFwc2VkIGJldHdlZW4gY2FsbHMuXG4gICAqXG4gICAqIExvZGFzaC1zdHlsZSB0aGUgZnVuY3Rpb24gZXhwb3NlcyBtZXRob2RzIHRvIGAjY2xlYXJgXG4gICAqIGFuZCBgI2ZsdXNoYCB0byBjb250cm9sIGludGVybmFsIGJlaGF2aW9yLlxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB0aW1lb3V0XG4gICAqXG4gICAqIEByZXR1cm4ge0RlYm91bmNlZEZ1bmN0aW9ufSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAgICovXG4gIGZ1bmN0aW9uIGRlYm91bmNlKGZuLCB0aW1lb3V0KSB7XG5cbiAgICBsZXQgdGltZXI7XG5cbiAgICBsZXQgbGFzdEFyZ3M7XG4gICAgbGV0IGxhc3RUaGlzO1xuXG4gICAgbGV0IGxhc3ROb3c7XG5cbiAgICBmdW5jdGlvbiBmaXJlKGZvcmNlKSB7XG5cbiAgICAgIGxldCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgICBsZXQgc2NoZWR1bGVkRGlmZiA9IGZvcmNlID8gMCA6IChsYXN0Tm93ICsgdGltZW91dCkgLSBub3c7XG5cbiAgICAgIGlmIChzY2hlZHVsZWREaWZmID4gMCkge1xuICAgICAgICByZXR1cm4gc2NoZWR1bGUoc2NoZWR1bGVkRGlmZik7XG4gICAgICB9XG5cbiAgICAgIGZuLmFwcGx5KGxhc3RUaGlzLCBsYXN0QXJncyk7XG5cbiAgICAgIGNsZWFyKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGUodGltZW91dCkge1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZpcmUsIHRpbWVvdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG5cbiAgICAgIHRpbWVyID0gbGFzdE5vdyA9IGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgZmlyZSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgY2xlYXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IERlYm91bmNlZEZ1bmN0aW9uIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWxsYmFjayguLi5hcmdzKSB7XG4gICAgICBsYXN0Tm93ID0gRGF0ZS5ub3coKTtcblxuICAgICAgbGFzdEFyZ3MgPSBhcmdzO1xuICAgICAgbGFzdFRoaXMgPSB0aGlzO1xuXG4gICAgICAvLyBlbnN1cmUgYW4gZXhlY3V0aW9uIGlzIHNjaGVkdWxlZFxuICAgICAgaWYgKCF0aW1lcikge1xuICAgICAgICBzY2hlZHVsZSh0aW1lb3V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxsYmFjay5mbHVzaCA9IGZsdXNoO1xuICAgIGNhbGxiYWNrLmNhbmNlbCA9IGNsZWFyO1xuXG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmQgZnVuY3Rpb24gYWdhaW5zdCB0YXJnZXQgPHRoaXM+LlxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIHRhcmdldFxuICAgKlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gYm91bmQgZnVuY3Rpb25cbiAgICovXG4gIGZ1bmN0aW9uIGJpbmQkMihmbiwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGZuLmJpbmQodGFyZ2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSB3cmFwcGVyIGZvciBgT2JqZWN0LmFzc2lnbmAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IG90aGVyc1xuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSB0YXJnZXRcbiAgICovXG4gIGZ1bmN0aW9uIGFzc2lnbiQxKHRhcmdldCwgLi4ub3RoZXJzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCAuLi5vdGhlcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBuZXN0ZWQgcHJvcGVydHkgb2YgYSBnaXZlbiBvYmplY3QgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZS5cbiAgICpcbiAgICogVGhpcyBtdXRhdGVzIHRoZSBvYmplY3QgYW5kIHJldHVybnMgaXQuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqXG4gICAqIEBwYXJhbSB7VH0gdGFyZ2V0IFRoZSB0YXJnZXQgb2YgdGhlIHNldCBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXIpW119IHBhdGggVGhlIHBhdGggdG8gdGhlIG5lc3RlZCB2YWx1ZS5cbiAgICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge1R9XG4gICAqL1xuICBmdW5jdGlvbiBzZXQkMSh0YXJnZXQsIHBhdGgsIHZhbHVlKSB7XG5cbiAgICBsZXQgY3VycmVudFRhcmdldCA9IHRhcmdldDtcblxuICAgIGZvckVhY2gkMShwYXRoLCBmdW5jdGlvbihrZXksIGlkeCkge1xuXG4gICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbGxlZ2FsIGtleSB0eXBlOiAnICsgdHlwZW9mIGtleSArICcuIEtleSBzaG91bGQgYmUgb2YgdHlwZSBudW1iZXIgb3Igc3RyaW5nLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaWxsZWdhbCBrZXk6IGNvbnN0cnVjdG9yJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaWxsZWdhbCBrZXk6IF9fcHJvdG9fXycpO1xuICAgICAgfVxuXG4gICAgICBsZXQgbmV4dEtleSA9IHBhdGhbaWR4ICsgMV07XG4gICAgICBsZXQgbmV4dFRhcmdldCA9IGN1cnJlbnRUYXJnZXRba2V5XTtcblxuICAgICAgaWYgKGlzRGVmaW5lZChuZXh0S2V5KSAmJiBpc05pbChuZXh0VGFyZ2V0KSkge1xuICAgICAgICBuZXh0VGFyZ2V0ID0gY3VycmVudFRhcmdldFtrZXldID0gaXNOYU4oK25leHRLZXkpID8ge30gOiBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzVW5kZWZpbmVkJDIobmV4dEtleSkpIHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkJDIodmFsdWUpKSB7XG4gICAgICAgICAgZGVsZXRlIGN1cnJlbnRUYXJnZXRba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFRhcmdldCA9IG5leHRUYXJnZXQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFBpY2sgcHJvcGVydGllcyBmcm9tIHRoZSBnaXZlbiB0YXJnZXQuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEB0ZW1wbGF0ZSB7YW55W119IFZcbiAgICpcbiAgICogQHBhcmFtIHtUfSB0YXJnZXRcbiAgICogQHBhcmFtIHtWfSBwcm9wZXJ0aWVzXG4gICAqXG4gICAqIEByZXR1cm4gUGljazxULCBWPlxuICAgKi9cbiAgZnVuY3Rpb24gcGljayh0YXJnZXQsIHByb3BlcnRpZXMpIHtcblxuICAgIGxldCByZXN1bHQgPSB7fTtcblxuICAgIGxldCBvYmogPSBPYmplY3QodGFyZ2V0KTtcblxuICAgIGZvckVhY2gkMShwcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wKSB7XG5cbiAgICAgIGlmIChwcm9wIGluIG9iaikge1xuICAgICAgICByZXN1bHRbcHJvcF0gPSB0YXJnZXRbcHJvcF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFBpY2sgYWxsIHRhcmdldCBwcm9wZXJ0aWVzLCBleGNsdWRpbmcgdGhlIGdpdmVuIG9uZXMuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEB0ZW1wbGF0ZSB7YW55W119IFZcbiAgICpcbiAgICogQHBhcmFtIHtUfSB0YXJnZXRcbiAgICogQHBhcmFtIHtWfSBwcm9wZXJ0aWVzXG4gICAqXG4gICAqIEByZXR1cm4ge09taXQ8VCwgVj59IHRhcmdldFxuICAgKi9cbiAgZnVuY3Rpb24gb21pdCh0YXJnZXQsIHByb3BlcnRpZXMpIHtcblxuICAgIGxldCByZXN1bHQgPSB7fTtcblxuICAgIGxldCBvYmogPSBPYmplY3QodGFyZ2V0KTtcblxuICAgIGZvckVhY2gkMShvYmosIGZ1bmN0aW9uKHByb3AsIGtleSkge1xuXG4gICAgICBpZiAocHJvcGVydGllcy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gcHJvcDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgREVGQVVMVF9SRU5ERVJfUFJJT1JJVFkkMSA9IDEwMDA7XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL2NvcmUvVHlwZXMnKS5FbGVtZW50TGlrZX0gRWxlbWVudFxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9jb3JlL1R5cGVzJykuQ29ubmVjdGlvbkxpa2V9IENvbm5lY3Rpb25cbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vY29yZS9UeXBlcycpLlNoYXBlTGlrZX0gU2hhcGVcbiAgICpcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vY29yZS9FdmVudEJ1cycpLmRlZmF1bHR9IEV2ZW50QnVzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBzaGFwZSBhbmQgY29ubmVjdGlvbiByZW5kZXJlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVuZGVyUHJpb3JpdHk9MTAwMF1cbiAgICovXG4gIGZ1bmN0aW9uIEJhc2VSZW5kZXJlcihldmVudEJ1cywgcmVuZGVyUHJpb3JpdHkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICByZW5kZXJQcmlvcml0eSA9IHJlbmRlclByaW9yaXR5IHx8IERFRkFVTFRfUkVOREVSX1BSSU9SSVRZJDE7XG5cbiAgICBldmVudEJ1cy5vbihbICdyZW5kZXIuc2hhcGUnLCAncmVuZGVyLmNvbm5lY3Rpb24nIF0sIHJlbmRlclByaW9yaXR5LCBmdW5jdGlvbihldnQsIGNvbnRleHQpIHtcbiAgICAgIHZhciB0eXBlID0gZXZ0LnR5cGUsXG4gICAgICAgICAgZWxlbWVudCA9IGNvbnRleHQuZWxlbWVudCxcbiAgICAgICAgICB2aXN1YWxzID0gY29udGV4dC5nZngsXG4gICAgICAgICAgYXR0cnMgPSBjb250ZXh0LmF0dHJzO1xuXG4gICAgICBpZiAoc2VsZi5jYW5SZW5kZXIoZWxlbWVudCkpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdyZW5kZXIuc2hhcGUnKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuZHJhd1NoYXBlKHZpc3VhbHMsIGVsZW1lbnQsIGF0dHJzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5kcmF3Q29ubmVjdGlvbih2aXN1YWxzLCBlbGVtZW50LCBhdHRycyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGV2ZW50QnVzLm9uKFsgJ3JlbmRlci5nZXRTaGFwZVBhdGgnLCAncmVuZGVyLmdldENvbm5lY3Rpb25QYXRoJyBdLCByZW5kZXJQcmlvcml0eSwgZnVuY3Rpb24oZXZ0LCBlbGVtZW50KSB7XG4gICAgICBpZiAoc2VsZi5jYW5SZW5kZXIoZWxlbWVudCkpIHtcbiAgICAgICAgaWYgKGV2dC50eXBlID09PSAncmVuZGVyLmdldFNoYXBlUGF0aCcpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5nZXRTaGFwZVBhdGgoZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0Q29ubmVjdGlvblBhdGgoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhbiBlbGVtZW50IGNhbiBiZSByZW5kZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGJlIHJlbmRlcmVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBlbGVtZW50IGNhbiBiZSByZW5kZXJlZC5cbiAgICovXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuY2FuUmVuZGVyID0gZnVuY3Rpb24oZWxlbWVudCkge307XG5cbiAgLyoqXG4gICAqIERyYXdzIGEgc2hhcGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gdmlzdWFscyBUaGUgU1ZHIGVsZW1lbnQgdG8gZHJhdyB0aGUgc2hhcGUgaW50by5cbiAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGUgVGhlIHNoYXBlIHRvIGJlIGRyYXduLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fSBUaGUgU1ZHIGVsZW1lbnQgb2YgdGhlIHNoYXBlIGRyYXduLlxuICAgKi9cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3U2hhcGUgPSBmdW5jdGlvbih2aXN1YWxzLCBzaGFwZSkge307XG5cbiAgLyoqXG4gICAqIERyYXdzIGEgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSB2aXN1YWxzIFRoZSBTVkcgZWxlbWVudCB0byBkcmF3IHRoZSBjb25uZWN0aW9uIGludG8uXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvbiBUaGUgY29ubmVjdGlvbiB0byBiZSBkcmF3bi5cbiAgICpcbiAgICogQHJldHVybiB7U1ZHRWxlbWVudH0gVGhlIFNWRyBlbGVtZW50IG9mIHRoZSBjb25uZWN0aW9uIGRyYXduLlxuICAgKi9cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKHZpc3VhbHMsIGNvbm5lY3Rpb24pIHt9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBTVkcgcGF0aCBvZiB0aGUgZ3JhcGhpY2FsIHJlcHJlc2VudGF0aW9uIG9mIGEgc2hhcGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlIFRoZSBzaGFwZS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgU1ZHIHBhdGggb2YgdGhlIHNoYXBlLlxuICAgKi9cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5nZXRTaGFwZVBhdGggPSBmdW5jdGlvbihzaGFwZSkge307XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIFNWRyBwYXRoIG9mIHRoZSBncmFwaGljYWwgcmVwcmVzZW50YXRpb24gb2YgYSBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb24gVGhlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFNWRyBwYXRoIG9mIHRoZSBjb25uZWN0aW9uLlxuICAgKi9cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5nZXRDb25uZWN0aW9uUGF0aCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHt9O1xuXG4gIC8qKlxyXG4gICAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9tb2RlbC9UeXBlcycpLkVsZW1lbnQgfSBFbGVtZW50XHJcbiAgICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL21vZGVsL1R5cGVzJykuTW9kZGxlRWxlbWVudCB9IE1vZGRsZUVsZW1lbnRcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogSXMgYW4gZWxlbWVudCBvZiB0aGUgZ2l2ZW4gQlBNTiB0eXBlP1xyXG4gICAqXHJcbiAgICogQHBhcmFtICB7RWxlbWVudHxNb2RkbGVFbGVtZW50fSBlbGVtZW50XHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0eXBlXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGlzJDEoZWxlbWVudCwgdHlwZSkge1xyXG4gICAgdmFyIGJvID0gZ2V0QnVzaW5lc3NPYmplY3QoZWxlbWVudCk7XHJcblxyXG4gICAgcmV0dXJuIGJvICYmICh0eXBlb2YgYm8uJGluc3RhbmNlT2YgPT09ICdmdW5jdGlvbicpICYmIGJvLiRpbnN0YW5jZU9mKHR5cGUpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIGVsZW1lbnQgaGFzIGFueSBvZiB0aGUgZ2l2ZW4gdHlwZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR8TW9kZGxlRWxlbWVudH0gZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IHR5cGVzXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGlzQW55KGVsZW1lbnQsIHR5cGVzKSB7XHJcbiAgICByZXR1cm4gc29tZSh0eXBlcywgZnVuY3Rpb24odCkge1xyXG4gICAgICByZXR1cm4gaXMkMShlbGVtZW50LCB0KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBidXNpbmVzcyBvYmplY3QgZm9yIGEgZ2l2ZW4gZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudHxNb2RkbGVFbGVtZW50fSBlbGVtZW50XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtNb2RkbGVFbGVtZW50fVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGdldEJ1c2luZXNzT2JqZWN0KGVsZW1lbnQpIHtcclxuICAgIHJldHVybiAoZWxlbWVudCAmJiBlbGVtZW50LmJ1c2luZXNzT2JqZWN0KSB8fCBlbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBkaSBvYmplY3QgZm9yIGEgZ2l2ZW4gZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7TW9kZGxlRWxlbWVudH1cclxuICAgKi9cclxuICBmdW5jdGlvbiBnZXREaShlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50LmRpO1xyXG4gIH1cblxuICAvKipcclxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9tb2RlbC9UeXBlcycpLkVsZW1lbnR9IEVsZW1lbnRcclxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9tb2RlbC9UeXBlcycpLk1vZGRsZUVsZW1lbnR9IE1vZGRsZUVsZW1lbnRcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBbZGldXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGlzRXhwYW5kZWQoZWxlbWVudCwgZGkpIHtcclxuXHJcbiAgICBpZiAoaXMkMShlbGVtZW50LCAnYnBtbjpDYWxsQWN0aXZpdHknKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzJDEoZWxlbWVudCwgJ2JwbW46U3ViUHJvY2VzcycpKSB7XHJcbiAgICAgIGRpID0gZGkgfHwgZ2V0RGkoZWxlbWVudCk7XHJcblxyXG4gICAgICBpZiAoZGkgJiYgaXMkMShkaSwgJ2JwbW5kaTpCUE1OUGxhbmUnKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZGkgJiYgISFkaS5pc0V4cGFuZGVkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpcyQxKGVsZW1lbnQsICdicG1uOlBhcnRpY2lwYW50JykpIHtcclxuICAgICAgcmV0dXJuICEhZ2V0QnVzaW5lc3NPYmplY3QoZWxlbWVudCkucHJvY2Vzc1JlZjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBmdW5jdGlvbiBpc0hvcml6b250YWwoZWxlbWVudCkge1xyXG5cclxuICAgIGlmICghaXMkMShlbGVtZW50LCAnYnBtbjpQYXJ0aWNpcGFudCcpICYmICFpcyQxKGVsZW1lbnQsICdicG1uOkxhbmUnKSkge1xyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpc0hvcml6b250YWwgPSBnZXREaShlbGVtZW50KS5pc0hvcml6b250YWw7XHJcblxyXG4gICAgaWYgKGlzSG9yaXpvbnRhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpc0hvcml6b250YWw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaXNFdmVudFN1YlByb2Nlc3MoZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIGVsZW1lbnQgJiYgISFnZXRCdXNpbmVzc09iamVjdChlbGVtZW50KS50cmlnZ2VyZWRCeUV2ZW50O1xyXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYSB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBDb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGlzQ29ubmVjdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgaGFzJDEodmFsdWUsICd3YXlwb2ludHMnKTtcbiAgfVxuXG4gIC8qKlxyXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJ2RpYWdyYW0tanMvbGliL3V0aWwvVHlwZXMnKS5Qb2ludH0gUG9pbnRcclxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCdkaWFncmFtLWpzL2xpYi91dGlsL1R5cGVzJykuUmVjdH0gUmVjdFxyXG4gICAqXHJcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vbW9kZWwvVHlwZXMnKS5FbGVtZW50fSBFbGVtZW50XHJcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vbW9kZWwvVHlwZXMnKS5Nb2RkbGVFbGVtZW50fSBNb2RkbGVFbGVtZW50XHJcbiAgICovXHJcblxyXG4gIHZhciBERUZBVUxUX0xBQkVMX1NJWkUkMSA9IHtcclxuICAgIHdpZHRoOiA5MCxcclxuICAgIGhlaWdodDogMjBcclxuICB9O1xyXG5cclxuICB2YXIgRkxPV19MQUJFTF9JTkRFTlQgPSAxNTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSBnaXZlbiBzZW1hbnRpYyBoYXMgYW4gZXh0ZXJuYWwgbGFiZWwuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHNlbWFudGljXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGlzTGFiZWxFeHRlcm5hbChzZW1hbnRpYykge1xyXG4gICAgcmV0dXJuIGlzJDEoc2VtYW50aWMsICdicG1uOkV2ZW50JykgfHxcclxuICAgICAgICAgICBpcyQxKHNlbWFudGljLCAnYnBtbjpHYXRld2F5JykgfHxcclxuICAgICAgICAgICBpcyQxKHNlbWFudGljLCAnYnBtbjpEYXRhU3RvcmVSZWZlcmVuY2UnKSB8fFxyXG4gICAgICAgICAgIGlzJDEoc2VtYW50aWMsICdicG1uOkRhdGFPYmplY3RSZWZlcmVuY2UnKSB8fFxyXG4gICAgICAgICAgIGlzJDEoc2VtYW50aWMsICdicG1uOkRhdGFJbnB1dCcpIHx8XHJcbiAgICAgICAgICAgaXMkMShzZW1hbnRpYywgJ2JwbW46RGF0YU91dHB1dCcpIHx8XHJcbiAgICAgICAgICAgaXMkMShzZW1hbnRpYywgJ2JwbW46U2VxdWVuY2VGbG93JykgfHxcclxuICAgICAgICAgICBpcyQxKHNlbWFudGljLCAnYnBtbjpNZXNzYWdlRmxvdycpIHx8XHJcbiAgICAgICAgICAgaXMkMShzZW1hbnRpYywgJ2JwbW46R3JvdXAnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcG9zaXRpb24gb2YgYSBzZXF1ZW5jZSBmbG93IGxhYmVsLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7UG9pbnRbXX0gd2F5cG9pbnRzXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtQb2ludH1cclxuICAgKi9cclxuICBmdW5jdGlvbiBnZXRGbG93TGFiZWxQb3NpdGlvbih3YXlwb2ludHMpIHtcclxuXHJcbiAgICAvLyBnZXQgdGhlIHdheXBvaW50cyBtaWRcclxuICAgIHZhciBtaWQgPSB3YXlwb2ludHMubGVuZ3RoIC8gMiAtIDE7XHJcblxyXG4gICAgdmFyIGZpcnN0ID0gd2F5cG9pbnRzW01hdGguZmxvb3IobWlkKV07XHJcbiAgICB2YXIgc2Vjb25kID0gd2F5cG9pbnRzW01hdGguY2VpbChtaWQgKyAwLjAxKV07XHJcblxyXG4gICAgLy8gZ2V0IHBvc2l0aW9uXHJcbiAgICB2YXIgcG9zaXRpb24gPSBnZXRXYXlwb2ludHNNaWQod2F5cG9pbnRzKTtcclxuXHJcbiAgICAvLyBjYWxjdWxhdGUgYW5nbGVcclxuICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbigoc2Vjb25kLnkgLSBmaXJzdC55KSAvIChzZWNvbmQueCAtIGZpcnN0LngpKTtcclxuXHJcbiAgICB2YXIgeCA9IHBvc2l0aW9uLngsXHJcbiAgICAgICAgeSA9IHBvc2l0aW9uLnk7XHJcblxyXG4gICAgaWYgKE1hdGguYWJzKGFuZ2xlKSA8IE1hdGguUEkgLyAyKSB7XHJcbiAgICAgIHkgLT0gRkxPV19MQUJFTF9JTkRFTlQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB4ICs9IEZMT1dfTEFCRUxfSU5ERU5UO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIG1pZGRsZSBvZiBhIG51bWJlciBvZiB3YXlwb2ludHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtQb2ludFtdfSB3YXlwb2ludHNcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1BvaW50fVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGdldFdheXBvaW50c01pZCh3YXlwb2ludHMpIHtcclxuXHJcbiAgICB2YXIgbWlkID0gd2F5cG9pbnRzLmxlbmd0aCAvIDIgLSAxO1xyXG5cclxuICAgIHZhciBmaXJzdCA9IHdheXBvaW50c1tNYXRoLmZsb29yKG1pZCldO1xyXG4gICAgdmFyIHNlY29uZCA9IHdheXBvaW50c1tNYXRoLmNlaWwobWlkICsgMC4wMSldO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IGZpcnN0LnggKyAoc2Vjb25kLnggLSBmaXJzdC54KSAvIDIsXHJcbiAgICAgIHk6IGZpcnN0LnkgKyAoc2Vjb25kLnkgLSBmaXJzdC55KSAvIDJcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIG1pZGRsZSBvZiB0aGUgZXh0ZXJuYWwgbGFiZWwgb2YgYW4gZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UG9pbnR9XHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZ2V0RXh0ZXJuYWxMYWJlbE1pZChlbGVtZW50KSB7XHJcblxyXG4gICAgaWYgKGVsZW1lbnQud2F5cG9pbnRzKSB7XHJcbiAgICAgIHJldHVybiBnZXRGbG93TGFiZWxQb3NpdGlvbihlbGVtZW50LndheXBvaW50cyk7XHJcbiAgICB9IGVsc2UgaWYgKGlzJDEoZWxlbWVudCwgJ2JwbW46R3JvdXAnKSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IGVsZW1lbnQueCArIGVsZW1lbnQud2lkdGggLyAyLFxyXG4gICAgICAgIHk6IGVsZW1lbnQueSArIERFRkFVTFRfTEFCRUxfU0laRSQxLmhlaWdodCAvIDJcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogZWxlbWVudC54ICsgZWxlbWVudC53aWR0aCAvIDIsXHJcbiAgICAgICAgeTogZWxlbWVudC55ICsgZWxlbWVudC5oZWlnaHQgKyBERUZBVUxUX0xBQkVMX1NJWkUkMS5oZWlnaHQgLyAyXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBib3VuZHMgb2YgYW4gZWxlbWVudHMgbGFiZWwsIHBhcnNlZCBmcm9tIHRoZSBlbGVtZW50cyBESSBvclxyXG4gICAqIGdlbmVyYXRlZCBmcm9tIGl0cyBib3VuZHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR9IGRpXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtSZWN0fVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGdldEV4dGVybmFsTGFiZWxCb3VuZHMoZGksIGVsZW1lbnQpIHtcclxuXHJcbiAgICB2YXIgbWlkLFxyXG4gICAgICAgIHNpemUsXHJcbiAgICAgICAgYm91bmRzLFxyXG4gICAgICAgIGxhYmVsID0gZGkubGFiZWw7XHJcblxyXG4gICAgaWYgKGxhYmVsICYmIGxhYmVsLmJvdW5kcykge1xyXG4gICAgICBib3VuZHMgPSBsYWJlbC5ib3VuZHM7XHJcblxyXG4gICAgICBzaXplID0ge1xyXG4gICAgICAgIHdpZHRoOiBNYXRoLm1heChERUZBVUxUX0xBQkVMX1NJWkUkMS53aWR0aCwgYm91bmRzLndpZHRoKSxcclxuICAgICAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHRcclxuICAgICAgfTtcclxuXHJcbiAgICAgIG1pZCA9IHtcclxuICAgICAgICB4OiBib3VuZHMueCArIGJvdW5kcy53aWR0aCAvIDIsXHJcbiAgICAgICAgeTogYm91bmRzLnkgKyBib3VuZHMuaGVpZ2h0IC8gMlxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgIG1pZCA9IGdldEV4dGVybmFsTGFiZWxNaWQoZWxlbWVudCk7XHJcblxyXG4gICAgICBzaXplID0gREVGQVVMVF9MQUJFTF9TSVpFJDE7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFzc2lnbiQxKHtcclxuICAgICAgeDogbWlkLnggLSBzaXplLndpZHRoIC8gMixcclxuICAgICAgeTogbWlkLnkgLSBzaXplLmhlaWdodCAvIDJcclxuICAgIH0sIHNpemUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBzZW1hbnRpY1xyXG4gICAqXHJcbiAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgKi9cclxuICBmdW5jdGlvbiBnZXRMYWJlbEF0dHIoc2VtYW50aWMpIHtcclxuICAgIGlmIChcclxuICAgICAgaXMkMShzZW1hbnRpYywgJ2JwbW46Rmxvd0VsZW1lbnQnKSB8fFxyXG4gICAgICBpcyQxKHNlbWFudGljLCAnYnBtbjpQYXJ0aWNpcGFudCcpIHx8XHJcbiAgICAgIGlzJDEoc2VtYW50aWMsICdicG1uOkxhbmUnKSB8fFxyXG4gICAgICBpcyQxKHNlbWFudGljLCAnYnBtbjpTZXF1ZW5jZUZsb3cnKSB8fFxyXG4gICAgICBpcyQxKHNlbWFudGljLCAnYnBtbjpNZXNzYWdlRmxvdycpIHx8XHJcbiAgICAgIGlzJDEoc2VtYW50aWMsICdicG1uOkRhdGFJbnB1dCcpIHx8XHJcbiAgICAgIGlzJDEoc2VtYW50aWMsICdicG1uOkRhdGFPdXRwdXQnKVxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiAnbmFtZSc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzJDEoc2VtYW50aWMsICdicG1uOlRleHRBbm5vdGF0aW9uJykpIHtcclxuICAgICAgcmV0dXJuICd0ZXh0JztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXMkMShzZW1hbnRpYywgJ2JwbW46R3JvdXAnKSkge1xyXG4gICAgICByZXR1cm4gJ2NhdGVnb3J5VmFsdWVSZWYnO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBzZW1hbnRpY1xyXG4gICAqXHJcbiAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgKi9cclxuICBmdW5jdGlvbiBnZXRDYXRlZ29yeVZhbHVlKHNlbWFudGljKSB7XHJcbiAgICB2YXIgY2F0ZWdvcnlWYWx1ZVJlZiA9IHNlbWFudGljWydjYXRlZ29yeVZhbHVlUmVmJ107XHJcblxyXG4gICAgaWYgKCFjYXRlZ29yeVZhbHVlUmVmKSB7XHJcbiAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuXHJcblxyXG4gICAgcmV0dXJuIGNhdGVnb3J5VmFsdWVSZWYudmFsdWUgfHwgJyc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKi9cclxuICBmdW5jdGlvbiBnZXRMYWJlbChlbGVtZW50KSB7XHJcbiAgICB2YXIgc2VtYW50aWMgPSBlbGVtZW50LmJ1c2luZXNzT2JqZWN0LFxyXG4gICAgICAgIGF0dHIgPSBnZXRMYWJlbEF0dHIoc2VtYW50aWMpO1xyXG5cclxuICAgIGlmIChhdHRyKSB7XHJcblxyXG4gICAgICBpZiAoYXR0ciA9PT0gJ2NhdGVnb3J5VmFsdWVSZWYnKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBnZXRDYXRlZ29yeVZhbHVlKHNlbWFudGljKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHNlbWFudGljW2F0dHJdIHx8ICcnO1xyXG4gICAgfVxyXG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVJbXBvcnRlZChlbGVtZW50LCB0YXJnZXQpIHtcblxuICAgIGlmIChlbGVtZW50Lm93bmVyRG9jdW1lbnQgIT09IHRhcmdldC5vd25lckRvY3VtZW50KSB7XG4gICAgICB0cnkge1xuXG4gICAgICAgIC8vIG1heSBmYWlsIG9uIHdlYmtpdFxuICAgICAgICByZXR1cm4gdGFyZ2V0Lm93bmVyRG9jdW1lbnQuaW1wb3J0Tm9kZShlbGVtZW50LCB0cnVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgICAgICAvLyBpZ25vcmVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBhcHBlbmRUbyB1dGlsaXR5XG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIEFwcGVuZCBhIG5vZGUgdG8gYSB0YXJnZXQgZWxlbWVudCBhbmQgcmV0dXJuIHRoZSBhcHBlbmRlZCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTVkdFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IHRhcmdldFxuICAgKlxuICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fSB0aGUgYXBwZW5kZWQgbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gYXBwZW5kVG8oZWxlbWVudCwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC5hcHBlbmRDaGlsZChlbnN1cmVJbXBvcnRlZChlbGVtZW50LCB0YXJnZXQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBhcHBlbmQgdXRpbGl0eVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBBcHBlbmQgYSBub2RlIHRvIGFuIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtICB7U1ZHRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0gIHtTVkdFbGVtZW50fSBub2RlXG4gICAqXG4gICAqIEByZXR1cm4ge1NWR0VsZW1lbnR9IHRoZSBlbGVtZW50XG4gICAqL1xuICBmdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG4gICAgYXBwZW5kVG8obm9kZSwgdGFyZ2V0KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIGF0dHJpYnV0ZSBhY2Nlc3NvciB1dGlsaXR5XG4gICAqL1xuXG4gIHZhciBMRU5HVEhfQVRUUiA9IDI7XG5cbiAgdmFyIENTU19QUk9QRVJUSUVTID0ge1xuICAgICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAxLFxuICAgICdiYXNlbGluZS1zaGlmdCc6IDEsXG4gICAgJ2NsaXAnOiAxLFxuICAgICdjbGlwLXBhdGgnOiAxLFxuICAgICdjbGlwLXJ1bGUnOiAxLFxuICAgICdjb2xvcic6IDEsXG4gICAgJ2NvbG9yLWludGVycG9sYXRpb24nOiAxLFxuICAgICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAxLFxuICAgICdjb2xvci1wcm9maWxlJzogMSxcbiAgICAnY29sb3ItcmVuZGVyaW5nJzogMSxcbiAgICAnY3Vyc29yJzogMSxcbiAgICAnZGlyZWN0aW9uJzogMSxcbiAgICAnZGlzcGxheSc6IDEsXG4gICAgJ2RvbWluYW50LWJhc2VsaW5lJzogMSxcbiAgICAnZW5hYmxlLWJhY2tncm91bmQnOiAxLFxuICAgICdmaWxsJzogMSxcbiAgICAnZmlsbC1vcGFjaXR5JzogMSxcbiAgICAnZmlsbC1ydWxlJzogMSxcbiAgICAnZmlsdGVyJzogMSxcbiAgICAnZmxvb2QtY29sb3InOiAxLFxuICAgICdmbG9vZC1vcGFjaXR5JzogMSxcbiAgICAnZm9udCc6IDEsXG4gICAgJ2ZvbnQtZmFtaWx5JzogMSxcbiAgICAnZm9udC1zaXplJzogTEVOR1RIX0FUVFIsXG4gICAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAxLFxuICAgICdmb250LXN0cmV0Y2gnOiAxLFxuICAgICdmb250LXN0eWxlJzogMSxcbiAgICAnZm9udC12YXJpYW50JzogMSxcbiAgICAnZm9udC13ZWlnaHQnOiAxLFxuICAgICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzogMSxcbiAgICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOiAxLFxuICAgICdpbWFnZS1yZW5kZXJpbmcnOiAxLFxuICAgICdrZXJuaW5nJzogMSxcbiAgICAnbGV0dGVyLXNwYWNpbmcnOiAxLFxuICAgICdsaWdodGluZy1jb2xvcic6IDEsXG4gICAgJ21hcmtlcic6IDEsXG4gICAgJ21hcmtlci1lbmQnOiAxLFxuICAgICdtYXJrZXItbWlkJzogMSxcbiAgICAnbWFya2VyLXN0YXJ0JzogMSxcbiAgICAnbWFzayc6IDEsXG4gICAgJ29wYWNpdHknOiAxLFxuICAgICdvdmVyZmxvdyc6IDEsXG4gICAgJ3BvaW50ZXItZXZlbnRzJzogMSxcbiAgICAnc2hhcGUtcmVuZGVyaW5nJzogMSxcbiAgICAnc3RvcC1jb2xvcic6IDEsXG4gICAgJ3N0b3Atb3BhY2l0eSc6IDEsXG4gICAgJ3N0cm9rZSc6IDEsXG4gICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAxLFxuICAgICdzdHJva2UtZGFzaG9mZnNldCc6IDEsXG4gICAgJ3N0cm9rZS1saW5lY2FwJzogMSxcbiAgICAnc3Ryb2tlLWxpbmVqb2luJzogMSxcbiAgICAnc3Ryb2tlLW1pdGVybGltaXQnOiAxLFxuICAgICdzdHJva2Utb3BhY2l0eSc6IDEsXG4gICAgJ3N0cm9rZS13aWR0aCc6IExFTkdUSF9BVFRSLFxuICAgICd0ZXh0LWFuY2hvcic6IDEsXG4gICAgJ3RleHQtZGVjb3JhdGlvbic6IDEsXG4gICAgJ3RleHQtcmVuZGVyaW5nJzogMSxcbiAgICAndW5pY29kZS1iaWRpJzogMSxcbiAgICAndmlzaWJpbGl0eSc6IDEsXG4gICAgJ3dvcmQtc3BhY2luZyc6IDEsXG4gICAgJ3dyaXRpbmctbW9kZSc6IDFcbiAgfTtcblxuXG4gIGZ1bmN0aW9uIGdldEF0dHJpYnV0ZShub2RlLCBuYW1lKSB7XG4gICAgaWYgKENTU19QUk9QRVJUSUVTW25hbWVdKSB7XG4gICAgICByZXR1cm4gbm9kZS5zdHlsZVtuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlTlMobnVsbCwgbmFtZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGh5cGhlbmF0ZWQgPSBuYW1lLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICB2YXIgdHlwZSA9IENTU19QUk9QRVJUSUVTW2h5cGhlbmF0ZWRdO1xuXG4gICAgaWYgKHR5cGUpIHtcblxuICAgICAgLy8gYXBwZW5kIHBpeGVsIHVuaXQsIHVubGVzcyBwcmVzZW50XG4gICAgICBpZiAodHlwZSA9PT0gTEVOR1RIX0FUVFIgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSkgKyAncHgnO1xuICAgICAgfVxuXG4gICAgICBub2RlLnN0eWxlW2h5cGhlbmF0ZWRdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobnVsbCwgbmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMobm9kZSwgYXR0cnMpIHtcblxuICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKGF0dHJzKSwgaSwgbmFtZTtcblxuICAgIGZvciAoaSA9IDAsIG5hbWU7IChuYW1lID0gbmFtZXNbaV0pOyBpKyspIHtcbiAgICAgIHNldEF0dHJpYnV0ZShub2RlLCBuYW1lLCBhdHRyc1tuYW1lXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyByYXcgYXR0cmlidXRlcyBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbYXR0cnNdXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW25hbWVdXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW3ZhbHVlXVxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBhdHRyJDEobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldEF0dHJpYnV0ZShub2RlLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0QXR0cmlidXRlcyhub2RlLCBuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8qKlxyXG4gICAqIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2NvbXBvbmVudC9jbGFzc2VzXHJcbiAgICpcclxuICAgKiBXaXRob3V0IHRoZSBjb21wb25lbnQgYml0cy5cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogdG9TdHJpbmcgcmVmZXJlbmNlLlxyXG4gICAqL1xyXG5cclxuICBjb25zdCB0b1N0cmluZyQxID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuXHJcbiAgLyoqXHJcbiAgICAqIFdyYXAgYGVsYCBpbiBhIGBDbGFzc0xpc3RgLlxyXG4gICAgKlxyXG4gICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXHJcbiAgICAqIEByZXR1cm4ge0NsYXNzTGlzdH1cclxuICAgICogQGFwaSBwdWJsaWNcclxuICAgICovXHJcblxyXG4gIGZ1bmN0aW9uIGNsYXNzZXMkMShlbCkge1xyXG4gICAgcmV0dXJuIG5ldyBDbGFzc0xpc3QkMShlbCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBDbGFzc0xpc3QkMShlbCkge1xyXG4gICAgaWYgKCFlbCB8fCAhZWwubm9kZVR5cGUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIERPTSBlbGVtZW50IHJlZmVyZW5jZSBpcyByZXF1aXJlZCcpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5lbCA9IGVsO1xyXG4gICAgdGhpcy5saXN0ID0gZWwuY2xhc3NMaXN0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAqIEFkZCBjbGFzcyBgbmFtZWAgaWYgbm90IGFscmVhZHkgcHJlc2VudC5cclxuICAgICpcclxuICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICAgICogQHJldHVybiB7Q2xhc3NMaXN0fVxyXG4gICAgKiBAYXBpIHB1YmxpY1xyXG4gICAgKi9cclxuXHJcbiAgQ2xhc3NMaXN0JDEucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgIHRoaXMubGlzdC5hZGQobmFtZSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgICogUmVtb3ZlIGNsYXNzIGBuYW1lYCB3aGVuIHByZXNlbnQsIG9yXHJcbiAgICAqIHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gcmVtb3ZlXHJcbiAgICAqIGFueSB3aGljaCBtYXRjaC5cclxuICAgICpcclxuICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBuYW1lXHJcbiAgICAqIEByZXR1cm4ge0NsYXNzTGlzdH1cclxuICAgICogQGFwaSBwdWJsaWNcclxuICAgICovXHJcblxyXG4gIENsYXNzTGlzdCQxLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICBpZiAoJ1tvYmplY3QgUmVnRXhwXScgPT0gdG9TdHJpbmckMS5jYWxsKG5hbWUpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZU1hdGNoaW5nKG5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubGlzdC5yZW1vdmUobmFtZSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgICogUmVtb3ZlIGFsbCBjbGFzc2VzIG1hdGNoaW5nIGByZWAuXHJcbiAgICAqXHJcbiAgICAqIEBwYXJhbSB7UmVnRXhwfSByZVxyXG4gICAgKiBAcmV0dXJuIHtDbGFzc0xpc3R9XHJcbiAgICAqIEBhcGkgcHJpdmF0ZVxyXG4gICAgKi9cclxuXHJcbiAgQ2xhc3NMaXN0JDEucHJvdG90eXBlLnJlbW92ZU1hdGNoaW5nID0gZnVuY3Rpb24ocmUpIHtcclxuICAgIGNvbnN0IGFyciA9IHRoaXMuYXJyYXkoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChyZS50ZXN0KGFycltpXSkpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZShhcnJbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgICogVG9nZ2xlIGNsYXNzIGBuYW1lYCwgY2FuIGZvcmNlIHN0YXRlIHZpYSBgZm9yY2VgLlxyXG4gICAgKlxyXG4gICAgKiBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGNsYXNzTGlzdCwgYnV0IGRvIG5vdCBzdXBwb3J0IGBmb3JjZWAgeWV0LFxyXG4gICAgKiB0aGUgbWlzdGFrZSB3aWxsIGJlIGRldGVjdGVkIGFuZCBjb3JyZWN0ZWQuXHJcbiAgICAqXHJcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VcclxuICAgICogQHJldHVybiB7Q2xhc3NMaXN0fVxyXG4gICAgKiBAYXBpIHB1YmxpY1xyXG4gICAgKi9cclxuXHJcbiAgQ2xhc3NMaXN0JDEucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKG5hbWUsIGZvcmNlKSB7XHJcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBmb3JjZSkge1xyXG4gICAgICBpZiAoZm9yY2UgIT09IHRoaXMubGlzdC50b2dnbGUobmFtZSwgZm9yY2UpKSB7XHJcbiAgICAgICAgdGhpcy5saXN0LnRvZ2dsZShuYW1lKTsgLy8gdG9nZ2xlIGFnYWluIHRvIGNvcnJlY3RcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5saXN0LnRvZ2dsZShuYW1lKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgY2xhc3Nlcy5cclxuICAgICpcclxuICAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICAqIEBhcGkgcHVibGljXHJcbiAgICAqL1xyXG5cclxuICBDbGFzc0xpc3QkMS5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubGlzdCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICAqIENoZWNrIGlmIGNsYXNzIGBuYW1lYCBpcyBwcmVzZW50LlxyXG4gICAgKlxyXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gICAgKiBAcmV0dXJuIHtDbGFzc0xpc3R9XHJcbiAgICAqIEBhcGkgcHVibGljXHJcbiAgICAqL1xyXG5cclxuICBDbGFzc0xpc3QkMS5wcm90b3R5cGUuaGFzID1cclxuICAgQ2xhc3NMaXN0JDEucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24obmFtZSkge1xyXG4gICAgIHJldHVybiB0aGlzLmxpc3QuY29udGFpbnMobmFtZSk7XHJcbiAgIH07XG5cbiAgdmFyIG5zID0ge1xuICAgIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBET00gcGFyc2luZyB1dGlsaXR5XG4gICAqL1xuXG5cbiAgdmFyIFNWR19TVEFSVCA9ICc8c3ZnIHhtbG5zPVwiJyArIG5zLnN2ZyArICdcIic7XG5cbiAgZnVuY3Rpb24gcGFyc2UkMShzdmcpIHtcblxuICAgIHZhciB1bndyYXAgPSBmYWxzZTtcblxuICAgIC8vIGVuc3VyZSB3ZSBpbXBvcnQgYSB2YWxpZCBzdmcgZG9jdW1lbnRcbiAgICBpZiAoc3ZnLnN1YnN0cmluZygwLCA0KSA9PT0gJzxzdmcnKSB7XG4gICAgICBpZiAoc3ZnLmluZGV4T2YobnMuc3ZnKSA9PT0gLTEpIHtcbiAgICAgICAgc3ZnID0gU1ZHX1NUQVJUICsgc3ZnLnN1YnN0cmluZyg0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBuYW1lc3BhY2Ugc3ZnXG4gICAgICBzdmcgPSBTVkdfU1RBUlQgKyAnPicgKyBzdmcgKyAnPC9zdmc+JztcbiAgICAgIHVud3JhcCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlRG9jdW1lbnQoc3ZnKTtcblxuICAgIGlmICghdW53cmFwKSB7XG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cblxuICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIHZhciBwYXJlbnQgPSBwYXJzZWQuZmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQocGFyZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRG9jdW1lbnQoc3ZnKSB7XG5cbiAgICB2YXIgcGFyc2VyO1xuXG4gICAgLy8gcGFyc2VcbiAgICBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgcGFyc2VyLmFzeW5jID0gZmFsc2U7XG5cbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhzdmcsICd0ZXh0L3htbCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB1dGlsaXR5IGZvciBTVkcgZWxlbWVudHNcbiAgICovXG5cblxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzcGVjaWZpYyB0eXBlIGZyb20gbmFtZSBvciBTVkcgbWFya3VwLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvciBtYXJrdXAgb2YgdGhlIGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyc10gYXR0cmlidXRlcyB0byBzZXQgb24gdGhlIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybnMge1NWR0VsZW1lbnR9XG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGUkMShuYW1lLCBhdHRycykge1xuICAgIHZhciBlbGVtZW50O1xuXG4gICAgbmFtZSA9IG5hbWUudHJpbSgpO1xuXG4gICAgaWYgKG5hbWUuY2hhckF0KDApID09PSAnPCcpIHtcbiAgICAgIGVsZW1lbnQgPSBwYXJzZSQxKG5hbWUpLmZpcnN0Q2hpbGQ7XG4gICAgICBlbGVtZW50ID0gZG9jdW1lbnQuaW1wb3J0Tm9kZShlbGVtZW50LCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucy5zdmcsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChhdHRycykge1xuICAgICAgYXR0ciQxKGVsZW1lbnQsIGF0dHJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW9tZXRyeSBoZWxwZXJzXG4gICAqL1xuXG5cbiAgLy8gZmFrZSBub2RlIHVzZWQgdG8gaW5zdGFudGlhdGUgc3ZnIGdlb21ldHJ5IGVsZW1lbnRzXG4gIHZhciBub2RlID0gbnVsbDtcblxuICBmdW5jdGlvbiBnZXROb2RlKCkge1xuICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICBub2RlID0gY3JlYXRlJDEoJ3N2ZycpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kJDEob2JqZWN0LCBwcm9wcykge1xuICAgIHZhciBpLCBrLCBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuXG4gICAgZm9yIChpID0gMDsgKGsgPSBrZXlzW2ldKTsgaSsrKSB7XG4gICAgICBvYmplY3Rba10gPSBwcm9wc1trXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBtYXRyaXggdmlhIGFyZ3MuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGNyZWF0ZU1hdHJpeCh7IGE6IDEsIGI6IDEgfSk7XG4gICAqIGNyZWF0ZU1hdHJpeCgpO1xuICAgKiBjcmVhdGVNYXRyaXgoMSwgMiwgMCwgMCwgMzAsIDIwKTtcbiAgICpcbiAgICogQHJldHVybiB7U1ZHTWF0cml4fVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlTWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICB2YXIgbWF0cml4ID0gZ2V0Tm9kZSgpLmNyZWF0ZVNWR01hdHJpeCgpO1xuXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZXh0ZW5kJDEobWF0cml4LCBhKTtcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gZXh0ZW5kJDEobWF0cml4LCB7XG4gICAgICAgIGE6IGEsXG4gICAgICAgIGI6IGIsXG4gICAgICAgIGM6IGMsXG4gICAgICAgIGQ6IGQsXG4gICAgICAgIGU6IGUsXG4gICAgICAgIGY6IGZcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybShtYXRyaXgpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZ2V0Tm9kZSgpLmNyZWF0ZVNWR1RyYW5zZm9ybSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemF0aW9uIHV0aWxcbiAgICovXG5cbiAgdmFyIFRFWFRfRU5USVRJRVMgPSAvKFsmPD5dezF9KS9nO1xuICB2YXIgQVRUUl9FTlRJVElFUyA9IC8oW1xcblxcclwiXXsxfSkvZztcblxuICB2YXIgRU5USVRZX1JFUExBQ0VNRU5UID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnXFwnJ1xuICB9O1xuXG4gIGZ1bmN0aW9uIGVzY2FwZSQxKHN0ciwgcGF0dGVybikge1xuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUZuKG1hdGNoLCBlbnRpdHkpIHtcbiAgICAgIHJldHVybiBFTlRJVFlfUkVQTEFDRU1FTlRbZW50aXR5XSB8fCBlbnRpdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKHBhdHRlcm4sIHJlcGxhY2VGbik7XG4gIH1cblxuICBmdW5jdGlvbiBzZXJpYWxpemUobm9kZSwgb3V0cHV0KSB7XG5cbiAgICB2YXIgaSwgbGVuLCBhdHRyTWFwLCBhdHRyTm9kZSwgY2hpbGROb2RlcztcblxuICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuXG4gICAgLy8gVEVYVFxuICAgIGNhc2UgMzpcblxuICAgICAgLy8gcmVwbGFjZSBzcGVjaWFsIFhNTCBjaGFyYWN0ZXJzXG4gICAgICBvdXRwdXQucHVzaChlc2NhcGUkMShub2RlLnRleHRDb250ZW50LCBURVhUX0VOVElUSUVTKSk7XG4gICAgICBicmVhaztcblxuICAgIC8vIEVMRU1FTlRcbiAgICBjYXNlIDE6XG4gICAgICBvdXRwdXQucHVzaCgnPCcsIG5vZGUudGFnTmFtZSk7XG5cbiAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgICAgICBhdHRyTWFwID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBhdHRyTWFwLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgYXR0ck5vZGUgPSBhdHRyTWFwLml0ZW0oaSk7XG4gICAgICAgICAgb3V0cHV0LnB1c2goJyAnLCBhdHRyTm9kZS5uYW1lLCAnPVwiJywgZXNjYXBlJDEoYXR0ck5vZGUudmFsdWUsIEFUVFJfRU5USVRJRVMpLCAnXCInKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goJz4nKTtcbiAgICAgICAgY2hpbGROb2RlcyA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIHNlcmlhbGl6ZShjaGlsZE5vZGVzLml0ZW0oaSksIG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnB1c2goJzwvJywgbm9kZS50YWdOYW1lLCAnPicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2goJy8+Jyk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIC8vIENPTU1FTlRcbiAgICBjYXNlIDg6XG4gICAgICBvdXRwdXQucHVzaCgnPCEtLScsIGVzY2FwZSQxKG5vZGUubm9kZVZhbHVlLCBURVhUX0VOVElUSUVTKSwgJy0tPicpO1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyBDREFUQVxuICAgIGNhc2UgNDpcbiAgICAgIG91dHB1dC5wdXNoKCc8IVtDREFUQVsnLCBub2RlLm5vZGVWYWx1ZSwgJ11dPicpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gaGFuZGxlIG5vZGUgJyArIG5vZGUubm9kZVR5cGUpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQoZWxlbWVudCkge1xuICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuZmlyc3RDaGlsZCxcbiAgICAgICAgb3V0cHV0ID0gW107XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIHNlcmlhbGl6ZShjaGlsZCwgb3V0cHV0KTtcbiAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlubmVyU1ZHKGVsZW1lbnQsIHN2Zykge1xuXG4gICAge1xuICAgICAgcmV0dXJuIGdldChlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmUkMihlbGVtZW50KSB7XG4gICAgdmFyIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiB0cmFuc2Zvcm0gYWNjZXNzb3IgdXRpbGl0eVxuICAgKi9cblxuICBmdW5jdGlvbiB3cmFwTWF0cml4KHRyYW5zZm9ybUxpc3QsIHRyYW5zZm9ybSkge1xuICAgIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBTVkdNYXRyaXgpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1MaXN0LmNyZWF0ZVNWR1RyYW5zZm9ybUZyb21NYXRyaXgodHJhbnNmb3JtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJhbnNmb3JtO1xuICB9XG5cblxuICBmdW5jdGlvbiBzZXRUcmFuc2Zvcm1zKHRyYW5zZm9ybUxpc3QsIHRyYW5zZm9ybXMpIHtcbiAgICB2YXIgaSwgdDtcblxuICAgIHRyYW5zZm9ybUxpc3QuY2xlYXIoKTtcblxuICAgIGZvciAoaSA9IDA7ICh0ID0gdHJhbnNmb3Jtc1tpXSk7IGkrKykge1xuICAgICAgdHJhbnNmb3JtTGlzdC5hcHBlbmRJdGVtKHdyYXBNYXRyaXgodHJhbnNmb3JtTGlzdCwgdCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSB0cmFuc2Zvcm1zIG9uIHRoZSBnaXZlbiBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtICB7U1ZHVHJhbnNmb3JtfFNWR01hdHJpeHxBcnJheTxTVkdUcmFuc2Zvcm18U1ZHTWF0cml4Pn0gW3RyYW5zZm9ybXNdXG4gICAqXG4gICAqIEByZXR1cm4ge1NWR1RyYW5zZm9ybX0gdGhlIGNvbnNvbGlkYXRlZCB0cmFuc2Zvcm1cbiAgICovXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybSQxKG5vZGUsIHRyYW5zZm9ybXMpIHtcbiAgICB2YXIgdHJhbnNmb3JtTGlzdCA9IG5vZGUudHJhbnNmb3JtLmJhc2VWYWw7XG5cbiAgICBpZiAodHJhbnNmb3Jtcykge1xuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodHJhbnNmb3JtcykpIHtcbiAgICAgICAgdHJhbnNmb3JtcyA9IFsgdHJhbnNmb3JtcyBdO1xuICAgICAgfVxuXG4gICAgICBzZXRUcmFuc2Zvcm1zKHRyYW5zZm9ybUxpc3QsIHRyYW5zZm9ybXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0cmFuc2Zvcm1MaXN0LmNvbnNvbGlkYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYgeyhzdHJpbmd8bnVtYmVyKVtdfSBDb21wb25lbnRcbiAgICpcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdXRpbC9UeXBlcycpLlBvaW50fSBQb2ludFxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtDb21wb25lbnRbXSB8IENvbXBvbmVudFtdW119IGVsZW1lbnRzXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBvbmVudHNUb1BhdGgoZWxlbWVudHMpIHtcbiAgICByZXR1cm4gZWxlbWVudHMuZmxhdCgpLmpvaW4oJywnKS5yZXBsYWNlKC8sPyhbQS1aYS16XSksPy9nLCAnJDEnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludFxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnRbXX1cbiAgICovXG4gIGZ1bmN0aW9uIG1vdmUocG9pbnQpIHtcbiAgICByZXR1cm4gWyAnTScsIHBvaW50LngsIHBvaW50LnkgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludFxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnRbXX1cbiAgICovXG4gIGZ1bmN0aW9uIGxpbmVUbyhwb2ludCkge1xuICAgIHJldHVybiBbICdMJywgcG9pbnQueCwgcG9pbnQueSBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UG9pbnR9IHAxXG4gICAqIEBwYXJhbSB7UG9pbnR9IHAyXG4gICAqIEBwYXJhbSB7UG9pbnR9IHAzXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudFtdfVxuICAgKi9cbiAgZnVuY3Rpb24gY3VydmVUbyhwMSwgcDIsIHAzKSB7XG4gICAgcmV0dXJuIFsgJ0MnLCBwMS54LCBwMS55LCBwMi54LCBwMi55LCBwMy54LCBwMy55IF07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtQb2ludFtdfSB3YXlwb2ludHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb3JuZXJSYWRpdXNdXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudFtdW119XG4gICAqL1xuICBmdW5jdGlvbiBkcmF3UGF0aCh3YXlwb2ludHMsIGNvcm5lclJhZGl1cykge1xuICAgIGNvbnN0IHBvaW50Q291bnQgPSB3YXlwb2ludHMubGVuZ3RoO1xuXG4gICAgY29uc3QgcGF0aCA9IFsgbW92ZSh3YXlwb2ludHNbMF0pIF07XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBvaW50Q291bnQ7IGkrKykge1xuXG4gICAgICBjb25zdCBwb2ludEJlZm9yZSA9IHdheXBvaW50c1tpIC0gMV07XG4gICAgICBjb25zdCBwb2ludCA9IHdheXBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBvaW50QWZ0ZXIgPSB3YXlwb2ludHNbaSArIDFdO1xuXG4gICAgICBpZiAoIXBvaW50QWZ0ZXIgfHwgIWNvcm5lclJhZGl1cykge1xuICAgICAgICBwYXRoLnB1c2gobGluZVRvKHBvaW50KSk7XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVmZmVjdGl2ZVJhZGl1cyA9IE1hdGgubWluKFxuICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgIHZlY3Rvckxlbmd0aChwb2ludC54IC0gcG9pbnRCZWZvcmUueCwgcG9pbnQueSAtIHBvaW50QmVmb3JlLnkpLFxuICAgICAgICB2ZWN0b3JMZW5ndGgocG9pbnRBZnRlci54IC0gcG9pbnQueCwgcG9pbnRBZnRlci55IC0gcG9pbnQueSlcbiAgICAgICk7XG5cbiAgICAgIGlmICghZWZmZWN0aXZlUmFkaXVzKSB7XG4gICAgICAgIHBhdGgucHVzaChsaW5lVG8ocG9pbnQpKTtcblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmVmb3JlUG9pbnQgPSBnZXRQb2ludEF0TGVuZ3RoKHBvaW50LCBwb2ludEJlZm9yZSwgZWZmZWN0aXZlUmFkaXVzKTtcbiAgICAgIGNvbnN0IGJlZm9yZVBvaW50MiA9IGdldFBvaW50QXRMZW5ndGgocG9pbnQsIHBvaW50QmVmb3JlLCBlZmZlY3RpdmVSYWRpdXMgKiAuNSk7XG5cbiAgICAgIGNvbnN0IGFmdGVyUG9pbnQgPSBnZXRQb2ludEF0TGVuZ3RoKHBvaW50LCBwb2ludEFmdGVyLCBlZmZlY3RpdmVSYWRpdXMpO1xuICAgICAgY29uc3QgYWZ0ZXJQb2ludDIgPSBnZXRQb2ludEF0TGVuZ3RoKHBvaW50LCBwb2ludEFmdGVyLCBlZmZlY3RpdmVSYWRpdXMgKiAuNSk7XG5cbiAgICAgIHBhdGgucHVzaChsaW5lVG8oYmVmb3JlUG9pbnQpKTtcbiAgICAgIHBhdGgucHVzaChjdXJ2ZVRvKGJlZm9yZVBvaW50MiwgYWZ0ZXJQb2ludDIsIGFmdGVyUG9pbnQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBvaW50QXRMZW5ndGgoc3RhcnQsIGVuZCwgbGVuZ3RoKSB7XG5cbiAgICBjb25zdCBkZWx0YVggPSBlbmQueCAtIHN0YXJ0Lng7XG4gICAgY29uc3QgZGVsdGFZID0gZW5kLnkgLSBzdGFydC55O1xuXG4gICAgY29uc3QgdG90YWxMZW5ndGggPSB2ZWN0b3JMZW5ndGgoZGVsdGFYLCBkZWx0YVkpO1xuXG4gICAgY29uc3QgcGVyY2VudCA9IGxlbmd0aCAvIHRvdGFsTGVuZ3RoO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHN0YXJ0LnggKyBkZWx0YVggKiBwZXJjZW50LFxuICAgICAgeTogc3RhcnQueSArIGRlbHRhWSAqIHBlcmNlbnRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdmVjdG9yTGVuZ3RoKHgsIHkpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgsIDIpICsgTWF0aC5wb3coeSwgMikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UG9pbnRbXX0gcG9pbnRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfE9iamVjdH0gW2F0dHJzXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl1c11cbiAgICpcbiAgICogQHJldHVybiB7U1ZHRWxlbWVudH1cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUxpbmUocG9pbnRzLCBhdHRycywgcmFkaXVzKSB7XG5cbiAgICBpZiAoaXNOdW1iZXIoYXR0cnMpKSB7XG4gICAgICByYWRpdXMgPSBhdHRycztcbiAgICAgIGF0dHJzID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIWF0dHJzKSB7XG4gICAgICBhdHRycyA9IHt9O1xuICAgIH1cblxuICAgIGNvbnN0IGxpbmUgPSBjcmVhdGUkMSgncGF0aCcsIGF0dHJzKTtcblxuICAgIGlmIChpc051bWJlcihyYWRpdXMpKSB7XG4gICAgICBsaW5lLmRhdGFzZXQuY29ybmVyUmFkaXVzID0gU3RyaW5nKHJhZGl1cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZUxpbmUobGluZSwgcG9pbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGdmeFxuICAgKiBAcGFyYW0ge1BvaW50W119IHBvaW50c1xuICAgKlxuICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fVxuICAgKi9cbiAgZnVuY3Rpb24gdXBkYXRlTGluZShnZngsIHBvaW50cykge1xuXG4gICAgY29uc3QgY29ybmVyUmFkaXVzID0gcGFyc2VJbnQoZ2Z4LmRhdGFzZXQuY29ybmVyUmFkaXVzLCAxMCkgfHwgMDtcblxuICAgIGF0dHIkMShnZngsIHtcbiAgICAgIGQ6IGNvbXBvbmVudHNUb1BhdGgoZHJhd1BhdGgocG9pbnRzLCBjb3JuZXJSYWRpdXMpKVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGdmeDtcbiAgfVxuXG4gIHZhciBibGFjayA9ICdoc2woMjI1LCAxMCUsIDE1JSknO1xyXG4gIHZhciB3aGl0ZSA9ICd3aGl0ZSc7XHJcblxyXG4gIC8vIGVsZW1lbnQgdXRpbHMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgZXZlbnREZWZpbml0aW9uIG9mIHRoZSBnaXZlbiBlbGVtZW50IG1hdGNoZXMgd2l0aCBzZW1hbnRpYyB0eXBlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBldmVudFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudERlZmluaXRpb25UeXBlXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGlzVHlwZWRFdmVudChldmVudCwgZXZlbnREZWZpbml0aW9uVHlwZSkge1xyXG4gICAgcmV0dXJuIHNvbWUoZXZlbnQuZXZlbnREZWZpbml0aW9ucywgZnVuY3Rpb24oZGVmaW5pdGlvbikge1xyXG4gICAgICByZXR1cm4gZGVmaW5pdGlvbi4kdHlwZSA9PT0gZXZlbnREZWZpbml0aW9uVHlwZTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgZWxlbWVudCBpcyBhIHRocm93IGV2ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBldmVudFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBmdW5jdGlvbiBpc1Rocm93RXZlbnQoZXZlbnQpIHtcclxuICAgIHJldHVybiAoZXZlbnQuJHR5cGUgPT09ICdicG1uOkludGVybWVkaWF0ZVRocm93RXZlbnQnKSB8fCAoZXZlbnQuJHR5cGUgPT09ICdicG1uOkVuZEV2ZW50Jyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBlbGVtZW50IGlzIGEgdGhyb3cgZXZlbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR9IGVsZW1lbnRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaXNDb2xsZWN0aW9uKGVsZW1lbnQpIHtcclxuICAgIHZhciBkYXRhT2JqZWN0ID0gZWxlbWVudC5kYXRhT2JqZWN0UmVmO1xyXG5cclxuICAgIHJldHVybiBlbGVtZW50LmlzQ29sbGVjdGlvbiB8fCAoZGF0YU9iamVjdCAmJiBkYXRhT2JqZWN0LmlzQ29sbGVjdGlvbik7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gY29sb3IgYWNjZXNzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkZWZhdWx0Q29sb3JdXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvdmVycmlkZUNvbG9yXVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0Q29sb3IsIG92ZXJyaWRlQ29sb3IpIHtcclxuICAgIHZhciBkaSA9IGdldERpKGVsZW1lbnQpO1xyXG5cclxuICAgIHJldHVybiBvdmVycmlkZUNvbG9yIHx8IGRpLmdldCgnY29sb3I6YmFja2dyb3VuZC1jb2xvcicpIHx8IGRpLmdldCgnYmlvYzpmaWxsJykgfHwgZGVmYXVsdENvbG9yIHx8IHdoaXRlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkZWZhdWx0Q29sb3JdXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvdmVycmlkZUNvbG9yXVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRDb2xvciwgb3ZlcnJpZGVDb2xvcikge1xyXG4gICAgdmFyIGRpID0gZ2V0RGkoZWxlbWVudCk7XHJcblxyXG4gICAgcmV0dXJuIG92ZXJyaWRlQ29sb3IgfHwgZGkuZ2V0KCdjb2xvcjpib3JkZXItY29sb3InKSB8fCBkaS5nZXQoJ2Jpb2M6c3Ryb2tlJykgfHwgZGVmYXVsdENvbG9yIHx8IGJsYWNrO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkZWZhdWx0Q29sb3JdXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkZWZhdWx0U3Ryb2tlQ29sb3JdXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvdmVycmlkZUNvbG9yXVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGdldExhYmVsQ29sb3IoZWxlbWVudCwgZGVmYXVsdENvbG9yLCBkZWZhdWx0U3Ryb2tlQ29sb3IsIG92ZXJyaWRlQ29sb3IpIHtcclxuICAgIHZhciBkaSA9IGdldERpKGVsZW1lbnQpLFxyXG4gICAgICAgIGxhYmVsID0gZGkuZ2V0KCdsYWJlbCcpO1xyXG5cclxuICAgIHJldHVybiBvdmVycmlkZUNvbG9yIHx8IChsYWJlbCAmJiBsYWJlbC5nZXQoJ2NvbG9yOmNvbG9yJykpIHx8IGRlZmF1bHRDb2xvciB8fFxyXG4gICAgICBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IpO1xyXG4gIH1cclxuXHJcbiAgLy8gY3JvcHBpbmcgcGF0aCBjdXN0b21pemF0aW9ucyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7U2hhcGVMaWtlfSBzaGFwZVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBwYXRoXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZ2V0Q2lyY2xlUGF0aChzaGFwZSkge1xyXG5cclxuICAgIHZhciBjeCA9IHNoYXBlLnggKyBzaGFwZS53aWR0aCAvIDIsXHJcbiAgICAgICAgY3kgPSBzaGFwZS55ICsgc2hhcGUuaGVpZ2h0IC8gMixcclxuICAgICAgICByYWRpdXMgPSBzaGFwZS53aWR0aCAvIDI7XHJcblxyXG4gICAgdmFyIGNpcmNsZVBhdGggPSBbXHJcbiAgICAgIFsgJ00nLCBjeCwgY3kgXSxcclxuICAgICAgWyAnbScsIDAsIC1yYWRpdXMgXSxcclxuICAgICAgWyAnYScsIHJhZGl1cywgcmFkaXVzLCAwLCAxLCAxLCAwLCAyICogcmFkaXVzIF0sXHJcbiAgICAgIFsgJ2EnLCByYWRpdXMsIHJhZGl1cywgMCwgMSwgMSwgMCwgLTIgKiByYWRpdXMgXSxcclxuICAgICAgWyAneicgXVxyXG4gICAgXTtcclxuXHJcbiAgICByZXR1cm4gY29tcG9uZW50c1RvUGF0aChjaXJjbGVQYXRoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7U2hhcGVMaWtlfSBzaGFwZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYm9yZGVyUmFkaXVzXVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBwYXRoXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZ2V0Um91bmRSZWN0UGF0aChzaGFwZSwgYm9yZGVyUmFkaXVzKSB7XHJcblxyXG4gICAgdmFyIHggPSBzaGFwZS54LFxyXG4gICAgICAgIHkgPSBzaGFwZS55LFxyXG4gICAgICAgIHdpZHRoID0gc2hhcGUud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xyXG5cclxuICAgIHZhciByb3VuZFJlY3RQYXRoID0gW1xyXG4gICAgICBbICdNJywgeCArIGJvcmRlclJhZGl1cywgeSBdLFxyXG4gICAgICBbICdsJywgd2lkdGggLSBib3JkZXJSYWRpdXMgKiAyLCAwIF0sXHJcbiAgICAgIFsgJ2EnLCBib3JkZXJSYWRpdXMsIGJvcmRlclJhZGl1cywgMCwgMCwgMSwgYm9yZGVyUmFkaXVzLCBib3JkZXJSYWRpdXMgXSxcclxuICAgICAgWyAnbCcsIDAsIGhlaWdodCAtIGJvcmRlclJhZGl1cyAqIDIgXSxcclxuICAgICAgWyAnYScsIGJvcmRlclJhZGl1cywgYm9yZGVyUmFkaXVzLCAwLCAwLCAxLCAtMTAsIGJvcmRlclJhZGl1cyBdLFxyXG4gICAgICBbICdsJywgYm9yZGVyUmFkaXVzICogMiAtIHdpZHRoLCAwIF0sXHJcbiAgICAgIFsgJ2EnLCBib3JkZXJSYWRpdXMsIGJvcmRlclJhZGl1cywgMCwgMCwgMSwgLTEwLCAtMTAgXSxcclxuICAgICAgWyAnbCcsIDAsIGJvcmRlclJhZGl1cyAqIDIgLSBoZWlnaHQgXSxcclxuICAgICAgWyAnYScsIGJvcmRlclJhZGl1cywgYm9yZGVyUmFkaXVzLCAwLCAwLCAxLCBib3JkZXJSYWRpdXMsIC0xMCBdLFxyXG4gICAgICBbICd6JyBdXHJcbiAgICBdO1xyXG5cclxuICAgIHJldHVybiBjb21wb25lbnRzVG9QYXRoKHJvdW5kUmVjdFBhdGgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtTaGFwZUxpa2V9IHNoYXBlXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHBhdGhcclxuICAgKi9cclxuICBmdW5jdGlvbiBnZXREaWFtb25kUGF0aChzaGFwZSkge1xyXG5cclxuICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoLFxyXG4gICAgICAgIGhlaWdodCA9IHNoYXBlLmhlaWdodCxcclxuICAgICAgICB4ID0gc2hhcGUueCxcclxuICAgICAgICB5ID0gc2hhcGUueSxcclxuICAgICAgICBoYWxmV2lkdGggPSB3aWR0aCAvIDIsXHJcbiAgICAgICAgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XHJcblxyXG4gICAgdmFyIGRpYW1vbmRQYXRoID0gW1xyXG4gICAgICBbICdNJywgeCArIGhhbGZXaWR0aCwgeSBdLFxyXG4gICAgICBbICdsJywgaGFsZldpZHRoLCBoYWxmSGVpZ2h0IF0sXHJcbiAgICAgIFsgJ2wnLCAtaGFsZldpZHRoLCBoYWxmSGVpZ2h0IF0sXHJcbiAgICAgIFsgJ2wnLCAtaGFsZldpZHRoLCAtaGFsZkhlaWdodCBdLFxyXG4gICAgICBbICd6JyBdXHJcbiAgICBdO1xyXG5cclxuICAgIHJldHVybiBjb21wb25lbnRzVG9QYXRoKGRpYW1vbmRQYXRoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7U2hhcGVMaWtlfSBzaGFwZVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBwYXRoXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZ2V0UmVjdFBhdGgoc2hhcGUpIHtcclxuICAgIHZhciB4ID0gc2hhcGUueCxcclxuICAgICAgICB5ID0gc2hhcGUueSxcclxuICAgICAgICB3aWR0aCA9IHNoYXBlLndpZHRoLFxyXG4gICAgICAgIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcclxuXHJcbiAgICB2YXIgcmVjdFBhdGggPSBbXHJcbiAgICAgIFsgJ00nLCB4LCB5IF0sXHJcbiAgICAgIFsgJ2wnLCB3aWR0aCwgMCBdLFxyXG4gICAgICBbICdsJywgMCwgaGVpZ2h0IF0sXHJcbiAgICAgIFsgJ2wnLCAtd2lkdGgsIDAgXSxcclxuICAgICAgWyAneicgXVxyXG4gICAgXTtcclxuXHJcbiAgICByZXR1cm4gY29tcG9uZW50c1RvUGF0aChyZWN0UGF0aCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgd2lkdGggYW5kIGhlaWdodCBmcm9tIGVsZW1lbnQgb3Igb3ZlcnJpZGVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtEaW1lbnNpb25zfFJlY3R8U2hhcGVMaWtlfSBib3VuZHNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3ZlcnJpZGVzXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGltZW5zaW9uc31cclxuICAgKi9cclxuICBmdW5jdGlvbiBnZXRCb3VuZHMoYm91bmRzLCBvdmVycmlkZXMgPSB7fSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgd2lkdGg6IGdldFdpZHRoKGJvdW5kcywgb3ZlcnJpZGVzKSxcclxuICAgICAgaGVpZ2h0OiBnZXRIZWlnaHQoYm91bmRzLCBvdmVycmlkZXMpXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHdpZHRoIGZyb20gZWxlbWVudCBvciBvdmVycmlkZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0RpbWVuc2lvbnN8UmVjdHxTaGFwZUxpa2V9IGJvdW5kc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvdmVycmlkZXNcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZ2V0V2lkdGgoYm91bmRzLCBvdmVycmlkZXMgPSB7fSkge1xyXG4gICAgcmV0dXJuIGhhcyQxKG92ZXJyaWRlcywgJ3dpZHRoJykgPyBvdmVycmlkZXMud2lkdGggOiBib3VuZHMud2lkdGg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgaGVpZ2h0IGZyb20gZWxlbWVudCBvciBvdmVycmlkZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0RpbWVuc2lvbnN8UmVjdHxTaGFwZUxpa2V9IGJvdW5kc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvdmVycmlkZXNcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZ2V0SGVpZ2h0KGJvdW5kcywgb3ZlcnJpZGVzID0ge30pIHtcclxuICAgIHJldHVybiBoYXMkMShvdmVycmlkZXMsICdoZWlnaHQnKSA/IG92ZXJyaWRlcy5oZWlnaHQgOiBib3VuZHMuaGVpZ2h0O1xyXG4gIH1cblxuICBmdW5jdGlvbiBfbWVyZ2VOYW1lc3BhY2VzJDEobiwgbSkge1xuICAgIG0uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgZSAmJiB0eXBlb2YgZSAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkoZSkgJiYgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnICYmICEoayBpbiBuKSkge1xuICAgICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGF0dGVuIGFycmF5LCBvbmUgbGV2ZWwgZGVlcC5cbiAgICpcbiAgICogQHRlbXBsYXRlIFRcbiAgICpcbiAgICogQHBhcmFtIHtUW11bXSB8IFRbXSB8IG51bGx9IFthcnJdXG4gICAqXG4gICAqIEByZXR1cm4ge1RbXX1cbiAgICovXG5cbiAgY29uc3QgbmF0aXZlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICBjb25zdCBuYXRpdmVIYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZnVuY3Rpb24gaXNVbmRlZmluZWQkMShvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBpc0FycmF5JDEob2JqKSB7XG4gICAgcmV0dXJuIG5hdGl2ZVRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSwgaWYgdGFyZ2V0IG93bnMgYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIG5hdGl2ZUhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpO1xuICB9XG5cblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGNvbGxlY3Rpb247IHJldHVybmluZyBzb21ldGhpbmdcbiAgICogKG5vbi11bmRlZmluZWQpIHdpbGwgc3RvcCBpdGVyYXRpb24uXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbjxUPn0gY29sbGVjdGlvblxuICAgKiBAcGFyYW0geyAoKGl0ZW06IFQsIGlkeDogbnVtYmVyKSA9PiAoYm9vbGVhbnx2b2lkKSkgfCAoKGl0ZW06IFQsIGtleTogc3RyaW5nKSA9PiAoYm9vbGVhbnx2b2lkKSkgfSBpdGVyYXRvclxuICAgKlxuICAgKiBAcmV0dXJuIHtUfSByZXR1cm4gcmVzdWx0IHRoYXQgc3RvcHBlZCB0aGUgaXRlcmF0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdG9yKSB7XG5cbiAgICBsZXQgdmFsLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaXNVbmRlZmluZWQkMShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnZlcnRLZXkgPSBpc0FycmF5JDEoY29sbGVjdGlvbikgPyB0b051bSA6IGlkZW50aXR5O1xuXG4gICAgZm9yIChsZXQga2V5IGluIGNvbGxlY3Rpb24pIHtcblxuICAgICAgaWYgKGhhcyhjb2xsZWN0aW9uLCBrZXkpKSB7XG4gICAgICAgIHZhbCA9IGNvbGxlY3Rpb25ba2V5XTtcblxuICAgICAgICByZXN1bHQgPSBpdGVyYXRvcih2YWwsIGNvbnZlcnRLZXkoa2V5KSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiBpZGVudGl0eShhcmcpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9OdW0oYXJnKSB7XG4gICAgcmV0dXJuIE51bWJlcihhcmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgc3R5bGUgYXR0cmlidXRlcyBpbiBhIHN0eWxlLXNyYyBjb21wbGlhbnQgd2F5LlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IHN0eWxlU291cmNlc1xuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSB0aGUgZWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gYXNzaWduKGVsZW1lbnQsIC4uLnN0eWxlU291cmNlcykge1xuICAgIGNvbnN0IHRhcmdldCA9IGVsZW1lbnQuc3R5bGU7XG5cbiAgICBmb3JFYWNoKHN0eWxlU291cmNlcywgZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3JFYWNoKHN0eWxlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhdHRyaWJ1dGUgYG5hbWVgIHRvIGB2YWxgLCBvciBnZXQgYXR0ciBgbmFtZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt2YWxdXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICBmdW5jdGlvbiBhdHRyKGVsLCBuYW1lLCB2YWwpIHtcblxuICAgIC8vIGdldFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcbiAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlXG4gICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG5cbiAgICAvLyBzZXRcbiAgICBlbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsKTtcblxuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jb21wb25lbnQvY2xhc3Nlc1xuICAgKlxuICAgKiBXaXRob3V0IHRoZSBjb21wb25lbnQgYml0cy5cbiAgICovXG5cbiAgLyoqXG4gICAqIHRvU3RyaW5nIHJlZmVyZW5jZS5cbiAgICovXG5cbiAgY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXcmFwIGBlbGAgaW4gYSBgQ2xhc3NMaXN0YC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNsYXNzZXMoZWwpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzTGlzdChlbCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIG5ldyBDbGFzc0xpc3QgZm9yIGBlbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIENsYXNzTGlzdChlbCkge1xuICAgIGlmICghZWwgfHwgIWVsLm5vZGVUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgRE9NIGVsZW1lbnQgcmVmZXJlbmNlIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIHRoaXMuZWwgPSBlbDtcbiAgICB0aGlzLmxpc3QgPSBlbC5jbGFzc0xpc3Q7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGNsYXNzIGBuYW1lYCBpZiBub3QgYWxyZWFkeSBwcmVzZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIENsYXNzTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHRoaXMubGlzdC5hZGQobmFtZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBjbGFzcyBgbmFtZWAgd2hlbiBwcmVzZW50LCBvclxuICAgKiBwYXNzIGEgcmVndWxhciBleHByZXNzaW9uIHRvIHJlbW92ZVxuICAgKiBhbnkgd2hpY2ggbWF0Y2guXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gbmFtZVxuICAgKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIENsYXNzTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICgnW29iamVjdCBSZWdFeHBdJyA9PSB0b1N0cmluZy5jYWxsKG5hbWUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmVNYXRjaGluZyhuYW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3QucmVtb3ZlKG5hbWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGNsYXNzZXMgbWF0Y2hpbmcgYHJlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlXG4gICAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIENsYXNzTGlzdC5wcm90b3R5cGUucmVtb3ZlTWF0Y2hpbmcgPSBmdW5jdGlvbihyZSkge1xuICAgIGNvbnN0IGFyciA9IHRoaXMuYXJyYXkoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlLnRlc3QoYXJyW2ldKSkge1xuICAgICAgICB0aGlzLnJlbW92ZShhcnJbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVG9nZ2xlIGNsYXNzIGBuYW1lYCwgY2FuIGZvcmNlIHN0YXRlIHZpYSBgZm9yY2VgLlxuICAgKlxuICAgKiBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGNsYXNzTGlzdCwgYnV0IGRvIG5vdCBzdXBwb3J0IGBmb3JjZWAgeWV0LFxuICAgKiB0aGUgbWlzdGFrZSB3aWxsIGJlIGRldGVjdGVkIGFuZCBjb3JyZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VcbiAgICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBDbGFzc0xpc3QucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKG5hbWUsIGZvcmNlKSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgZm9yY2UpIHtcbiAgICAgIGlmIChmb3JjZSAhPT0gdGhpcy5saXN0LnRvZ2dsZShuYW1lLCBmb3JjZSkpIHtcbiAgICAgICAgdGhpcy5saXN0LnRvZ2dsZShuYW1lKTsgLy8gdG9nZ2xlIGFnYWluIHRvIGNvcnJlY3RcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5saXN0LnRvZ2dsZShuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBjbGFzc2VzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQ2xhc3NMaXN0LnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubGlzdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGNsYXNzIGBuYW1lYCBpcyBwcmVzZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIENsYXNzTGlzdC5wcm90b3R5cGUuaGFzID1cbiAgQ2xhc3NMaXN0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0LmNvbnRhaW5zKG5hbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciB1dGlsaXR5XG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBjaGlsZHJlbiBmcm9tIHRoZSBnaXZlbiBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSB0aGUgZWxlbWVudCAoZm9yIGNoYWluaW5nKVxuICAgKi9cbiAgZnVuY3Rpb24gY2xlYXIoZWxlbWVudCkge1xuICAgIHZhciBjaGlsZDtcblxuICAgIHdoaWxlICgoY2hpbGQgPSBlbGVtZW50LmZpcnN0Q2hpbGQpKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXN0XG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tZb3VyU2VsZiAob3B0aW9uYWwpXG4gICAqL1xuICBmdW5jdGlvbiBjbG9zZXN0KGVsZW1lbnQsIHNlbGVjdG9yLCBjaGVja1lvdXJTZWxmKSB7XG4gICAgdmFyIGFjdHVhbEVsZW1lbnQgPSBjaGVja1lvdXJTZWxmID8gZWxlbWVudCA6IGVsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgIHJldHVybiBhY3R1YWxFbGVtZW50ICYmIHR5cGVvZiBhY3R1YWxFbGVtZW50LmNsb3Nlc3QgPT09ICdmdW5jdGlvbicgJiYgYWN0dWFsRWxlbWVudC5jbG9zZXN0KHNlbGVjdG9yKSB8fCBudWxsO1xuICB9XG5cbiAgdmFyIGNvbXBvbmVudEV2ZW50ID0ge307XG5cbiAgdmFyIGJpbmQkMSwgdW5iaW5kJDEsIHByZWZpeCQ2O1xuXG4gIGZ1bmN0aW9uIGRldGVjdCAoKSB7XG4gICAgYmluZCQxID0gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAnYXR0YWNoRXZlbnQnO1xuICAgIHVuYmluZCQxID0gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgPyAncmVtb3ZlRXZlbnRMaXN0ZW5lcicgOiAnZGV0YWNoRXZlbnQnO1xuICAgIHByZWZpeCQ2ID0gYmluZCQxICE9PSAnYWRkRXZlbnRMaXN0ZW5lcicgPyAnb24nIDogJyc7XG4gIH1cblxuICAvKipcbiAgICogQmluZCBgZWxgIGV2ZW50IGB0eXBlYCB0byBgZm5gLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgdmFyIGJpbmRfMSA9IGNvbXBvbmVudEV2ZW50LmJpbmQgPSBmdW5jdGlvbihlbCwgdHlwZSwgZm4sIGNhcHR1cmUpe1xuICAgIGlmICghYmluZCQxKSBkZXRlY3QoKTtcbiAgICBlbFtiaW5kJDFdKHByZWZpeCQ2ICsgdHlwZSwgZm4sIGNhcHR1cmUgfHwgZmFsc2UpO1xuICAgIHJldHVybiBmbjtcbiAgfTtcblxuICAvKipcbiAgICogVW5iaW5kIGBlbGAgZXZlbnQgYHR5cGVgJ3MgY2FsbGJhY2sgYGZuYC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmVcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHZhciB1bmJpbmRfMSA9IGNvbXBvbmVudEV2ZW50LnVuYmluZCA9IGZ1bmN0aW9uKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSl7XG4gICAgaWYgKCF1bmJpbmQkMSkgZGV0ZWN0KCk7XG4gICAgZWxbdW5iaW5kJDFdKHByZWZpeCQ2ICsgdHlwZSwgZm4sIGNhcHR1cmUgfHwgZmFsc2UpO1xuICAgIHJldHVybiBmbjtcbiAgfTtcblxuICB2YXIgZXZlbnQgPSAvKiNfX1BVUkVfXyovX21lcmdlTmFtZXNwYWNlcyQxKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgYmluZDogYmluZF8xLFxuICAgIHVuYmluZDogdW5iaW5kXzEsXG4gICAgJ2RlZmF1bHQnOiBjb21wb25lbnRFdmVudFxuICB9LCBbY29tcG9uZW50RXZlbnRdKTtcblxuICAvKipcbiAgICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAgICovXG5cbiAgLyoqXG4gICAqIERlbGVnYXRlIGV2ZW50IGB0eXBlYCB0byBgc2VsZWN0b3JgXG4gICAqIGFuZCBpbnZva2UgYGZuKGUpYC4gQSBjYWxsYmFjayBmdW5jdGlvblxuICAgKiBpcyByZXR1cm5lZCB3aGljaCBtYXkgYmUgcGFzc2VkIHRvIGAudW5iaW5kKClgLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmVcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIC8vIFNvbWUgZXZlbnRzIGRvbid0IGJ1YmJsZSwgc28gd2Ugd2FudCB0byBiaW5kIHRvIHRoZSBjYXB0dXJlIHBoYXNlIGluc3RlYWRcbiAgLy8gd2hlbiBkZWxlZ2F0aW5nLlxuICB2YXIgZm9yY2VDYXB0dXJlRXZlbnRzID0gWyAnZm9jdXMnLCAnYmx1cicgXTtcblxuICBmdW5jdGlvbiBiaW5kKGVsLCBzZWxlY3RvciwgdHlwZSwgZm4sIGNhcHR1cmUpIHtcbiAgICBpZiAoZm9yY2VDYXB0dXJlRXZlbnRzLmluZGV4T2YodHlwZSkgIT09IC0xKSB7XG4gICAgICBjYXB0dXJlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnQuYmluZChlbCwgdHlwZSwgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgICAgIGUuZGVsZWdhdGVUYXJnZXQgPSBjbG9zZXN0KHRhcmdldCwgc2VsZWN0b3IsIHRydWUpO1xuICAgICAgaWYgKGUuZGVsZWdhdGVUYXJnZXQpIHtcbiAgICAgICAgZm4uY2FsbChlbCwgZSk7XG4gICAgICB9XG4gICAgfSwgY2FwdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5iaW5kIGV2ZW50IGB0eXBlYCdzIGNhbGxiYWNrIGBmbmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICBmdW5jdGlvbiB1bmJpbmQoZWwsIHR5cGUsIGZuLCBjYXB0dXJlKSB7XG4gICAgaWYgKGZvcmNlQ2FwdHVyZUV2ZW50cy5pbmRleE9mKHR5cGUpICE9PSAtMSkge1xuICAgICAgY2FwdHVyZSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50LnVuYmluZChlbCwgdHlwZSwgZm4sIGNhcHR1cmUpO1xuICB9XG5cbiAgdmFyIGRlbGVnYXRlID0ge1xuICAgIGJpbmQsXG4gICAgdW5iaW5kXG4gIH07XG5cbiAgLyoqXG4gICAqIEV4cG9zZSBgcGFyc2VgLlxuICAgKi9cblxuICB2YXIgZG9taWZ5ID0gcGFyc2U7XG5cbiAgLyoqXG4gICAqIFRlc3RzIGZvciBicm93c2VyIHN1cHBvcnQuXG4gICAqL1xuXG4gIHZhciBpbm5lckhUTUxCdWcgPSBmYWxzZTtcbiAgdmFyIGJ1Z1Rlc3REaXY7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgYnVnVGVzdERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIC8vIFNldHVwXG4gICAgYnVnVGVzdERpdi5pbm5lckhUTUwgPSAnICA8bGluay8+PHRhYmxlPjwvdGFibGU+PGEgaHJlZj1cIi9hXCI+YTwvYT48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIvPic7XG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgbGluayBlbGVtZW50cyBnZXQgc2VyaWFsaXplZCBjb3JyZWN0bHkgYnkgaW5uZXJIVE1MXG4gICAgLy8gVGhpcyByZXF1aXJlcyBhIHdyYXBwZXIgZWxlbWVudCBpbiBJRVxuICAgIGlubmVySFRNTEJ1ZyA9ICFidWdUZXN0RGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaW5rJykubGVuZ3RoO1xuICAgIGJ1Z1Rlc3REaXYgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogV3JhcCBtYXAgZnJvbSBqcXVlcnkuXG4gICAqL1xuXG4gIHZhciBtYXAgPSB7XG4gICAgbGVnZW5kOiBbMSwgJzxmaWVsZHNldD4nLCAnPC9maWVsZHNldD4nXSxcbiAgICB0cjogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG4gICAgY29sOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXSxcbiAgICAvLyBmb3Igc2NyaXB0L2xpbmsvc3R5bGUgdGFncyB0byB3b3JrIGluIElFNi04LCB5b3UgaGF2ZSB0byB3cmFwXG4gICAgLy8gaW4gYSBkaXYgd2l0aCBhIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlciBpbiBmcm9udCwgaGEhXG4gICAgX2RlZmF1bHQ6IGlubmVySFRNTEJ1ZyA/IFsxLCAnWDxkaXY+JywgJzwvZGl2PiddIDogWzAsICcnLCAnJ11cbiAgfTtcblxuICBtYXAudGQgPVxuICBtYXAudGggPSBbMywgJzx0YWJsZT48dGJvZHk+PHRyPicsICc8L3RyPjwvdGJvZHk+PC90YWJsZT4nXTtcblxuICBtYXAub3B0aW9uID1cbiAgbWFwLm9wdGdyb3VwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwibXVsdGlwbGVcIj4nLCAnPC9zZWxlY3Q+J107XG5cbiAgbWFwLnRoZWFkID1cbiAgbWFwLnRib2R5ID1cbiAgbWFwLmNvbGdyb3VwID1cbiAgbWFwLmNhcHRpb24gPVxuICBtYXAudGZvb3QgPSBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXTtcblxuICBtYXAucG9seWxpbmUgPVxuICBtYXAuZWxsaXBzZSA9XG4gIG1hcC5wb2x5Z29uID1cbiAgbWFwLmNpcmNsZSA9XG4gIG1hcC50ZXh0ID1cbiAgbWFwLmxpbmUgPVxuICBtYXAucGF0aCA9XG4gIG1hcC5yZWN0ID1cbiAgbWFwLmcgPSBbMSwgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZlcnNpb249XCIxLjFcIj4nLCc8L3N2Zz4nXTtcblxuICAvKipcbiAgICogUGFyc2UgYGh0bWxgIGFuZCByZXR1cm4gYSBET00gTm9kZSBpbnN0YW5jZSwgd2hpY2ggY291bGQgYmUgYSBUZXh0Tm9kZSxcbiAgICogSFRNTCBET00gTm9kZSBvZiBzb21lIGtpbmQgKDxkaXY+IGZvciBleGFtcGxlKSwgb3IgYSBEb2N1bWVudEZyYWdtZW50XG4gICAqIGluc3RhbmNlLCBkZXBlbmRpbmcgb24gdGhlIGNvbnRlbnRzIG9mIHRoZSBgaHRtbGAgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaHRtbCAtIEhUTUwgc3RyaW5nIHRvIFwiZG9taWZ5XCJcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIC0gVGhlIGBkb2N1bWVudGAgaW5zdGFuY2UgdG8gY3JlYXRlIHRoZSBOb2RlIGZvclxuICAgKiBAcmV0dXJuIHtET01Ob2RlfSB0aGUgVGV4dE5vZGUsIERPTSBOb2RlLCBvciBEb2N1bWVudEZyYWdtZW50IGluc3RhbmNlXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBmdW5jdGlvbiBwYXJzZShodG1sLCBkb2MpIHtcbiAgICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIGh0bWwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0cmluZyBleHBlY3RlZCcpO1xuXG4gICAgLy8gZGVmYXVsdCB0byB0aGUgZ2xvYmFsIGBkb2N1bWVudGAgb2JqZWN0XG4gICAgaWYgKCFkb2MpIGRvYyA9IGRvY3VtZW50O1xuXG4gICAgLy8gdGFnIG5hbWVcbiAgICB2YXIgbSA9IC88KFtcXHc6XSspLy5leGVjKGh0bWwpO1xuICAgIGlmICghbSkgcmV0dXJuIGRvYy5jcmVhdGVUZXh0Tm9kZShodG1sKTtcblxuICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTsgLy8gUmVtb3ZlIGxlYWRpbmcvdHJhaWxpbmcgd2hpdGVzcGFjZVxuXG4gICAgdmFyIHRhZyA9IG1bMV07XG5cbiAgICAvLyBib2R5IHN1cHBvcnRcbiAgICBpZiAodGFnID09ICdib2R5Jykge1xuICAgICAgdmFyIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2h0bWwnKTtcbiAgICAgIGVsLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICByZXR1cm4gZWwucmVtb3ZlQ2hpbGQoZWwubGFzdENoaWxkKTtcbiAgICB9XG5cbiAgICAvLyB3cmFwIG1hcFxuICAgIHZhciB3cmFwID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwgdGFnKSA/IG1hcFt0YWddIDogbWFwLl9kZWZhdWx0O1xuICAgIHZhciBkZXB0aCA9IHdyYXBbMF07XG4gICAgdmFyIHByZWZpeCA9IHdyYXBbMV07XG4gICAgdmFyIHN1ZmZpeCA9IHdyYXBbMl07XG4gICAgdmFyIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsLmlubmVySFRNTCA9IHByZWZpeCArIGh0bWwgKyBzdWZmaXg7XG4gICAgd2hpbGUgKGRlcHRoLS0pIGVsID0gZWwubGFzdENoaWxkO1xuXG4gICAgLy8gb25lIGVsZW1lbnRcbiAgICBpZiAoZWwuZmlyc3RDaGlsZCA9PSBlbC5sYXN0Q2hpbGQpIHtcbiAgICAgIHJldHVybiBlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICAvLyBzZXZlcmFsIGVsZW1lbnRzXG4gICAgdmFyIGZyYWdtZW50ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCkpO1xuICAgIH1cblxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuXG4gIHZhciBkb21pZnkkMSA9IGRvbWlmeTtcblxuICBmdW5jdGlvbiBxdWVyeShzZWxlY3RvciwgZWwpIHtcbiAgICBlbCA9IGVsIHx8IGRvY3VtZW50O1xuXG4gICAgcmV0dXJuIGVsLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWxsKHNlbGVjdG9yLCBlbCkge1xuICAgIGVsID0gZWwgfHwgZG9jdW1lbnQ7XG5cbiAgICByZXR1cm4gZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmUkMShlbCkge1xuICAgIGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gIH1cblxuICAvKipcclxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGdmeFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2FuZ2xlXVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYW1vdW50XVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybShnZngsIHgsIHksIGFuZ2xlLCBhbW91bnQpIHtcclxuICAgIHZhciB0cmFuc2xhdGUgPSBjcmVhdGVUcmFuc2Zvcm0oKTtcclxuICAgIHRyYW5zbGF0ZS5zZXRUcmFuc2xhdGUoeCwgeSk7XHJcblxyXG4gICAgdmFyIHJvdGF0ZSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xyXG4gICAgcm90YXRlLnNldFJvdGF0ZShhbmdsZSB8fCAwLCAwLCAwKTtcclxuXHJcbiAgICB2YXIgc2NhbGUgPSBjcmVhdGVUcmFuc2Zvcm0oKTtcclxuICAgIHNjYWxlLnNldFNjYWxlKDEsIDEpO1xyXG5cclxuICAgIHRyYW5zZm9ybSQxKGdmeCwgWyB0cmFuc2xhdGUsIHJvdGF0ZSwgc2NhbGUgXSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBnZnhcclxuICAgKiBAcGFyYW0ge251bWJlcn0geFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAgICovXHJcbiAgZnVuY3Rpb24gdHJhbnNsYXRlJDEoZ2Z4LCB4LCB5KSB7XHJcbiAgICB2YXIgdHJhbnNsYXRlID0gY3JlYXRlVHJhbnNmb3JtKCk7XHJcbiAgICB0cmFuc2xhdGUuc2V0VHJhbnNsYXRlKHgsIHkpO1xyXG5cclxuICAgIHRyYW5zZm9ybSQxKGdmeCwgdHJhbnNsYXRlKTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGdmeFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHJvdGF0ZShnZngsIGFuZ2xlKSB7XHJcbiAgICB2YXIgcm90YXRlID0gY3JlYXRlVHJhbnNmb3JtKCk7XHJcbiAgICByb3RhdGUuc2V0Um90YXRlKGFuZ2xlLCAwLCAwKTtcclxuXHJcbiAgICB0cmFuc2Zvcm0kMShnZngsIHJvdGF0ZSk7XHJcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcbiAgXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG4gIH1cblxuICB2YXIgaGF0XzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4gIHZhciBoYXQgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRzLCBiYXNlKSB7XG4gICAgICBpZiAoIWJhc2UpIGJhc2UgPSAxNjtcbiAgICAgIGlmIChiaXRzID09PSB1bmRlZmluZWQpIGJpdHMgPSAxMjg7XG4gICAgICBpZiAoYml0cyA8PSAwKSByZXR1cm4gJzAnO1xuICAgICAgXG4gICAgICB2YXIgZGlnaXRzID0gTWF0aC5sb2coTWF0aC5wb3coMiwgYml0cykpIC8gTWF0aC5sb2coYmFzZSk7XG4gICAgICBmb3IgKHZhciBpID0gMjsgZGlnaXRzID09PSBJbmZpbml0eTsgaSAqPSAyKSB7XG4gICAgICAgICAgZGlnaXRzID0gTWF0aC5sb2coTWF0aC5wb3coMiwgYml0cyAvIGkpKSAvIE1hdGgubG9nKGJhc2UpICogaTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIHJlbSA9IGRpZ2l0cyAtIE1hdGguZmxvb3IoZGlnaXRzKTtcbiAgICAgIFxuICAgICAgdmFyIHJlcyA9ICcnO1xuICAgICAgXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGguZmxvb3IoZGlnaXRzKTsgaSsrKSB7XG4gICAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBiYXNlKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgICByZXMgPSB4ICsgcmVzO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAocmVtKSB7XG4gICAgICAgICAgdmFyIGIgPSBNYXRoLnBvdyhiYXNlLCByZW0pO1xuICAgICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYikudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgICAgcmVzID0geCArIHJlcztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHJlcywgYmFzZSk7XG4gICAgICBpZiAocGFyc2VkICE9PSBJbmZpbml0eSAmJiBwYXJzZWQgPj0gTWF0aC5wb3coMiwgYml0cykpIHtcbiAgICAgICAgICByZXR1cm4gaGF0KGJpdHMsIGJhc2UpXG4gICAgICB9XG4gICAgICBlbHNlIHJldHVybiByZXM7XG4gIH07XG5cbiAgaGF0LnJhY2sgPSBmdW5jdGlvbiAoYml0cywgYmFzZSwgZXhwYW5kQnkpIHtcbiAgICAgIHZhciBmbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgdmFyIGl0ZXJzID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGlmIChpdGVycyArKyA+IDEwKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZXhwYW5kQnkpIGJpdHMgKz0gZXhwYW5kQnk7XG4gICAgICAgICAgICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcigndG9vIG1hbnkgSUQgY29sbGlzaW9ucywgdXNlIG1vcmUgYml0cycpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHZhciBpZCA9IGhhdChiaXRzLCBiYXNlKTtcbiAgICAgICAgICB9IHdoaWxlIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChoYXRzLCBpZCkpO1xuICAgICAgICAgIFxuICAgICAgICAgIGhhdHNbaWRdID0gZGF0YTtcbiAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9O1xuICAgICAgdmFyIGhhdHMgPSBmbi5oYXRzID0ge307XG4gICAgICBcbiAgICAgIGZuLmdldCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgIHJldHVybiBmbi5oYXRzW2lkXTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGZuLnNldCA9IGZ1bmN0aW9uIChpZCwgdmFsdWUpIHtcbiAgICAgICAgICBmbi5oYXRzW2lkXSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGZuLmJpdHMgPSBiaXRzIHx8IDEyODtcbiAgICAgIGZuLmJhc2UgPSBiYXNlIHx8IDE2O1xuICAgICAgcmV0dXJuIGZuO1xuICB9O1xuICB9KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGlkIGdlbmVyYXRvciAvIGNhY2hlIGluc3RhbmNlLlxuICAgKlxuICAgKiBZb3UgbWF5IG9wdGlvbmFsbHkgcHJvdmlkZSBhIHNlZWQgdGhhdCBpcyB1c2VkIGludGVybmFsbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7U2VlZH0gc2VlZFxuICAgKi9cbiAgZnVuY3Rpb24gSWRzKHNlZWQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSWRzKSkge1xuICAgICAgcmV0dXJuIG5ldyBJZHMoc2VlZCk7XG4gICAgfVxuICAgIHNlZWQgPSBzZWVkIHx8IFsxMjgsIDM2LCAxXTtcbiAgICB0aGlzLl9zZWVkID0gc2VlZC5sZW5ndGggPyBoYXRfMS5yYWNrKHNlZWRbMF0sIHNlZWRbMV0sIHNlZWRbMl0pIDogc2VlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5leHQgaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZWxlbWVudF0gZWxlbWVudCB0byBiaW5kIHRoZSBpZCB0b1xuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGlkXG4gICAqL1xuICBJZHMucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiB0aGlzLl9zZWVkKGVsZW1lbnQgfHwgdHJ1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV4dCBpZCB3aXRoIGEgZ2l2ZW4gcHJlZml4LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2VsZW1lbnRdIGVsZW1lbnQgdG8gYmluZCB0aGUgaWQgdG9cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSBpZFxuICAgKi9cbiAgSWRzLnByb3RvdHlwZS5uZXh0UHJlZml4ZWQgPSBmdW5jdGlvbiAocHJlZml4LCBlbGVtZW50KSB7XG4gICAgdmFyIGlkO1xuICAgIGRvIHtcbiAgICAgIGlkID0gcHJlZml4ICsgdGhpcy5uZXh0KHRydWUpO1xuICAgIH0gd2hpbGUgKHRoaXMuYXNzaWduZWQoaWQpKTtcblxuICAgIC8vIGNsYWltIHtwcmVmaXh9e3JhbmRvbX1cbiAgICB0aGlzLmNsYWltKGlkLCBlbGVtZW50KTtcblxuICAgIC8vIHJldHVyblxuICAgIHJldHVybiBpZDtcbiAgfTtcblxuICAvKipcbiAgICogTWFudWFsbHkgY2xhaW0gYW4gZXhpc3RpbmcgaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2VsZW1lbnRdIGVsZW1lbnQgdGhlIGlkIGlzIGNsYWltZWQgYnlcbiAgICovXG4gIElkcy5wcm90b3R5cGUuY2xhaW0gPSBmdW5jdGlvbiAoaWQsIGVsZW1lbnQpIHtcbiAgICB0aGlzLl9zZWVkLnNldChpZCwgZWxlbWVudCB8fCB0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBpZCBoYXMgYWxyZWFkeSBiZWVuIGFzc2lnbmVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGlkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBJZHMucHJvdG90eXBlLmFzc2lnbmVkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlZWQuZ2V0KGlkKSB8fCBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogVW5jbGFpbSBhbiBpZC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBpZCB0aGUgaWQgdG8gdW5jbGFpbVxuICAgKi9cbiAgSWRzLnByb3RvdHlwZS51bmNsYWltID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgZGVsZXRlIHRoaXMuX3NlZWQuaGF0c1tpZF07XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBjbGFpbWVkIGlkcy5cbiAgICovXG4gIElkcy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhdHMgPSB0aGlzLl9zZWVkLmhhdHMsXG4gICAgICBpZDtcbiAgICBmb3IgKGlkIGluIGhhdHMpIHtcbiAgICAgIHRoaXMudW5jbGFpbShpZCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBtYXJrZXJJZHMgPSBuZXcgSWRzKCk7XG5cbiAgdmFyIEVMRU1FTlRfTEFCRUxfRElTVEFOQ0UgPSAxMCxcbiAgICAgIElOTkVSX09VVEVSX0RJU1QgPSAzLFxuICAgICAgUEFSVElDSVBBTlRfU1RST0tFX1dJRFRIID0gMS41LFxuICAgICAgVEFTS19CT1JERVJfUkFESVVTID0gMTA7XG5cbiAgdmFyIERFRkFVTFRfT1BBQ0lUWSA9IDAuOTUsXG4gICAgICBGVUxMX09QQUNJVFkgPSAxLFxuICAgICAgTE9XX09QQUNJVFkgPSAwLjI1O1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7IFBhcnRpYWw8e1xuICAgKiAgIGRlZmF1bHRGaWxsQ29sb3I6IHN0cmluZyxcbiAgICogICBkZWZhdWx0U3Ryb2tlQ29sb3I6IHN0cmluZyxcbiAgICogICBkZWZhdWx0TGFiZWxDb2xvcjogc3RyaW5nXG4gICAqIH0+IH0gQnBtblJlbmRlcmVyQ29uZmlnXG4gICAqXG4gICAqIEB0eXBlZGVmIHsgUGFydGlhbDx7XG4gICAqICAgZmlsbDogc3RyaW5nLFxuICAgKiAgIHN0cm9rZTogc3RyaW5nLFxuICAgKiAgIHdpZHRoOiBzdHJpbmcsXG4gICAqICAgaGVpZ2h0OiBzdHJpbmdcbiAgICogfT4gfSBBdHRyc1xuICAgKi9cblxuICAvKipcbiAgICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL21vZGVsL1R5cGVzJykuRWxlbWVudCB9IEVsZW1lbnRcbiAgICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL21vZGVsL1R5cGVzJykuU2hhcGUgfSBTaGFwZVxuICAgKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vbW9kZWwvVHlwZXMnKS5Db25uZWN0aW9uIH0gQ29ubmVjdGlvblxuICAgKi9cblxuICAvKipcbiAgICogQSByZW5kZXJlciBmb3IgQlBNTiBlbGVtZW50c1xuICAgKlxuICAgKiBAcGFyYW0ge0JwbW5SZW5kZXJlckNvbmZpZ30gY29uZmlnXG4gICAqIEBwYXJhbSB7aW1wb3J0KCdkaWFncmFtLWpzL2xpYi9jb3JlL0V2ZW50QnVzJykuZGVmYXVsdH0gZXZlbnRCdXNcbiAgICogQHBhcmFtIHtpbXBvcnQoJ2RpYWdyYW0tanMvbGliL2RyYXcvU3R5bGVzJykuZGVmYXVsdH0gc3R5bGVzXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL1BhdGhNYXAnKS5kZWZhdWx0fSBwYXRoTWFwXG4gICAqIEBwYXJhbSB7aW1wb3J0KCdkaWFncmFtLWpzL2xpYi9jb3JlL0NhbnZhcycpLmRlZmF1bHR9IGNhbnZhc1xuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9UZXh0UmVuZGVyZXInKS5kZWZhdWx0fSB0ZXh0UmVuZGVyZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eV1cbiAgICovXG4gIGZ1bmN0aW9uIEJwbW5SZW5kZXJlcihcbiAgICAgIGNvbmZpZywgZXZlbnRCdXMsIHN0eWxlcywgcGF0aE1hcCxcbiAgICAgIGNhbnZhcywgdGV4dFJlbmRlcmVyLCBwcmlvcml0eSkge1xuXG4gICAgQmFzZVJlbmRlcmVyLmNhbGwodGhpcywgZXZlbnRCdXMsIHByaW9yaXR5KTtcblxuICAgIHZhciBkZWZhdWx0RmlsbENvbG9yID0gY29uZmlnICYmIGNvbmZpZy5kZWZhdWx0RmlsbENvbG9yLFxuICAgICAgICBkZWZhdWx0U3Ryb2tlQ29sb3IgPSBjb25maWcgJiYgY29uZmlnLmRlZmF1bHRTdHJva2VDb2xvcixcbiAgICAgICAgZGVmYXVsdExhYmVsQ29sb3IgPSBjb25maWcgJiYgY29uZmlnLmRlZmF1bHRMYWJlbENvbG9yO1xuXG4gICAgZnVuY3Rpb24gc2hhcGVTdHlsZShhdHRycykge1xuICAgICAgcmV0dXJuIHN0eWxlcy5jb21wdXRlU3R5bGUoYXR0cnMsIHtcbiAgICAgICAgc3Ryb2tlTGluZWNhcDogJ3JvdW5kJyxcbiAgICAgICAgc3Ryb2tlTGluZWpvaW46ICdyb3VuZCcsXG4gICAgICAgIHN0cm9rZTogYmxhY2ssXG4gICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICBmaWxsOiAnd2hpdGUnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lU3R5bGUoYXR0cnMpIHtcbiAgICAgIHJldHVybiBzdHlsZXMuY29tcHV0ZVN0eWxlKGF0dHJzLCBbICduby1maWxsJyBdLCB7XG4gICAgICAgIHN0cm9rZUxpbmVjYXA6ICdyb3VuZCcsXG4gICAgICAgIHN0cm9rZUxpbmVqb2luOiAncm91bmQnLFxuICAgICAgICBzdHJva2U6IGJsYWNrLFxuICAgICAgICBzdHJva2VXaWR0aDogMlxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTWFya2VyKGlkLCBvcHRpb25zKSB7XG4gICAgICB2YXIge1xuICAgICAgICByZWYgPSB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgc2NhbGUgPSAxLFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICBwYXJlbnRHZnggPSBjYW52YXMuX3N2Z1xuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIHZhciBtYXJrZXIgPSBjcmVhdGUkMSgnbWFya2VyJywge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIHZpZXdCb3g6ICcwIDAgMjAgMjAnLFxuICAgICAgICByZWZYOiByZWYueCxcbiAgICAgICAgcmVmWTogcmVmLnksXG4gICAgICAgIG1hcmtlcldpZHRoOiAyMCAqIHNjYWxlLFxuICAgICAgICBtYXJrZXJIZWlnaHQ6IDIwICogc2NhbGUsXG4gICAgICAgIG9yaWVudDogJ2F1dG8nXG4gICAgICB9KTtcblxuICAgICAgYXBwZW5kKG1hcmtlciwgZWxlbWVudCk7XG5cbiAgICAgIHZhciBkZWZzID0gcXVlcnkoJzpzY29wZSA+IGRlZnMnLCBwYXJlbnRHZngpO1xuXG4gICAgICBpZiAoIWRlZnMpIHtcbiAgICAgICAgZGVmcyA9IGNyZWF0ZSQxKCdkZWZzJyk7XG5cbiAgICAgICAgYXBwZW5kKHBhcmVudEdmeCwgZGVmcyk7XG4gICAgICB9XG5cbiAgICAgIGFwcGVuZChkZWZzLCBtYXJrZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcmtlcihwYXJlbnRHZngsIHR5cGUsIGZpbGwsIHN0cm9rZSkge1xuXG5cbiAgICAgIHZhciBpZCA9IG1hcmtlcklkcy5uZXh0UHJlZml4ZWQoJ21hcmtlci0nKTtcblxuICAgICAgY3JlYXRlTWFya2VyKHBhcmVudEdmeCwgaWQsIHR5cGUsIGZpbGwsIHN0cm9rZSk7XG5cbiAgICAgIHJldHVybiAndXJsKCMnICsgaWQgKyAnKSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTWFya2VyKHBhcmVudEdmeCwgaWQsIHR5cGUsIGZpbGwsIHN0cm9rZSkge1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ3NlcXVlbmNlZmxvdy1lbmQnKSB7XG4gICAgICAgIHZhciBzZXF1ZW5jZWZsb3dFbmQgPSBjcmVhdGUkMSgncGF0aCcsIHtcbiAgICAgICAgICBkOiAnTSAxIDUgTCAxMSAxMCBMIDEgMTUgWicsXG4gICAgICAgICAgLi4uc2hhcGVTdHlsZSh7XG4gICAgICAgICAgICBmaWxsOiBzdHJva2UsXG4gICAgICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYWRkTWFya2VyKGlkLCB7XG4gICAgICAgICAgZWxlbWVudDogc2VxdWVuY2VmbG93RW5kLFxuICAgICAgICAgIHJlZjogeyB4OiAxMSwgeTogMTAgfSxcbiAgICAgICAgICBzY2FsZTogMC41LFxuICAgICAgICAgIHBhcmVudEdmeFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdtZXNzYWdlZmxvdy1zdGFydCcpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2VmbG93U3RhcnQgPSBjcmVhdGUkMSgnY2lyY2xlJywge1xuICAgICAgICAgIGN4OiA2LFxuICAgICAgICAgIGN5OiA2LFxuICAgICAgICAgIHI6IDMuNSxcbiAgICAgICAgICAuLi5zaGFwZVN0eWxlKHtcbiAgICAgICAgICAgIGZpbGwsXG4gICAgICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuXG4gICAgICAgICAgICAvLyBmaXggZm9yIHNhZmFyaSAvIGNocm9tZSAvIGZpcmVmb3ggYnVnIG5vdCBjb3JyZWN0bHlcbiAgICAgICAgICAgIC8vIHJlc2V0dGluZyBzdHJva2UgZGFzaCBhcnJheVxuICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBbIDEwMDAwLCAxIF1cbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBhZGRNYXJrZXIoaWQsIHtcbiAgICAgICAgICBlbGVtZW50OiBtZXNzYWdlZmxvd1N0YXJ0LFxuICAgICAgICAgIHJlZjogeyB4OiA2LCB5OiA2IH0sXG4gICAgICAgICAgcGFyZW50R2Z4XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSA9PT0gJ21lc3NhZ2VmbG93LWVuZCcpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2VmbG93RW5kID0gY3JlYXRlJDEoJ3BhdGgnLCB7XG4gICAgICAgICAgZDogJ20gMSA1IGwgMCAtMyBsIDcgMyBsIC03IDMgeicsXG4gICAgICAgICAgLi4uc2hhcGVTdHlsZSh7XG4gICAgICAgICAgICBmaWxsLFxuICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcblxuICAgICAgICAgICAgLy8gZml4IGZvciBzYWZhcmkgLyBjaHJvbWUgLyBmaXJlZm94IGJ1ZyBub3QgY29ycmVjdGx5XG4gICAgICAgICAgICAvLyByZXNldHRpbmcgc3Ryb2tlIGRhc2ggYXJyYXlcbiAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogWyAxMDAwMCwgMSBdXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYWRkTWFya2VyKGlkLCB7XG4gICAgICAgICAgZWxlbWVudDogbWVzc2FnZWZsb3dFbmQsXG4gICAgICAgICAgcmVmOiB7IHg6IDguNSwgeTogNSB9LFxuICAgICAgICAgIHBhcmVudEdmeFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdhc3NvY2lhdGlvbi1zdGFydCcpIHtcbiAgICAgICAgdmFyIGFzc29jaWF0aW9uU3RhcnQgPSBjcmVhdGUkMSgncGF0aCcsIHtcbiAgICAgICAgICBkOiAnTSAxMSA1IEwgMSAxMCBMIDExIDE1JyxcbiAgICAgICAgICAuLi5saW5lU3R5bGUoe1xuICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgc3Ryb2tlLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDEuNSxcblxuICAgICAgICAgICAgLy8gZml4IGZvciBzYWZhcmkgLyBjaHJvbWUgLyBmaXJlZm94IGJ1ZyBub3QgY29ycmVjdGx5XG4gICAgICAgICAgICAvLyByZXNldHRpbmcgc3Ryb2tlIGRhc2ggYXJyYXlcbiAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogWyAxMDAwMCwgMSBdXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYWRkTWFya2VyKGlkLCB7XG4gICAgICAgICAgZWxlbWVudDogYXNzb2NpYXRpb25TdGFydCxcbiAgICAgICAgICByZWY6IHsgeDogMSwgeTogMTAgfSxcbiAgICAgICAgICBzY2FsZTogMC41LFxuICAgICAgICAgIHBhcmVudEdmeFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdhc3NvY2lhdGlvbi1lbmQnKSB7XG4gICAgICAgIHZhciBhc3NvY2lhdGlvbkVuZCA9IGNyZWF0ZSQxKCdwYXRoJywge1xuICAgICAgICAgIGQ6ICdNIDEgNSBMIDExIDEwIEwgMSAxNScsXG4gICAgICAgICAgLi4ubGluZVN0eWxlKHtcbiAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICAgIHN0cm9rZSxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLjUsXG5cbiAgICAgICAgICAgIC8vIGZpeCBmb3Igc2FmYXJpIC8gY2hyb21lIC8gZmlyZWZveCBidWcgbm90IGNvcnJlY3RseVxuICAgICAgICAgICAgLy8gcmVzZXR0aW5nIHN0cm9rZSBkYXNoIGFycmF5XG4gICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IFsgMTAwMDAsIDEgXVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFkZE1hcmtlcihpZCwge1xuICAgICAgICAgIGVsZW1lbnQ6IGFzc29jaWF0aW9uRW5kLFxuICAgICAgICAgIHJlZjogeyB4OiAxMSwgeTogMTAgfSxcbiAgICAgICAgICBzY2FsZTogMC41LFxuICAgICAgICAgIHBhcmVudEdmeFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdjb25kaXRpb25hbC1mbG93LW1hcmtlcicpIHtcbiAgICAgICAgdmFyIGNvbmRpdGlvbmFsRmxvd01hcmtlciA9IGNyZWF0ZSQxKCdwYXRoJywge1xuICAgICAgICAgIGQ6ICdNIDAgMTAgTCA4IDYgTCAxNiAxMCBMIDggMTQgWicsXG4gICAgICAgICAgLi4uc2hhcGVTdHlsZSh7XG4gICAgICAgICAgICBmaWxsLFxuICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2VcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBhZGRNYXJrZXIoaWQsIHtcbiAgICAgICAgICBlbGVtZW50OiBjb25kaXRpb25hbEZsb3dNYXJrZXIsXG4gICAgICAgICAgcmVmOiB7IHg6IC0xLCB5OiAxMCB9LFxuICAgICAgICAgIHNjYWxlOiAwLjUsXG4gICAgICAgICAgcGFyZW50R2Z4XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSA9PT0gJ2NvbmRpdGlvbmFsLWRlZmF1bHQtZmxvdy1tYXJrZXInKSB7XG4gICAgICAgIHZhciBkZWZhdWx0Rmxvd01hcmtlciA9IGNyZWF0ZSQxKCdwYXRoJywge1xuICAgICAgICAgIGQ6ICdNIDYgNCBMIDEwIDE2JyxcbiAgICAgICAgICAuLi5zaGFwZVN0eWxlKHtcbiAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgICAgZmlsbDogJ25vbmUnXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYWRkTWFya2VyKGlkLCB7XG4gICAgICAgICAgZWxlbWVudDogZGVmYXVsdEZsb3dNYXJrZXIsXG4gICAgICAgICAgcmVmOiB7IHg6IDAsIHk6IDEwIH0sXG4gICAgICAgICAgc2NhbGU6IDAuNSxcbiAgICAgICAgICBwYXJlbnRHZnhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd0NpcmNsZShwYXJlbnRHZngsIHdpZHRoLCBoZWlnaHQsIG9mZnNldCwgYXR0cnMgPSB7fSkge1xuXG4gICAgICBpZiAoaXNPYmplY3Qob2Zmc2V0KSkge1xuICAgICAgICBhdHRycyA9IG9mZnNldDtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgIGF0dHJzID0gc2hhcGVTdHlsZShhdHRycyk7XG5cbiAgICAgIHZhciBjeCA9IHdpZHRoIC8gMixcbiAgICAgICAgICBjeSA9IGhlaWdodCAvIDI7XG5cbiAgICAgIHZhciBjaXJjbGUgPSBjcmVhdGUkMSgnY2lyY2xlJywge1xuICAgICAgICBjeDogY3gsXG4gICAgICAgIGN5OiBjeSxcbiAgICAgICAgcjogTWF0aC5yb3VuZCgod2lkdGggKyBoZWlnaHQpIC8gNCAtIG9mZnNldCksXG4gICAgICAgIC4uLmF0dHJzXG4gICAgICB9KTtcblxuICAgICAgYXBwZW5kKHBhcmVudEdmeCwgY2lyY2xlKTtcblxuICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmF3UmVjdChwYXJlbnRHZngsIHdpZHRoLCBoZWlnaHQsIHIsIG9mZnNldCwgYXR0cnMpIHtcblxuICAgICAgaWYgKGlzT2JqZWN0KG9mZnNldCkpIHtcbiAgICAgICAgYXR0cnMgPSBvZmZzZXQ7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgICBhdHRycyA9IHNoYXBlU3R5bGUoYXR0cnMpO1xuXG4gICAgICB2YXIgcmVjdCA9IGNyZWF0ZSQxKCdyZWN0Jywge1xuICAgICAgICB4OiBvZmZzZXQsXG4gICAgICAgIHk6IG9mZnNldCxcbiAgICAgICAgd2lkdGg6IHdpZHRoIC0gb2Zmc2V0ICogMixcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgLSBvZmZzZXQgKiAyLFxuICAgICAgICByeDogcixcbiAgICAgICAgcnk6IHIsXG4gICAgICAgIC4uLmF0dHJzXG4gICAgICB9KTtcblxuICAgICAgYXBwZW5kKHBhcmVudEdmeCwgcmVjdCk7XG5cbiAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdEaWFtb25kKHBhcmVudEdmeCwgd2lkdGgsIGhlaWdodCwgYXR0cnMpIHtcblxuICAgICAgdmFyIHhfMiA9IHdpZHRoIC8gMjtcbiAgICAgIHZhciB5XzIgPSBoZWlnaHQgLyAyO1xuXG4gICAgICB2YXIgcG9pbnRzID0gW1xuICAgICAgICB7IHg6IHhfMiwgeTogMCB9LFxuICAgICAgICB7IHg6IHdpZHRoLCB5OiB5XzIgfSxcbiAgICAgICAgeyB4OiB4XzIsIHk6IGhlaWdodCB9LFxuICAgICAgICB7IHg6IDAsIHk6IHlfMiB9XG4gICAgICBdO1xuXG4gICAgICB2YXIgcG9pbnRzU3RyaW5nID0gcG9pbnRzLm1hcChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gcG9pbnQueCArICcsJyArIHBvaW50Lnk7XG4gICAgICB9KS5qb2luKCcgJyk7XG5cbiAgICAgIGF0dHJzID0gc2hhcGVTdHlsZShhdHRycyk7XG5cbiAgICAgIHZhciBwb2x5Z29uID0gY3JlYXRlJDEoJ3BvbHlnb24nLCB7XG4gICAgICAgIC4uLmF0dHJzLFxuICAgICAgICBwb2ludHM6IHBvaW50c1N0cmluZ1xuICAgICAgfSk7XG5cbiAgICAgIGFwcGVuZChwYXJlbnRHZngsIHBvbHlnb24pO1xuXG4gICAgICByZXR1cm4gcG9seWdvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IHBhcmVudEdmeFxuICAgICAqIEBwYXJhbSB7UG9pbnRbXX0gd2F5cG9pbnRzXG4gICAgICogQHBhcmFtIHthbnl9IGF0dHJzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXNdXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXdMaW5lKHBhcmVudEdmeCwgd2F5cG9pbnRzLCBhdHRycywgcmFkaXVzKSB7XG4gICAgICBhdHRycyA9IGxpbmVTdHlsZShhdHRycyk7XG5cbiAgICAgIHZhciBsaW5lID0gY3JlYXRlTGluZSh3YXlwb2ludHMsIGF0dHJzLCByYWRpdXMpO1xuXG4gICAgICBhcHBlbmQocGFyZW50R2Z4LCBsaW5lKTtcblxuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBwYXJlbnRHZnhcbiAgICAgKiBAcGFyYW0ge1BvaW50W119IHdheXBvaW50c1xuICAgICAqIEBwYXJhbSB7YW55fSBhdHRyc1xuICAgICAqXG4gICAgICogQHJldHVybiB7U1ZHRWxlbWVudH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3Q29ubmVjdGlvblNlZ21lbnRzKHBhcmVudEdmeCwgd2F5cG9pbnRzLCBhdHRycykge1xuICAgICAgcmV0dXJuIGRyYXdMaW5lKHBhcmVudEdmeCwgd2F5cG9pbnRzLCBhdHRycywgNSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd1BhdGgocGFyZW50R2Z4LCBkLCBhdHRycykge1xuICAgICAgYXR0cnMgPSBsaW5lU3R5bGUoYXR0cnMpO1xuXG4gICAgICB2YXIgcGF0aCA9IGNyZWF0ZSQxKCdwYXRoJywge1xuICAgICAgICAuLi5hdHRycyxcbiAgICAgICAgZFxuICAgICAgfSk7XG5cbiAgICAgIGFwcGVuZChwYXJlbnRHZngsIHBhdGgpO1xuXG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmF3TWFya2VyKHR5cGUsIHBhcmVudEdmeCwgcGF0aCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGgsIGFzc2lnbiQxKHsgJ2RhdGEtbWFya2VyJzogdHlwZSB9LCBhdHRycykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlcmVyKHR5cGUpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyc1t0eXBlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcyh0eXBlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICByZXR1cm4gcmVuZGVyZXIodHlwZSkocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBldmVudEljb25SZW5kZXJlcnMgPSB7XG4gICAgICAnYnBtbjpNZXNzYWdlRXZlbnREZWZpbml0aW9uJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9LCBpc1Rocm93aW5nKSB7XG4gICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnRVZFTlRfTUVTU0FHRScsIHtcbiAgICAgICAgICB4U2NhbGVGYWN0b3I6IDAuOSxcbiAgICAgICAgICB5U2NhbGVGYWN0b3I6IDAuOSxcbiAgICAgICAgICBjb250YWluZXJXaWR0aDogYXR0cnMud2lkdGggfHwgZWxlbWVudC53aWR0aCxcbiAgICAgICAgICBjb250YWluZXJIZWlnaHQ6IGF0dHJzLmhlaWdodCB8fCBlbGVtZW50LmhlaWdodCxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgbXg6IDAuMjM1LFxuICAgICAgICAgICAgbXk6IDAuMzE1XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZmlsbCA9IGlzVGhyb3dpbmdcbiAgICAgICAgICA/IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKVxuICAgICAgICAgIDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpO1xuXG4gICAgICAgIHZhciBzdHJva2UgPSBpc1Rocm93aW5nXG4gICAgICAgICAgPyBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciwgYXR0cnMuZmlsbClcbiAgICAgICAgICA6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKTtcblxuICAgICAgICB2YXIgbWVzc2FnZVBhdGggPSBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhLCB7XG4gICAgICAgICAgZmlsbCxcbiAgICAgICAgICBzdHJva2UsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VQYXRoO1xuICAgICAgfSxcbiAgICAgICdicG1uOlRpbWVyRXZlbnREZWZpbml0aW9uJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICAgIHZhciBiYXNlV2lkdGggPSBhdHRycy53aWR0aCB8fCBlbGVtZW50LndpZHRoO1xuICAgICAgICB2YXIgYmFzZUhlaWdodCA9IGF0dHJzLmhlaWdodCB8fCBlbGVtZW50LmhlaWdodDtcblxuICAgICAgICAvLyB1c2UgYSBsaWdodGVyIHN0cm9rZSBmb3IgZXZlbnQgc3Vwcm9jZXNzIGljb25zXG4gICAgICAgIHZhciBzdHJva2VXaWR0aCA9IGF0dHJzLndpZHRoID8gMSA6IDI7XG5cbiAgICAgICAgdmFyIGNpcmNsZSA9IGRyYXdDaXJjbGUocGFyZW50R2Z4LCBiYXNlV2lkdGgsIGJhc2VIZWlnaHQsIDAuMiAqIGJhc2VIZWlnaHQsIHtcbiAgICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciwgYXR0cnMuZmlsbCksXG4gICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnRVZFTlRfVElNRVJfV0gnLCB7XG4gICAgICAgICAgeFNjYWxlRmFjdG9yOiAwLjc1LFxuICAgICAgICAgIHlTY2FsZUZhY3RvcjogMC43NSxcbiAgICAgICAgICBjb250YWluZXJXaWR0aDogYmFzZVdpZHRoLFxuICAgICAgICAgIGNvbnRhaW5lckhlaWdodDogYmFzZUhlaWdodCxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgbXg6IDAuNSxcbiAgICAgICAgICAgIG15OiAwLjVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRyYXdQYXRoKHBhcmVudEdmeCwgcGF0aERhdGEsIHtcbiAgICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKSxcbiAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGxpbmVQYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnRVZFTlRfVElNRVJfTElORScsIHtcbiAgICAgICAgICAgIHhTY2FsZUZhY3RvcjogMC43NSxcbiAgICAgICAgICAgIHlTY2FsZUZhY3RvcjogMC43NSxcbiAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoOiBiYXNlV2lkdGgsXG4gICAgICAgICAgICBjb250YWluZXJIZWlnaHQ6IGJhc2VIZWlnaHQsXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICBteDogMC41LFxuICAgICAgICAgICAgICBteTogMC41XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgd2lkdGggPSBiYXNlV2lkdGggLyAyLFxuICAgICAgICAgICAgICBoZWlnaHQgPSBiYXNlSGVpZ2h0IC8gMjtcblxuICAgICAgICAgIGRyYXdQYXRoKHBhcmVudEdmeCwgbGluZVBhdGhEYXRhLCB7XG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiAncm90YXRlKCcgKyAoaSAqIDMwKSArICcsJyArIGhlaWdodCArICcsJyArIHdpZHRoICsgJyknXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2lyY2xlO1xuICAgICAgfSxcbiAgICAgICdicG1uOkVzY2FsYXRpb25FdmVudERlZmluaXRpb24nOiBmdW5jdGlvbihwYXJlbnRHZngsIGV2ZW50LCBhdHRycyA9IHt9LCBpc1Rocm93aW5nKSB7XG4gICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnRVZFTlRfRVNDQUxBVElPTicsIHtcbiAgICAgICAgICB4U2NhbGVGYWN0b3I6IDEsXG4gICAgICAgICAgeVNjYWxlRmFjdG9yOiAxLFxuICAgICAgICAgIGNvbnRhaW5lcldpZHRoOiBhdHRycy53aWR0aCB8fCBldmVudC53aWR0aCxcbiAgICAgICAgICBjb250YWluZXJIZWlnaHQ6IGF0dHJzLmhlaWdodCB8fCBldmVudC5oZWlnaHQsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIG14OiAwLjUsXG4gICAgICAgICAgICBteTogMC4yXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZmlsbCA9IGlzVGhyb3dpbmdcbiAgICAgICAgICA/IGdldFN0cm9rZUNvbG9yKGV2ZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSlcbiAgICAgICAgICA6IGdldEZpbGxDb2xvcihldmVudCwgZGVmYXVsdEZpbGxDb2xvciwgYXR0cnMuZmlsbCk7XG5cbiAgICAgICAgcmV0dXJuIGRyYXdQYXRoKHBhcmVudEdmeCwgcGF0aERhdGEsIHtcbiAgICAgICAgICBmaWxsLFxuICAgICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZXZlbnQsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKSxcbiAgICAgICAgICBzdHJva2VXaWR0aDogMVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAnYnBtbjpDb25kaXRpb25hbEV2ZW50RGVmaW5pdGlvbic6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZXZlbnQsIGF0dHJzID0ge30pIHtcbiAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdFVkVOVF9DT05ESVRJT05BTCcsIHtcbiAgICAgICAgICB4U2NhbGVGYWN0b3I6IDEsXG4gICAgICAgICAgeVNjYWxlRmFjdG9yOiAxLFxuICAgICAgICAgIGNvbnRhaW5lcldpZHRoOiBhdHRycy53aWR0aCB8fCBldmVudC53aWR0aCxcbiAgICAgICAgICBjb250YWluZXJIZWlnaHQ6IGF0dHJzLmhlaWdodCB8fCBldmVudC5oZWlnaHQsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIG14OiAwLjUsXG4gICAgICAgICAgICBteTogMC4yMjJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhLCB7XG4gICAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGV2ZW50LCBkZWZhdWx0RmlsbENvbG9yLCBhdHRycy5maWxsKSxcbiAgICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGV2ZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDFcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgJ2JwbW46TGlua0V2ZW50RGVmaW5pdGlvbic6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZXZlbnQsIGF0dHJzID0ge30sIGlzVGhyb3dpbmcpIHtcbiAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdFVkVOVF9MSU5LJywge1xuICAgICAgICAgIHhTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgICB5U2NhbGVGYWN0b3I6IDEsXG4gICAgICAgICAgY29udGFpbmVyV2lkdGg6IGV2ZW50LndpZHRoLFxuICAgICAgICAgIGNvbnRhaW5lckhlaWdodDogZXZlbnQuaGVpZ2h0LFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICBteDogMC41NyxcbiAgICAgICAgICAgIG15OiAwLjI2M1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGZpbGwgPSBpc1Rocm93aW5nXG4gICAgICAgICAgPyBnZXRTdHJva2VDb2xvcihldmVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpXG4gICAgICAgICAgOiBnZXRGaWxsQ29sb3IoZXZlbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpO1xuXG4gICAgICAgIHJldHVybiBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhLCB7XG4gICAgICAgICAgZmlsbCxcbiAgICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGV2ZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDFcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgJ2JwbW46RXJyb3JFdmVudERlZmluaXRpb24nOiBmdW5jdGlvbihwYXJlbnRHZngsIGV2ZW50LCBhdHRycyA9IHt9LCBpc1Rocm93aW5nKSB7XG4gICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnRVZFTlRfRVJST1InLCB7XG4gICAgICAgICAgeFNjYWxlRmFjdG9yOiAxLjEsXG4gICAgICAgICAgeVNjYWxlRmFjdG9yOiAxLjEsXG4gICAgICAgICAgY29udGFpbmVyV2lkdGg6IGF0dHJzLndpZHRoIHx8IGV2ZW50LndpZHRoLFxuICAgICAgICAgIGNvbnRhaW5lckhlaWdodDogYXR0cnMuaGVpZ2h0IHx8IGV2ZW50LmhlaWdodCxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgbXg6IDAuMixcbiAgICAgICAgICAgIG15OiAwLjcyMlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGZpbGwgPSBpc1Rocm93aW5nXG4gICAgICAgICAgPyBnZXRTdHJva2VDb2xvcihldmVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpXG4gICAgICAgICAgOiBnZXRGaWxsQ29sb3IoZXZlbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpO1xuXG4gICAgICAgIHJldHVybiBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhLCB7XG4gICAgICAgICAgZmlsbCxcbiAgICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGV2ZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDFcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgJ2JwbW46Q2FuY2VsRXZlbnREZWZpbml0aW9uJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBldmVudCwgYXR0cnMgPSB7fSwgaXNUaHJvd2luZykge1xuICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ0VWRU5UX0NBTkNFTF80NScsIHtcbiAgICAgICAgICB4U2NhbGVGYWN0b3I6IDEuMCxcbiAgICAgICAgICB5U2NhbGVGYWN0b3I6IDEuMCxcbiAgICAgICAgICBjb250YWluZXJXaWR0aDogZXZlbnQud2lkdGgsXG4gICAgICAgICAgY29udGFpbmVySGVpZ2h0OiBldmVudC5oZWlnaHQsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIG14OiAwLjYzOCxcbiAgICAgICAgICAgIG15OiAtMC4wNTVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBmaWxsID0gaXNUaHJvd2luZyA/IGdldFN0cm9rZUNvbG9yKGV2ZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSkgOiAnbm9uZSc7XG5cbiAgICAgICAgdmFyIHBhdGggPSBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhLCB7XG4gICAgICAgICAgZmlsbCxcbiAgICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGV2ZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcm90YXRlKHBhdGgsIDQ1KTtcblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH0sXG4gICAgICAnYnBtbjpDb21wZW5zYXRlRXZlbnREZWZpbml0aW9uJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBldmVudCwgYXR0cnMgPSB7fSwgaXNUaHJvd2luZykge1xuICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ0VWRU5UX0NPTVBFTlNBVElPTicsIHtcbiAgICAgICAgICB4U2NhbGVGYWN0b3I6IDEsXG4gICAgICAgICAgeVNjYWxlRmFjdG9yOiAxLFxuICAgICAgICAgIGNvbnRhaW5lcldpZHRoOiBhdHRycy53aWR0aCB8fCBldmVudC53aWR0aCxcbiAgICAgICAgICBjb250YWluZXJIZWlnaHQ6IGF0dHJzLmhlaWdodCB8fCBldmVudC5oZWlnaHQsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIG14OiAwLjIyLFxuICAgICAgICAgICAgbXk6IDAuNVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGZpbGwgPSBpc1Rocm93aW5nXG4gICAgICAgICAgPyBnZXRTdHJva2VDb2xvcihldmVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpXG4gICAgICAgICAgOiBnZXRGaWxsQ29sb3IoZXZlbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpO1xuXG4gICAgICAgIHJldHVybiBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhLCB7XG4gICAgICAgICAgZmlsbCxcbiAgICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGV2ZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDFcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgJ2JwbW46U2lnbmFsRXZlbnREZWZpbml0aW9uJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBldmVudCwgYXR0cnMgPSB7fSwgaXNUaHJvd2luZykge1xuICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ0VWRU5UX1NJR05BTCcsIHtcbiAgICAgICAgICB4U2NhbGVGYWN0b3I6IDAuOSxcbiAgICAgICAgICB5U2NhbGVGYWN0b3I6IDAuOSxcbiAgICAgICAgICBjb250YWluZXJXaWR0aDogYXR0cnMud2lkdGggfHwgZXZlbnQud2lkdGgsXG4gICAgICAgICAgY29udGFpbmVySGVpZ2h0OiBhdHRycy5oZWlnaHQgfHwgZXZlbnQuaGVpZ2h0LFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICBteDogMC41LFxuICAgICAgICAgICAgbXk6IDAuMlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGZpbGwgPSBpc1Rocm93aW5nXG4gICAgICAgICAgPyBnZXRTdHJva2VDb2xvcihldmVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpXG4gICAgICAgICAgOiBnZXRGaWxsQ29sb3IoZXZlbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpO1xuXG4gICAgICAgIHJldHVybiBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhLCB7XG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgICAgZmlsbCxcbiAgICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGV2ZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSlcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgJ2JwbW46TXVsdGlwbGVFdmVudERlZmluaXRpb24nOiBmdW5jdGlvbihwYXJlbnRHZngsIGV2ZW50LCBhdHRycyA9IHt9LCBpc1Rocm93aW5nKSB7XG4gICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnRVZFTlRfTVVMVElQTEUnLCB7XG4gICAgICAgICAgeFNjYWxlRmFjdG9yOiAxLjEsXG4gICAgICAgICAgeVNjYWxlRmFjdG9yOiAxLjEsXG4gICAgICAgICAgY29udGFpbmVyV2lkdGg6IGF0dHJzLndpZHRoIHx8IGV2ZW50LndpZHRoLFxuICAgICAgICAgIGNvbnRhaW5lckhlaWdodDogYXR0cnMuaGVpZ2h0IHx8IGV2ZW50LmhlaWdodCxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgbXg6IDAuMjExLFxuICAgICAgICAgICAgbXk6IDAuMzZcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBmaWxsID0gaXNUaHJvd2luZ1xuICAgICAgICAgID8gZ2V0U3Ryb2tlQ29sb3IoZXZlbnQsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKVxuICAgICAgICAgIDogZ2V0RmlsbENvbG9yKGV2ZW50LCBkZWZhdWx0RmlsbENvbG9yLCBhdHRycy5maWxsKTtcblxuICAgICAgICByZXR1cm4gZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YSwge1xuICAgICAgICAgIGZpbGwsXG4gICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihldmVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAxXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgICdicG1uOlBhcmFsbGVsTXVsdGlwbGVFdmVudERlZmluaXRpb24nOiBmdW5jdGlvbihwYXJlbnRHZngsIGV2ZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnRVZFTlRfUEFSQUxMRUxfTVVMVElQTEUnLCB7XG4gICAgICAgICAgeFNjYWxlRmFjdG9yOiAxLjIsXG4gICAgICAgICAgeVNjYWxlRmFjdG9yOiAxLjIsXG4gICAgICAgICAgY29udGFpbmVyV2lkdGg6IGF0dHJzLndpZHRoIHx8IGV2ZW50LndpZHRoLFxuICAgICAgICAgIGNvbnRhaW5lckhlaWdodDogYXR0cnMuaGVpZ2h0IHx8IGV2ZW50LmhlaWdodCxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgbXg6IDAuNDU4LFxuICAgICAgICAgICAgbXk6IDAuMTk0XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YSwge1xuICAgICAgICAgIGZpbGw6IGdldEZpbGxDb2xvcihldmVudCwgZGVmYXVsdEZpbGxDb2xvciwgYXR0cnMuZmlsbCksXG4gICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihldmVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAxXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgICdicG1uOlRlcm1pbmF0ZUV2ZW50RGVmaW5pdGlvbic6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMgPSB7fSkge1xuICAgICAgICB2YXIgY2lyY2xlID0gZHJhd0NpcmNsZShwYXJlbnRHZngsIGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0LCA4LCB7XG4gICAgICAgICAgZmlsbDogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpLFxuICAgICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiA0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaXJjbGU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbmRlckV2ZW50SWNvbihlbGVtZW50LCBwYXJlbnRHZngsIGF0dHJzID0ge30sIHByb3h5RWxlbWVudCkge1xuICAgICAgdmFyIHNlbWFudGljID0gZ2V0QnVzaW5lc3NPYmplY3QoZWxlbWVudCksXG4gICAgICAgICAgaXNUaHJvd2luZyA9IGlzVGhyb3dFdmVudChzZW1hbnRpYyk7XG5cbiAgICAgIHZhciBub2RlRWxlbWVudCA9IHByb3h5RWxlbWVudCB8fCBlbGVtZW50O1xuXG4gICAgICBpZiAoc2VtYW50aWMuZ2V0KCdldmVudERlZmluaXRpb25zJykgJiYgc2VtYW50aWMuZ2V0KCdldmVudERlZmluaXRpb25zJykubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAoc2VtYW50aWMuZ2V0KCdwYXJhbGxlbE11bHRpcGxlJykpIHtcbiAgICAgICAgICByZXR1cm4gZXZlbnRJY29uUmVuZGVyZXJzWyAnYnBtbjpQYXJhbGxlbE11bHRpcGxlRXZlbnREZWZpbml0aW9uJyBdKHBhcmVudEdmeCwgbm9kZUVsZW1lbnQsIGF0dHJzLCBpc1Rocm93aW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZXZlbnRJY29uUmVuZGVyZXJzWyAnYnBtbjpNdWx0aXBsZUV2ZW50RGVmaW5pdGlvbicgXShwYXJlbnRHZngsIG5vZGVFbGVtZW50LCBhdHRycywgaXNUaHJvd2luZyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzVHlwZWRFdmVudChzZW1hbnRpYywgJ2JwbW46TWVzc2FnZUV2ZW50RGVmaW5pdGlvbicpKSB7XG4gICAgICAgIHJldHVybiBldmVudEljb25SZW5kZXJlcnNbICdicG1uOk1lc3NhZ2VFdmVudERlZmluaXRpb24nIF0ocGFyZW50R2Z4LCBub2RlRWxlbWVudCwgYXR0cnMsIGlzVGhyb3dpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNUeXBlZEV2ZW50KHNlbWFudGljLCAnYnBtbjpUaW1lckV2ZW50RGVmaW5pdGlvbicpKSB7XG4gICAgICAgIHJldHVybiBldmVudEljb25SZW5kZXJlcnNbICdicG1uOlRpbWVyRXZlbnREZWZpbml0aW9uJyBdKHBhcmVudEdmeCwgbm9kZUVsZW1lbnQsIGF0dHJzLCBpc1Rocm93aW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzVHlwZWRFdmVudChzZW1hbnRpYywgJ2JwbW46Q29uZGl0aW9uYWxFdmVudERlZmluaXRpb24nKSkge1xuICAgICAgICByZXR1cm4gZXZlbnRJY29uUmVuZGVyZXJzWyAnYnBtbjpDb25kaXRpb25hbEV2ZW50RGVmaW5pdGlvbicgXShwYXJlbnRHZngsIG5vZGVFbGVtZW50LCBhdHRycywgaXNUaHJvd2luZyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1R5cGVkRXZlbnQoc2VtYW50aWMsICdicG1uOlNpZ25hbEV2ZW50RGVmaW5pdGlvbicpKSB7XG4gICAgICAgIHJldHVybiBldmVudEljb25SZW5kZXJlcnNbICdicG1uOlNpZ25hbEV2ZW50RGVmaW5pdGlvbicgXShwYXJlbnRHZngsIG5vZGVFbGVtZW50LCBhdHRycywgaXNUaHJvd2luZyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1R5cGVkRXZlbnQoc2VtYW50aWMsICdicG1uOkVzY2FsYXRpb25FdmVudERlZmluaXRpb24nKSkge1xuICAgICAgICByZXR1cm4gZXZlbnRJY29uUmVuZGVyZXJzWyAnYnBtbjpFc2NhbGF0aW9uRXZlbnREZWZpbml0aW9uJyBdKHBhcmVudEdmeCwgbm9kZUVsZW1lbnQsIGF0dHJzLCBpc1Rocm93aW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzVHlwZWRFdmVudChzZW1hbnRpYywgJ2JwbW46TGlua0V2ZW50RGVmaW5pdGlvbicpKSB7XG4gICAgICAgIHJldHVybiBldmVudEljb25SZW5kZXJlcnNbICdicG1uOkxpbmtFdmVudERlZmluaXRpb24nIF0ocGFyZW50R2Z4LCBub2RlRWxlbWVudCwgYXR0cnMsIGlzVGhyb3dpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNUeXBlZEV2ZW50KHNlbWFudGljLCAnYnBtbjpFcnJvckV2ZW50RGVmaW5pdGlvbicpKSB7XG4gICAgICAgIHJldHVybiBldmVudEljb25SZW5kZXJlcnNbICdicG1uOkVycm9yRXZlbnREZWZpbml0aW9uJyBdKHBhcmVudEdmeCwgbm9kZUVsZW1lbnQsIGF0dHJzLCBpc1Rocm93aW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzVHlwZWRFdmVudChzZW1hbnRpYywgJ2JwbW46Q2FuY2VsRXZlbnREZWZpbml0aW9uJykpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50SWNvblJlbmRlcmVyc1sgJ2JwbW46Q2FuY2VsRXZlbnREZWZpbml0aW9uJyBdKHBhcmVudEdmeCwgbm9kZUVsZW1lbnQsIGF0dHJzLCBpc1Rocm93aW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzVHlwZWRFdmVudChzZW1hbnRpYywgJ2JwbW46Q29tcGVuc2F0ZUV2ZW50RGVmaW5pdGlvbicpKSB7XG4gICAgICAgIHJldHVybiBldmVudEljb25SZW5kZXJlcnNbICdicG1uOkNvbXBlbnNhdGVFdmVudERlZmluaXRpb24nIF0ocGFyZW50R2Z4LCBub2RlRWxlbWVudCwgYXR0cnMsIGlzVGhyb3dpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNUeXBlZEV2ZW50KHNlbWFudGljLCAnYnBtbjpUZXJtaW5hdGVFdmVudERlZmluaXRpb24nKSkge1xuICAgICAgICByZXR1cm4gZXZlbnRJY29uUmVuZGVyZXJzWyAnYnBtbjpUZXJtaW5hdGVFdmVudERlZmluaXRpb24nIF0ocGFyZW50R2Z4LCBub2RlRWxlbWVudCwgYXR0cnMsIGlzVGhyb3dpbmcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdGFza01hcmtlclJlbmRlcmVycyA9IHtcbiAgICAgICdQYXJ0aWNpcGFudE11bHRpcGxpY2l0eU1hcmtlcic6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMgPSB7fSkge1xuICAgICAgICB2YXIgd2lkdGggPSBnZXRXaWR0aChlbGVtZW50LCBhdHRycyksXG4gICAgICAgICAgICBoZWlnaHQgPSBnZXRIZWlnaHQoZWxlbWVudCwgYXR0cnMpO1xuXG4gICAgICAgIHZhciBtYXJrZXJQYXRoID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdNQVJLRVJfUEFSQUxMRUwnLCB7XG4gICAgICAgICAgeFNjYWxlRmFjdG9yOiAxLFxuICAgICAgICAgIHlTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgICBjb250YWluZXJXaWR0aDogd2lkdGgsXG4gICAgICAgICAgY29udGFpbmVySGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIG14OiAoKHdpZHRoIC8gMiAtIDYpIC8gd2lkdGgpLFxuICAgICAgICAgICAgbXk6IChoZWlnaHQgLSAxNSkgLyBoZWlnaHRcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRyYXdNYXJrZXIoJ3BhcnRpY2lwYW50LW11bHRpcGxpY2l0eScsIHBhcmVudEdmeCwgbWFya2VyUGF0aCwge1xuICAgICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICAgIGZpbGw6IGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0RmlsbENvbG9yLCBhdHRycy5maWxsKSxcbiAgICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAnU3ViUHJvY2Vzc01hcmtlcic6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMgPSB7fSkge1xuICAgICAgICB2YXIgbWFya2VyUmVjdCA9IGRyYXdSZWN0KHBhcmVudEdmeCwgMTQsIDE0LCAwLCB7XG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpLFxuICAgICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRyYW5zbGF0ZSQxKG1hcmtlclJlY3QsIGVsZW1lbnQud2lkdGggLyAyIC0gNy41LCBlbGVtZW50LmhlaWdodCAtIDIwKTtcblxuICAgICAgICB2YXIgbWFya2VyUGF0aCA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnTUFSS0VSX1NVQl9QUk9DRVNTJywge1xuICAgICAgICAgIHhTY2FsZUZhY3RvcjogMS41LFxuICAgICAgICAgIHlTY2FsZUZhY3RvcjogMS41LFxuICAgICAgICAgIGNvbnRhaW5lcldpZHRoOiBlbGVtZW50LndpZHRoLFxuICAgICAgICAgIGNvbnRhaW5lckhlaWdodDogZWxlbWVudC5oZWlnaHQsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIG14OiAoZWxlbWVudC53aWR0aCAvIDIgLSA3LjUpIC8gZWxlbWVudC53aWR0aCxcbiAgICAgICAgICAgIG15OiAoZWxlbWVudC5oZWlnaHQgLSAyMCkgLyBlbGVtZW50LmhlaWdodFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZHJhd01hcmtlcignc3ViLXByb2Nlc3MnLCBwYXJlbnRHZngsIG1hcmtlclBhdGgsIHtcbiAgICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciwgYXR0cnMuZmlsbCksXG4gICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSlcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgJ1BhcmFsbGVsTWFya2VyJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICB2YXIgd2lkdGggPSBnZXRXaWR0aChlbGVtZW50LCBhdHRycyksXG4gICAgICAgICAgICBoZWlnaHQgPSBnZXRIZWlnaHQoZWxlbWVudCwgYXR0cnMpO1xuXG4gICAgICAgIHZhciBtYXJrZXJQYXRoID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdNQVJLRVJfUEFSQUxMRUwnLCB7XG4gICAgICAgICAgeFNjYWxlRmFjdG9yOiAxLFxuICAgICAgICAgIHlTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgICBjb250YWluZXJXaWR0aDogd2lkdGgsXG4gICAgICAgICAgY29udGFpbmVySGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIG14OiAoKHdpZHRoIC8gMiArIGF0dHJzLnBhcmFsbGVsKSAvIHdpZHRoKSxcbiAgICAgICAgICAgIG15OiAoaGVpZ2h0IC0gMjApIC8gaGVpZ2h0XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBkcmF3TWFya2VyKCdwYXJhbGxlbCcsIHBhcmVudEdmeCwgbWFya2VyUGF0aCwge1xuICAgICAgICAgIGZpbGw6IGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0RmlsbENvbG9yLCBhdHRycy5maWxsKSxcbiAgICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAnU2VxdWVudGlhbE1hcmtlcic6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgdmFyIG1hcmtlclBhdGggPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ01BUktFUl9TRVFVRU5USUFMJywge1xuICAgICAgICAgIHhTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgICB5U2NhbGVGYWN0b3I6IDEsXG4gICAgICAgICAgY29udGFpbmVyV2lkdGg6IGVsZW1lbnQud2lkdGgsXG4gICAgICAgICAgY29udGFpbmVySGVpZ2h0OiBlbGVtZW50LmhlaWdodCxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgbXg6ICgoZWxlbWVudC53aWR0aCAvIDIgKyBhdHRycy5zZXEpIC8gZWxlbWVudC53aWR0aCksXG4gICAgICAgICAgICBteTogKGVsZW1lbnQuaGVpZ2h0IC0gMTkpIC8gZWxlbWVudC5oZWlnaHRcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRyYXdNYXJrZXIoJ3NlcXVlbnRpYWwnLCBwYXJlbnRHZngsIG1hcmtlclBhdGgsIHtcbiAgICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciwgYXR0cnMuZmlsbCksXG4gICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSlcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgJ0NvbXBlbnNhdGlvbk1hcmtlcic6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgdmFyIG1hcmtlck1hdGggPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ01BUktFUl9DT01QRU5TQVRJT04nLCB7XG4gICAgICAgICAgeFNjYWxlRmFjdG9yOiAxLFxuICAgICAgICAgIHlTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgICBjb250YWluZXJXaWR0aDogZWxlbWVudC53aWR0aCxcbiAgICAgICAgICBjb250YWluZXJIZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0LFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICBteDogKChlbGVtZW50LndpZHRoIC8gMiArIGF0dHJzLmNvbXBlbnNhdGlvbikgLyBlbGVtZW50LndpZHRoKSxcbiAgICAgICAgICAgIG15OiAoZWxlbWVudC5oZWlnaHQgLSAxMykgLyBlbGVtZW50LmhlaWdodFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZHJhd01hcmtlcignY29tcGVuc2F0aW9uJywgcGFyZW50R2Z4LCBtYXJrZXJNYXRoLCB7XG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpLFxuICAgICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgICdMb29wTWFya2VyJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICB2YXIgd2lkdGggPSBnZXRXaWR0aChlbGVtZW50LCBhdHRycyksXG4gICAgICAgICAgICBoZWlnaHQgPSBnZXRIZWlnaHQoZWxlbWVudCwgYXR0cnMpO1xuXG4gICAgICAgIHZhciBtYXJrZXJQYXRoID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdNQVJLRVJfTE9PUCcsIHtcbiAgICAgICAgICB4U2NhbGVGYWN0b3I6IDEsXG4gICAgICAgICAgeVNjYWxlRmFjdG9yOiAxLFxuICAgICAgICAgIGNvbnRhaW5lcldpZHRoOiB3aWR0aCxcbiAgICAgICAgICBjb250YWluZXJIZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgbXg6ICgod2lkdGggLyAyICsgYXR0cnMubG9vcCkgLyB3aWR0aCksXG4gICAgICAgICAgICBteTogKGhlaWdodCAtIDcpIC8gaGVpZ2h0XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBkcmF3TWFya2VyKCdsb29wJywgcGFyZW50R2Z4LCBtYXJrZXJQYXRoLCB7XG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDEuNSxcbiAgICAgICAgICBmaWxsOiAnbm9uZScsXG4gICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogMC41XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgICdBZGhvY01hcmtlcic6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gZ2V0V2lkdGgoZWxlbWVudCwgYXR0cnMpLFxuICAgICAgICAgICAgaGVpZ2h0ID0gZ2V0SGVpZ2h0KGVsZW1lbnQsIGF0dHJzKTtcblxuICAgICAgICB2YXIgbWFya2VyUGF0aCA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnTUFSS0VSX0FESE9DJywge1xuICAgICAgICAgIHhTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgICB5U2NhbGVGYWN0b3I6IDEsXG4gICAgICAgICAgY29udGFpbmVyV2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGNvbnRhaW5lckhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICBteDogKCh3aWR0aCAvIDIgKyBhdHRycy5hZGhvYykgLyB3aWR0aCksXG4gICAgICAgICAgICBteTogKGhlaWdodCAtIDE1KSAvIGhlaWdodFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZHJhd01hcmtlcignYWRob2MnLCBwYXJlbnRHZngsIG1hcmtlclBhdGgsIHtcbiAgICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgICBmaWxsOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbmRlclRhc2tNYXJrZXIodHlwZSwgcGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycykge1xuICAgICAgdGFza01hcmtlclJlbmRlcmVyc1sgdHlwZSBdKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlclRhc2tNYXJrZXJzKHBhcmVudEdmeCwgZWxlbWVudCwgdGFza01hcmtlcnMgPSBbXSwgYXR0cnMgPSB7fSkge1xuICAgICAgYXR0cnMgPSB7XG4gICAgICAgIGZpbGw6IGF0dHJzLmZpbGwsXG4gICAgICAgIHN0cm9rZTogYXR0cnMuc3Ryb2tlLFxuICAgICAgICB3aWR0aDogZ2V0V2lkdGgoZWxlbWVudCwgYXR0cnMpLFxuICAgICAgICBoZWlnaHQ6IGdldEhlaWdodChlbGVtZW50LCBhdHRycylcbiAgICAgIH07XG5cbiAgICAgIHZhciBzZW1hbnRpYyA9IGdldEJ1c2luZXNzT2JqZWN0KGVsZW1lbnQpO1xuXG4gICAgICB2YXIgc3VicHJvY2VzcyA9IHRhc2tNYXJrZXJzLmluY2x1ZGVzKCdTdWJQcm9jZXNzTWFya2VyJyk7XG5cbiAgICAgIGlmIChzdWJwcm9jZXNzKSB7XG4gICAgICAgIGF0dHJzID0ge1xuICAgICAgICAgIC4uLmF0dHJzLFxuICAgICAgICAgIHNlcTogLTIxLFxuICAgICAgICAgIHBhcmFsbGVsOiAtMjIsXG4gICAgICAgICAgY29tcGVuc2F0aW9uOiAtMjUsXG4gICAgICAgICAgbG9vcDogLTE4LFxuICAgICAgICAgIGFkaG9jOiAxMFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cnMgPSB7XG4gICAgICAgICAgLi4uYXR0cnMsXG4gICAgICAgICAgc2VxOiAtNSxcbiAgICAgICAgICBwYXJhbGxlbDogLTYsXG4gICAgICAgICAgY29tcGVuc2F0aW9uOiAtNyxcbiAgICAgICAgICBsb29wOiAwLFxuICAgICAgICAgIGFkaG9jOiAtOFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VtYW50aWMuZ2V0KCdpc0ZvckNvbXBlbnNhdGlvbicpKSB7XG4gICAgICAgIHRhc2tNYXJrZXJzLnB1c2goJ0NvbXBlbnNhdGlvbk1hcmtlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXMkMShzZW1hbnRpYywgJ2JwbW46QWRIb2NTdWJQcm9jZXNzJykpIHtcbiAgICAgICAgdGFza01hcmtlcnMucHVzaCgnQWRob2NNYXJrZXInKTtcblxuICAgICAgICBpZiAoIXN1YnByb2Nlc3MpIHtcbiAgICAgICAgICBhc3NpZ24kMShhdHRycywgeyBjb21wZW5zYXRpb246IGF0dHJzLmNvbXBlbnNhdGlvbiAtIDE4IH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBsb29wQ2hhcmFjdGVyaXN0aWNzID0gc2VtYW50aWMuZ2V0KCdsb29wQ2hhcmFjdGVyaXN0aWNzJyksXG4gICAgICAgICAgaXNTZXF1ZW50aWFsID0gbG9vcENoYXJhY3RlcmlzdGljcyAmJiBsb29wQ2hhcmFjdGVyaXN0aWNzLmdldCgnaXNTZXF1ZW50aWFsJyk7XG5cbiAgICAgIGlmIChsb29wQ2hhcmFjdGVyaXN0aWNzKSB7XG5cbiAgICAgICAgYXNzaWduJDEoYXR0cnMsIHtcbiAgICAgICAgICBjb21wZW5zYXRpb246IGF0dHJzLmNvbXBlbnNhdGlvbiAtIDE4LFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGFza01hcmtlcnMuaW5jbHVkZXMoJ0FkaG9jTWFya2VyJykpIHtcbiAgICAgICAgICBhc3NpZ24kMShhdHRycywge1xuICAgICAgICAgICAgc2VxOiAtMjMsXG4gICAgICAgICAgICBsb29wOiAtMTgsXG4gICAgICAgICAgICBwYXJhbGxlbDogLTI0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNTZXF1ZW50aWFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0YXNrTWFya2Vycy5wdXNoKCdMb29wTWFya2VyJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNTZXF1ZW50aWFsID09PSBmYWxzZSkge1xuICAgICAgICAgIHRhc2tNYXJrZXJzLnB1c2goJ1BhcmFsbGVsTWFya2VyJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNTZXF1ZW50aWFsID09PSB0cnVlKSB7XG4gICAgICAgICAgdGFza01hcmtlcnMucHVzaCgnU2VxdWVudGlhbE1hcmtlcicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXNrTWFya2Vycy5pbmNsdWRlcygnQ29tcGVuc2F0aW9uTWFya2VyJykgJiYgdGFza01hcmtlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGFzc2lnbiQxKGF0dHJzLCB7XG4gICAgICAgICAgY29tcGVuc2F0aW9uOiAtOFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZm9yRWFjaCQxKHRhc2tNYXJrZXJzLCBmdW5jdGlvbihtYXJrZXIpIHtcbiAgICAgICAgcmVuZGVyVGFza01hcmtlcihtYXJrZXIsIHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyTGFiZWwocGFyZW50R2Z4LCBsYWJlbCwgYXR0cnMgPSB7fSkge1xuICAgICAgYXR0cnMgPSBhc3NpZ24kMSh7XG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICB3aWR0aDogMTAwXG4gICAgICAgIH1cbiAgICAgIH0sIGF0dHJzKTtcblxuICAgICAgdmFyIHRleHQgPSB0ZXh0UmVuZGVyZXIuY3JlYXRlVGV4dChsYWJlbCB8fCAnJywgYXR0cnMpO1xuXG4gICAgICBjbGFzc2VzJDEodGV4dCkuYWRkKCdkanMtbGFiZWwnKTtcblxuICAgICAgYXBwZW5kKHBhcmVudEdmeCwgdGV4dCk7XG5cbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlckVtYmVkZGVkTGFiZWwocGFyZW50R2Z4LCBlbGVtZW50LCBhbGlnbiwgYXR0cnMgPSB7fSkge1xuICAgICAgdmFyIHNlbWFudGljID0gZ2V0QnVzaW5lc3NPYmplY3QoZWxlbWVudCk7XG5cbiAgICAgIHZhciBib3ggPSBnZXRCb3VuZHMoe1xuICAgICAgICB4OiBlbGVtZW50LngsXG4gICAgICAgIHk6IGVsZW1lbnQueSxcbiAgICAgICAgd2lkdGg6IGVsZW1lbnQud2lkdGgsXG4gICAgICAgIGhlaWdodDogZWxlbWVudC5oZWlnaHRcbiAgICAgIH0sIGF0dHJzKTtcblxuICAgICAgcmV0dXJuIHJlbmRlckxhYmVsKHBhcmVudEdmeCwgc2VtYW50aWMubmFtZSwge1xuICAgICAgICBhbGlnbixcbiAgICAgICAgYm94LFxuICAgICAgICBwYWRkaW5nOiA3LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGZpbGw6IGdldExhYmVsQ29sb3IoZWxlbWVudCwgZGVmYXVsdExhYmVsQ29sb3IsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJFeHRlcm5hbExhYmVsKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMgPSB7fSkge1xuICAgICAgdmFyIGJveCA9IHtcbiAgICAgICAgd2lkdGg6IDkwLFxuICAgICAgICBoZWlnaHQ6IDMwLFxuICAgICAgICB4OiBlbGVtZW50LndpZHRoIC8gMiArIGVsZW1lbnQueCxcbiAgICAgICAgeTogZWxlbWVudC5oZWlnaHQgLyAyICsgZWxlbWVudC55XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcmVuZGVyTGFiZWwocGFyZW50R2Z4LCBnZXRMYWJlbChlbGVtZW50KSwge1xuICAgICAgICBib3g6IGJveCxcbiAgICAgICAgZml0Qm94OiB0cnVlLFxuICAgICAgICBzdHlsZTogYXNzaWduJDEoXG4gICAgICAgICAge30sXG4gICAgICAgICAgdGV4dFJlbmRlcmVyLmdldEV4dGVybmFsU3R5bGUoKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmaWxsOiBnZXRMYWJlbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRMYWJlbENvbG9yLCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSlcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlckxhbmVMYWJlbChwYXJlbnRHZngsIHRleHQsIGVsZW1lbnQsIGF0dHJzID0ge30pIHtcbiAgICAgIHZhciBpc0hvcml6b250YWxMYW5lID0gaXNIb3Jpem9udGFsKGVsZW1lbnQpO1xuXG4gICAgICB2YXIgdGV4dEJveCA9IHJlbmRlckxhYmVsKHBhcmVudEdmeCwgdGV4dCwge1xuICAgICAgICBib3g6IHtcbiAgICAgICAgICBoZWlnaHQ6IDMwLFxuICAgICAgICAgIHdpZHRoOiBpc0hvcml6b250YWxMYW5lID8gZ2V0SGVpZ2h0KGVsZW1lbnQsIGF0dHJzKSA6IGdldFdpZHRoKGVsZW1lbnQsIGF0dHJzKSxcbiAgICAgICAgfSxcbiAgICAgICAgYWxpZ246ICdjZW50ZXItbWlkZGxlJyxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBmaWxsOiBnZXRMYWJlbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRMYWJlbENvbG9yLCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc0hvcml6b250YWxMYW5lKSB7XG4gICAgICAgIHZhciB0b3AgPSAtMSAqIGdldEhlaWdodChlbGVtZW50LCBhdHRycyk7XG4gICAgICAgIHRyYW5zZm9ybSh0ZXh0Qm94LCAwLCAtdG9wLCAyNzApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlckFjdGl2aXR5KHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMgPSB7fSkge1xuICAgICAgdmFyIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IGdldEJvdW5kcyhlbGVtZW50LCBhdHRycyk7XG5cbiAgICAgIHJldHVybiBkcmF3UmVjdChwYXJlbnRHZngsIHdpZHRoLCBoZWlnaHQsIFRBU0tfQk9SREVSX1JBRElVUywge1xuICAgICAgICAuLi5hdHRycyxcbiAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpLFxuICAgICAgICBmaWxsT3BhY2l0eTogREVGQVVMVF9PUEFDSVRZLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyQXNzb2NpYXRpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICB2YXIgc2VtYW50aWMgPSBnZXRCdXNpbmVzc09iamVjdChlbGVtZW50KTtcblxuICAgICAgdmFyIGZpbGwgPSBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciwgYXR0cnMuZmlsbCksXG4gICAgICAgICAgc3Ryb2tlID0gZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpO1xuXG4gICAgICBpZiAoc2VtYW50aWMuZ2V0KCdhc3NvY2lhdGlvbkRpcmVjdGlvbicpID09PSAnT25lJyB8fFxuICAgICAgICAgIHNlbWFudGljLmdldCgnYXNzb2NpYXRpb25EaXJlY3Rpb24nKSA9PT0gJ0JvdGgnKSB7XG4gICAgICAgIGF0dHJzLm1hcmtlckVuZCA9IG1hcmtlcihwYXJlbnRHZngsICdhc3NvY2lhdGlvbi1lbmQnLCBmaWxsLCBzdHJva2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VtYW50aWMuZ2V0KCdhc3NvY2lhdGlvbkRpcmVjdGlvbicpID09PSAnQm90aCcpIHtcbiAgICAgICAgYXR0cnMubWFya2VyU3RhcnQgPSBtYXJrZXIocGFyZW50R2Z4LCAnYXNzb2NpYXRpb24tc3RhcnQnLCBmaWxsLCBzdHJva2UpO1xuICAgICAgfVxuXG4gICAgICBhdHRycyA9IHBpY2tBdHRycyhhdHRycywgW1xuICAgICAgICAnbWFya2VyU3RhcnQnLFxuICAgICAgICAnbWFya2VyRW5kJ1xuICAgICAgXSk7XG5cbiAgICAgIHJldHVybiBkcmF3Q29ubmVjdGlvblNlZ21lbnRzKHBhcmVudEdmeCwgZWxlbWVudC53YXlwb2ludHMsIHtcbiAgICAgICAgLi4uYXR0cnMsXG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiAnMCwgNSdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlckRhdGFPYmplY3QocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICB2YXIgZmlsbCA9IGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0RmlsbENvbG9yLCBhdHRycy5maWxsKSxcbiAgICAgICAgICBzdHJva2UgPSBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSk7XG5cbiAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnREFUQV9PQkpFQ1RfUEFUSCcsIHtcbiAgICAgICAgeFNjYWxlRmFjdG9yOiAxLFxuICAgICAgICB5U2NhbGVGYWN0b3I6IDEsXG4gICAgICAgIGNvbnRhaW5lcldpZHRoOiBlbGVtZW50LndpZHRoLFxuICAgICAgICBjb250YWluZXJIZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIG14OiAwLjQ3NCxcbiAgICAgICAgICBteTogMC4yOTZcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBkYXRhT2JqZWN0ID0gZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YSwge1xuICAgICAgICBmaWxsLFxuICAgICAgICBmaWxsT3BhY2l0eTogREVGQVVMVF9PUEFDSVRZLFxuICAgICAgICBzdHJva2VcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc2VtYW50aWMgPSBnZXRCdXNpbmVzc09iamVjdChlbGVtZW50KTtcblxuICAgICAgaWYgKGlzQ29sbGVjdGlvbihzZW1hbnRpYykpIHtcbiAgICAgICAgdmFyIGNvbGxlY3Rpb25QYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnREFUQV9PQkpFQ1RfQ09MTEVDVElPTl9QQVRIJywge1xuICAgICAgICAgIHhTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgICB5U2NhbGVGYWN0b3I6IDEsXG4gICAgICAgICAgY29udGFpbmVyV2lkdGg6IGVsZW1lbnQud2lkdGgsXG4gICAgICAgICAgY29udGFpbmVySGVpZ2h0OiBlbGVtZW50LmhlaWdodCxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgbXg6IDAuMzMsXG4gICAgICAgICAgICBteTogKGVsZW1lbnQuaGVpZ2h0IC0gMTgpIC8gZWxlbWVudC5oZWlnaHRcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRyYXdQYXRoKHBhcmVudEdmeCwgY29sbGVjdGlvblBhdGhEYXRhLCB7XG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICAgICAgZmlsbCxcbiAgICAgICAgICBzdHJva2VcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhT2JqZWN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlckV2ZW50KHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMgPSB7fSkge1xuICAgICAgcmV0dXJuIGRyYXdDaXJjbGUocGFyZW50R2Z4LCBlbGVtZW50LndpZHRoLCBlbGVtZW50LmhlaWdodCwge1xuICAgICAgICBmaWxsT3BhY2l0eTogREVGQVVMVF9PUEFDSVRZLFxuICAgICAgICAuLi5hdHRycyxcbiAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyR2F0ZXdheShwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzID0ge30pIHtcbiAgICAgIHJldHVybiBkcmF3RGlhbW9uZChwYXJlbnRHZngsIGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0LCB7XG4gICAgICAgIGZpbGw6IGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0RmlsbENvbG9yLCBhdHRycy5maWxsKSxcbiAgICAgICAgZmlsbE9wYWNpdHk6IERFRkFVTFRfT1BBQ0lUWSxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlckxhbmUocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICB2YXIgbGFuZSA9IGRyYXdSZWN0KHBhcmVudEdmeCwgZ2V0V2lkdGgoZWxlbWVudCwgYXR0cnMpLCBnZXRIZWlnaHQoZWxlbWVudCwgYXR0cnMpLCAwLCB7XG4gICAgICAgIGZpbGw6IGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0RmlsbENvbG9yLCBhdHRycy5maWxsKSxcbiAgICAgICAgZmlsbE9wYWNpdHk6IGF0dHJzLmZpbGxPcGFjaXR5IHx8IERFRkFVTFRfT1BBQ0lUWSxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLjVcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc2VtYW50aWMgPSBnZXRCdXNpbmVzc09iamVjdChlbGVtZW50KTtcblxuICAgICAgaWYgKGlzJDEoc2VtYW50aWMsICdicG1uOkxhbmUnKSkge1xuICAgICAgICB2YXIgdGV4dCA9IHNlbWFudGljLmdldCgnbmFtZScpO1xuXG4gICAgICAgIHJlbmRlckxhbmVMYWJlbChwYXJlbnRHZngsIHRleHQsIGVsZW1lbnQsIGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxhbmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyU3ViUHJvY2VzcyhwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzID0ge30pIHtcbiAgICAgIHZhciBhY3Rpdml0eSA9IHJlbmRlckFjdGl2aXR5KHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMpO1xuXG4gICAgICB2YXIgZXhwYW5kZWQgPSBpc0V4cGFuZGVkKGVsZW1lbnQpO1xuXG4gICAgICBpZiAoaXNFdmVudFN1YlByb2Nlc3MoZWxlbWVudCkpIHtcbiAgICAgICAgYXR0ciQxKGFjdGl2aXR5LCB7XG4gICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiAnMCwgNS41JyxcbiAgICAgICAgICBzdHJva2VXaWR0aDogMi41XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghZXhwYW5kZWQpIHtcbiAgICAgICAgICB2YXIgZmxvd0VsZW1lbnRzID0gZ2V0QnVzaW5lc3NPYmplY3QoZWxlbWVudCkuZmxvd0VsZW1lbnRzIHx8IFtdO1xuICAgICAgICAgIHZhciBzdGFydEV2ZW50cyA9IGZsb3dFbGVtZW50cy5maWx0ZXIoZSA9PiBpcyQxKGUsICdicG1uOlN0YXJ0RXZlbnQnKSk7XG5cbiAgICAgICAgICBpZiAoc3RhcnRFdmVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZW5kZXJFdmVudFN1YlByb2Nlc3NJY29uKHN0YXJ0RXZlbnRzWzBdLCBwYXJlbnRHZngsIGF0dHJzLCBlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVuZGVyRW1iZWRkZWRMYWJlbChwYXJlbnRHZngsIGVsZW1lbnQsIGV4cGFuZGVkID8gJ2NlbnRlci10b3AnIDogJ2NlbnRlci1taWRkbGUnLCBhdHRycyk7XG5cbiAgICAgIGlmIChleHBhbmRlZCkge1xuICAgICAgICByZW5kZXJUYXNrTWFya2VycyhwYXJlbnRHZngsIGVsZW1lbnQsIHVuZGVmaW5lZCwgYXR0cnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyVGFza01hcmtlcnMocGFyZW50R2Z4LCBlbGVtZW50LCBbICdTdWJQcm9jZXNzTWFya2VyJyBdLCBhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY3Rpdml0eTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJFdmVudFN1YlByb2Nlc3NJY29uKHN0YXJ0RXZlbnQsIHBhcmVudEdmeCwgYXR0cnMsIHByb3h5RWxlbWVudCkge1xuICAgICAgdmFyIGljb25TaXplID0gMjI7XG5cbiAgICAgIC8vIG1hdGNoIHRoZSBjb2xvcnMgb2YgdGhlIGVuY2xvc2luZyBzdWJwcm9jZXNzXG4gICAgICB2YXIgcHJveHlBdHRycyA9IHtcbiAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKHByb3h5RWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciwgYXR0cnMuZmlsbCksXG4gICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IocHJveHlFbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgIHdpZHRoOiBpY29uU2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBpY29uU2l6ZVxuICAgICAgfTtcblxuICAgICAgdmFyIGludGVycnVwdGluZyA9IGdldEJ1c2luZXNzT2JqZWN0KHN0YXJ0RXZlbnQpLmlzSW50ZXJydXB0aW5nO1xuICAgICAgdmFyIHN0cm9rZURhc2hhcnJheSA9IGludGVycnVwdGluZyA/IDAgOiAzO1xuXG4gICAgICAvLyBiZXR0ZXIgdmlzaWJpbGl0eSBmb3Igbm9uLWludGVycnVwdGluZyBldmVudHNcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IGludGVycnVwdGluZyA/IDEgOiAxLjI7XG5cbiAgICAgIC8vIG1ha2UgdGhlIGljb24gbG9vayBsYXJnZXIgYnkgZHJhd2luZyBhIHNtYWxsZXIgY2lyY2xlXG4gICAgICB2YXIgY2lyY2xlU2l6ZSA9IDIwO1xuICAgICAgdmFyIHNoaWZ0ID0gKGljb25TaXplIC0gY2lyY2xlU2l6ZSkgLyAyO1xuICAgICAgdmFyIHRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIHNoaWZ0ICsgJywnICsgc2hpZnQgKyAnKSc7XG5cbiAgICAgIGRyYXdDaXJjbGUocGFyZW50R2Z4LCBjaXJjbGVTaXplLCBjaXJjbGVTaXplLCB7XG4gICAgICAgIGZpbGw6IHByb3h5QXR0cnMuZmlsbCxcbiAgICAgICAgc3Ryb2tlOiBwcm94eUF0dHJzLnN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIHN0cm9rZURhc2hhcnJheSxcbiAgICAgICAgdHJhbnNmb3JtXG4gICAgICB9KTtcblxuICAgICAgcmVuZGVyRXZlbnRJY29uKHN0YXJ0RXZlbnQsIHBhcmVudEdmeCwgcHJveHlBdHRycywgcHJveHlFbGVtZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJUYXNrKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMgPSB7fSkge1xuICAgICAgdmFyIGFjdGl2aXR5ID0gcmVuZGVyQWN0aXZpdHkocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyk7XG5cbiAgICAgIHJlbmRlckVtYmVkZGVkTGFiZWwocGFyZW50R2Z4LCBlbGVtZW50LCAnY2VudGVyLW1pZGRsZScsIGF0dHJzKTtcblxuICAgICAgcmVuZGVyVGFza01hcmtlcnMocGFyZW50R2Z4LCBlbGVtZW50LCB1bmRlZmluZWQsIGF0dHJzKTtcblxuICAgICAgcmV0dXJuIGFjdGl2aXR5O1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnMgPSB7XG4gICAgICAnYnBtbjpBZEhvY1N1YlByb2Nlc3MnOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzID0ge30pIHtcbiAgICAgICAgaWYgKGlzRXhwYW5kZWQoZWxlbWVudCkpIHtcbiAgICAgICAgICBhdHRycyA9IHBpY2tBdHRycyhhdHRycywgW1xuICAgICAgICAgICAgJ2ZpbGwnLFxuICAgICAgICAgICAgJ3N0cm9rZScsXG4gICAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICAgJ2hlaWdodCdcbiAgICAgICAgICBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRycyA9IHBpY2tBdHRycyhhdHRycywgW1xuICAgICAgICAgICAgJ2ZpbGwnLFxuICAgICAgICAgICAgJ3N0cm9rZSdcbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW5kZXJTdWJQcm9jZXNzKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMpO1xuICAgICAgfSxcbiAgICAgICdicG1uOkFzc29jaWF0aW9uJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICAgIGF0dHJzID0gcGlja0F0dHJzKGF0dHJzLCBbXG4gICAgICAgICAgJ2ZpbGwnLFxuICAgICAgICAgICdzdHJva2UnXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHJldHVybiByZW5kZXJBc3NvY2lhdGlvbihwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzKTtcbiAgICAgIH0sXG4gICAgICAnYnBtbjpCb3VuZGFyeUV2ZW50JzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICAgIHZhciB7IHJlbmRlckljb24gPSB0cnVlIH0gPSBhdHRycztcblxuICAgICAgICBhdHRycyA9IHBpY2tBdHRycyhhdHRycywgW1xuICAgICAgICAgICdmaWxsJyxcbiAgICAgICAgICAnc3Ryb2tlJ1xuICAgICAgICBdKTtcblxuICAgICAgICB2YXIgc2VtYW50aWMgPSBnZXRCdXNpbmVzc09iamVjdChlbGVtZW50KSxcbiAgICAgICAgICAgIGNhbmNlbEFjdGl2aXR5ID0gc2VtYW50aWMuZ2V0KCdjYW5jZWxBY3Rpdml0eScpO1xuXG4gICAgICAgIGF0dHJzID0ge1xuICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLjUsXG4gICAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpLFxuICAgICAgICAgIGZpbGxPcGFjaXR5OiBGVUxMX09QQUNJVFksXG4gICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWNhbmNlbEFjdGl2aXR5KSB7XG4gICAgICAgICAgYXR0cnMuc3Ryb2tlRGFzaGFycmF5ID0gJzYnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV2ZW50ID0gcmVuZGVyRXZlbnQocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyk7XG5cbiAgICAgICAgZHJhd0NpcmNsZShwYXJlbnRHZngsIGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0LCBJTk5FUl9PVVRFUl9ESVNULCB7XG4gICAgICAgICAgLi4uYXR0cnMsXG4gICAgICAgICAgZmlsbDogJ25vbmUnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZW5kZXJJY29uKSB7XG4gICAgICAgICAgcmVuZGVyRXZlbnRJY29uKGVsZW1lbnQsIHBhcmVudEdmeCwgYXR0cnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfSxcbiAgICAgICdicG1uOkJ1c2luZXNzUnVsZVRhc2snOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzID0ge30pIHtcbiAgICAgICAgYXR0cnMgPSBwaWNrQXR0cnMoYXR0cnMsIFtcbiAgICAgICAgICAnZmlsbCcsXG4gICAgICAgICAgJ3N0cm9rZSdcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdmFyIHRhc2sgPSByZW5kZXJUYXNrKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMpO1xuXG4gICAgICAgIHZhciBoZWFkZXJEYXRhID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdUQVNLX1RZUEVfQlVTSU5FU1NfUlVMRV9NQUlOJywge1xuICAgICAgICAgIGFic3Bvczoge1xuICAgICAgICAgICAgeDogOCxcbiAgICAgICAgICAgIHk6IDhcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBidXNpbmVzc1BhdGggPSBkcmF3UGF0aChwYXJlbnRHZngsIGhlYWRlckRhdGEpO1xuXG4gICAgICAgIGF0dHIkMShidXNpbmVzc1BhdGgsIHtcbiAgICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciwgYXR0cnMuZmlsbCksXG4gICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGhlYWRlclBhdGhEYXRhID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdUQVNLX1RZUEVfQlVTSU5FU1NfUlVMRV9IRUFERVInLCB7XG4gICAgICAgICAgYWJzcG9zOiB7XG4gICAgICAgICAgICB4OiA4LFxuICAgICAgICAgICAgeTogOFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGJ1c2luZXNzSGVhZGVyUGF0aCA9IGRyYXdQYXRoKHBhcmVudEdmeCwgaGVhZGVyUGF0aERhdGEpO1xuXG4gICAgICAgIGF0dHIkMShidXNpbmVzc0hlYWRlclBhdGgsIHtcbiAgICAgICAgICBmaWxsOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICB9LFxuICAgICAgJ2JwbW46Q2FsbEFjdGl2aXR5JzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICAgIGF0dHJzID0gcGlja0F0dHJzKGF0dHJzLCBbXG4gICAgICAgICAgJ2ZpbGwnLFxuICAgICAgICAgICdzdHJva2UnXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHJldHVybiByZW5kZXJTdWJQcm9jZXNzKHBhcmVudEdmeCwgZWxlbWVudCwge1xuICAgICAgICAgIHN0cm9rZVdpZHRoOiA1LFxuICAgICAgICAgIC4uLmF0dHJzXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgICdicG1uOkNvbXBsZXhHYXRld2F5JzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICAgIGF0dHJzID0gcGlja0F0dHJzKGF0dHJzLCBbXG4gICAgICAgICAgJ2ZpbGwnLFxuICAgICAgICAgICdzdHJva2UnXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHZhciBnYXRld2F5ID0gcmVuZGVyR2F0ZXdheShwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzKTtcblxuICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ0dBVEVXQVlfQ09NUExFWCcsIHtcbiAgICAgICAgICB4U2NhbGVGYWN0b3I6IDAuNSxcbiAgICAgICAgICB5U2NhbGVGYWN0b3I6MC41LFxuICAgICAgICAgIGNvbnRhaW5lcldpZHRoOiBlbGVtZW50LndpZHRoLFxuICAgICAgICAgIGNvbnRhaW5lckhlaWdodDogZWxlbWVudC5oZWlnaHQsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIG14OiAwLjQ2LFxuICAgICAgICAgICAgbXk6IDAuMjZcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRyYXdQYXRoKHBhcmVudEdmeCwgcGF0aERhdGEsIHtcbiAgICAgICAgICBmaWxsOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGdhdGV3YXk7XG4gICAgICB9LFxuICAgICAgJ2JwbW46RGF0YUlucHV0JzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICAgIGF0dHJzID0gcGlja0F0dHJzKGF0dHJzLCBbXG4gICAgICAgICAgJ2ZpbGwnLFxuICAgICAgICAgICdzdHJva2UnXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHZhciBhcnJvd1BhdGhEYXRhID0gcGF0aE1hcC5nZXRSYXdQYXRoKCdEQVRBX0FSUk9XJyk7XG5cbiAgICAgICAgdmFyIGRhdGFPYmplY3QgPSByZW5kZXJEYXRhT2JqZWN0KHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMpO1xuXG4gICAgICAgIGRyYXdQYXRoKHBhcmVudEdmeCwgYXJyb3dQYXRoRGF0YSwge1xuICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKSxcbiAgICAgICAgICBzdHJva2VXaWR0aDogMVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGF0YU9iamVjdDtcbiAgICAgIH0sXG4gICAgICAnYnBtbjpEYXRhSW5wdXRBc3NvY2lhdGlvbic6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMgPSB7fSkge1xuICAgICAgICBhdHRycyA9IHBpY2tBdHRycyhhdHRycywgW1xuICAgICAgICAgICdmaWxsJyxcbiAgICAgICAgICAnc3Ryb2tlJ1xuICAgICAgICBdKTtcblxuICAgICAgICByZXR1cm4gcmVuZGVyQXNzb2NpYXRpb24ocGFyZW50R2Z4LCBlbGVtZW50LCB7XG4gICAgICAgICAgLi4uYXR0cnMsXG4gICAgICAgICAgbWFya2VyRW5kOiBtYXJrZXIocGFyZW50R2Z4LCAnYXNzb2NpYXRpb24tZW5kJywgZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpLCBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSkpXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgICdicG1uOkRhdGFPYmplY3QnOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzID0ge30pIHtcbiAgICAgICAgYXR0cnMgPSBwaWNrQXR0cnMoYXR0cnMsIFtcbiAgICAgICAgICAnZmlsbCcsXG4gICAgICAgICAgJ3N0cm9rZSdcbiAgICAgICAgXSk7XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlckRhdGFPYmplY3QocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyk7XG4gICAgICB9LFxuICAgICAgJ2JwbW46RGF0YU9iamVjdFJlZmVyZW5jZSc6IGFzKCdicG1uOkRhdGFPYmplY3QnKSxcbiAgICAgICdicG1uOkRhdGFPdXRwdXQnOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzID0ge30pIHtcbiAgICAgICAgYXR0cnMgPSBwaWNrQXR0cnMoYXR0cnMsIFtcbiAgICAgICAgICAnZmlsbCcsXG4gICAgICAgICAgJ3N0cm9rZSdcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdmFyIGFycm93UGF0aERhdGEgPSBwYXRoTWFwLmdldFJhd1BhdGgoJ0RBVEFfQVJST1cnKTtcblxuICAgICAgICB2YXIgZGF0YU9iamVjdCA9IHJlbmRlckRhdGFPYmplY3QocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyk7XG5cbiAgICAgICAgZHJhd1BhdGgocGFyZW50R2Z4LCBhcnJvd1BhdGhEYXRhLCB7XG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpLFxuICAgICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkYXRhT2JqZWN0O1xuICAgICAgfSxcbiAgICAgICdicG1uOkRhdGFPdXRwdXRBc3NvY2lhdGlvbic6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMgPSB7fSkge1xuICAgICAgICBhdHRycyA9IHBpY2tBdHRycyhhdHRycywgW1xuICAgICAgICAgICdmaWxsJyxcbiAgICAgICAgICAnc3Ryb2tlJ1xuICAgICAgICBdKTtcblxuICAgICAgICByZXR1cm4gcmVuZGVyQXNzb2NpYXRpb24ocGFyZW50R2Z4LCBlbGVtZW50LCB7XG4gICAgICAgICAgLi4uYXR0cnMsXG4gICAgICAgICAgbWFya2VyRW5kOiBtYXJrZXIocGFyZW50R2Z4LCAnYXNzb2NpYXRpb24tZW5kJywgZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpLCBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSkpXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgICdicG1uOkRhdGFTdG9yZVJlZmVyZW5jZSc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMgPSB7fSkge1xuICAgICAgICBhdHRycyA9IHBpY2tBdHRycyhhdHRycywgW1xuICAgICAgICAgICdmaWxsJyxcbiAgICAgICAgICAnc3Ryb2tlJ1xuICAgICAgICBdKTtcblxuICAgICAgICB2YXIgZGF0YVN0b3JlUGF0aCA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnREFUQV9TVE9SRScsIHtcbiAgICAgICAgICB4U2NhbGVGYWN0b3I6IDEsXG4gICAgICAgICAgeVNjYWxlRmFjdG9yOiAxLFxuICAgICAgICAgIGNvbnRhaW5lcldpZHRoOiBlbGVtZW50LndpZHRoLFxuICAgICAgICAgIGNvbnRhaW5lckhlaWdodDogZWxlbWVudC5oZWlnaHQsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIG14OiAwLFxuICAgICAgICAgICAgbXk6IDAuMTMzXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZHJhd1BhdGgocGFyZW50R2Z4LCBkYXRhU3RvcmVQYXRoLCB7XG4gICAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpLFxuICAgICAgICAgIGZpbGxPcGFjaXR5OiBERUZBVUxUX09QQUNJVFksXG4gICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDJcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgJ2JwbW46RW5kRXZlbnQnOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzID0ge30pIHtcbiAgICAgICAgdmFyIHsgcmVuZGVySWNvbiA9IHRydWUgfSA9IGF0dHJzO1xuXG4gICAgICAgIGF0dHJzID0gcGlja0F0dHJzKGF0dHJzLCBbXG4gICAgICAgICAgJ2ZpbGwnLFxuICAgICAgICAgICdzdHJva2UnXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHZhciBldmVudCA9IHJlbmRlckV2ZW50KHBhcmVudEdmeCwgZWxlbWVudCwge1xuICAgICAgICAgIC4uLmF0dHJzLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiA0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZW5kZXJJY29uKSB7XG4gICAgICAgICAgcmVuZGVyRXZlbnRJY29uKGVsZW1lbnQsIHBhcmVudEdmeCwgYXR0cnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfSxcbiAgICAgICdicG1uOkV2ZW50QmFzZWRHYXRld2F5JzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICAgIGF0dHJzID0gcGlja0F0dHJzKGF0dHJzLCBbXG4gICAgICAgICAgJ2ZpbGwnLFxuICAgICAgICAgICdzdHJva2UnXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHZhciBzZW1hbnRpYyA9IGdldEJ1c2luZXNzT2JqZWN0KGVsZW1lbnQpO1xuXG4gICAgICAgIHZhciBkaWFtb25kID0gcmVuZGVyR2F0ZXdheShwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzKTtcblxuICAgICAgICBkcmF3Q2lyY2xlKHBhcmVudEdmeCwgZWxlbWVudC53aWR0aCwgZWxlbWVudC5oZWlnaHQsIGVsZW1lbnQuaGVpZ2h0ICogMC4yMCwge1xuICAgICAgICAgIGZpbGw6IGdldEZpbGxDb2xvcihlbGVtZW50LCAnbm9uZScsIGF0dHJzLmZpbGwpLFxuICAgICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAxXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB0eXBlID0gc2VtYW50aWMuZ2V0KCdldmVudEdhdGV3YXlUeXBlJyksXG4gICAgICAgICAgICBpbnN0YW50aWF0ZSA9ICEhc2VtYW50aWMuZ2V0KCdpbnN0YW50aWF0ZScpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdFdmVudCgpIHtcblxuICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnR0FURVdBWV9FVkVOVF9CQVNFRCcsIHtcbiAgICAgICAgICAgIHhTY2FsZUZhY3RvcjogMC4xOCxcbiAgICAgICAgICAgIHlTY2FsZUZhY3RvcjogMC4xOCxcbiAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoOiBlbGVtZW50LndpZHRoLFxuICAgICAgICAgICAgY29udGFpbmVySGVpZ2h0OiBlbGVtZW50LmhlaWdodCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgIG14OiAwLjM2LFxuICAgICAgICAgICAgICBteTogMC40NFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YSwge1xuICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdQYXJhbGxlbCcpIHtcbiAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ0dBVEVXQVlfUEFSQUxMRUwnLCB7XG4gICAgICAgICAgICB4U2NhbGVGYWN0b3I6IDAuNCxcbiAgICAgICAgICAgIHlTY2FsZUZhY3RvcjogMC40LFxuICAgICAgICAgICAgY29udGFpbmVyV2lkdGg6IGVsZW1lbnQud2lkdGgsXG4gICAgICAgICAgICBjb250YWluZXJIZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0LFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgbXg6IDAuNDc0LFxuICAgICAgICAgICAgICBteTogMC4yOTZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGRyYXdQYXRoKHBhcmVudEdmeCwgcGF0aERhdGEsIHtcbiAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnRXhjbHVzaXZlJykge1xuICAgICAgICAgIGlmICghaW5zdGFudGlhdGUpIHtcbiAgICAgICAgICAgIGRyYXdDaXJjbGUocGFyZW50R2Z4LCBlbGVtZW50LndpZHRoLCBlbGVtZW50LmhlaWdodCwgZWxlbWVudC5oZWlnaHQgKiAwLjI2LCB7XG4gICAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkcmF3RXZlbnQoKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGRpYW1vbmQ7XG4gICAgICB9LFxuICAgICAgJ2JwbW46RXhjbHVzaXZlR2F0ZXdheSc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMgPSB7fSkge1xuICAgICAgICBhdHRycyA9IHBpY2tBdHRycyhhdHRycywgW1xuICAgICAgICAgICdmaWxsJyxcbiAgICAgICAgICAnc3Ryb2tlJ1xuICAgICAgICBdKTtcblxuICAgICAgICB2YXIgZ2F0ZXdheSA9IHJlbmRlckdhdGV3YXkocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyk7XG5cbiAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdHQVRFV0FZX0VYQ0xVU0lWRScsIHtcbiAgICAgICAgICB4U2NhbGVGYWN0b3I6IDAuNCxcbiAgICAgICAgICB5U2NhbGVGYWN0b3I6IDAuNCxcbiAgICAgICAgICBjb250YWluZXJXaWR0aDogZWxlbWVudC53aWR0aCxcbiAgICAgICAgICBjb250YWluZXJIZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0LFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICBteDogMC4zMixcbiAgICAgICAgICAgIG15OiAwLjNcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBkaSA9IGdldERpKGVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChkaS5nZXQoJ2lzTWFya2VyVmlzaWJsZScpKSB7XG4gICAgICAgICAgZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YSwge1xuICAgICAgICAgICAgZmlsbDogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpLFxuICAgICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdhdGV3YXk7XG4gICAgICB9LFxuICAgICAgJ2JwbW46R2F0ZXdheSc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMgPSB7fSkge1xuICAgICAgICBhdHRycyA9IHBpY2tBdHRycyhhdHRycywgW1xuICAgICAgICAgICdmaWxsJyxcbiAgICAgICAgICAnc3Ryb2tlJ1xuICAgICAgICBdKTtcblxuICAgICAgICByZXR1cm4gcmVuZGVyR2F0ZXdheShwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzKTtcbiAgICAgIH0sXG4gICAgICAnYnBtbjpHcm91cCc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMgPSB7fSkge1xuICAgICAgICBhdHRycyA9IHBpY2tBdHRycyhhdHRycywgW1xuICAgICAgICAgICdmaWxsJyxcbiAgICAgICAgICAnc3Ryb2tlJyxcbiAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICdoZWlnaHQnXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHJldHVybiBkcmF3UmVjdChwYXJlbnRHZngsIGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0LCBUQVNLX0JPUkRFUl9SQURJVVMsIHtcbiAgICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKSxcbiAgICAgICAgICBzdHJva2VXaWR0aDogMS41LFxuICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogJzEwLCA2LCAwLCA2JyxcbiAgICAgICAgICBmaWxsOiAnbm9uZScsXG4gICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICAgIHdpZHRoOiBnZXRXaWR0aChlbGVtZW50LCBhdHRycyksXG4gICAgICAgICAgaGVpZ2h0OiBnZXRIZWlnaHQoZWxlbWVudCwgYXR0cnMpXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgICdicG1uOkluY2x1c2l2ZUdhdGV3YXknOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzID0ge30pIHtcbiAgICAgICAgYXR0cnMgPSBwaWNrQXR0cnMoYXR0cnMsIFtcbiAgICAgICAgICAnZmlsbCcsXG4gICAgICAgICAgJ3N0cm9rZSdcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdmFyIGdhdGV3YXkgPSByZW5kZXJHYXRld2F5KHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMpO1xuXG4gICAgICAgIGRyYXdDaXJjbGUocGFyZW50R2Z4LCBlbGVtZW50LndpZHRoLCBlbGVtZW50LmhlaWdodCwgZWxlbWVudC5oZWlnaHQgKiAwLjI0LCB7XG4gICAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpLFxuICAgICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAyLjVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGdhdGV3YXk7XG4gICAgICB9LFxuICAgICAgJ2JwbW46SW50ZXJtZWRpYXRlRXZlbnQnOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzID0ge30pIHtcbiAgICAgICAgdmFyIHsgcmVuZGVySWNvbiA9IHRydWUgfSA9IGF0dHJzO1xuXG4gICAgICAgIGF0dHJzID0gcGlja0F0dHJzKGF0dHJzLCBbXG4gICAgICAgICAgJ2ZpbGwnLFxuICAgICAgICAgICdzdHJva2UnXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHZhciBvdXRlciA9IHJlbmRlckV2ZW50KHBhcmVudEdmeCwgZWxlbWVudCwge1xuICAgICAgICAgIC4uLmF0dHJzLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLjVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZHJhd0NpcmNsZShwYXJlbnRHZngsIGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0LCBJTk5FUl9PVVRFUl9ESVNULCB7XG4gICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLjVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlbmRlckljb24pIHtcbiAgICAgICAgICByZW5kZXJFdmVudEljb24oZWxlbWVudCwgcGFyZW50R2Z4LCBhdHRycyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0ZXI7XG4gICAgICB9LFxuICAgICAgJ2JwbW46SW50ZXJtZWRpYXRlQ2F0Y2hFdmVudCc6IGFzKCdicG1uOkludGVybWVkaWF0ZUV2ZW50JyksXG4gICAgICAnYnBtbjpJbnRlcm1lZGlhdGVUaHJvd0V2ZW50JzogYXMoJ2JwbW46SW50ZXJtZWRpYXRlRXZlbnQnKSxcbiAgICAgICdicG1uOkxhbmUnOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzID0ge30pIHtcbiAgICAgICAgYXR0cnMgPSBwaWNrQXR0cnMoYXR0cnMsIFtcbiAgICAgICAgICAnZmlsbCcsXG4gICAgICAgICAgJ3N0cm9rZScsXG4gICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgICAnaGVpZ2h0J1xuICAgICAgICBdKTtcblxuICAgICAgICByZXR1cm4gcmVuZGVyTGFuZShwYXJlbnRHZngsIGVsZW1lbnQsIHtcbiAgICAgICAgICAuLi5hdHRycyxcbiAgICAgICAgICBmaWxsT3BhY2l0eTogTE9XX09QQUNJVFlcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgJ2JwbW46TWFudWFsVGFzayc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMgPSB7fSkge1xuICAgICAgICBhdHRycyA9IHBpY2tBdHRycyhhdHRycywgW1xuICAgICAgICAgICdmaWxsJyxcbiAgICAgICAgICAnc3Ryb2tlJ1xuICAgICAgICBdKTtcblxuICAgICAgICB2YXIgdGFzayA9IHJlbmRlclRhc2socGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyk7XG5cbiAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdUQVNLX1RZUEVfTUFOVUFMJywge1xuICAgICAgICAgIGFic3Bvczoge1xuICAgICAgICAgICAgeDogMTcsXG4gICAgICAgICAgICB5OiAxNVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YSwge1xuICAgICAgICAgIGZpbGw6IGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0RmlsbENvbG9yLCBhdHRycy5maWxsKSxcbiAgICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKSxcbiAgICAgICAgICBzdHJva2VXaWR0aDogMC41XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0YXNrO1xuICAgICAgfSxcbiAgICAgICdicG1uOk1lc3NhZ2VGbG93JzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICAgIGF0dHJzID0gcGlja0F0dHJzKGF0dHJzLCBbXG4gICAgICAgICAgJ2ZpbGwnLFxuICAgICAgICAgICdzdHJva2UnXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHZhciBzZW1hbnRpYyA9IGdldEJ1c2luZXNzT2JqZWN0KGVsZW1lbnQpLFxuICAgICAgICAgICAgZGkgPSBnZXREaShlbGVtZW50KTtcblxuICAgICAgICB2YXIgZmlsbCA9IGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0RmlsbENvbG9yLCBhdHRycy5maWxsKSxcbiAgICAgICAgICAgIHN0cm9rZSA9IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKTtcblxuICAgICAgICB2YXIgcGF0aCA9IGRyYXdDb25uZWN0aW9uU2VnbWVudHMocGFyZW50R2Z4LCBlbGVtZW50LndheXBvaW50cywge1xuICAgICAgICAgIG1hcmtlckVuZDogbWFya2VyKHBhcmVudEdmeCwgJ21lc3NhZ2VmbG93LWVuZCcsIGZpbGwsIHN0cm9rZSksXG4gICAgICAgICAgbWFya2VyU3RhcnQ6IG1hcmtlcihwYXJlbnRHZngsICdtZXNzYWdlZmxvdy1zdGFydCcsIGZpbGwsIHN0cm9rZSksXG4gICAgICAgICAgc3Ryb2tlLFxuICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogJzEwLCAxMScsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDEuNVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2VtYW50aWMuZ2V0KCdtZXNzYWdlUmVmJykpIHtcbiAgICAgICAgICB2YXIgbWlkUG9pbnQgPSBwYXRoLmdldFBvaW50QXRMZW5ndGgocGF0aC5nZXRUb3RhbExlbmd0aCgpIC8gMik7XG5cbiAgICAgICAgICB2YXIgbWFya2VyUGF0aERhdGEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ01FU1NBR0VfRkxPV19NQVJLRVInLCB7XG4gICAgICAgICAgICBhYnNwb3M6IHtcbiAgICAgICAgICAgICAgeDogbWlkUG9pbnQueCxcbiAgICAgICAgICAgICAgeTogbWlkUG9pbnQueVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIG1lc3NhZ2VBdHRycyA9IHtcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChkaS5nZXQoJ21lc3NhZ2VWaXNpYmxlS2luZCcpID09PSAnaW5pdGlhdGluZycpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VBdHRycy5maWxsID0gZmlsbDtcbiAgICAgICAgICAgIG1lc3NhZ2VBdHRycy5zdHJva2UgPSBzdHJva2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2VBdHRycy5maWxsID0gc3Ryb2tlO1xuICAgICAgICAgICAgbWVzc2FnZUF0dHJzLnN0cm9rZSA9IGZpbGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBkcmF3UGF0aChwYXJlbnRHZngsIG1hcmtlclBhdGhEYXRhLCBtZXNzYWdlQXR0cnMpO1xuXG4gICAgICAgICAgdmFyIG1lc3NhZ2VSZWYgPSBzZW1hbnRpYy5nZXQoJ21lc3NhZ2VSZWYnKSxcbiAgICAgICAgICAgICAgbmFtZSA9IG1lc3NhZ2VSZWYuZ2V0KCduYW1lJyk7XG5cbiAgICAgICAgICB2YXIgbGFiZWwgPSByZW5kZXJMYWJlbChwYXJlbnRHZngsIG5hbWUsIHtcbiAgICAgICAgICAgIGFsaWduOiAnY2VudGVyLXRvcCcsXG4gICAgICAgICAgICBmaXRCb3g6IHRydWUsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBmaWxsOiBzdHJva2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBtZXNzYWdlQm91bmRzID0gbWVzc2FnZS5nZXRCQm94KCksXG4gICAgICAgICAgICAgIGxhYmVsQm91bmRzID0gbGFiZWwuZ2V0QkJveCgpO1xuXG4gICAgICAgICAgdmFyIHRyYW5zbGF0ZVggPSBtaWRQb2ludC54IC0gbGFiZWxCb3VuZHMud2lkdGggLyAyLFxuICAgICAgICAgICAgICB0cmFuc2xhdGVZID0gbWlkUG9pbnQueSArIG1lc3NhZ2VCb3VuZHMuaGVpZ2h0IC8gMiArIEVMRU1FTlRfTEFCRUxfRElTVEFOQ0U7XG5cbiAgICAgICAgICB0cmFuc2Zvcm0obGFiZWwsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9LFxuICAgICAgJ2JwbW46UGFyYWxsZWxHYXRld2F5JzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICAgIGF0dHJzID0gcGlja0F0dHJzKGF0dHJzLCBbXG4gICAgICAgICAgJ2ZpbGwnLFxuICAgICAgICAgICdzdHJva2UnXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHZhciBkaWFtb25kID0gcmVuZGVyR2F0ZXdheShwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzKTtcblxuICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ0dBVEVXQVlfUEFSQUxMRUwnLCB7XG4gICAgICAgICAgeFNjYWxlRmFjdG9yOiAwLjYsXG4gICAgICAgICAgeVNjYWxlRmFjdG9yOiAwLjYsXG4gICAgICAgICAgY29udGFpbmVyV2lkdGg6IGVsZW1lbnQud2lkdGgsXG4gICAgICAgICAgY29udGFpbmVySGVpZ2h0OiBlbGVtZW50LmhlaWdodCxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgbXg6IDAuNDYsXG4gICAgICAgICAgICBteTogMC4yXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhLCB7XG4gICAgICAgICAgZmlsbDogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpLFxuICAgICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAxXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkaWFtb25kO1xuICAgICAgfSxcbiAgICAgICdicG1uOlBhcnRpY2lwYW50JzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICAgIGF0dHJzID0gcGlja0F0dHJzKGF0dHJzLCBbXG4gICAgICAgICAgJ2ZpbGwnLFxuICAgICAgICAgICdzdHJva2UnLFxuICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgJ2hlaWdodCdcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdmFyIHBhcnRpY2lwYW50ID0gcmVuZGVyTGFuZShwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzKTtcblxuICAgICAgICB2YXIgZXhwYW5kZWRQYXJ0aWNpcGFudCA9IGlzRXhwYW5kZWQoZWxlbWVudCk7XG4gICAgICAgIHZhciBob3Jpem9udGFsUGFydGljaXBhbnQgPSBpc0hvcml6b250YWwoZWxlbWVudCk7XG5cbiAgICAgICAgdmFyIHNlbWFudGljID0gZ2V0QnVzaW5lc3NPYmplY3QoZWxlbWVudCksXG4gICAgICAgICAgICBuYW1lID0gc2VtYW50aWMuZ2V0KCduYW1lJyk7XG5cbiAgICAgICAgaWYgKGV4cGFuZGVkUGFydGljaXBhbnQpIHtcbiAgICAgICAgICB2YXIgd2F5cG9pbnRzID0gaG9yaXpvbnRhbFBhcnRpY2lwYW50ID8gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiAzMCxcbiAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogMzAsXG4gICAgICAgICAgICAgIHk6IGdldEhlaWdodChlbGVtZW50LCBhdHRycylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdIDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICB5OiAzMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogZ2V0V2lkdGgoZWxlbWVudCwgYXR0cnMpLFxuICAgICAgICAgICAgICB5OiAzMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIF07XG5cbiAgICAgICAgICBkcmF3TGluZShwYXJlbnRHZngsIHdheXBvaW50cywge1xuICAgICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogUEFSVElDSVBBTlRfU1RST0tFX1dJRFRIXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZW5kZXJMYW5lTGFiZWwocGFyZW50R2Z4LCBuYW1lLCBlbGVtZW50LCBhdHRycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGJvdW5kcyA9IGdldEJvdW5kcyhlbGVtZW50LCBhdHRycyk7XG5cbiAgICAgICAgICBpZiAoIWhvcml6b250YWxQYXJ0aWNpcGFudCkge1xuICAgICAgICAgICAgYm91bmRzLmhlaWdodCA9IGdldFdpZHRoKGVsZW1lbnQsIGF0dHJzKTtcbiAgICAgICAgICAgIGJvdW5kcy53aWR0aCA9IGdldEhlaWdodChlbGVtZW50LCBhdHRycyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRleHRCb3ggPSByZW5kZXJMYWJlbChwYXJlbnRHZngsIG5hbWUsIHtcbiAgICAgICAgICAgIGJveDogYm91bmRzLFxuICAgICAgICAgICAgYWxpZ246ICdjZW50ZXItbWlkZGxlJyxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIGZpbGw6IGdldExhYmVsQ29sb3IoZWxlbWVudCwgZGVmYXVsdExhYmVsQ29sb3IsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCFob3Jpem9udGFsUGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgIHZhciB0b3AgPSAtMSAqIGdldEhlaWdodChlbGVtZW50LCBhdHRycyk7XG4gICAgICAgICAgICB0cmFuc2Zvcm0odGV4dEJveCwgMCwgLXRvcCwgMjcwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VtYW50aWMuZ2V0KCdwYXJ0aWNpcGFudE11bHRpcGxpY2l0eScpKSB7XG4gICAgICAgICAgcmVuZGVyVGFza01hcmtlcignUGFydGljaXBhbnRNdWx0aXBsaWNpdHlNYXJrZXInLCBwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJ0aWNpcGFudDtcbiAgICAgIH0sXG4gICAgICAnYnBtbjpSZWNlaXZlVGFzaycgOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzID0ge30pIHtcbiAgICAgICAgYXR0cnMgPSBwaWNrQXR0cnMoYXR0cnMsIFtcbiAgICAgICAgICAnZmlsbCcsXG4gICAgICAgICAgJ3N0cm9rZSdcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdmFyIHNlbWFudGljID0gZ2V0QnVzaW5lc3NPYmplY3QoZWxlbWVudCk7XG5cbiAgICAgICAgdmFyIHRhc2sgPSByZW5kZXJUYXNrKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMpO1xuXG4gICAgICAgIHZhciBwYXRoRGF0YTtcblxuICAgICAgICBpZiAoc2VtYW50aWMuZ2V0KCdpbnN0YW50aWF0ZScpKSB7XG4gICAgICAgICAgZHJhd0NpcmNsZShwYXJlbnRHZngsIDI4LCAyOCwgMjAgKiAwLjIyLCB7XG4gICAgICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciwgYXR0cnMuZmlsbCksXG4gICAgICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKSxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBwYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnVEFTS19UWVBFX0lOU1RBTlRJQVRJTkdfU0VORCcsIHtcbiAgICAgICAgICAgIGFic3Bvczoge1xuICAgICAgICAgICAgICB4OiA3Ljc3LFxuICAgICAgICAgICAgICB5OiA5LjUyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aERhdGEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ1RBU0tfVFlQRV9TRU5EJywge1xuICAgICAgICAgICAgeFNjYWxlRmFjdG9yOiAwLjksXG4gICAgICAgICAgICB5U2NhbGVGYWN0b3I6IDAuOSxcbiAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoOiAyMSxcbiAgICAgICAgICAgIGNvbnRhaW5lckhlaWdodDogMTQsXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICBteDogMC4zLFxuICAgICAgICAgICAgICBteTogMC40XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhLCB7XG4gICAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpLFxuICAgICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAxXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0YXNrO1xuICAgICAgfSxcbiAgICAgICdicG1uOlNjcmlwdFRhc2snOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzID0ge30pIHtcbiAgICAgICAgYXR0cnMgPSBwaWNrQXR0cnMoYXR0cnMsIFtcbiAgICAgICAgICAnZmlsbCcsXG4gICAgICAgICAgJ3N0cm9rZSdcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdmFyIHRhc2sgPSByZW5kZXJUYXNrKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMpO1xuXG4gICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnVEFTS19UWVBFX1NDUklQVCcsIHtcbiAgICAgICAgICBhYnNwb3M6IHtcbiAgICAgICAgICAgIHg6IDE1LFxuICAgICAgICAgICAgeTogMjBcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRyYXdQYXRoKHBhcmVudEdmeCwgcGF0aERhdGEsIHtcbiAgICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciwgYXR0cnMuZmlsbCksXG4gICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSksXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICB9LFxuICAgICAgJ2JwbW46U2VuZFRhc2snOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzID0ge30pIHtcbiAgICAgICAgYXR0cnMgPSBwaWNrQXR0cnMoYXR0cnMsIFtcbiAgICAgICAgICAnZmlsbCcsXG4gICAgICAgICAgJ3N0cm9rZSdcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdmFyIHRhc2sgPSByZW5kZXJUYXNrKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMpO1xuXG4gICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGhNYXAuZ2V0U2NhbGVkUGF0aCgnVEFTS19UWVBFX1NFTkQnLCB7XG4gICAgICAgICAgeFNjYWxlRmFjdG9yOiAxLFxuICAgICAgICAgIHlTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgICBjb250YWluZXJXaWR0aDogMjEsXG4gICAgICAgICAgY29udGFpbmVySGVpZ2h0OiAxNCxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgbXg6IDAuMjg1LFxuICAgICAgICAgICAgbXk6IDAuMzU3XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBkcmF3UGF0aChwYXJlbnRHZngsIHBhdGhEYXRhLCB7XG4gICAgICAgICAgZmlsbDogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpLFxuICAgICAgICAgIHN0cm9rZTogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAxXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0YXNrO1xuICAgICAgfSxcbiAgICAgICdicG1uOlNlcXVlbmNlRmxvdyc6IGZ1bmN0aW9uKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMgPSB7fSkge1xuICAgICAgICBhdHRycyA9IHBpY2tBdHRycyhhdHRycywgW1xuICAgICAgICAgICdmaWxsJyxcbiAgICAgICAgICAnc3Ryb2tlJ1xuICAgICAgICBdKTtcblxuICAgICAgICB2YXIgZmlsbCA9IGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0RmlsbENvbG9yLCBhdHRycy5maWxsKSxcbiAgICAgICAgICAgIHN0cm9rZSA9IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKTtcblxuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IGRyYXdDb25uZWN0aW9uU2VnbWVudHMocGFyZW50R2Z4LCBlbGVtZW50LndheXBvaW50cywge1xuICAgICAgICAgIG1hcmtlckVuZDogbWFya2VyKHBhcmVudEdmeCwgJ3NlcXVlbmNlZmxvdy1lbmQnLCBmaWxsLCBzdHJva2UpLFxuICAgICAgICAgIHN0cm9rZVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc2VtYW50aWMgPSBnZXRCdXNpbmVzc09iamVjdChlbGVtZW50KTtcblxuICAgICAgICB2YXIgeyBzb3VyY2UgfSA9IGVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgIHZhciBzb3VyY2VTZW1hbnRpYyA9IGdldEJ1c2luZXNzT2JqZWN0KHNvdXJjZSk7XG5cbiAgICAgICAgICAvLyBjb25kaXRpb25hbCBmbG93IG1hcmtlclxuICAgICAgICAgIGlmIChzZW1hbnRpYy5nZXQoJ2NvbmRpdGlvbkV4cHJlc3Npb24nKSAmJiBpcyQxKHNvdXJjZVNlbWFudGljLCAnYnBtbjpBY3Rpdml0eScpKSB7XG4gICAgICAgICAgICBhdHRyJDEoY29ubmVjdGlvbiwge1xuICAgICAgICAgICAgICBtYXJrZXJTdGFydDogbWFya2VyKHBhcmVudEdmeCwgJ2NvbmRpdGlvbmFsLWZsb3ctbWFya2VyJywgZmlsbCwgc3Ryb2tlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZGVmYXVsdCBtYXJrZXJcbiAgICAgICAgICBpZiAoc291cmNlU2VtYW50aWMuZ2V0KCdkZWZhdWx0JykgJiYgKGlzJDEoc291cmNlU2VtYW50aWMsICdicG1uOkdhdGV3YXknKSB8fCBpcyQxKHNvdXJjZVNlbWFudGljLCAnYnBtbjpBY3Rpdml0eScpKSAmJlxuICAgICAgICAgICAgICBzb3VyY2VTZW1hbnRpYy5nZXQoJ2RlZmF1bHQnKSA9PT0gc2VtYW50aWMpIHtcbiAgICAgICAgICAgIGF0dHIkMShjb25uZWN0aW9uLCB7XG4gICAgICAgICAgICAgIG1hcmtlclN0YXJ0OiBtYXJrZXIocGFyZW50R2Z4LCAnY29uZGl0aW9uYWwtZGVmYXVsdC1mbG93LW1hcmtlcicsIGZpbGwsIHN0cm9rZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgICAgfSxcbiAgICAgICdicG1uOlNlcnZpY2VUYXNrJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICAgIGF0dHJzID0gcGlja0F0dHJzKGF0dHJzLCBbXG4gICAgICAgICAgJ2ZpbGwnLFxuICAgICAgICAgICdzdHJva2UnXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHZhciB0YXNrID0gcmVuZGVyVGFzayhwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzKTtcblxuICAgICAgICBkcmF3Q2lyY2xlKHBhcmVudEdmeCwgMTAsIDEwLCB7XG4gICAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpLFxuICAgICAgICAgIHN0cm9rZTogJ25vbmUnLFxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSg2LCA2KSdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHBhdGhEYXRhU2VydmljZTEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ1RBU0tfVFlQRV9TRVJWSUNFJywge1xuICAgICAgICAgIGFic3Bvczoge1xuICAgICAgICAgICAgeDogMTIsXG4gICAgICAgICAgICB5OiAxOFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YVNlcnZpY2UxLCB7XG4gICAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpLFxuICAgICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAxXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRyYXdDaXJjbGUocGFyZW50R2Z4LCAxMCwgMTAsIHtcbiAgICAgICAgICBmaWxsOiBnZXRGaWxsQ29sb3IoZWxlbWVudCwgZGVmYXVsdEZpbGxDb2xvciwgYXR0cnMuZmlsbCksXG4gICAgICAgICAgc3Ryb2tlOiAnbm9uZScsXG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDExLCAxMCknXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBwYXRoRGF0YVNlcnZpY2UyID0gcGF0aE1hcC5nZXRTY2FsZWRQYXRoKCdUQVNLX1RZUEVfU0VSVklDRScsIHtcbiAgICAgICAgICBhYnNwb3M6IHtcbiAgICAgICAgICAgIHg6IDE3LFxuICAgICAgICAgICAgeTogMjJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRyYXdQYXRoKHBhcmVudEdmeCwgcGF0aERhdGFTZXJ2aWNlMiwge1xuICAgICAgICAgIGZpbGw6IGdldEZpbGxDb2xvcihlbGVtZW50LCBkZWZhdWx0RmlsbENvbG9yLCBhdHRycy5maWxsKSxcbiAgICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKSxcbiAgICAgICAgICBzdHJva2VXaWR0aDogMVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGFzaztcbiAgICAgIH0sXG4gICAgICAnYnBtbjpTdGFydEV2ZW50JzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICAgIHZhciB7IHJlbmRlckljb24gPSB0cnVlIH0gPSBhdHRycztcblxuICAgICAgICBhdHRycyA9IHBpY2tBdHRycyhhdHRycywgW1xuICAgICAgICAgICdmaWxsJyxcbiAgICAgICAgICAnc3Ryb2tlJ1xuICAgICAgICBdKTtcblxuICAgICAgICB2YXIgc2VtYW50aWMgPSBnZXRCdXNpbmVzc09iamVjdChlbGVtZW50KTtcblxuICAgICAgICBpZiAoIXNlbWFudGljLmdldCgnaXNJbnRlcnJ1cHRpbmcnKSkge1xuICAgICAgICAgIGF0dHJzID0ge1xuICAgICAgICAgICAgLi4uYXR0cnMsXG4gICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6ICc2J1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXZlbnQgPSByZW5kZXJFdmVudChwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzKTtcblxuICAgICAgICBpZiAocmVuZGVySWNvbikge1xuICAgICAgICAgIHJlbmRlckV2ZW50SWNvbihlbGVtZW50LCBwYXJlbnRHZngsIGF0dHJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH0sXG4gICAgICAnYnBtbjpTdWJQcm9jZXNzJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICAgIGlmIChpc0V4cGFuZGVkKGVsZW1lbnQpKSB7XG4gICAgICAgICAgYXR0cnMgPSBwaWNrQXR0cnMoYXR0cnMsIFtcbiAgICAgICAgICAgICdmaWxsJyxcbiAgICAgICAgICAgICdzdHJva2UnLFxuICAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgICAgICdoZWlnaHQnXG4gICAgICAgICAgXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXR0cnMgPSBwaWNrQXR0cnMoYXR0cnMsIFtcbiAgICAgICAgICAgICdmaWxsJyxcbiAgICAgICAgICAgICdzdHJva2UnXG4gICAgICAgICAgXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVuZGVyU3ViUHJvY2VzcyhwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzKTtcbiAgICAgIH0sXG4gICAgICAnYnBtbjpUYXNrJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICAgIGF0dHJzID0gcGlja0F0dHJzKGF0dHJzLCBbXG4gICAgICAgICAgJ2ZpbGwnLFxuICAgICAgICAgICdzdHJva2UnXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHJldHVybiByZW5kZXJUYXNrKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMpO1xuICAgICAgfSxcbiAgICAgICdicG1uOlRleHRBbm5vdGF0aW9uJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICAgIGF0dHJzID0gcGlja0F0dHJzKGF0dHJzLCBbXG4gICAgICAgICAgJ2ZpbGwnLFxuICAgICAgICAgICdzdHJva2UnLFxuICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgJ2hlaWdodCdcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdmFyIHtcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHRcbiAgICAgICAgfSA9IGdldEJvdW5kcyhlbGVtZW50LCBhdHRycyk7XG5cbiAgICAgICAgdmFyIHRleHRFbGVtZW50ID0gZHJhd1JlY3QocGFyZW50R2Z4LCB3aWR0aCwgaGVpZ2h0LCAwLCAwLCB7XG4gICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgIHN0cm9rZTogJ25vbmUnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB0ZXh0UGF0aERhdGEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ1RFWFRfQU5OT1RBVElPTicsIHtcbiAgICAgICAgICB4U2NhbGVGYWN0b3I6IDEsXG4gICAgICAgICAgeVNjYWxlRmFjdG9yOiAxLFxuICAgICAgICAgIGNvbnRhaW5lcldpZHRoOiB3aWR0aCxcbiAgICAgICAgICBjb250YWluZXJIZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgbXg6IDAuMCxcbiAgICAgICAgICAgIG15OiAwLjBcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRyYXdQYXRoKHBhcmVudEdmeCwgdGV4dFBhdGhEYXRhLCB7XG4gICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihlbGVtZW50LCBkZWZhdWx0U3Ryb2tlQ29sb3IsIGF0dHJzLnN0cm9rZSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHNlbWFudGljID0gZ2V0QnVzaW5lc3NPYmplY3QoZWxlbWVudCksXG4gICAgICAgICAgICB0ZXh0ID0gc2VtYW50aWMuZ2V0KCd0ZXh0JykgfHwgJyc7XG5cbiAgICAgICAgcmVuZGVyTGFiZWwocGFyZW50R2Z4LCB0ZXh0LCB7XG4gICAgICAgICAgYWxpZ246ICdsZWZ0LXRvcCcsXG4gICAgICAgICAgYm94OiBnZXRCb3VuZHMoZWxlbWVudCwgYXR0cnMpLFxuICAgICAgICAgIHBhZGRpbmc6IDcsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGZpbGw6IGdldExhYmVsQ29sb3IoZWxlbWVudCwgZGVmYXVsdExhYmVsQ29sb3IsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRleHRFbGVtZW50O1xuICAgICAgfSxcbiAgICAgICdicG1uOlRyYW5zYWN0aW9uJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICAgIGlmIChpc0V4cGFuZGVkKGVsZW1lbnQpKSB7XG4gICAgICAgICAgYXR0cnMgPSBwaWNrQXR0cnMoYXR0cnMsIFtcbiAgICAgICAgICAgICdmaWxsJyxcbiAgICAgICAgICAgICdzdHJva2UnLFxuICAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgICAgICdoZWlnaHQnXG4gICAgICAgICAgXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXR0cnMgPSBwaWNrQXR0cnMoYXR0cnMsIFtcbiAgICAgICAgICAgICdmaWxsJyxcbiAgICAgICAgICAgICdzdHJva2UnXG4gICAgICAgICAgXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0ZXIgPSByZW5kZXJTdWJQcm9jZXNzKHBhcmVudEdmeCwgZWxlbWVudCwge1xuICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLjUsXG4gICAgICAgICAgLi4uYXR0cnNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGlubmVyQXR0cnMgPSBzdHlsZXMuc3R5bGUoWyAnbm8tZmlsbCcsICduby1ldmVudHMnIF0sIHtcbiAgICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGVsZW1lbnQsIGRlZmF1bHRTdHJva2VDb2xvciwgYXR0cnMuc3Ryb2tlKSxcbiAgICAgICAgICBzdHJva2VXaWR0aDogMS41XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBleHBhbmRlZCA9IGlzRXhwYW5kZWQoZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKCFleHBhbmRlZCkge1xuICAgICAgICAgIGF0dHJzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBkcmF3UmVjdChcbiAgICAgICAgICBwYXJlbnRHZngsXG4gICAgICAgICAgZ2V0V2lkdGgoZWxlbWVudCwgYXR0cnMpLFxuICAgICAgICAgIGdldEhlaWdodChlbGVtZW50LCBhdHRycyksXG4gICAgICAgICAgVEFTS19CT1JERVJfUkFESVVTIC0gSU5ORVJfT1VURVJfRElTVCxcbiAgICAgICAgICBJTk5FUl9PVVRFUl9ESVNULFxuICAgICAgICAgIGlubmVyQXR0cnNcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gb3V0ZXI7XG4gICAgICB9LFxuICAgICAgJ2JwbW46VXNlclRhc2snOiBmdW5jdGlvbihwYXJlbnRHZngsIGVsZW1lbnQsIGF0dHJzID0ge30pIHtcbiAgICAgICAgYXR0cnMgPSBwaWNrQXR0cnMoYXR0cnMsIFtcbiAgICAgICAgICAnZmlsbCcsXG4gICAgICAgICAgJ3N0cm9rZSdcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdmFyIHRhc2sgPSByZW5kZXJUYXNrKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMpO1xuXG4gICAgICAgIHZhciB4ID0gMTU7XG4gICAgICAgIHZhciB5ID0gMTI7XG5cbiAgICAgICAgdmFyIHBhdGhEYXRhVXNlcjEgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ1RBU0tfVFlQRV9VU0VSXzEnLCB7XG4gICAgICAgICAgYWJzcG9zOiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YVVzZXIxLCB7XG4gICAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpLFxuICAgICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAwLjVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHBhdGhEYXRhVXNlcjIgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ1RBU0tfVFlQRV9VU0VSXzInLCB7XG4gICAgICAgICAgYWJzcG9zOiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YVVzZXIyLCB7XG4gICAgICAgICAgZmlsbDogZ2V0RmlsbENvbG9yKGVsZW1lbnQsIGRlZmF1bHRGaWxsQ29sb3IsIGF0dHJzLmZpbGwpLFxuICAgICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAwLjVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHBhdGhEYXRhVXNlcjMgPSBwYXRoTWFwLmdldFNjYWxlZFBhdGgoJ1RBU0tfVFlQRV9VU0VSXzMnLCB7XG4gICAgICAgICAgYWJzcG9zOiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZHJhd1BhdGgocGFyZW50R2Z4LCBwYXRoRGF0YVVzZXIzLCB7XG4gICAgICAgICAgZmlsbDogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpLFxuICAgICAgICAgIHN0cm9rZTogZ2V0U3Ryb2tlQ29sb3IoZWxlbWVudCwgZGVmYXVsdFN0cm9rZUNvbG9yLCBhdHRycy5zdHJva2UpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAwLjVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICB9LFxuICAgICAgJ2xhYmVsJzogZnVuY3Rpb24ocGFyZW50R2Z4LCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgICAgIHJldHVybiByZW5kZXJFeHRlcm5hbExhYmVsKHBhcmVudEdmeCwgZWxlbWVudCwgYXR0cnMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBleHRlbnNpb24gQVBJLCB1c2UgYXQgeW91ciBvd24gcmlza1xuICAgIHRoaXMuX2RyYXdQYXRoID0gZHJhd1BhdGg7XG5cbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG5cblxuICBlKEJwbW5SZW5kZXJlciwgQmFzZVJlbmRlcmVyKTtcblxuICBCcG1uUmVuZGVyZXIuJGluamVjdCA9IFtcbiAgICAnY29uZmlnLmJwbW5SZW5kZXJlcicsXG4gICAgJ2V2ZW50QnVzJyxcbiAgICAnc3R5bGVzJyxcbiAgICAncGF0aE1hcCcsXG4gICAgJ2NhbnZhcycsXG4gICAgJ3RleHRSZW5kZXJlcidcbiAgXTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIEJwbW5SZW5kZXJlci5wcm90b3R5cGUuY2FuUmVuZGVyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHJldHVybiBpcyQxKGVsZW1lbnQsICdicG1uOkJhc2VFbGVtZW50Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERyYXcgc2hhcGUgaW50byBwYXJlbnRHZnguXG4gICAqXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gcGFyZW50R2Z4XG4gICAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlXG4gICAqIEBwYXJhbSB7QXR0cnN9IFthdHRyc11cbiAgICpcbiAgICogQHJldHVybiB7U1ZHRWxlbWVudH0gbWFpbkdmeFxuICAgKi9cbiAgQnBtblJlbmRlcmVyLnByb3RvdHlwZS5kcmF3U2hhcGUgPSBmdW5jdGlvbihwYXJlbnRHZngsIHNoYXBlLCBhdHRycyA9IHt9KSB7XG4gICAgdmFyIHsgdHlwZSB9ID0gc2hhcGU7XG5cbiAgICB2YXIgaGFuZGxlciA9IHRoaXMuX3JlbmRlcmVyKHR5cGUpO1xuXG4gICAgcmV0dXJuIGhhbmRsZXIocGFyZW50R2Z4LCBzaGFwZSwgYXR0cnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEcmF3IGNvbm5lY3Rpb24gaW50byBwYXJlbnRHZnguXG4gICAqXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gcGFyZW50R2Z4XG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICAgKiBAcGFyYW0ge0F0dHJzfSBbYXR0cnNdXG4gICAqXG4gICAqIEByZXR1cm4ge1NWR0VsZW1lbnR9IG1haW5HZnhcbiAgICovXG4gIEJwbW5SZW5kZXJlci5wcm90b3R5cGUuZHJhd0Nvbm5lY3Rpb24gPSBmdW5jdGlvbihwYXJlbnRHZngsIGNvbm5lY3Rpb24sIGF0dHJzID0ge30pIHtcbiAgICB2YXIgeyB0eXBlIH0gPSBjb25uZWN0aW9uO1xuXG4gICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9yZW5kZXJlcih0eXBlKTtcblxuICAgIHJldHVybiBoYW5kbGVyKHBhcmVudEdmeCwgY29ubmVjdGlvbiwgYXR0cnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgc2hhcGUgcGF0aC5cbiAgICpcbiAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBwYXRoXG4gICAqL1xuICBCcG1uUmVuZGVyZXIucHJvdG90eXBlLmdldFNoYXBlUGF0aCA9IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgaWYgKGlzJDEoc2hhcGUsICdicG1uOkV2ZW50JykpIHtcbiAgICAgIHJldHVybiBnZXRDaXJjbGVQYXRoKHNoYXBlKTtcbiAgICB9XG5cbiAgICBpZiAoaXMkMShzaGFwZSwgJ2JwbW46QWN0aXZpdHknKSkge1xuICAgICAgcmV0dXJuIGdldFJvdW5kUmVjdFBhdGgoc2hhcGUsIFRBU0tfQk9SREVSX1JBRElVUyk7XG4gICAgfVxuXG4gICAgaWYgKGlzJDEoc2hhcGUsICdicG1uOkdhdGV3YXknKSkge1xuICAgICAgcmV0dXJuIGdldERpYW1vbmRQYXRoKHNoYXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0UmVjdFBhdGgoc2hhcGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQaWNrIGF0dHJpYnV0ZXMgaWYgdGhleSBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGtleXNcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIGZ1bmN0aW9uIHBpY2tBdHRycyhhdHRycywga2V5cyA9IFtdKSB7XG4gICAgcmV0dXJuIGtleXMucmVkdWNlKChwaWNrZWRBdHRycywga2V5KSA9PiB7XG4gICAgICBpZiAoYXR0cnNbIGtleSBdKSB7XG4gICAgICAgIHBpY2tlZEF0dHJzWyBrZXkgXSA9IGF0dHJzWyBrZXkgXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBpY2tlZEF0dHJzO1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi91dGlsL1R5cGVzJykuRGltZW5zaW9uc30gRGltZW5zaW9uc1xuICAgKlxuICAgKiBAdHlwZWRlZiB7IHtcbiAgICogICB0b3A6IG51bWJlcjtcbiAgICogICBsZWZ0OiBudW1iZXI7XG4gICAqICAgcmlnaHQ6IG51bWJlcjtcbiAgICogICBib3R0b206IG51bWJlcjtcbiAgICogfSB9IFBhZGRpbmdcbiAgICpcbiAgICogQHR5cGVkZWYgeyBudW1iZXIgfCBQYXJ0aWFsPFBhZGRpbmc+IH0gUGFkZGluZ0NvbmZpZ1xuICAgKlxuICAgKiBAdHlwZWRlZiB7IHtcbiAgICogICBob3Jpem9udGFsOiAnY2VudGVyJyB8ICdsZWZ0JyB8ICdyaWdodCc7XG4gICAqICAgdmVydGljYWw6ICd0b3AnIHwgJ21pZGRsZSc7XG4gICAqIH0gfSBBbGlnbm1lbnRcbiAgICpcbiAgICogIEB0eXBlZGVmIHsgJ2NlbnRlci1taWRkbGUnIHwgJ2NlbnRlci10b3AnIH0gQWxpZ25tZW50Q29uZmlnXG4gICAqXG4gICAqIEB0eXBlZGVmIHsgUGFydGlhbDx7XG4gICAqICAgYWxpZ246IEFsaWdubWVudENvbmZpZztcbiAgICogICBzdHlsZTogUmVjb3JkPHN0cmluZywgbnVtYmVyIHwgc3RyaW5nPjtcbiAgICogICBwYWRkaW5nOiBQYWRkaW5nQ29uZmlnO1xuICAgKiB9PiB9IEJhc2VUZXh0Q29uZmlnXG4gICAqXG4gICAqIEB0eXBlZGVmIHsgQmFzZVRleHRDb25maWcgJiBQYXJ0aWFsPHtcbiAgICogICBzaXplOiBEaW1lbnNpb25zO1xuICAgKiB9PiB9IFRleHRDb25maWdcbiAgICpcbiAgICogQHR5cGVkZWYgeyBCYXNlVGV4dENvbmZpZyAmIFBhcnRpYWw8e1xuICAgKiAgIGJveDogRGltZW5zaW9ucztcbiAgICogICBmaXRCb3g6IGJvb2xlYW47XG4gICAqIH0+IH0gVGV4dExheW91dENvbmZpZ1xuICAgKlxuICAgKiAgQHR5cGVkZWYgeyBEaW1lbnNpb25zICYge1xuICAgKiAgdGV4dDogc3RyaW5nO1xuICAgKiB9IH0gTGluZURlc2NyaXB0b3JcbiAgICovXG5cbiAgdmFyIERFRkFVTFRfQk9YX1BBRERJTkcgPSAwO1xuXG4gIHZhciBERUZBVUxUX0xBQkVMX1NJWkUgPSB7XG4gICAgd2lkdGg6IDE1MCxcbiAgICBoZWlnaHQ6IDUwXG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtBbGlnbm1lbnRDb25maWd9IGFsaWduXG4gICAqIEByZXR1cm4ge0FsaWdubWVudH1cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQWxpZ24oYWxpZ24pIHtcblxuICAgIHZhciBwYXJ0cyA9IGFsaWduLnNwbGl0KCctJyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaG9yaXpvbnRhbDogcGFydHNbMF0gfHwgJ2NlbnRlcicsXG4gICAgICB2ZXJ0aWNhbDogcGFydHNbMV0gfHwgJ3RvcCdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UGFkZGluZ0NvbmZpZ30gcGFkZGluZ1xuICAgKlxuICAgKiBAcmV0dXJuIHtQYWRkaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VQYWRkaW5nKHBhZGRpbmcpIHtcblxuICAgIGlmIChpc09iamVjdChwYWRkaW5nKSkge1xuICAgICAgcmV0dXJuIGFzc2lnbiQxKHsgdG9wOiAwLCBsZWZ0OiAwLCByaWdodDogMCwgYm90dG9tOiAwIH0sIHBhZGRpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHBhZGRpbmcsXG4gICAgICAgIGxlZnQ6IHBhZGRpbmcsXG4gICAgICAgIHJpZ2h0OiBwYWRkaW5nLFxuICAgICAgICBib3R0b206IHBhZGRpbmdcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7U1ZHVGV4dEVsZW1lbnR9IGZha2VUZXh0XG4gICAqXG4gICAqIEByZXR1cm4ge2ltcG9ydCgnLi4vdXRpbC9UeXBlcycpLkRpbWVuc2lvbnN9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRUZXh0QkJveCh0ZXh0LCBmYWtlVGV4dCkge1xuXG4gICAgZmFrZVRleHQudGV4dENvbnRlbnQgPSB0ZXh0O1xuXG4gICAgdmFyIHRleHRCQm94O1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBiYm94LFxuICAgICAgICAgIGVtcHR5TGluZSA9IHRleHQgPT09ICcnO1xuXG4gICAgICAvLyBhZGQgZHVtbXkgdGV4dCwgd2hlbiBsaW5lIGlzIGVtcHR5IHRvXG4gICAgICAvLyBkZXRlcm1pbmUgY29ycmVjdCBoZWlnaHRcbiAgICAgIGZha2VUZXh0LnRleHRDb250ZW50ID0gZW1wdHlMaW5lID8gJ2R1bW15JyA6IHRleHQ7XG5cbiAgICAgIHRleHRCQm94ID0gZmFrZVRleHQuZ2V0QkJveCgpO1xuXG4gICAgICAvLyB0YWtlIHRleHQgcmVuZGVyaW5nIHJlbGF0ZWQgaG9yaXpvbnRhbFxuICAgICAgLy8gcGFkZGluZyBpbnRvIGFjY291bnRcbiAgICAgIGJib3ggPSB7XG4gICAgICAgIHdpZHRoOiB0ZXh0QkJveC53aWR0aCArIHRleHRCQm94LnggKiAyLFxuICAgICAgICBoZWlnaHQ6IHRleHRCQm94LmhlaWdodFxuICAgICAgfTtcblxuICAgICAgaWYgKGVtcHR5TGluZSkge1xuXG4gICAgICAgIC8vIGNvcnJlY3Qgd2lkdGhcbiAgICAgICAgYmJveC53aWR0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYm94O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKGUpO1xuXG4gICAgICByZXR1cm4geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogTGF5b3V0IHRoZSBuZXh0IGxpbmUgYW5kIHJldHVybiB0aGUgbGF5b3V0ZWQgZWxlbWVudC5cbiAgICpcbiAgICogQWx0ZXJzIHRoZSBsaW5lcyBwYXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGxpbmVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhXaWR0aFxuICAgKiBAcGFyYW0ge1NWR1RleHRFbGVtZW50fSBmYWtlVGV4dFxuICAgKlxuICAgKiBAcmV0dXJuIHtMaW5lRGVzY3JpcHRvcn0gdGhlIGxpbmUgZGVzY3JpcHRvclxuICAgKi9cbiAgZnVuY3Rpb24gbGF5b3V0TmV4dChsaW5lcywgbWF4V2lkdGgsIGZha2VUZXh0KSB7XG5cbiAgICB2YXIgb3JpZ2luYWxMaW5lID0gbGluZXMuc2hpZnQoKSxcbiAgICAgICAgZml0TGluZSA9IG9yaWdpbmFsTGluZTtcblxuICAgIHZhciB0ZXh0QkJveDtcblxuICAgIGZvciAoOzspIHtcbiAgICAgIHRleHRCQm94ID0gZ2V0VGV4dEJCb3goZml0TGluZSwgZmFrZVRleHQpO1xuXG4gICAgICB0ZXh0QkJveC53aWR0aCA9IGZpdExpbmUgPyB0ZXh0QkJveC53aWR0aCA6IDA7XG5cbiAgICAgIC8vIHRyeSB0byBmaXRcbiAgICAgIGlmIChmaXRMaW5lID09PSAnICcgfHwgZml0TGluZSA9PT0gJycgfHwgdGV4dEJCb3gud2lkdGggPCBNYXRoLnJvdW5kKG1heFdpZHRoKSB8fCBmaXRMaW5lLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGZpdChsaW5lcywgZml0TGluZSwgb3JpZ2luYWxMaW5lLCB0ZXh0QkJveCk7XG4gICAgICB9XG5cbiAgICAgIGZpdExpbmUgPSBzaG9ydGVuTGluZShmaXRMaW5lLCB0ZXh0QkJveC53aWR0aCwgbWF4V2lkdGgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBsaW5lc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZml0TGluZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luYWxMaW5lXG4gICAqIEBwYXJhbSB7RGltZW5zaW9uc30gdGV4dEJCb3hcbiAgICpcbiAgICogQHJldHVybiB7TGluZURlc2NyaXB0b3J9XG4gICAqL1xuICBmdW5jdGlvbiBmaXQobGluZXMsIGZpdExpbmUsIG9yaWdpbmFsTGluZSwgdGV4dEJCb3gpIHtcbiAgICBpZiAoZml0TGluZS5sZW5ndGggPCBvcmlnaW5hbExpbmUubGVuZ3RoKSB7XG4gICAgICB2YXIgcmVtYWluZGVyID0gb3JpZ2luYWxMaW5lLnNsaWNlKGZpdExpbmUubGVuZ3RoKS50cmltKCk7XG5cbiAgICAgIGxpbmVzLnVuc2hpZnQocmVtYWluZGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHRleHRCQm94LndpZHRoLFxuICAgICAgaGVpZ2h0OiB0ZXh0QkJveC5oZWlnaHQsXG4gICAgICB0ZXh0OiBmaXRMaW5lXG4gICAgfTtcbiAgfVxuXG4gIHZhciBTT0ZUX0JSRUFLID0gJ1xcdTAwQUQnO1xuXG5cbiAgLyoqXG4gICAqIFNob3J0ZW5zIGEgbGluZSBiYXNlZCBvbiBzcGFjaW5nIGFuZCBoeXBoZW5zLlxuICAgKiBSZXR1cm5zIHRoZSBzaG9ydGVuZWQgcmVzdWx0IG9uIHN1Y2Nlc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhMZW5ndGggdGhlIG1heGltdW0gY2hhcmFjdGVycyBvZiB0aGUgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHNob3J0ZW5lZCBzdHJpbmdcbiAgICovXG4gIGZ1bmN0aW9uIHNlbWFudGljU2hvcnRlbihsaW5lLCBtYXhMZW5ndGgpIHtcblxuICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoLyhcXHN8LXxcXHUwMEFEKS9nKSxcbiAgICAgICAgcGFydCxcbiAgICAgICAgc2hvcnRlbmVkUGFydHMgPSBbXSxcbiAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgIC8vIHRyeSB0byBzaG9ydGVuIHZpYSBicmVhayBjaGFyc1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cbiAgICAgIHdoaWxlICgocGFydCA9IHBhcnRzLnNoaWZ0KCkpKSB7XG4gICAgICAgIGlmIChwYXJ0Lmxlbmd0aCArIGxlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICAgIHNob3J0ZW5lZFBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgbGVuZ3RoICs9IHBhcnQubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gcmVtb3ZlIHByZXZpb3VzIHBhcnQsIHRvbyBpZiBoeXBoZW4gZG9lcyBub3QgZml0IGFueW1vcmVcbiAgICAgICAgICBpZiAocGFydCA9PT0gJy0nIHx8IHBhcnQgPT09IFNPRlRfQlJFQUspIHtcbiAgICAgICAgICAgIHNob3J0ZW5lZFBhcnRzLnBvcCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhc3QgPSBzaG9ydGVuZWRQYXJ0c1tzaG9ydGVuZWRQYXJ0cy5sZW5ndGggLSAxXTtcblxuICAgIC8vIHRyYW5zbGF0ZSB0cmFpbGluZyBzb2Z0IGJyZWFrIHRvIGFjdHVhbCBoeXBoZW5cbiAgICBpZiAobGFzdCAmJiBsYXN0ID09PSBTT0ZUX0JSRUFLKSB7XG4gICAgICBzaG9ydGVuZWRQYXJ0c1tzaG9ydGVuZWRQYXJ0cy5sZW5ndGggLSAxXSA9ICctJztcbiAgICB9XG5cbiAgICByZXR1cm4gc2hvcnRlbmVkUGFydHMuam9pbignJyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGluZVxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heFdpZHRoXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIHNob3J0ZW5MaW5lKGxpbmUsIHdpZHRoLCBtYXhXaWR0aCkge1xuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChsaW5lLmxlbmd0aCAqIChtYXhXaWR0aCAvIHdpZHRoKSwgMSk7XG5cbiAgICAvLyB0cnkgdG8gc2hvcnRlbiBzZW1hbnRpY2FsbHkgKGkuZS4gYmFzZWQgb24gc3BhY2VzIGFuZCBoeXBoZW5zKVxuICAgIHZhciBzaG9ydGVuZWRMaW5lID0gc2VtYW50aWNTaG9ydGVuKGxpbmUsIGxlbmd0aCk7XG5cbiAgICBpZiAoIXNob3J0ZW5lZExpbmUpIHtcblxuICAgICAgLy8gZm9yY2Ugc2hvcnRlbiBieSBjdXR0aW5nIHRoZSBsb25nIHdvcmRcbiAgICAgIHNob3J0ZW5lZExpbmUgPSBsaW5lLnNsaWNlKDAsIE1hdGgubWF4KE1hdGgucm91bmQobGVuZ3RoIC0gMSksIDEpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hvcnRlbmVkTGluZTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1NWR1NWR0VsZW1lbnR9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRIZWxwZXJTdmcoKSB7XG4gICAgdmFyIGhlbHBlclN2ZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWxwZXItc3ZnJyk7XG5cbiAgICBpZiAoIWhlbHBlclN2Zykge1xuICAgICAgaGVscGVyU3ZnID0gY3JlYXRlJDEoJ3N2ZycpO1xuXG4gICAgICBhdHRyJDEoaGVscGVyU3ZnLCB7XG4gICAgICAgIGlkOiAnaGVscGVyLXN2ZydcbiAgICAgIH0pO1xuXG4gICAgICBhc3NpZ24oaGVscGVyU3ZnLCB7XG4gICAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfSk7XG5cbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaGVscGVyU3ZnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGVscGVyU3ZnO1xuICB9XG5cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBsYWJlbCB1dGlsaXR5XG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dENvbmZpZ30gW2NvbmZpZ11cbiAgICovXG4gIGZ1bmN0aW9uIFRleHQoY29uZmlnKSB7XG5cbiAgICB0aGlzLl9jb25maWcgPSBhc3NpZ24kMSh7fSwge1xuICAgICAgc2l6ZTogREVGQVVMVF9MQUJFTF9TSVpFLFxuICAgICAgcGFkZGluZzogREVGQVVMVF9CT1hfUEFERElORyxcbiAgICAgIHN0eWxlOiB7fSxcbiAgICAgIGFsaWduOiAnY2VudGVyLXRvcCdcbiAgICB9LCBjb25maWcgfHwge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxheW91dGVkIHRleHQgYXMgYW4gU1ZHIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7VGV4dExheW91dENvbmZpZ30gb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fVxuICAgKi9cbiAgVGV4dC5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXRUZXh0KHRleHQsIG9wdGlvbnMpLmVsZW1lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsYWJlbHMgbGF5b3V0ZWQgZGltZW5zaW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgdG8gbGF5b3V0XG4gICAqIEBwYXJhbSB7VGV4dExheW91dENvbmZpZ30gb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJuIHtEaW1lbnNpb25zfVxuICAgKi9cbiAgVGV4dC5wcm90b3R5cGUuZ2V0RGltZW5zaW9ucyA9IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXRUZXh0KHRleHQsIG9wdGlvbnMpLmRpbWVuc2lvbnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBsYWJlbCBhbmQgaXRzIGJvdW5kaW5nIGJveC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgdGhlIHRleHQgdG8gcmVuZGVyIG9uIHRoZSBsYWJlbFxuICAgKiBAcGFyYW0ge1RleHRMYXlvdXRDb25maWd9IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybiB7IHtcbiAgICogICBlbGVtZW50OiBTVkdFbGVtZW50LFxuICAgKiAgIGRpbWVuc2lvbnM6IERpbWVuc2lvbnNcbiAgICogfSB9XG4gICAqL1xuICBUZXh0LnByb3RvdHlwZS5sYXlvdXRUZXh0ID0gZnVuY3Rpb24odGV4dCwgb3B0aW9ucykge1xuICAgIHZhciBib3ggPSBhc3NpZ24kMSh7fSwgdGhpcy5fY29uZmlnLnNpemUsIG9wdGlvbnMuYm94KSxcbiAgICAgICAgc3R5bGUgPSBhc3NpZ24kMSh7fSwgdGhpcy5fY29uZmlnLnN0eWxlLCBvcHRpb25zLnN0eWxlKSxcbiAgICAgICAgYWxpZ24gPSBwYXJzZUFsaWduKG9wdGlvbnMuYWxpZ24gfHwgdGhpcy5fY29uZmlnLmFsaWduKSxcbiAgICAgICAgcGFkZGluZyA9IHBhcnNlUGFkZGluZyhvcHRpb25zLnBhZGRpbmcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucGFkZGluZyA6IHRoaXMuX2NvbmZpZy5wYWRkaW5nKSxcbiAgICAgICAgZml0Qm94ID0gb3B0aW9ucy5maXRCb3ggfHwgZmFsc2U7XG5cbiAgICB2YXIgbGluZUhlaWdodCA9IGdldExpbmVIZWlnaHQoc3R5bGUpO1xuXG4gICAgLy8gd2Ugc3BsaXQgdGV4dCBieSBsaW5lcyBhbmQgbm9ybWFsaXplXG4gICAgLy8ge3NvZnQgYnJlYWt9ICsge2xpbmUgYnJlYWt9ID0+IHsgbGluZSBicmVhayB9XG4gICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgvXFx1MDBBRD9cXHI/XFxuLyksXG4gICAgICAgIGxheW91dGVkID0gW107XG5cbiAgICB2YXIgbWF4V2lkdGggPSBib3gud2lkdGggLSBwYWRkaW5nLmxlZnQgLSBwYWRkaW5nLnJpZ2h0O1xuXG4gICAgLy8gZW5zdXJlIGNvcnJlY3QgcmVuZGVyaW5nIGJ5IGF0dGFjaGluZyBoZWxwZXIgdGV4dCBub2RlIHRvIGludmlzaWJsZSBTVkdcbiAgICB2YXIgaGVscGVyVGV4dCA9IGNyZWF0ZSQxKCd0ZXh0Jyk7XG4gICAgYXR0ciQxKGhlbHBlclRleHQsIHsgeDogMCwgeTogMCB9KTtcbiAgICBhdHRyJDEoaGVscGVyVGV4dCwgc3R5bGUpO1xuXG4gICAgdmFyIGhlbHBlclN2ZyA9IGdldEhlbHBlclN2ZygpO1xuXG4gICAgYXBwZW5kKGhlbHBlclN2ZywgaGVscGVyVGV4dCk7XG5cbiAgICB3aGlsZSAobGluZXMubGVuZ3RoKSB7XG4gICAgICBsYXlvdXRlZC5wdXNoKGxheW91dE5leHQobGluZXMsIG1heFdpZHRoLCBoZWxwZXJUZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGFsaWduLnZlcnRpY2FsID09PSAnbWlkZGxlJykge1xuICAgICAgcGFkZGluZy50b3AgPSBwYWRkaW5nLmJvdHRvbSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHRvdGFsSGVpZ2h0ID0gcmVkdWNlKGxheW91dGVkLCBmdW5jdGlvbihzdW0sIGxpbmUsIGlkeCkge1xuICAgICAgcmV0dXJuIHN1bSArIChsaW5lSGVpZ2h0IHx8IGxpbmUuaGVpZ2h0KTtcbiAgICB9LCAwKSArIHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b207XG5cbiAgICB2YXIgbWF4TGluZVdpZHRoID0gcmVkdWNlKGxheW91dGVkLCBmdW5jdGlvbihzdW0sIGxpbmUsIGlkeCkge1xuICAgICAgcmV0dXJuIGxpbmUud2lkdGggPiBzdW0gPyBsaW5lLndpZHRoIDogc3VtO1xuICAgIH0sIDApO1xuXG4gICAgLy8gdGhlIHkgcG9zaXRpb24gb2YgdGhlIG5leHQgbGluZVxuICAgIHZhciB5ID0gcGFkZGluZy50b3A7XG5cbiAgICBpZiAoYWxpZ24udmVydGljYWwgPT09ICdtaWRkbGUnKSB7XG4gICAgICB5ICs9IChib3guaGVpZ2h0IC0gdG90YWxIZWlnaHQpIC8gMjtcbiAgICB9XG5cbiAgICAvLyBtYWdpYyBudW1iZXIgaW5pdGlhbCBvZmZzZXRcbiAgICB5IC09IChsaW5lSGVpZ2h0IHx8IGxheW91dGVkWzBdLmhlaWdodCkgLyA0O1xuXG5cbiAgICB2YXIgdGV4dEVsZW1lbnQgPSBjcmVhdGUkMSgndGV4dCcpO1xuXG4gICAgYXR0ciQxKHRleHRFbGVtZW50LCBzdHlsZSk7XG5cbiAgICAvLyBsYXlvdXQgZWFjaCBsaW5lIHRha2luZyBpbnRvIGFjY291bnQgdGhhdCBwYXJlbnRcbiAgICAvLyBzaGFwZSBtaWdodCByZXNpemUgdG8gZml0IHRleHQgc2l6ZVxuICAgIGZvckVhY2gkMShsYXlvdXRlZCwgZnVuY3Rpb24obGluZSkge1xuXG4gICAgICB2YXIgeDtcblxuICAgICAgeSArPSAobGluZUhlaWdodCB8fCBsaW5lLmhlaWdodCk7XG5cbiAgICAgIHN3aXRjaCAoYWxpZ24uaG9yaXpvbnRhbCkge1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIHggPSBwYWRkaW5nLmxlZnQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIHggPSAoKGZpdEJveCA/IG1heExpbmVXaWR0aCA6IG1heFdpZHRoKVxuICAgICAgICAgIC0gcGFkZGluZy5yaWdodCAtIGxpbmUud2lkdGgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcblxuICAgICAgICAvLyBha2EgY2VudGVyXG4gICAgICAgIHggPSBNYXRoLm1heCgoKChmaXRCb3ggPyBtYXhMaW5lV2lkdGggOiBtYXhXaWR0aClcbiAgICAgICAgICAtIGxpbmUud2lkdGgpIC8gMiArIHBhZGRpbmcubGVmdCksIDApO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHNwYW4gPSBjcmVhdGUkMSgndHNwYW4nKTtcbiAgICAgIGF0dHIkMSh0c3BhbiwgeyB4OiB4LCB5OiB5IH0pO1xuXG4gICAgICB0c3Bhbi50ZXh0Q29udGVudCA9IGxpbmUudGV4dDtcblxuICAgICAgYXBwZW5kKHRleHRFbGVtZW50LCB0c3Bhbik7XG4gICAgfSk7XG5cbiAgICByZW1vdmUkMihoZWxwZXJUZXh0KTtcblxuICAgIHZhciBkaW1lbnNpb25zID0ge1xuICAgICAgd2lkdGg6IG1heExpbmVXaWR0aCxcbiAgICAgIGhlaWdodDogdG90YWxIZWlnaHRcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgICBlbGVtZW50OiB0ZXh0RWxlbWVudFxuICAgIH07XG4gIH07XG5cblxuICBmdW5jdGlvbiBnZXRMaW5lSGVpZ2h0KHN0eWxlKSB7XG4gICAgaWYgKCdmb250U2l6ZScgaW4gc3R5bGUgJiYgJ2xpbmVIZWlnaHQnIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gc3R5bGUubGluZUhlaWdodCAqIHBhcnNlSW50KHN0eWxlLmZvbnRTaXplLCAxMCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIERFRkFVTFRfRk9OVF9TSVpFID0gMTI7XHJcbiAgdmFyIExJTkVfSEVJR0hUX1JBVElPID0gMS4yO1xyXG5cclxuICB2YXIgTUlOX1RFWFRfQU5OT1RBVElPTl9IRUlHSFQgPSAzMDtcclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGVkZWYgeyB7XHJcbiAgICogICBmb250RmFtaWx5OiBzdHJpbmc7XHJcbiAgICogICBmb250U2l6ZTogbnVtYmVyO1xyXG4gICAqICAgZm9udFdlaWdodDogc3RyaW5nO1xyXG4gICAqICAgbGluZUhlaWdodDogbnVtYmVyO1xyXG4gICAqIH0gfSBUZXh0UmVuZGVyZXJTdHlsZVxyXG4gICAqXHJcbiAgICogQHR5cGVkZWYgeyB7XHJcbiAgICogICBkZWZhdWx0U3R5bGU/OiBQYXJ0aWFsPFRleHRSZW5kZXJlclN0eWxlPjtcclxuICAgKiAgIGV4dGVybmFsU3R5bGU/OiBQYXJ0aWFsPFRleHRSZW5kZXJlclN0eWxlPjtcclxuICAgKiB9IH0gVGV4dFJlbmRlcmVyQ29uZmlnXHJcbiAgICpcclxuICAgKiBAdHlwZWRlZiB7IGltcG9ydCgnZGlhZ3JhbS1qcy9saWIvdXRpbC9UZXh0JykuVGV4dExheW91dENvbmZpZyB9IFRleHRMYXlvdXRDb25maWdcclxuICAgKlxyXG4gICAqIEB0eXBlZGVmIHsgaW1wb3J0KCdkaWFncmFtLWpzL2xpYi91dGlsL1R5cGVzJykuUmVjdCB9IFJlY3RcclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlcnMgdGV4dCBhbmQgY29tcHV0ZXMgdGV4dCBib3VuZGluZyBib3hlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VGV4dFJlbmRlcmVyQ29uZmlnfSBbY29uZmlnXVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFRleHRSZW5kZXJlcihjb25maWcpIHtcclxuXHJcbiAgICB2YXIgZGVmYXVsdFN0eWxlID0gYXNzaWduJDEoe1xyXG4gICAgICBmb250RmFtaWx5OiAnQXJpYWwsIHNhbnMtc2VyaWYnLFxyXG4gICAgICBmb250U2l6ZTogREVGQVVMVF9GT05UX1NJWkUsXHJcbiAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxyXG4gICAgICBsaW5lSGVpZ2h0OiBMSU5FX0hFSUdIVF9SQVRJT1xyXG4gICAgfSwgY29uZmlnICYmIGNvbmZpZy5kZWZhdWx0U3R5bGUgfHwge30pO1xyXG5cclxuICAgIHZhciBmb250U2l6ZSA9IHBhcnNlSW50KGRlZmF1bHRTdHlsZS5mb250U2l6ZSwgMTApIC0gMTtcclxuXHJcbiAgICB2YXIgZXh0ZXJuYWxTdHlsZSA9IGFzc2lnbiQxKHt9LCBkZWZhdWx0U3R5bGUsIHtcclxuICAgICAgZm9udFNpemU6IGZvbnRTaXplXHJcbiAgICB9LCBjb25maWcgJiYgY29uZmlnLmV4dGVybmFsU3R5bGUgfHwge30pO1xyXG5cclxuICAgIHZhciB0ZXh0VXRpbCA9IG5ldyBUZXh0KHtcclxuICAgICAgc3R5bGU6IGRlZmF1bHRTdHlsZVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIG5ldyBib3VuZHMgb2YgYW4gZXh0ZXJuYWxseSByZW5kZXJlZCxcclxuICAgICAqIGxheW91dGVkIGxhYmVsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVjdH0gYm91bmRzXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1JlY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0RXh0ZXJuYWxMYWJlbEJvdW5kcyA9IGZ1bmN0aW9uKGJvdW5kcywgdGV4dCkge1xyXG5cclxuICAgICAgdmFyIGxheW91dGVkRGltZW5zaW9ucyA9IHRleHRVdGlsLmdldERpbWVuc2lvbnModGV4dCwge1xyXG4gICAgICAgIGJveDoge1xyXG4gICAgICAgICAgd2lkdGg6IDkwLFxyXG4gICAgICAgICAgaGVpZ2h0OiAzMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3R5bGU6IGV4dGVybmFsU3R5bGVcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyByZXNpemUgbGFiZWwgc2hhcGUgdG8gZml0IGxhYmVsIHRleHRcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB4OiBNYXRoLnJvdW5kKGJvdW5kcy54ICsgYm91bmRzLndpZHRoIC8gMiAtIGxheW91dGVkRGltZW5zaW9ucy53aWR0aCAvIDIpLFxyXG4gICAgICAgIHk6IE1hdGgucm91bmQoYm91bmRzLnkpLFxyXG4gICAgICAgIHdpZHRoOiBNYXRoLmNlaWwobGF5b3V0ZWREaW1lbnNpb25zLndpZHRoKSxcclxuICAgICAgICBoZWlnaHQ6IE1hdGguY2VpbChsYXlvdXRlZERpbWVuc2lvbnMuaGVpZ2h0KVxyXG4gICAgICB9O1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIG5ldyBib3VuZHMgb2YgdGV4dCBhbm5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVjdH0gYm91bmRzXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1JlY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0VGV4dEFubm90YXRpb25Cb3VuZHMgPSBmdW5jdGlvbihib3VuZHMsIHRleHQpIHtcclxuXHJcbiAgICAgIHZhciBsYXlvdXRlZERpbWVuc2lvbnMgPSB0ZXh0VXRpbC5nZXREaW1lbnNpb25zKHRleHQsIHtcclxuICAgICAgICBib3g6IGJvdW5kcyxcclxuICAgICAgICBzdHlsZTogZGVmYXVsdFN0eWxlLFxyXG4gICAgICAgIGFsaWduOiAnbGVmdC10b3AnLFxyXG4gICAgICAgIHBhZGRpbmc6IDVcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IGJvdW5kcy54LFxyXG4gICAgICAgIHk6IGJvdW5kcy55LFxyXG4gICAgICAgIHdpZHRoOiBib3VuZHMud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChNSU5fVEVYVF9BTk5PVEFUSU9OX0hFSUdIVCwgTWF0aC5yb3VuZChsYXlvdXRlZERpbWVuc2lvbnMuaGVpZ2h0KSlcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBsYXlvdXRlZCB0ZXh0IGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcclxuICAgICAqIEBwYXJhbSB7VGV4dExheW91dENvbmZpZ30gW29wdGlvbnNdXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7U1ZHRWxlbWVudH0gcmVuZGVyZWQgdGV4dFxyXG4gICAgICovXHJcbiAgICB0aGlzLmNyZWF0ZVRleHQgPSBmdW5jdGlvbih0ZXh0LCBvcHRpb25zKSB7XHJcbiAgICAgIHJldHVybiB0ZXh0VXRpbC5jcmVhdGVUZXh0KHRleHQsIG9wdGlvbnMgfHwge30pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBkZWZhdWx0IHRleHQgc3R5bGUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0RGVmYXVsdFN0eWxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBkZWZhdWx0U3R5bGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBleHRlcm5hbCB0ZXh0IHN0eWxlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmdldEV4dGVybmFsU3R5bGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIGV4dGVybmFsU3R5bGU7XHJcbiAgICB9O1xyXG5cclxuICB9XHJcblxyXG4gIFRleHRSZW5kZXJlci4kaW5qZWN0ID0gW1xyXG4gICAgJ2NvbmZpZy50ZXh0UmVuZGVyZXInXHJcbiAgXTtcblxuICAvKipcclxuICAgKiBNYXAgY29udGFpbmluZyBTVkcgcGF0aHMgbmVlZGVkIGJ5IEJwbW5SZW5kZXJlclxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFBhdGhNYXAoKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb250YWlucyBhIG1hcCBvZiBwYXRoIGVsZW1lbnRzXHJcbiAgICAgKlxyXG4gICAgICogPGgxPlBhdGggZGVmaW5pdGlvbjwvaDE+XHJcbiAgICAgKiBBIHBhcmFtZXRlcml6ZWQgcGF0aCBpcyBkZWZpbmVkIGxpa2UgdGhpczpcclxuICAgICAqIDxwcmU+XHJcbiAgICAgKiAnR0FURVdBWV9QQVJBTExFTCc6IHtcclxuICAgICAqICAgZDogJ20ge214fSx7bXl9IHtlLngwfSwwIDAse2UueDF9IHtlLngxfSwwIDAse2UueTB9IC17ZS54MX0sMCAwLHtlLnkxfSAnICtcclxuICAgICAgICAgICAgJy17ZS54MH0sMCAwLC17ZS55MX0gLXtlLngxfSwwIDAsLXtlLnkwfSB7ZS54MX0sMCB6JyxcclxuICAgICAqICAgaGVpZ2h0OiAxNy41LFxyXG4gICAgICogICB3aWR0aDogIDE3LjUsXHJcbiAgICAgKiAgIGhlaWdodEVsZW1lbnRzOiBbMi41LCA3LjVdLFxyXG4gICAgICogICB3aWR0aEVsZW1lbnRzOiBbMi41LCA3LjVdXHJcbiAgICAgKiB9XHJcbiAgICAgKiA8L3ByZT5cclxuICAgICAqIDxwPkl0J3MgaW1wb3J0YW50IHRvIHNwZWNpZnkgYSBjb3JyZWN0IDxiPmhlaWdodCBhbmQgd2lkdGg8L2I+IGZvciB0aGUgcGF0aCBhcyB0aGUgc2NhbGluZ1xyXG4gICAgICogaXMgYmFzZWQgb24gdGhlIHJhdGlvIGJldHdlZW4gdGhlIHNwZWNpZmllZCBoZWlnaHQgYW5kIHdpZHRoIGluIHRoaXMgb2JqZWN0IGFuZCB0aGVcclxuICAgICAqIGhlaWdodCBhbmQgd2lkdGggdGhhdCBpcyBzZXQgYXMgc2NhbGUgdGFyZ2V0IChOb3RlIHgseSBjb29yZGluYXRlcyB3aWxsIGJlIHNjYWxlZCB3aXRoXHJcbiAgICAgKiBpbmRpdmlkdWFsIHJhdGlvcykuPC9wPlxyXG4gICAgICogPHA+VGhlICc8Yj5oZWlnaHRFbGVtZW50czwvYj4nIGFuZCAnPGI+d2lkdGhFbGVtZW50czwvYj4nIGFycmF5IG11c3QgY29udGFpbiB0aGUgdmFsdWVzIHRoYXQgd2lsbCBiZSBzY2FsZWQuXHJcbiAgICAgKiBUaGUgc2NhbGluZyBpcyBiYXNlZCBvbiB0aGUgY29tcHV0ZWQgcmF0aW9zLlxyXG4gICAgICogQ29vcmRpbmF0ZXMgb24gdGhlIHkgYXhpcyBzaG91bGQgYmUgaW4gdGhlIDxiPmhlaWdodEVsZW1lbnQ8L2I+J3MgYXJyYXksIHRoZXkgd2lsbCBiZSBzY2FsZWQgdXNpbmdcclxuICAgICAqIHRoZSBjb21wdXRlZCByYXRpbyBjb2VmZmljaWVudC5cclxuICAgICAqIEluIHRoZSBwYXJhbWV0ZXJpemVkIHBhdGggdGhlIHNjYWxlZCB2YWx1ZXMgY2FuIGJlIGFjY2Vzc2VkIHRocm91Z2ggdGhlICdlJyBvYmplY3QgaW4ge30gYnJhY2tldHMuXHJcbiAgICAgKiAgIDx1bD5cclxuICAgICAqICAgIDxsaT5UaGUgdmFsdWVzIGZvciB0aGUgeSBheGlzIGNhbiBiZSBhY2Nlc3NlZCBpbiB0aGUgcGF0aCBzdHJpbmcgdXNpbmcge2UueTB9LCB7ZS55MX0sIC4uLi48L2xpPlxyXG4gICAgICogICAgPGxpPlRoZSB2YWx1ZXMgZm9yIHRoZSB4IGF4aXMgY2FuIGJlIGFjY2Vzc2VkIGluIHRoZSBwYXRoIHN0cmluZyB1c2luZyB7ZS54MH0sIHtlLngxfSwgLi4uLjwvbGk+XHJcbiAgICAgKiAgIDwvdWw+XHJcbiAgICAgKiAgIFRoZSBudW1iZXJzIHgwLCB4MSByZXNwZWN0aXZlbHkgeTAsIHkxLCAuLi4gbWFwIHRvIHRoZSBjb3JyZXNwb25kaW5nIGFycmF5IGluZGV4LlxyXG4gICAgICogPC9wPlxyXG4gICAgICovXHJcbiAgICB0aGlzLnBhdGhNYXAgPSB7XHJcbiAgICAgICdFVkVOVF9NRVNTQUdFJzoge1xyXG4gICAgICAgIGQ6ICdtIHtteH0se215fSBsIDAse2UueTF9IGwge2UueDF9LDAgbCAwLC17ZS55MX0geiBsIHtlLngwfSx7ZS55MH0gbCB7ZS54MH0sLXtlLnkwfScsXHJcbiAgICAgICAgaGVpZ2h0OiAzNixcclxuICAgICAgICB3aWR0aDogIDM2LFxyXG4gICAgICAgIGhlaWdodEVsZW1lbnRzOiBbIDYsIDE0IF0sXHJcbiAgICAgICAgd2lkdGhFbGVtZW50czogWyAxMC41LCAyMSBdXHJcbiAgICAgIH0sXHJcbiAgICAgICdFVkVOVF9TSUdOQUwnOiB7XHJcbiAgICAgICAgZDogJ00ge214fSx7bXl9IGwge2UueDB9LHtlLnkwfSBsIC17ZS54MX0sMCBaJyxcclxuICAgICAgICBoZWlnaHQ6IDM2LFxyXG4gICAgICAgIHdpZHRoOiAzNixcclxuICAgICAgICBoZWlnaHRFbGVtZW50czogWyAxOCBdLFxyXG4gICAgICAgIHdpZHRoRWxlbWVudHM6IFsgMTAsIDIwIF1cclxuICAgICAgfSxcclxuICAgICAgJ0VWRU5UX0VTQ0FMQVRJT04nOiB7XHJcbiAgICAgICAgZDogJ00ge214fSx7bXl9IGwge2UueDB9LHtlLnkwfSBsIC17ZS54MH0sLXtlLnkxfSBsIC17ZS54MH0se2UueTF9IFonLFxyXG4gICAgICAgIGhlaWdodDogMzYsXHJcbiAgICAgICAgd2lkdGg6IDM2LFxyXG4gICAgICAgIGhlaWdodEVsZW1lbnRzOiBbIDIwLCA3IF0sXHJcbiAgICAgICAgd2lkdGhFbGVtZW50czogWyA4IF1cclxuICAgICAgfSxcclxuICAgICAgJ0VWRU5UX0NPTkRJVElPTkFMJzoge1xyXG4gICAgICAgIGQ6ICdNIHtlLngwfSx7ZS55MH0gbCB7ZS54MX0sMCBsIDAse2UueTJ9IGwgLXtlLngxfSwwIFogJyArXHJcbiAgICAgICAgICAgJ00ge2UueDJ9LHtlLnkzfSBsIHtlLngwfSwwICcgK1xyXG4gICAgICAgICAgICdNIHtlLngyfSx7ZS55NH0gbCB7ZS54MH0sMCAnICtcclxuICAgICAgICAgICAnTSB7ZS54Mn0se2UueTV9IGwge2UueDB9LDAgJyArXHJcbiAgICAgICAgICAgJ00ge2UueDJ9LHtlLnk2fSBsIHtlLngwfSwwICcgK1xyXG4gICAgICAgICAgICdNIHtlLngyfSx7ZS55N30gbCB7ZS54MH0sMCAnICtcclxuICAgICAgICAgICAnTSB7ZS54Mn0se2UueTh9IGwge2UueDB9LDAgJyxcclxuICAgICAgICBoZWlnaHQ6IDM2LFxyXG4gICAgICAgIHdpZHRoOiAgMzYsXHJcbiAgICAgICAgaGVpZ2h0RWxlbWVudHM6IFsgOC41LCAxNC41LCAxOCwgMTEuNSwgMTQuNSwgMTcuNSwgMjAuNSwgMjMuNSwgMjYuNSBdLFxyXG4gICAgICAgIHdpZHRoRWxlbWVudHM6ICBbIDEwLjUsIDE0LjUsIDEyLjUgXVxyXG4gICAgICB9LFxyXG4gICAgICAnRVZFTlRfTElOSyc6IHtcclxuICAgICAgICBkOiAnbSB7bXh9LHtteX0gMCx7ZS55MH0gLXtlLngxfSwwIDAse2UueTF9IHtlLngxfSwwIDAse2UueTB9IHtlLngwfSwte2UueTJ9IC17ZS54MH0sLXtlLnkyfSB6JyxcclxuICAgICAgICBoZWlnaHQ6IDM2LFxyXG4gICAgICAgIHdpZHRoOiAzNixcclxuICAgICAgICBoZWlnaHRFbGVtZW50czogWyA0LjQzNzUsIDYuNzUsIDcuODEyNSBdLFxyXG4gICAgICAgIHdpZHRoRWxlbWVudHM6IFsgOS44NDM3NSwgMTMuNSBdXHJcbiAgICAgIH0sXHJcbiAgICAgICdFVkVOVF9FUlJPUic6IHtcclxuICAgICAgICBkOiAnbSB7bXh9LHtteX0ge2UueDB9LC17ZS55MH0ge2UueDF9LC17ZS55MX0ge2UueDJ9LHtlLnkyfSB7ZS54M30sLXtlLnkzfSAte2UueDR9LHtlLnk0fSAte2UueDV9LC17ZS55NX0geicsXHJcbiAgICAgICAgaGVpZ2h0OiAzNixcclxuICAgICAgICB3aWR0aDogMzYsXHJcbiAgICAgICAgaGVpZ2h0RWxlbWVudHM6IFsgMC4wMjMsIDguNzM3LCA4LjE1MSwgMTYuNTY0LCAxMC41OTEsIDguNzE0IF0sXHJcbiAgICAgICAgd2lkdGhFbGVtZW50czogWyAwLjA4NSwgNi42NzIsIDYuOTcsIDQuMjczLCA1LjMzNywgNi42MzYgXVxyXG4gICAgICB9LFxyXG4gICAgICAnRVZFTlRfQ0FOQ0VMXzQ1Jzoge1xyXG4gICAgICAgIGQ6ICdtIHtteH0se215fSAte2UueDF9LDAgMCx7ZS54MH0ge2UueDF9LDAgMCx7ZS55MX0ge2UueDB9LDAgJyArXHJcbiAgICAgICAgICAnMCwte2UueTF9IHtlLngxfSwwIDAsLXtlLnkwfSAte2UueDF9LDAgMCwte2UueTF9IC17ZS54MH0sMCB6JyxcclxuICAgICAgICBoZWlnaHQ6IDM2LFxyXG4gICAgICAgIHdpZHRoOiAzNixcclxuICAgICAgICBoZWlnaHRFbGVtZW50czogWyA0Ljc1LCA4LjUgXSxcclxuICAgICAgICB3aWR0aEVsZW1lbnRzOiBbIDQuNzUsIDguNSBdXHJcbiAgICAgIH0sXHJcbiAgICAgICdFVkVOVF9DT01QRU5TQVRJT04nOiB7XHJcbiAgICAgICAgZDogJ20ge214fSx7bXl9IHtlLngwfSwte2UueTB9IDAse2UueTF9IHogbSB7ZS54MX0sLXtlLnkyfSB7ZS54Mn0sLXtlLnkzfSAwLHtlLnkxfSAte2UueDJ9LC17ZS55M30geicsXHJcbiAgICAgICAgaGVpZ2h0OiAzNixcclxuICAgICAgICB3aWR0aDogMzYsXHJcbiAgICAgICAgaGVpZ2h0RWxlbWVudHM6IFsgNi41LCAxMywgMC40LCA2LjEgXSxcclxuICAgICAgICB3aWR0aEVsZW1lbnRzOiBbIDksIDkuMywgOC43IF1cclxuICAgICAgfSxcclxuICAgICAgJ0VWRU5UX1RJTUVSX1dIJzoge1xyXG4gICAgICAgIGQ6ICdNIHtteH0se215fSBsIHtlLngwfSwte2UueTB9IG0gLXtlLngwfSx7ZS55MH0gbCB7ZS54MX0se2UueTF9ICcsXHJcbiAgICAgICAgaGVpZ2h0OiAzNixcclxuICAgICAgICB3aWR0aDogIDM2LFxyXG4gICAgICAgIGhlaWdodEVsZW1lbnRzOiBbIDEwLCAyIF0sXHJcbiAgICAgICAgd2lkdGhFbGVtZW50czogWyAzLCA3IF1cclxuICAgICAgfSxcclxuICAgICAgJ0VWRU5UX1RJTUVSX0xJTkUnOiB7XHJcbiAgICAgICAgZDogICdNIHtteH0se215fSAnICtcclxuICAgICAgICAgICAgJ20ge2UueDB9LHtlLnkwfSBsIC17ZS54MX0se2UueTF9ICcsXHJcbiAgICAgICAgaGVpZ2h0OiAzNixcclxuICAgICAgICB3aWR0aDogIDM2LFxyXG4gICAgICAgIGhlaWdodEVsZW1lbnRzOiBbIDEwLCAzIF0sXHJcbiAgICAgICAgd2lkdGhFbGVtZW50czogWyAwLCAwIF1cclxuICAgICAgfSxcclxuICAgICAgJ0VWRU5UX01VTFRJUExFJzoge1xyXG4gICAgICAgIGQ6J20ge214fSx7bXl9IHtlLngxfSwte2UueTB9IHtlLngxfSx7ZS55MH0gLXtlLngwfSx7ZS55MX0gLXtlLngyfSwwIHonLFxyXG4gICAgICAgIGhlaWdodDogMzYsXHJcbiAgICAgICAgd2lkdGg6ICAzNixcclxuICAgICAgICBoZWlnaHRFbGVtZW50czogWyA2LjI4MDk5LCAxMi41NjE5OSBdLFxyXG4gICAgICAgIHdpZHRoRWxlbWVudHM6IFsgMy4xNDA1LCA5LjQyMTQ5LCAxMi41NjE5OCBdXHJcbiAgICAgIH0sXHJcbiAgICAgICdFVkVOVF9QQVJBTExFTF9NVUxUSVBMRSc6IHtcclxuICAgICAgICBkOidtIHtteH0se215fSB7ZS54MH0sMCAwLHtlLnkxfSB7ZS54MX0sMCAwLHtlLnkwfSAte2UueDF9LDAgMCx7ZS55MX0gJyArXHJcbiAgICAgICAgICAnLXtlLngwfSwwIDAsLXtlLnkxfSAte2UueDF9LDAgMCwte2UueTB9IHtlLngxfSwwIHonLFxyXG4gICAgICAgIGhlaWdodDogMzYsXHJcbiAgICAgICAgd2lkdGg6ICAzNixcclxuICAgICAgICBoZWlnaHRFbGVtZW50czogWyAyLjU2MjI4LCA3LjY4NjgzIF0sXHJcbiAgICAgICAgd2lkdGhFbGVtZW50czogWyAyLjU2MjI4LCA3LjY4NjgzIF1cclxuICAgICAgfSxcclxuICAgICAgJ0dBVEVXQVlfRVhDTFVTSVZFJzoge1xyXG4gICAgICAgIGQ6J20ge214fSx7bXl9IHtlLngwfSx7ZS55MH0ge2UueDF9LHtlLnkwfSB7ZS54Mn0sMCB7ZS54NH0se2UueTJ9ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgJ3tlLng0fSx7ZS55MX0ge2UueDJ9LDAge2UueDF9LHtlLnkzfSB7ZS54MH0se2UueTN9ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgJ3tlLngzfSwwIHtlLng1fSx7ZS55MX0ge2UueDV9LHtlLnkyfSB7ZS54M30sMCB6JyxcclxuICAgICAgICBoZWlnaHQ6IDE3LjUsXHJcbiAgICAgICAgd2lkdGg6ICAxNy41LFxyXG4gICAgICAgIGhlaWdodEVsZW1lbnRzOiBbIDguNSwgNi41MzEyLCAtNi41MzEyLCAtOC41IF0sXHJcbiAgICAgICAgd2lkdGhFbGVtZW50czogIFsgNi41LCAtNi41LCAzLCAtMywgNSwgLTUgXVxyXG4gICAgICB9LFxyXG4gICAgICAnR0FURVdBWV9QQVJBTExFTCc6IHtcclxuICAgICAgICBkOidtIHtteH0se215fSAwLHtlLnkxfSAte2UueDF9LDAgMCx7ZS55MH0ge2UueDF9LDAgMCx7ZS55MX0ge2UueDB9LDAgJyArXHJcbiAgICAgICAgICAnMCwte2UueTF9IHtlLngxfSwwIDAsLXtlLnkwfSAte2UueDF9LDAgMCwte2UueTF9IC17ZS54MH0sMCB6JyxcclxuICAgICAgICBoZWlnaHQ6IDMwLFxyXG4gICAgICAgIHdpZHRoOiAgMzAsXHJcbiAgICAgICAgaGVpZ2h0RWxlbWVudHM6IFsgNSwgMTIuNSBdLFxyXG4gICAgICAgIHdpZHRoRWxlbWVudHM6IFsgNSwgMTIuNSBdXHJcbiAgICAgIH0sXHJcbiAgICAgICdHQVRFV0FZX0VWRU5UX0JBU0VEJzoge1xyXG4gICAgICAgIGQ6J20ge214fSx7bXl9IHtlLngwfSx7ZS55MH0ge2UueDB9LHtlLnkxfSB7ZS54MX0se2UueTJ9IHtlLngyfSwwIHonLFxyXG4gICAgICAgIGhlaWdodDogMTEsXHJcbiAgICAgICAgd2lkdGg6ICAxMSxcclxuICAgICAgICBoZWlnaHRFbGVtZW50czogWyAtNiwgNiwgMTIsIC0xMiBdLFxyXG4gICAgICAgIHdpZHRoRWxlbWVudHM6IFsgOSwgLTMsIC0xMiBdXHJcbiAgICAgIH0sXHJcbiAgICAgICdHQVRFV0FZX0NPTVBMRVgnOiB7XHJcbiAgICAgICAgZDonbSB7bXh9LHtteX0gMCx7ZS55MH0gLXtlLngwfSwte2UueTF9IC17ZS54MX0se2UueTJ9IHtlLngwfSx7ZS55MX0gLXtlLngyfSwwIDAse2UueTN9ICcgK1xyXG4gICAgICAgICAgJ3tlLngyfSwwICAte2UueDB9LHtlLnkxfSBsIHtlLngxfSx7ZS55Mn0ge2UueDB9LC17ZS55MX0gMCx7ZS55MH0ge2UueDN9LDAgMCwte2UueTB9IHtlLngwfSx7ZS55MX0gJyArXHJcbiAgICAgICAgICAne2UueDF9LC17ZS55Mn0gLXtlLngwfSwte2UueTF9IHtlLngyfSwwIDAsLXtlLnkzfSAte2UueDJ9LDAge2UueDB9LC17ZS55MX0gLXtlLngxfSwte2UueTJ9ICcgK1xyXG4gICAgICAgICAgJy17ZS54MH0se2UueTF9IDAsLXtlLnkwfSAte2UueDN9LDAgeicsXHJcbiAgICAgICAgaGVpZ2h0OiAxNy4xMjUsXHJcbiAgICAgICAgd2lkdGg6ICAxNy4xMjUsXHJcbiAgICAgICAgaGVpZ2h0RWxlbWVudHM6IFsgNC44NzUsIDMuNDM3NSwgMi4xMjUsIDMgXSxcclxuICAgICAgICB3aWR0aEVsZW1lbnRzOiBbIDMuNDM3NSwgMi4xMjUsIDQuODc1LCAzIF1cclxuICAgICAgfSxcclxuICAgICAgJ0RBVEFfT0JKRUNUX1BBVEgnOiB7XHJcbiAgICAgICAgZDonbSAwLDAge2UueDF9LDAge2UueDB9LHtlLnkwfSAwLHtlLnkxfSAte2UueDJ9LDAgMCwte2UueTJ9IHtlLngxfSwwIDAse2UueTB9IHtlLngwfSwwJyxcclxuICAgICAgICBoZWlnaHQ6IDYxLFxyXG4gICAgICAgIHdpZHRoOiAgNTEsXHJcbiAgICAgICAgaGVpZ2h0RWxlbWVudHM6IFsgMTAsIDUwLCA2MCBdLFxyXG4gICAgICAgIHdpZHRoRWxlbWVudHM6IFsgMTAsIDQwLCA1MCwgNjAgXVxyXG4gICAgICB9LFxyXG4gICAgICAnREFUQV9PQkpFQ1RfQ09MTEVDVElPTl9QQVRIJzoge1xyXG4gICAgICAgIGQ6ICdte214fSx7bXl9IG0gMywyIGwgMCwxMCBtIDMsLTEwIGwgMCwxMCBtIDMsLTEwIGwgMCwxMCcsXHJcbiAgICAgICAgaGVpZ2h0OiAxMCxcclxuICAgICAgICB3aWR0aDogMTAsXHJcbiAgICAgICAgaGVpZ2h0RWxlbWVudHM6IFtdLFxyXG4gICAgICAgIHdpZHRoRWxlbWVudHM6IFtdXHJcbiAgICAgIH0sXHJcbiAgICAgICdEQVRBX0FSUk9XJzoge1xyXG4gICAgICAgIGQ6J20gNSw5IDksMCAwLC0zIDUsNSAtNSw1IDAsLTMgLTksMCB6JyxcclxuICAgICAgICBoZWlnaHQ6IDYxLFxyXG4gICAgICAgIHdpZHRoOiAgNTEsXHJcbiAgICAgICAgaGVpZ2h0RWxlbWVudHM6IFtdLFxyXG4gICAgICAgIHdpZHRoRWxlbWVudHM6IFtdXHJcbiAgICAgIH0sXHJcbiAgICAgICdEQVRBX1NUT1JFJzoge1xyXG4gICAgICAgIGQ6J20gIHtteH0se215fSAnICtcclxuICAgICAgICAgICdsICAwLHtlLnkyfSAnICtcclxuICAgICAgICAgICdjICB7ZS54MH0se2UueTF9IHtlLngxfSx7ZS55MX0gIHtlLngyfSwwICcgK1xyXG4gICAgICAgICAgJ2wgIDAsLXtlLnkyfSAnICtcclxuICAgICAgICAgICdjIC17ZS54MH0sLXtlLnkxfSAte2UueDF9LC17ZS55MX0gLXtlLngyfSwwJyArXHJcbiAgICAgICAgICAnYyAge2UueDB9LHtlLnkxfSB7ZS54MX0se2UueTF9ICB7ZS54Mn0sMCAnICtcclxuICAgICAgICAgICdtICAte2UueDJ9LHtlLnkwfScgK1xyXG4gICAgICAgICAgJ2MgIHtlLngwfSx7ZS55MX0ge2UueDF9LHtlLnkxfSB7ZS54Mn0sMCcgK1xyXG4gICAgICAgICAgJ20gIC17ZS54Mn0se2UueTB9JyArXHJcbiAgICAgICAgICAnYyAge2UueDB9LHtlLnkxfSB7ZS54MX0se2UueTF9ICB7ZS54Mn0sMCcsXHJcbiAgICAgICAgaGVpZ2h0OiA2MSxcclxuICAgICAgICB3aWR0aDogIDYxLFxyXG4gICAgICAgIGhlaWdodEVsZW1lbnRzOiBbIDcsIDEwLCA0NSBdLFxyXG4gICAgICAgIHdpZHRoRWxlbWVudHM6ICBbIDIsIDU4LCA2MCBdXHJcbiAgICAgIH0sXHJcbiAgICAgICdURVhUX0FOTk9UQVRJT04nOiB7XHJcbiAgICAgICAgZDogJ20ge214fSwge215fSBtIDEwLDAgbCAtMTAsMCBsIDAse2UueTB9IGwgMTAsMCcsXHJcbiAgICAgICAgaGVpZ2h0OiAzMCxcclxuICAgICAgICB3aWR0aDogMTAsXHJcbiAgICAgICAgaGVpZ2h0RWxlbWVudHM6IFsgMzAgXSxcclxuICAgICAgICB3aWR0aEVsZW1lbnRzOiBbIDEwIF1cclxuICAgICAgfSxcclxuICAgICAgJ01BUktFUl9TVUJfUFJPQ0VTUyc6IHtcclxuICAgICAgICBkOiAnbXtteH0se215fSBtIDcsMiBsIDAsMTAgbSAtNSwtNSBsIDEwLDAnLFxyXG4gICAgICAgIGhlaWdodDogMTAsXHJcbiAgICAgICAgd2lkdGg6IDEwLFxyXG4gICAgICAgIGhlaWdodEVsZW1lbnRzOiBbXSxcclxuICAgICAgICB3aWR0aEVsZW1lbnRzOiBbXVxyXG4gICAgICB9LFxyXG4gICAgICAnTUFSS0VSX1BBUkFMTEVMJzoge1xyXG4gICAgICAgIGQ6ICdte214fSx7bXl9IG0gMywyIGwgMCwxMCBtIDMsLTEwIGwgMCwxMCBtIDMsLTEwIGwgMCwxMCcsXHJcbiAgICAgICAgaGVpZ2h0OiAxMCxcclxuICAgICAgICB3aWR0aDogMTAsXHJcbiAgICAgICAgaGVpZ2h0RWxlbWVudHM6IFtdLFxyXG4gICAgICAgIHdpZHRoRWxlbWVudHM6IFtdXHJcbiAgICAgIH0sXHJcbiAgICAgICdNQVJLRVJfU0VRVUVOVElBTCc6IHtcclxuICAgICAgICBkOiAnbXtteH0se215fSBtIDAsMyBsIDEwLDAgbSAtMTAsMyBsIDEwLDAgbSAtMTAsMyBsIDEwLDAnLFxyXG4gICAgICAgIGhlaWdodDogMTAsXHJcbiAgICAgICAgd2lkdGg6IDEwLFxyXG4gICAgICAgIGhlaWdodEVsZW1lbnRzOiBbXSxcclxuICAgICAgICB3aWR0aEVsZW1lbnRzOiBbXVxyXG4gICAgICB9LFxyXG4gICAgICAnTUFSS0VSX0NPTVBFTlNBVElPTic6IHtcclxuICAgICAgICBkOiAnbSB7bXh9LHtteX0gNywtNSAwLDEwIHogbSA3LjEsLTAuMyA2LjksLTQuNyAwLDEwIC02LjksLTQuNyB6JyxcclxuICAgICAgICBoZWlnaHQ6IDEwLFxyXG4gICAgICAgIHdpZHRoOiAyMSxcclxuICAgICAgICBoZWlnaHRFbGVtZW50czogW10sXHJcbiAgICAgICAgd2lkdGhFbGVtZW50czogW11cclxuICAgICAgfSxcclxuICAgICAgJ01BUktFUl9MT09QJzoge1xyXG4gICAgICAgIGQ6ICdtIHtteH0se215fSBjIDMuNTI2OTc5LDAgNi4zODYxNjEsLTIuODI5ODU4IDYuMzg2MTYxLC02LjMyMDY2MSAwLC0zLjQ5MDgwNiAtMi44NTkxODIsLTYuMzIwNjYxICcgK1xyXG4gICAgICAgICAgJy02LjM4NjE2MSwtNi4zMjA2NjEgLTMuNTI2OTc4LDAgLTYuMzg2MTYsMi44Mjk4NTUgLTYuMzg2MTYsNi4zMjA2NjEgMCwxLjc0NTQwMiAnICtcclxuICAgICAgICAgICcwLjcxNDc5NywzLjMyNTU2NyAxLjg3MDQ2Myw0LjQ2OTM4MSAwLjU3NzgzNCwwLjU3MTkwOCAxLjI2NTg4NSwxLjAzNDcyOCAyLjAyOTkxNiwxLjM1NDU3ICcgK1xyXG4gICAgICAgICAgJ2wgLTAuNzE4MTYzLC0zLjkwOTc5MyBtIDAuNzE4MTYzLDMuOTA5NzkzIC0zLjg4NTIxMSwwLjgwMjkwMicsXHJcbiAgICAgICAgaGVpZ2h0OiAxMy45LFxyXG4gICAgICAgIHdpZHRoOiAxMy43LFxyXG4gICAgICAgIGhlaWdodEVsZW1lbnRzOiBbXSxcclxuICAgICAgICB3aWR0aEVsZW1lbnRzOiBbXVxyXG4gICAgICB9LFxyXG4gICAgICAnTUFSS0VSX0FESE9DJzoge1xyXG4gICAgICAgIGQ6ICdtIHtteH0se215fSBtIDAuODQ0NjEsMi42NDQxMSBjIDEuMDU1MzMsLTEuMjM3ODA5OTYgMi42NDMzNywtMi4wNzg4MiA0LjI5NjUzLC0xLjk3OTk3OTk2IDIuMDUxNjMsMC4wODA1ICcgK1xyXG4gICAgICAgICAgJzMuODU1NzksMS4xNTgwMyA1Ljc2MDgyLDEuNzkxMDcgMS4wNjM4NSwwLjM0MTM5OTk2IDIuMjQ0NTQsMC4xNDM4IDMuMTg3NTksLTAuNDM3NjcgMC42MTc0MywtMC4zMzY0MiAnICtcclxuICAgICAgICAgICcxLjI3NzUsLTAuNjQwNzggMS43NTQyLC0xLjE3NTExIDAsMC41NjAyMyAwLDEuMTIwNDYgMCwxLjY4MDcgLTAuOTg3MDYsMC45NjIzNzk5NiAtMi4yOTc5MiwxLjYyMzkzOTk2ICcgK1xyXG4gICAgICAgICAgJy0zLjY5MTgsMS42NjE4MTk5NiAtMS4yNDQ1OSwwLjA5MjcgLTIuNDY2NzEsLTAuMjQ5MSAtMy41OTUwNSwtMC43NDgxMiAtMS4zNTc4OSwtMC41NTk2NSAnICtcclxuICAgICAgICAgICctMi43NTEzMywtMS4zMzQzNjk5NiAtNC4yNzAyNywtMS4xODEyMTk5NiAtMS4zNzc0MSwwLjE0NjAxIC0yLjQxODQyLDEuMTM2ODU5OTYgLTMuNDQyODgsMS45Njc4Mjk5NiB6JyxcclxuICAgICAgICBoZWlnaHQ6IDQsXHJcbiAgICAgICAgd2lkdGg6IDE1LFxyXG4gICAgICAgIGhlaWdodEVsZW1lbnRzOiBbXSxcclxuICAgICAgICB3aWR0aEVsZW1lbnRzOiBbXVxyXG4gICAgICB9LFxyXG4gICAgICAnVEFTS19UWVBFX1NFTkQnOiB7XHJcbiAgICAgICAgZDogJ20ge214fSx7bXl9IGwgMCx7ZS55MX0gbCB7ZS54MX0sMCBsIDAsLXtlLnkxfSB6IGwge2UueDB9LHtlLnkwfSBsIHtlLngwfSwte2UueTB9JyxcclxuICAgICAgICBoZWlnaHQ6IDE0LFxyXG4gICAgICAgIHdpZHRoOiAgMjEsXHJcbiAgICAgICAgaGVpZ2h0RWxlbWVudHM6IFsgNiwgMTQgXSxcclxuICAgICAgICB3aWR0aEVsZW1lbnRzOiBbIDEwLjUsIDIxIF1cclxuICAgICAgfSxcclxuICAgICAgJ1RBU0tfVFlQRV9TQ1JJUFQnOiB7XHJcbiAgICAgICAgZDogJ20ge214fSx7bXl9IGMgOS45NjY1NTMsLTYuMjcyNzYgLTguMDAwOTI2LC03LjkxOTMyIDIuOTY4OTY4LC0xNC45MzggbCAtOC44MDI3MjgsMCAnICtcclxuICAgICAgICAgICdjIC0xMC45Njk4OTQsNy4wMTg2OCA2Ljk5NzU4NSw4LjY2NTI0IC0yLjk2ODk2NywxNC45MzggeiAnICtcclxuICAgICAgICAgICdtIC03LC0xMiBsIDUsMCAnICtcclxuICAgICAgICAgICdtIC00LjUsMyBsIDQuNSwwICcgK1xyXG4gICAgICAgICAgJ20gLTMsMyBsIDUsMCcgK1xyXG4gICAgICAgICAgJ20gLTQsMyBsIDUsMCcsXHJcbiAgICAgICAgaGVpZ2h0OiAxNSxcclxuICAgICAgICB3aWR0aDogIDEyLjYsXHJcbiAgICAgICAgaGVpZ2h0RWxlbWVudHM6IFsgNiwgMTQgXSxcclxuICAgICAgICB3aWR0aEVsZW1lbnRzOiBbIDEwLjUsIDIxIF1cclxuICAgICAgfSxcclxuICAgICAgJ1RBU0tfVFlQRV9VU0VSXzEnOiB7XHJcbiAgICAgICAgZDogJ20ge214fSx7bXl9IGMgMC45MDksLTAuODQ1IDEuNTk0LC0yLjA0OSAxLjU5NCwtMy4zODUgMCwtMi41NTQgLTEuODA1LC00LjYyMTk5OTk5ICcgK1xyXG4gICAgICAgICAgJy00LjM1NywtNC42MjE5OTk5OSAtMi41NTE5OTk5OCwwIC00LjI4Nzk5OTk4LDIuMDY3OTk5OTkgLTQuMjg3OTk5OTgsNC42MjE5OTk5OSAwLDEuMzQ4ICcgK1xyXG4gICAgICAgICAgJzAuOTc0LDIuNTYyIDEuODk1OTk5OTgsMy40MDUgLTAuNTI4OTk5OTgsMC4xODcgLTUuNjY5LDIuMDk3IC01Ljc5NCw0Ljc1NjAwMDUgdiA2LjcxOCAnICtcclxuICAgICAgICAgICdoIDE3IHYgLTYuNzE4IGMgMCwtMi4yOTgwMDA1IC01LjUyNzk5OTYsLTQuNTk1MDAwNSAtNi4wNTA5OTk2LC00Ljc3NjAwMDUgeicgK1xyXG4gICAgICAgICAgJ20gLTgsNiBsIDAsNS41IG0gMTEsMCBsIDAsLTUnXHJcbiAgICAgIH0sXHJcbiAgICAgICdUQVNLX1RZUEVfVVNFUl8yJzoge1xyXG4gICAgICAgIGQ6ICdtIHtteH0se215fSBtIDIuMTYyLDEuMDA5IGMgMCwyLjQ0NzAwMDUgLTIuMTU4LDQuNDMxMDAwNSAtNC44MjEsNC40MzEwMDA1ICcgK1xyXG4gICAgICAgICAgJy0yLjY2NDk5OTk4LDAgLTQuODIyLC0xLjk4MSAtNC44MjIsLTQuNDMxMDAwNSAnXHJcbiAgICAgIH0sXHJcbiAgICAgICdUQVNLX1RZUEVfVVNFUl8zJzoge1xyXG4gICAgICAgIGQ6ICdtIHtteH0se215fSBtIC02LjksLTMuODAgYyAwLDAgMi4yNTA5OTk5OCwtMi4zNTggNC4yNzM5OTk5OCwtMS4xNzcgMi4wMjQsMS4xODEgNC4yMjEsMS41MzcgJyArXHJcbiAgICAgICAgICAnNC4xMjQsMC45NjUgLTAuMDk4LC0wLjU3IC0wLjExNywtMy43OTA5OTk5OSAtNC4xOTEsLTQuMTM1OTk5OTkgLTMuNTc0OTk5OTgsMC4wMDEgJyArXHJcbiAgICAgICAgICAnLTQuMjA3OTk5OTgsMy4zNjY5OTk5OSAtNC4yMDY5OTk5OCw0LjM0Nzk5OTk5IHonXHJcbiAgICAgIH0sXHJcbiAgICAgICdUQVNLX1RZUEVfTUFOVUFMJzoge1xyXG4gICAgICAgIGQ6ICdtIHtteH0se215fSBjIDAuMjM0LC0wLjAxIDUuNjA0LDAuMDA4IDguMDI5LDAuMDA0IDAuODA4LDAgMS4yNzEsLTAuMTcyIDEuNDE3LC0wLjc1MiAwLjIyNywtMC44OTggJyArXHJcbiAgICAgICAgICAnLTAuMzM0LC0xLjMxNCAtMS4zMzgsLTEuMzE2IC0yLjQ2NywtMC4wMSAtNy44ODYsLTAuMDA0IC04LjEwOCwtMC4wMDQgLTAuMDE0LC0wLjA3OSAwLjAxNiwtMC41MzMgMCwtMC42MSAnICtcclxuICAgICAgICAgICcwLjE5NSwtMC4wNDIgOC41MDcsMC4wMDYgOS42MTYsMC4wMDIgMC44NzcsLTAuMDA3IDEuMzUsLTAuNDM4IDEuMzUzLC0xLjIwOCAwLjAwMywtMC43NjggLTAuNDc5LC0xLjA5ICcgK1xyXG4gICAgICAgICAgJy0xLjM1LC0xLjA5MSAtMi45NjgsLTAuMDAyIC05LjYxOSwtMC4wMTMgLTkuNjE5LC0wLjAxMyB2IC0wLjU5MSBjIDAsMCA1LjA1MiwtMC4wMTYgNy4yMjUsLTAuMDE2ICcgK1xyXG4gICAgICAgICAgJzAuODg4LC0wLjAwMiAxLjM1NCwtMC40MTYgMS4zNTEsLTEuMTkzIC0wLjAwNiwtMC43NjEgLTAuNDkyLC0xLjE5NiAtMS4zNjEsLTEuMTk2IC0zLjQ3MywtMC4wMDUgJyArXHJcbiAgICAgICAgICAnLTEwLjg2LC0wLjAwMyAtMTEuMDgyOTk5NSwtMC4wMDMgLTAuMDIyLC0wLjA0NyAtMC4wNDUsLTAuMDk0IC0wLjA2OSwtMC4xMzkgMC4zOTM5OTk1LC0wLjMxOSAnICtcclxuICAgICAgICAgICcyLjA0MDk5OTUsLTEuNjI2IDIuNDE0OTk5NSwtMi4wMTcgMC40NjksLTAuNDg3MDAwNSAwLjUxOSwtMS4xNjUwMDA1IDAuMTYyLC0xLjYwNDAwMDUgLTAuNDE0LC0wLjUxMSAnICtcclxuICAgICAgICAgICctMC45NzMsLTAuNSAtMS40OCwtMC4yMzYgLTEuNDYwOTk5NSwwLjc2NCAtNi41OTk5OTk1LDMuNjQzMDAwNSAtNy43MzI5OTk1LDQuMjcxMDAwNSAtMC45LDAuNDk5ICcgK1xyXG4gICAgICAgICAgJy0xLjUxNiwxLjI1MyAtMS44ODIsMi4xOSAtMC4zNzAwMDAwMiwwLjk1IC0wLjE3LDIuMDEgLTAuMTY2LDIuOTc5IDAuMDA0LDAuNzE4IC0wLjI3MzAwMDAyLDEuMzQ1ICcgK1xyXG4gICAgICAgICAgJy0wLjA1NSwyLjA2MyAwLjYyOSwyLjA4NyAyLjQyNSwzLjMxMiA0Ljg1OSwzLjMxOCA0LjYxNzk5OTUsMC4wMTQgOS4yMzc5OTk1LC0wLjEzOSAxMy44NTY5OTk1LC0wLjE1OCAnICtcclxuICAgICAgICAgICcwLjc1NSwtMC4wMDQgMS4xNzEsLTAuMzAxIDEuMTgyLC0xLjAzMyAwLjAxMiwtMC43NTQgLTAuNDIzLC0wLjk2OSAtMS4xODMsLTAuOTczIC0xLjc3OCwtMC4wMSAnICtcclxuICAgICAgICAgICctNS44MjQsLTAuMDA0IC02LjA0LC0wLjAwNCAxMGUtNCwtMC4wODQgMC4wMDMsLTAuNTg2IDEwZS00LC0wLjY3IHonXHJcbiAgICAgIH0sXHJcbiAgICAgICdUQVNLX1RZUEVfSU5TVEFOVElBVElOR19TRU5EJzoge1xyXG4gICAgICAgIGQ6ICdtIHtteH0se215fSBsIDAsOC40IGwgMTIuNiwwIGwgMCwtOC40IHogbCA2LjMsMy42IGwgNi4zLC0zLjYnXHJcbiAgICAgIH0sXHJcbiAgICAgICdUQVNLX1RZUEVfU0VSVklDRSc6IHtcclxuICAgICAgICBkOiAnbSB7bXh9LHtteX0gdiAtMS43MTMzNSBjIDAuMzUyMzI2LC0wLjA3MDUgMC43MDM5MzIsLTAuMTc4MzggMS4wNDc2MjgsLTAuMzIxMzMgJyArXHJcbiAgICAgICAgICAnMC4zNDQ0MTYsLTAuMTQ0NjUgMC42NjU4MjIsLTAuMzIxMzMgMC45NjYzNzcsLTAuNTIxNDUgbCAxLjE5NDMxLDEuMTgwMDUgMS41Njc0ODcsLTEuNTc2ODggJyArXHJcbiAgICAgICAgICAnLTEuMTk1MDI4LC0xLjE4MDE0IGMgMC40MDMzNzYsLTAuNjEzOTQgMC42ODMwNzksLTEuMjk5MDggMC44MjU0NDcsLTIuMDE4MjQgbCAxLjYyMjEzMywtMC4wMSAnICtcclxuICAgICAgICAgICd2IC0yLjIxOTYgbCAtMS42MzY1MTQsMC4wMSBjIC0wLjA3MzMzLC0wLjM1MTUzIC0wLjE3ODMxOSwtMC43MDAyNCAtMC4zMjM1NjQsLTEuMDQzNzIgJyArXHJcbiAgICAgICAgICAnLTAuMTQ1MjQ0LC0wLjM0NDA2IC0wLjMyMTQwNywtMC42NjQ0IC0wLjUyMjczNSwtMC45NjIxNyBsIDEuMTMxMDM1LC0xLjEzNjMxIC0xLjU4MzMwNSwtMS41NjI5MyAnICtcclxuICAgICAgICAgICctMS4xMjk1OTgsMS4xMzU4OSBjIC0wLjYxNDA1MiwtMC40MDEwOCAtMS4zMDI4ODMsLTAuNjgwOTMgLTIuMDIyNjMzLC0wLjgyMjQ3IGwgMC4wMDkzLC0xLjYxODUyICcgK1xyXG4gICAgICAgICAgJ2ggLTIuMjQxMTczIGwgMC4wMDQyLDEuNjMxMjQgYyAtMC4zNTM3NjMsMC4wNzM2IC0wLjcwNTM2OSwwLjE3OTc3IC0xLjA0OTc4NSwwLjMyMzcxIC0wLjM0NDQxNSwwLjE0NDM3ICcgK1xyXG4gICAgICAgICAgJy0wLjY2NTEwMiwwLjMyMDkyIC0wLjk2MzUwMDYsMC41MjA0NiBsIC0xLjE2OTg2MjgsLTEuMTU4MjMgLTEuNTY2NzY5MSwxLjU3OTIgMS4xNjg0MjY1LDEuMTU2NjkgJyArXHJcbiAgICAgICAgICAnYyAtMC40MDI2NTczLDAuNjEyODMgLTAuNjgzMDgsMS4yOTc5NyAtMC44MjQ3Mjg3LDIuMDE3MTMgbCAtMS42NTg4MDQxLDAuMDAzIHYgMi4yMjE3NCAnICtcclxuICAgICAgICAgICdsIDEuNjcyNDY0OCwtMC4wMDYgYyAwLjA3MzMyNywwLjM1MDc3IDAuMTc5NzU5OCwwLjcwMjQzIDAuMzI0Mjg1MSwxLjA0NDcyIDAuMTQ1MjQyOCwwLjM0NDQ4ICcgK1xyXG4gICAgICAgICAgJzAuMzIxNDA2NCwwLjY2NDQgMC41MjI3MzM5LDAuOTYwNjYgbCAtMS4xOTkzNDMxLDEuMTk3MjMgMS41ODQwMjU2LDEuNTYwMTEgMS4xOTY0NjY4LC0xLjE5MzQ4ICcgK1xyXG4gICAgICAgICAgJ2MgMC42MTQwNTE3LDAuNDAzNDYgMS4zMDI4ODI3LDAuNjgyMzIgMi4wMjMzNTE3LDAuODIzMzEgbCA3LjE5ZS00LDEuNjk4OTIgaCAyLjIyNjg0OCB6ICcgK1xyXG4gICAgICAgICAgJ20gMC4yMjE0NjIsLTMuOTk1NyBjIC0xLjc4ODk0OCwwLjc1MDIgLTMuODU3NiwtMC4wOTI4IC00LjYwOTcwNTUsLTEuODc0MzggLTAuNzUyMTA2NSwtMS43ODMyMSAnICtcclxuICAgICAgICAgICcwLjA5MDU5OCwtMy44NDYyNyAxLjg4MDI2NDUsLTQuNTk2MDQgMS43ODgyMywtMC43NDkzNiAzLjg1Njg4MSwwLjA5MjkgNC42MDg5ODcsMS44NzQzNyAnICtcclxuICAgICAgICAgICcwLjc1MjEwNiwxLjc4MTY1IC0wLjA5MDYsMy44NDYxMiAtMS44Nzk1NDYsNC41OTYwNSB6J1xyXG4gICAgICB9LFxyXG4gICAgICAnVEFTS19UWVBFX1NFUlZJQ0VfRklMTCc6IHtcclxuICAgICAgICBkOiAnbSB7bXh9LHtteX0gYyAtMS43ODg5NDgsMC43NTAyIC0zLjg1NzYsLTAuMDkyOCAtNC42MDk3MDU1LC0xLjg3NDM4IC0wLjc1MjEwNjUsLTEuNzgzMjEgJyArXHJcbiAgICAgICAgICAnMC4wOTA1OTgsLTMuODQ2MjcgMS44ODAyNjQ1LC00LjU5NjA0IDEuNzg4MjMsLTAuNzQ5MzYgMy44NTY4ODEsMC4wOTI5IDQuNjA4OTg3LDEuODc0MzcgJyArXHJcbiAgICAgICAgICAnMC43NTIxMDYsMS43ODE2NSAtMC4wOTA2LDMuODQ2MTIgLTEuODc5NTQ2LDQuNTk2MDUgeidcclxuICAgICAgfSxcclxuICAgICAgJ1RBU0tfVFlQRV9CVVNJTkVTU19SVUxFX0hFQURFUic6IHtcclxuICAgICAgICBkOiAnbSB7bXh9LHtteX0gMCw0IDIwLDAgMCwtNCB6J1xyXG4gICAgICB9LFxyXG4gICAgICAnVEFTS19UWVBFX0JVU0lORVNTX1JVTEVfTUFJTic6IHtcclxuICAgICAgICBkOiAnbSB7bXh9LHtteX0gMCwxMiAyMCwwIDAsLTEyIHonICtcclxuICAgICAgICAgICdtIDAsOCBsIDIwLDAgJyArXHJcbiAgICAgICAgICAnbSAtMTMsLTQgbCAwLDgnXHJcbiAgICAgIH0sXHJcbiAgICAgICdNRVNTQUdFX0ZMT1dfTUFSS0VSJzoge1xyXG4gICAgICAgIGQ6ICdtIHtteH0se215fSBtIC0xMC41ICwtNyBsIDAsMTQgbCAyMSwwIGwgMCwtMTQgeiBsIDEwLjUsNiBsIDEwLjUsLTYnXHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gcmF3IHBhdGggZm9yIHRoZSBnaXZlbiBJRC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aElkXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSByYXcgcGF0aFxyXG4gICAgICovXHJcbiAgICB0aGlzLmdldFJhd1BhdGggPSBmdW5jdGlvbiBnZXRSYXdQYXRoKHBhdGhJZCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXRoTWFwW3BhdGhJZF0uZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2FsZXMgdGhlIHBhdGggdG8gdGhlIGdpdmVuIGhlaWdodCBhbmQgd2lkdGguXHJcbiAgICAgKiA8aDE+VXNlIGNhc2U8L2gxPlxyXG4gICAgICogPHA+VXNlIGNhc2UgaXMgdG8gc2NhbGUgdGhlIGNvbnRlbnQgb2YgZWxlbWVudHMgKGV2ZW50LCBnYXRld2F5cykgYmFzZWRcclxuICAgICAqIG9uIHRoZSBlbGVtZW50IGJvdW5kaW5nIGJveCdzIHNpemUuXHJcbiAgICAgKiA8L3A+XHJcbiAgICAgKiA8aDE+V2h5IG5vdCB0cmFuc2Zvcm08L2gxPlxyXG4gICAgICogPHA+U2NhbGluZyBhIHBhdGggd2l0aCB0cmFuc2Zvcm0oKSB3aWxsIGFsc28gc2NhbGUgdGhlIHN0cm9rZSBhbmQgSUUgZG9lcyBub3Qgc3VwcG9ydFxyXG4gICAgICogdGhlIG9wdGlvbiAnbm9uLXNjYWxpbmctc3Ryb2tlJyB0byBwcmV2ZW50IHRoaXMuXHJcbiAgICAgKiBBbHNvIHRoZXJlIGFyZSB1c2UgY2FzZXMgd2hlcmUgb25seSBzb21lIHBhcnRzIG9mIGEgcGF0aCBzaG91bGQgYmVcclxuICAgICAqIHNjYWxlZC48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhJZCBUaGUgSUQgb2YgdGhlIHBhdGguXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gPHA+XHJcbiAgICAgKiAgIEV4YW1wbGUgcGFyYW0gb2JqZWN0IHNjYWxlcyB0aGUgcGF0aCB0byA2MCUgc2l6ZSBvZiB0aGUgY29udGFpbmVyIChkYXRhLndpZHRoLCBkYXRhLmhlaWdodCkuXHJcbiAgICAgKiAgIDxwcmU+XHJcbiAgICAgKiAgIHtcclxuICAgICAqICAgICB4U2NhbGVGYWN0b3I6IDAuNixcclxuICAgICAqICAgICB5U2NhbGVGYWN0b3I6MC42LFxyXG4gICAgICogICAgIGNvbnRhaW5lcldpZHRoOiBkYXRhLndpZHRoLFxyXG4gICAgICogICAgIGNvbnRhaW5lckhlaWdodDogZGF0YS5oZWlnaHQsXHJcbiAgICAgKiAgICAgcG9zaXRpb246IHtcclxuICAgICAqICAgICAgIG14OiAwLjQ2LFxyXG4gICAgICogICAgICAgbXk6IDAuMixcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqICAgPC9wcmU+XHJcbiAgICAgKiAgIDx1bD5cclxuICAgICAqICAgIDxsaT50YXJnZXRwYXRod2lkdGggPSB4U2NhbGVGYWN0b3IgKiBjb250YWluZXJXaWR0aDwvbGk+XHJcbiAgICAgKiAgICA8bGk+dGFyZ2V0cGF0aGhlaWdodCA9IHlTY2FsZUZhY3RvciAqIGNvbnRhaW5lckhlaWdodDwvbGk+XHJcbiAgICAgKiAgICA8bGk+UG9zaXRpb24gaXMgdXNlZCB0byBzZXQgdGhlIHN0YXJ0aW5nIGNvb3JkaW5hdGUgb2YgdGhlIHBhdGguIE0gaXMgY29tcHV0ZWQ6XHJcbiAgICAgICogICAgPHVsPlxyXG4gICAgICAqICAgICAgPGxpPnBvc2l0aW9uLnggKiBjb250YWluZXJXaWR0aDwvbGk+XHJcbiAgICAgICogICAgICA8bGk+cG9zaXRpb24ueSAqIGNvbnRhaW5lckhlaWdodDwvbGk+XHJcbiAgICAgICogICAgPC91bD5cclxuICAgICAgKiAgICBDZW50ZXIgb2YgdGhlIGNvbnRhaW5lciA8cHJlPiBwb3NpdGlvbjoge1xyXG4gICAgICogICAgICAgbXg6IDAuNSxcclxuICAgICAqICAgICAgIG15OiAwLjUsXHJcbiAgICAgKiAgICAgfTwvcHJlPlxyXG4gICAgICogICAgIFVwcGVyIGxlZnQgY29ybmVyIG9mIHRoZSBjb250YWluZXJcclxuICAgICAqICAgICA8cHJlPiBwb3NpdGlvbjoge1xyXG4gICAgICogICAgICAgbXg6IDAuMCxcclxuICAgICAqICAgICAgIG15OiAwLjAsXHJcbiAgICAgKiAgICAgfTwvcHJlPlxyXG4gICAgICogICAgPC9saT5cclxuICAgICAqICAgPC91bD5cclxuICAgICAqIDwvcD5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHNjYWxlZCBwYXRoXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0U2NhbGVkUGF0aCA9IGZ1bmN0aW9uIGdldFNjYWxlZFBhdGgocGF0aElkLCBwYXJhbSkge1xyXG4gICAgICB2YXIgcmF3UGF0aCA9IHRoaXMucGF0aE1hcFtwYXRoSWRdO1xyXG5cclxuICAgICAgLy8gcG9zaXRpb25pbmdcclxuICAgICAgLy8gY29tcHV0ZSB0aGUgc3RhcnQgcG9pbnQgb2YgdGhlIHBhdGhcclxuICAgICAgdmFyIG14LCBteTtcclxuXHJcbiAgICAgIGlmIChwYXJhbS5hYnNwb3MpIHtcclxuICAgICAgICBteCA9IHBhcmFtLmFic3Bvcy54O1xyXG4gICAgICAgIG15ID0gcGFyYW0uYWJzcG9zLnk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbXggPSBwYXJhbS5jb250YWluZXJXaWR0aCAqIHBhcmFtLnBvc2l0aW9uLm14O1xyXG4gICAgICAgIG15ID0gcGFyYW0uY29udGFpbmVySGVpZ2h0ICogcGFyYW0ucG9zaXRpb24ubXk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IHt9OyAvLyBtYXAgZm9yIHRoZSBzY2FsZWQgY29vcmRpbmF0ZXNcclxuICAgICAgaWYgKHBhcmFtLnBvc2l0aW9uKSB7XHJcblxyXG4gICAgICAgIC8vIHBhdGhcclxuICAgICAgICB2YXIgaGVpZ2h0UmF0aW8gPSAocGFyYW0uY29udGFpbmVySGVpZ2h0IC8gcmF3UGF0aC5oZWlnaHQpICogcGFyYW0ueVNjYWxlRmFjdG9yO1xyXG4gICAgICAgIHZhciB3aWR0aFJhdGlvID0gKHBhcmFtLmNvbnRhaW5lcldpZHRoIC8gcmF3UGF0aC53aWR0aCkgKiBwYXJhbS54U2NhbGVGYWN0b3I7XHJcblxyXG5cclxuICAgICAgICAvLyBBcHBseSBoZWlnaHQgcmF0aW9cclxuICAgICAgICBmb3IgKHZhciBoZWlnaHRJbmRleCA9IDA7IGhlaWdodEluZGV4IDwgcmF3UGF0aC5oZWlnaHRFbGVtZW50cy5sZW5ndGg7IGhlaWdodEluZGV4KyspIHtcclxuICAgICAgICAgIGNvb3JkaW5hdGVzWyd5JyArIGhlaWdodEluZGV4XSA9IHJhd1BhdGguaGVpZ2h0RWxlbWVudHNbaGVpZ2h0SW5kZXhdICogaGVpZ2h0UmF0aW87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcHBseSB3aWR0aCByYXRpb1xyXG4gICAgICAgIGZvciAodmFyIHdpZHRoSW5kZXggPSAwOyB3aWR0aEluZGV4IDwgcmF3UGF0aC53aWR0aEVsZW1lbnRzLmxlbmd0aDsgd2lkdGhJbmRleCsrKSB7XHJcbiAgICAgICAgICBjb29yZGluYXRlc1sneCcgKyB3aWR0aEluZGV4XSA9IHJhd1BhdGgud2lkdGhFbGVtZW50c1t3aWR0aEluZGV4XSAqIHdpZHRoUmF0aW87XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBcHBseSB2YWx1ZSB0byByYXcgcGF0aFxyXG4gICAgICB2YXIgcGF0aCA9IGZvcm1hdChcclxuICAgICAgICByYXdQYXRoLmQsIHtcclxuICAgICAgICAgIG14OiBteCxcclxuICAgICAgICAgIG15OiBteSxcclxuICAgICAgICAgIGU6IGNvb3JkaW5hdGVzXHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gcGF0aDtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbiAgLy8gY29waWVkIGFuZCBhZGp1c3RlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS13ZWJwbGF0Zm9ybS9TbmFwLnN2Zy9ibG9iL21hc3Rlci9zcmMvc3ZnLmpzXHJcbiAgdmFyIHRva2VuUmVnZXggPSAvXFx7KFtee31dKylcXH0vZyxcclxuICAgICAgb2JqTm90YXRpb25SZWdleCA9IC8oPzooPzpefFxcLikoLis/KSg/PVxcW3xcXC58JHxcXCgpfFxcWygnfFwiKSguKz8pXFwyXFxdKShcXChcXCkpPy9nOyAvLyBtYXRjaGVzIC54eHh4eCBvciBbXCJ4eHh4eFwiXSB0byBydW4gb3ZlciBvYmplY3QgcHJvcGVydGllc1xyXG5cclxuICBmdW5jdGlvbiByZXBsYWNlcihhbGwsIGtleSwgb2JqKSB7XHJcbiAgICB2YXIgcmVzID0gb2JqO1xyXG4gICAga2V5LnJlcGxhY2Uob2JqTm90YXRpb25SZWdleCwgZnVuY3Rpb24oYWxsLCBuYW1lLCBxdW90ZSwgcXVvdGVkTmFtZSwgaXNGdW5jKSB7XHJcbiAgICAgIG5hbWUgPSBuYW1lIHx8IHF1b3RlZE5hbWU7XHJcbiAgICAgIGlmIChyZXMpIHtcclxuICAgICAgICBpZiAobmFtZSBpbiByZXMpIHtcclxuICAgICAgICAgIHJlcyA9IHJlc1tuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHlwZW9mIHJlcyA9PSAnZnVuY3Rpb24nICYmIGlzRnVuYyAmJiAocmVzID0gcmVzKCkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJlcyA9IChyZXMgPT0gbnVsbCB8fCByZXMgPT0gb2JqID8gYWxsIDogcmVzKSArICcnO1xyXG5cclxuICAgIHJldHVybiByZXM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmb3JtYXQoc3RyLCBvYmopIHtcclxuICAgIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKHRva2VuUmVnZXgsIGZ1bmN0aW9uKGFsbCwga2V5KSB7XHJcbiAgICAgIHJldHVybiByZXBsYWNlcihhbGwsIGtleSwgb2JqKTtcclxuICAgIH0pO1xyXG4gIH1cblxuICB2YXIgRHJhd01vZHVsZSQxID0ge1xyXG4gICAgX19pbml0X186IFsgJ2JwbW5SZW5kZXJlcicgXSxcclxuICAgIGJwbW5SZW5kZXJlcjogWyAndHlwZScsIEJwbW5SZW5kZXJlciBdLFxyXG4gICAgdGV4dFJlbmRlcmVyOiBbICd0eXBlJywgVGV4dFJlbmRlcmVyIF0sXHJcbiAgICBwYXRoTWFwOiBbICd0eXBlJywgUGF0aE1hcCBdXHJcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGVkZWYgeyB7XG4gICAqICAgW2tleTogc3RyaW5nXTogc3RyaW5nO1xuICAgKiB9IH0gVHJhbnNsYXRlUmVwbGFjZW1lbnRzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBIHNpbXBsZSB0cmFuc2xhdGlvbiBzdHViIHRvIGJlIHVzZWQgZm9yIG11bHRpLWxhbmd1YWdlIHN1cHBvcnRcbiAgICogaW4gZGlhZ3JhbXMuIENhbiBiZSBlYXNpbHkgcmVwbGFjZWQgd2l0aCBhIG1vcmUgc29waGlzdGljYXRlZFxuICAgKiBzb2x1dGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyB1c2UgaXQgaW5zaWRlIGFueSBkaWFncmFtIGNvbXBvbmVudCBieSBpbmplY3RpbmcgYHRyYW5zbGF0ZWAuXG4gICAqXG4gICAqIGZ1bmN0aW9uIE15U2VydmljZSh0cmFuc2xhdGUpIHtcbiAgICogICBhbGVydCh0cmFuc2xhdGUoJ0hFTExPIHt5b3V9JywgeyB5b3U6ICdZb3UhJyB9KSk7XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSB0byBpbnRlcnBvbGF0ZVxuICAgKiBAcGFyYW0ge1RyYW5zbGF0ZVJlcGxhY2VtZW50c30gW3JlcGxhY2VtZW50c10gYSBtYXAgd2l0aCBzdWJzdGl0dXRlc1xuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSB0cmFuc2xhdGVkIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gdHJhbnNsYXRlKHRlbXBsYXRlLCByZXBsYWNlbWVudHMpIHtcblxuICAgIHJlcGxhY2VtZW50cyA9IHJlcGxhY2VtZW50cyB8fCB7fTtcblxuICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKC97KFtefV0rKX0vZywgZnVuY3Rpb24oXywga2V5KSB7XG4gICAgICByZXR1cm4gcmVwbGFjZW1lbnRzW2tleV0gfHwgJ3snICsga2V5ICsgJ30nO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsgaW1wb3J0KCdkaWRpJykuTW9kdWxlRGVjbGFyYXRpb24gfVxuICAgKi9cbiAgdmFyIFRyYW5zbGF0ZU1vZHVsZSA9IHtcbiAgICB0cmFuc2xhdGU6IFsgJ3ZhbHVlJywgdHJhbnNsYXRlIF1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAgICpcbiAgICogQHJldHVybnMge1BvaW50fVxuICAgKi9cbiAgZnVuY3Rpb24gcm91bmRQb2ludChwb2ludCkge1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE1hdGgucm91bmQocG9pbnQueCksXG4gICAgICB5OiBNYXRoLnJvdW5kKHBvaW50LnkpXG4gICAgfTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIGdpdmVuIGJvdW5kcyB0byBhIHsgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0IH0gZGVzY3JpcHRvci5cbiAgICpcbiAgICogQHBhcmFtIHtQb2ludHxSZWN0fSBib3VuZHNcbiAgICpcbiAgICogQHJldHVybiB7UmVjdFRSQkx9XG4gICAqL1xuICBmdW5jdGlvbiBhc1RSQkwoYm91bmRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogYm91bmRzLnksXG4gICAgICByaWdodDogYm91bmRzLnggKyAoYm91bmRzLndpZHRoIHx8IDApLFxuICAgICAgYm90dG9tOiBib3VuZHMueSArIChib3VuZHMuaGVpZ2h0IHx8IDApLFxuICAgICAgbGVmdDogYm91bmRzLnhcbiAgICB9O1xuICB9XG5cblxuICAvKipcbiAgICogQ29udmVydCBhIHsgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0IH0gdG8gYW4gb2JqZWN0cyBib3VuZHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVjdFRSQkx9IHRyYmxcbiAgICpcbiAgICogQHJldHVybiB7UmVjdH1cbiAgICovXG4gIGZ1bmN0aW9uIGFzQm91bmRzKHRyYmwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdHJibC5sZWZ0LFxuICAgICAgeTogdHJibC50b3AsXG4gICAgICB3aWR0aDogdHJibC5yaWdodCAtIHRyYmwubGVmdCxcbiAgICAgIGhlaWdodDogdHJibC5ib3R0b20gLSB0cmJsLnRvcFxuICAgIH07XG4gIH1cblxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pZCBvZiB0aGUgZ2l2ZW4gYm91bmRzIG9yIHBvaW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1BvaW50fFJlY3R9IGJvdW5kc1xuICAgKlxuICAgKiBAcmV0dXJuIHtQb2ludH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEJvdW5kc01pZChib3VuZHMpIHtcbiAgICByZXR1cm4gcm91bmRQb2ludCh7XG4gICAgICB4OiBib3VuZHMueCArIChib3VuZHMud2lkdGggfHwgMCkgLyAyLFxuICAgICAgeTogYm91bmRzLnkgKyAoYm91bmRzLmhlaWdodCB8fCAwKSAvIDJcbiAgICB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWlkIG9mIHRoZSBnaXZlbiBDb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAgICpcbiAgICogQHJldHVybiB7UG9pbnR9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRDb25uZWN0aW9uTWlkKGNvbm5lY3Rpb24pIHtcbiAgICB2YXIgd2F5cG9pbnRzID0gY29ubmVjdGlvbi53YXlwb2ludHM7XG5cbiAgICAvLyBjYWxjdWxhdGUgdG90YWwgbGVuZ3RoIGFuZCBsZW5ndGggb2YgZWFjaCBzZWdtZW50XG4gICAgdmFyIHBhcnRzID0gd2F5cG9pbnRzLnJlZHVjZShmdW5jdGlvbihwYXJ0cywgcG9pbnQsIGluZGV4KSB7XG5cbiAgICAgIHZhciBsYXN0UG9pbnQgPSB3YXlwb2ludHNbaW5kZXggLSAxXTtcblxuICAgICAgaWYgKGxhc3RQb2ludCkge1xuICAgICAgICB2YXIgbGFzdFBhcnQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcblxuICAgICAgICB2YXIgc3RhcnRMZW5ndGggPSBsYXN0UGFydCAmJiBsYXN0UGFydC5lbmRMZW5ndGggfHwgMDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGRpc3RhbmNlKGxhc3RQb2ludCwgcG9pbnQpO1xuXG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHN0YXJ0OiBsYXN0UG9pbnQsXG4gICAgICAgICAgZW5kOiBwb2ludCxcbiAgICAgICAgICBzdGFydExlbmd0aDogc3RhcnRMZW5ndGgsXG4gICAgICAgICAgZW5kTGVuZ3RoOiBzdGFydExlbmd0aCArIGxlbmd0aCxcbiAgICAgICAgICBsZW5ndGg6IGxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH0sIFtdKTtcblxuICAgIHZhciB0b3RhbExlbmd0aCA9IHBhcnRzLnJlZHVjZShmdW5jdGlvbihsZW5ndGgsIHBhcnQpIHtcbiAgICAgIHJldHVybiBsZW5ndGggKyBwYXJ0Lmxlbmd0aDtcbiAgICB9LCAwKTtcblxuICAgIC8vIGZpbmQgd2hpY2ggc2VnZW1lbnQgY29udGFpbnMgbWlkZGxlIHBvaW50XG4gICAgdmFyIG1pZExlbmd0aCA9IHRvdGFsTGVuZ3RoIC8gMjtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbWlkU2VnbWVudCA9IHBhcnRzW2ldO1xuXG4gICAgd2hpbGUgKG1pZFNlZ21lbnQuZW5kTGVuZ3RoIDwgbWlkTGVuZ3RoKSB7XG4gICAgICBtaWRTZWdtZW50ID0gcGFydHNbKytpXTtcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVsYXRpdmUgcG9zaXRpb24gb24gbWlkIHNlZ21lbnRcbiAgICB2YXIgc2VnbWVudFByb2dyZXNzID0gKG1pZExlbmd0aCAtIG1pZFNlZ21lbnQuc3RhcnRMZW5ndGgpIC8gbWlkU2VnbWVudC5sZW5ndGg7XG5cbiAgICB2YXIgbWlkUG9pbnQgPSB7XG4gICAgICB4OiBtaWRTZWdtZW50LnN0YXJ0LnggKyAobWlkU2VnbWVudC5lbmQueCAtIG1pZFNlZ21lbnQuc3RhcnQueCkgKiBzZWdtZW50UHJvZ3Jlc3MsXG4gICAgICB5OiBtaWRTZWdtZW50LnN0YXJ0LnkgKyAobWlkU2VnbWVudC5lbmQueSAtIG1pZFNlZ21lbnQuc3RhcnQueSkgKiBzZWdtZW50UHJvZ3Jlc3NcbiAgICB9O1xuXG4gICAgcmV0dXJuIG1pZFBvaW50O1xuICB9XG5cblxuICAvKipcbiAgICogR2V0IHRoZSBtaWQgb2YgdGhlIGdpdmVuIEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtQb2ludH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldE1pZChlbGVtZW50KSB7XG4gICAgaWYgKGlzQ29ubmVjdGlvbihlbGVtZW50KSkge1xuICAgICAgcmV0dXJuIGdldENvbm5lY3Rpb25NaWQoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldEJvdW5kc01pZChlbGVtZW50KTtcbiAgfVxuXG4gIC8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGEueCAtIGIueCwgMikgKyBNYXRoLnBvdyhhLnkgLSBiLnksIDIpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVsZW1lbnRUb1N0cmluZyhlKSB7XHJcbiAgICBpZiAoIWUpIHtcclxuICAgICAgcmV0dXJuICc8bnVsbD4nO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAnPCcgKyBlLiR0eXBlICsgKGUuaWQgPyAnIGlkPVwiJyArIGUuaWQgOiAnJykgKyAnXCIgLz4nO1xyXG4gIH1cblxuICAvKipcclxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCdkaWFncmFtLWpzL2xpYi9jb3JlL0NhbnZhcycpLmRlZmF1bHR9IENhbnZhc1xyXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJ2RpYWdyYW0tanMvbGliL2NvcmUvRWxlbWVudFJlZ2lzdHJ5JykuZGVmYXVsdH0gRWxlbWVudFJlZ2lzdHJ5XHJcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnZGlhZ3JhbS1qcy9saWIvY29yZS9FdmVudEJ1cycpLmRlZmF1bHR9IEV2ZW50QnVzXHJcbiAgICpcclxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9mZWF0dXJlcy9tb2RlbGluZy9FbGVtZW50RmFjdG9yeScpLmRlZmF1bHR9IEVsZW1lbnRGYWN0b3J5XHJcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vZHJhdy9UZXh0UmVuZGVyZXInKS5kZWZhdWx0fSBUZXh0UmVuZGVyZXJcclxuICAgKlxyXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL21vZGVsL1R5cGVzJykuRWxlbWVudH0gRWxlbWVudFxyXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL21vZGVsL1R5cGVzJykuTGFiZWx9IExhYmVsXHJcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vbW9kZWwvVHlwZXMnKS5TaGFwZX0gU2hhcGVcclxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9tb2RlbC9UeXBlcycpLkNvbm5lY3Rpb259IENvbm5lY3Rpb25cclxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9tb2RlbC9UeXBlcycpLlJvb3R9IFJvb3RcclxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9tb2RlbC9UeXBlcycpLk1vZGRsZUVsZW1lbnR9IE1vZGRsZUVsZW1lbnRcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBzZW1hbnRpY1xyXG4gICAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gZGlcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJzPW51bGxdXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZWxlbWVudERhdGEoc2VtYW50aWMsIGRpLCBhdHRycykge1xyXG4gICAgcmV0dXJuIGFzc2lnbiQxKHtcclxuICAgICAgaWQ6IHNlbWFudGljLmlkLFxyXG4gICAgICB0eXBlOiBzZW1hbnRpYy4kdHlwZSxcclxuICAgICAgYnVzaW5lc3NPYmplY3Q6IHNlbWFudGljLFxyXG4gICAgICBkaTogZGlcclxuICAgIH0sIGF0dHJzKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFdheXBvaW50cyhkaSwgc291cmNlLCB0YXJnZXQpIHtcclxuXHJcbiAgICB2YXIgd2F5cG9pbnRzID0gZGkud2F5cG9pbnQ7XHJcblxyXG4gICAgaWYgKCF3YXlwb2ludHMgfHwgd2F5cG9pbnRzLmxlbmd0aCA8IDIpIHtcclxuICAgICAgcmV0dXJuIFsgZ2V0TWlkKHNvdXJjZSksIGdldE1pZCh0YXJnZXQpIF07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHdheXBvaW50cy5tYXAoZnVuY3Rpb24ocCkge1xyXG4gICAgICByZXR1cm4geyB4OiBwLngsIHk6IHAueSB9O1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBub3RZZXREcmF3bihzZW1hbnRpYywgcmVmU2VtYW50aWMsIHByb3BlcnR5KSB7XHJcbiAgICByZXR1cm4gbmV3IEVycm9yKFxyXG4gICAgICBgZWxlbWVudCAkeyBlbGVtZW50VG9TdHJpbmcocmVmU2VtYW50aWMpIH0gcmVmZXJlbmNlZCBieSAkeyBlbGVtZW50VG9TdHJpbmcoc2VtYW50aWMpIH0jJHsgcHJvcGVydHkgfSBub3QgeWV0IGRyYXduYFxyXG4gICAgKTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBBbiBpbXBvcnRlciB0aGF0IGFkZHMgYnBtbiBlbGVtZW50cyB0byB0aGUgY2FudmFzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xyXG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcclxuICAgKiBAcGFyYW0ge0VsZW1lbnRGYWN0b3J5fSBlbGVtZW50RmFjdG9yeVxyXG4gICAqIEBwYXJhbSB7RWxlbWVudFJlZ2lzdHJ5fSBlbGVtZW50UmVnaXN0cnlcclxuICAgKiBAcGFyYW0ge1RleHRSZW5kZXJlcn0gdGV4dFJlbmRlcmVyXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gQnBtbkltcG9ydGVyKFxyXG4gICAgICBldmVudEJ1cywgY2FudmFzLCBlbGVtZW50RmFjdG9yeSxcclxuICAgICAgZWxlbWVudFJlZ2lzdHJ5LCB0ZXh0UmVuZGVyZXIpIHtcclxuXHJcbiAgICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xyXG4gICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xyXG4gICAgdGhpcy5fZWxlbWVudEZhY3RvcnkgPSBlbGVtZW50RmFjdG9yeTtcclxuICAgIHRoaXMuX2VsZW1lbnRSZWdpc3RyeSA9IGVsZW1lbnRSZWdpc3RyeTtcclxuICAgIHRoaXMuX3RleHRSZW5kZXJlciA9IHRleHRSZW5kZXJlcjtcclxuICB9XHJcblxyXG4gIEJwbW5JbXBvcnRlci4kaW5qZWN0ID0gW1xyXG4gICAgJ2V2ZW50QnVzJyxcclxuICAgICdjYW52YXMnLFxyXG4gICAgJ2VsZW1lbnRGYWN0b3J5JyxcclxuICAgICdlbGVtZW50UmVnaXN0cnknLFxyXG4gICAgJ3RleHRSZW5kZXJlcidcclxuICBdO1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgQlBNTiBlbGVtZW50IChzZW1hbnRpYykgdG8gdGhlIGNhbnZhcyBtYWtpbmcgaXQgYSBjaGlsZCBvZiB0aGVcclxuICAgKiBnaXZlbiBwYXJlbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR9IHNlbWFudGljXHJcbiAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBkaVxyXG4gICAqIEBwYXJhbSB7U2hhcGV9IHBhcmVudEVsZW1lbnRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1NoYXBlIHwgUm9vdCB8IENvbm5lY3Rpb259XHJcbiAgICovXHJcbiAgQnBtbkltcG9ydGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihzZW1hbnRpYywgZGksIHBhcmVudEVsZW1lbnQpIHtcclxuICAgIHZhciBlbGVtZW50LFxyXG4gICAgICAgIGhpZGRlbjtcclxuXHJcbiAgICB2YXIgcGFyZW50SW5kZXg7XHJcblxyXG4gICAgLy8gUk9PVCBFTEVNRU5UXHJcbiAgICAvLyBoYW5kbGUgdGhlIHNwZWNpYWwgY2FzZSB0aGF0IHdlIGRlYWwgd2l0aCBhXHJcbiAgICAvLyBpbnZpc2libGUgcm9vdCBlbGVtZW50IChwcm9jZXNzLCBzdWJwcm9jZXNzIG9yIGNvbGxhYm9yYXRpb24pXHJcbiAgICBpZiAoaXMkMShkaSwgJ2JwbW5kaTpCUE1OUGxhbmUnKSkge1xyXG5cclxuICAgICAgdmFyIGF0dHJzID0gaXMkMShzZW1hbnRpYywgJ2JwbW46U3ViUHJvY2VzcycpXHJcbiAgICAgICAgPyB7IGlkOiBzZW1hbnRpYy5pZCArICdfcGxhbmUnIH1cclxuICAgICAgICA6IHt9O1xyXG5cclxuICAgICAgLy8gYWRkIGEgdmlydHVhbCBlbGVtZW50IChub3QgYmVpbmcgZHJhd24pXHJcbiAgICAgIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50RmFjdG9yeS5jcmVhdGVSb290KGVsZW1lbnREYXRhKHNlbWFudGljLCBkaSwgYXR0cnMpKTtcclxuXHJcbiAgICAgIHRoaXMuX2NhbnZhcy5hZGRSb290RWxlbWVudChlbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTSEFQRVxyXG4gICAgZWxzZSBpZiAoaXMkMShkaSwgJ2JwbW5kaTpCUE1OU2hhcGUnKSkge1xyXG5cclxuICAgICAgdmFyIGNvbGxhcHNlZCA9ICFpc0V4cGFuZGVkKHNlbWFudGljLCBkaSksXHJcbiAgICAgICAgICBpc0ZyYW1lID0gaXNGcmFtZUVsZW1lbnQkMShzZW1hbnRpYyk7XHJcblxyXG4gICAgICBoaWRkZW4gPSBwYXJlbnRFbGVtZW50ICYmIChwYXJlbnRFbGVtZW50LmhpZGRlbiB8fCBwYXJlbnRFbGVtZW50LmNvbGxhcHNlZCk7XHJcblxyXG4gICAgICB2YXIgYm91bmRzID0gZGkuYm91bmRzO1xyXG5cclxuICAgICAgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnRGYWN0b3J5LmNyZWF0ZVNoYXBlKGVsZW1lbnREYXRhKHNlbWFudGljLCBkaSwge1xyXG4gICAgICAgIGNvbGxhcHNlZDogY29sbGFwc2VkLFxyXG4gICAgICAgIGhpZGRlbjogaGlkZGVuLFxyXG4gICAgICAgIHg6IE1hdGgucm91bmQoYm91bmRzLngpLFxyXG4gICAgICAgIHk6IE1hdGgucm91bmQoYm91bmRzLnkpLFxyXG4gICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKGJvdW5kcy53aWR0aCksXHJcbiAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKGJvdW5kcy5oZWlnaHQpLFxyXG4gICAgICAgIGlzRnJhbWU6IGlzRnJhbWVcclxuICAgICAgfSkpO1xyXG5cclxuICAgICAgaWYgKGlzJDEoc2VtYW50aWMsICdicG1uOkJvdW5kYXJ5RXZlbnQnKSkge1xyXG4gICAgICAgIHRoaXMuX2F0dGFjaEJvdW5kYXJ5KHNlbWFudGljLCBlbGVtZW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaW5zZXJ0IGxhbmVzIGJlaGluZCBvdGhlciBmbG93IG5vZGVzIChjZi4gIzcyNylcclxuICAgICAgaWYgKGlzJDEoc2VtYW50aWMsICdicG1uOkxhbmUnKSkge1xyXG4gICAgICAgIHBhcmVudEluZGV4ID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzJDEoc2VtYW50aWMsICdicG1uOkRhdGFTdG9yZVJlZmVyZW5jZScpKSB7XHJcblxyXG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgZGF0YSBzdG9yZSBpcyBpbnNpZGUgb3VyIG91dHNpZGUgb2YgaXRzIHNlbWFudGljIHBhcmVudFxyXG4gICAgICAgIGlmICghaXNQb2ludEluc2lkZUJCb3gocGFyZW50RWxlbWVudCwgZ2V0TWlkKGJvdW5kcykpKSB7XHJcbiAgICAgICAgICBwYXJlbnRFbGVtZW50ID0gdGhpcy5fY2FudmFzLmZpbmRSb290KHBhcmVudEVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fY2FudmFzLmFkZFNoYXBlKGVsZW1lbnQsIHBhcmVudEVsZW1lbnQsIHBhcmVudEluZGV4KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDT05ORUNUSU9OXHJcbiAgICBlbHNlIGlmIChpcyQxKGRpLCAnYnBtbmRpOkJQTU5FZGdlJykpIHtcclxuXHJcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLl9nZXRTb3VyY2Uoc2VtYW50aWMpLFxyXG4gICAgICAgICAgdGFyZ2V0ID0gdGhpcy5fZ2V0VGFyZ2V0KHNlbWFudGljKTtcclxuXHJcbiAgICAgIGhpZGRlbiA9IHBhcmVudEVsZW1lbnQgJiYgKHBhcmVudEVsZW1lbnQuaGlkZGVuIHx8IHBhcmVudEVsZW1lbnQuY29sbGFwc2VkKTtcclxuXHJcbiAgICAgIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50RmFjdG9yeS5jcmVhdGVDb25uZWN0aW9uKGVsZW1lbnREYXRhKHNlbWFudGljLCBkaSwge1xyXG4gICAgICAgIGhpZGRlbjogaGlkZGVuLFxyXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxyXG4gICAgICAgIHRhcmdldDogdGFyZ2V0LFxyXG4gICAgICAgIHdheXBvaW50czogZ2V0V2F5cG9pbnRzKGRpLCBzb3VyY2UsIHRhcmdldClcclxuICAgICAgfSkpO1xyXG5cclxuICAgICAgaWYgKGlzJDEoc2VtYW50aWMsICdicG1uOkRhdGFBc3NvY2lhdGlvbicpKSB7XHJcblxyXG4gICAgICAgIC8vIHJlbmRlciBhbHdheXMgb24gdG9wOyB0aGlzIGVuc3VyZXMgRGF0YUFzc29jaWF0aW9uc1xyXG4gICAgICAgIC8vIGFyZSByZW5kZXJlZCBjb3JyZWN0bHkgYWNyb3NzIGRpZmZlcmVudCBcImhhY2tzXCIgcGVvcGxlXHJcbiAgICAgICAgLy8gbG92ZSB0byBtb2RlbCBzdWNoIGFzIGNyb3NzIHBhcnRpY2lwYW50IC8gc3ViIHByb2Nlc3NcclxuICAgICAgICAvLyBhc3NvY2lhdGlvbnNcclxuICAgICAgICBwYXJlbnRFbGVtZW50ID0gdGhpcy5fY2FudmFzLmZpbmRSb290KHBhcmVudEVsZW1lbnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9jYW52YXMuYWRkQ29ubmVjdGlvbihlbGVtZW50LCBwYXJlbnRFbGVtZW50LCBwYXJlbnRJbmRleCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYHVua25vd24gZGkgJHsgZWxlbWVudFRvU3RyaW5nKGRpKSB9IGZvciBlbGVtZW50ICR7IGVsZW1lbnRUb1N0cmluZyhzZW1hbnRpYykgfWBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAob3B0aW9uYWwpIExBQkVMXHJcbiAgICBpZiAoaXNMYWJlbEV4dGVybmFsKHNlbWFudGljKSAmJiBnZXRMYWJlbChlbGVtZW50KSkge1xyXG4gICAgICB0aGlzLmFkZExhYmVsKHNlbWFudGljLCBkaSwgZWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZXZlbnRCdXMuZmlyZSgnYnBtbkVsZW1lbnQuYWRkZWQnLCB7IGVsZW1lbnQ6IGVsZW1lbnQgfSk7XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaCBhIGJvdW5kYXJ5IGVsZW1lbnQgdG8gdGhlIGdpdmVuIGhvc3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR9IGJvdW5kYXJ5U2VtYW50aWNcclxuICAgKiBAcGFyYW0ge1NoYXBlfSBib3VuZGFyeUVsZW1lbnRcclxuICAgKi9cclxuICBCcG1uSW1wb3J0ZXIucHJvdG90eXBlLl9hdHRhY2hCb3VuZGFyeSA9IGZ1bmN0aW9uKGJvdW5kYXJ5U2VtYW50aWMsIGJvdW5kYXJ5RWxlbWVudCkge1xyXG4gICAgdmFyIGhvc3RTZW1hbnRpYyA9IGJvdW5kYXJ5U2VtYW50aWMuYXR0YWNoZWRUb1JlZjtcclxuXHJcbiAgICBpZiAoIWhvc3RTZW1hbnRpYykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYG1pc3NpbmcgJHsgZWxlbWVudFRvU3RyaW5nKGJvdW5kYXJ5U2VtYW50aWMpIH0jYXR0YWNoZWRUb1JlZmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaG9zdCA9IHRoaXMuX2VsZW1lbnRSZWdpc3RyeS5nZXQoaG9zdFNlbWFudGljLmlkKSxcclxuICAgICAgICBhdHRhY2hlcnMgPSBob3N0ICYmIGhvc3QuYXR0YWNoZXJzO1xyXG5cclxuICAgIGlmICghaG9zdCkge1xyXG4gICAgICB0aHJvdyBub3RZZXREcmF3bihib3VuZGFyeVNlbWFudGljLCBob3N0U2VtYW50aWMsICdhdHRhY2hlZFRvUmVmJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2lyZSBlbGVtZW50Lmhvc3QgPD4gaG9zdC5hdHRhY2hlcnNcclxuICAgIGJvdW5kYXJ5RWxlbWVudC5ob3N0ID0gaG9zdDtcclxuXHJcbiAgICBpZiAoIWF0dGFjaGVycykge1xyXG4gICAgICBob3N0LmF0dGFjaGVycyA9IGF0dGFjaGVycyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhdHRhY2hlcnMuaW5kZXhPZihib3VuZGFyeUVsZW1lbnQpID09PSAtMSkge1xyXG4gICAgICBhdHRhY2hlcnMucHVzaChib3VuZGFyeUVsZW1lbnQpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSBsYWJlbCB0byBhIGdpdmVuIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR9IHNlbWFudGljXHJcbiAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBkaVxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7TGFiZWx9XHJcbiAgICovXHJcbiAgQnBtbkltcG9ydGVyLnByb3RvdHlwZS5hZGRMYWJlbCA9IGZ1bmN0aW9uKHNlbWFudGljLCBkaSwgZWxlbWVudCkge1xyXG4gICAgdmFyIGJvdW5kcyxcclxuICAgICAgICB0ZXh0LFxyXG4gICAgICAgIGxhYmVsO1xyXG5cclxuICAgIGJvdW5kcyA9IGdldEV4dGVybmFsTGFiZWxCb3VuZHMoZGksIGVsZW1lbnQpO1xyXG5cclxuICAgIHRleHQgPSBnZXRMYWJlbChlbGVtZW50KTtcclxuXHJcbiAgICBpZiAodGV4dCkge1xyXG5cclxuICAgICAgLy8gZ2V0IGNvcnJlY3RlZCBib3VuZHMgZnJvbSBhY3R1YWwgbGF5b3V0ZWQgdGV4dFxyXG4gICAgICBib3VuZHMgPSB0aGlzLl90ZXh0UmVuZGVyZXIuZ2V0RXh0ZXJuYWxMYWJlbEJvdW5kcyhib3VuZHMsIHRleHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGxhYmVsID0gdGhpcy5fZWxlbWVudEZhY3RvcnkuY3JlYXRlTGFiZWwoZWxlbWVudERhdGEoc2VtYW50aWMsIGRpLCB7XHJcbiAgICAgIGlkOiBzZW1hbnRpYy5pZCArICdfbGFiZWwnLFxyXG4gICAgICBsYWJlbFRhcmdldDogZWxlbWVudCxcclxuICAgICAgdHlwZTogJ2xhYmVsJyxcclxuICAgICAgaGlkZGVuOiBlbGVtZW50LmhpZGRlbiB8fCAhZ2V0TGFiZWwoZWxlbWVudCksXHJcbiAgICAgIHg6IE1hdGgucm91bmQoYm91bmRzLngpLFxyXG4gICAgICB5OiBNYXRoLnJvdW5kKGJvdW5kcy55KSxcclxuICAgICAgd2lkdGg6IE1hdGgucm91bmQoYm91bmRzLndpZHRoKSxcclxuICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKGJvdW5kcy5oZWlnaHQpXHJcbiAgICB9KSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhcy5hZGRTaGFwZShsYWJlbCwgZWxlbWVudC5wYXJlbnQpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc291cmNlIG9yIHRhcmdldCBvZiB0aGUgZ2l2ZW4gY29ubmVjdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gc2VtYW50aWNcclxuICAgKiBAcGFyYW0geydzb3VyY2UnIHwgJ3RhcmdldCd9IHNpZGVcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICovXHJcbiAgQnBtbkltcG9ydGVyLnByb3RvdHlwZS5fZ2V0Q29ubmVjdGVkRWxlbWVudCA9IGZ1bmN0aW9uKHNlbWFudGljLCBzaWRlKSB7XHJcblxyXG4gICAgdmFyIGVsZW1lbnQsXHJcbiAgICAgICAgcmVmU2VtYW50aWMsXHJcbiAgICAgICAgdHlwZSA9IHNlbWFudGljLiR0eXBlO1xyXG5cclxuICAgIHJlZlNlbWFudGljID0gc2VtYW50aWNbc2lkZSArICdSZWYnXTtcclxuXHJcbiAgICAvLyBoYW5kbGUgbXlzdGVyaW91cyBpc01hbnkgRGF0YUFzc29jaWF0aW9uI3NvdXJjZVJlZlxyXG4gICAgaWYgKHNpZGUgPT09ICdzb3VyY2UnICYmIHR5cGUgPT09ICdicG1uOkRhdGFJbnB1dEFzc29jaWF0aW9uJykge1xyXG4gICAgICByZWZTZW1hbnRpYyA9IHJlZlNlbWFudGljICYmIHJlZlNlbWFudGljWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZpeCBzb3VyY2UgLyB0YXJnZXQgZm9yIERhdGFJbnB1dEFzc29jaWF0aW9uIC8gRGF0YU91dHB1dEFzc29jaWF0aW9uXHJcbiAgICBpZiAoc2lkZSA9PT0gJ3NvdXJjZScgJiYgdHlwZSA9PT0gJ2JwbW46RGF0YU91dHB1dEFzc29jaWF0aW9uJyB8fFxyXG4gICAgICAgIHNpZGUgPT09ICd0YXJnZXQnICYmIHR5cGUgPT09ICdicG1uOkRhdGFJbnB1dEFzc29jaWF0aW9uJykge1xyXG5cclxuICAgICAgcmVmU2VtYW50aWMgPSBzZW1hbnRpYy4kcGFyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGVsZW1lbnQgPSByZWZTZW1hbnRpYyAmJiB0aGlzLl9nZXRFbGVtZW50KHJlZlNlbWFudGljKTtcclxuXHJcbiAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmVmU2VtYW50aWMpIHtcclxuICAgICAgdGhyb3cgbm90WWV0RHJhd24oc2VtYW50aWMsIHJlZlNlbWFudGljLCBzaWRlICsgJ1JlZicpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGAkeyBlbGVtZW50VG9TdHJpbmcoc2VtYW50aWMpIH0jJHsgc2lkZSB9IFJlZiBub3Qgc3BlY2lmaWVkYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIEJwbW5JbXBvcnRlci5wcm90b3R5cGUuX2dldFNvdXJjZSA9IGZ1bmN0aW9uKHNlbWFudGljKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q29ubmVjdGVkRWxlbWVudChzZW1hbnRpYywgJ3NvdXJjZScpO1xyXG4gIH07XHJcblxyXG4gIEJwbW5JbXBvcnRlci5wcm90b3R5cGUuX2dldFRhcmdldCA9IGZ1bmN0aW9uKHNlbWFudGljKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q29ubmVjdGVkRWxlbWVudChzZW1hbnRpYywgJ3RhcmdldCcpO1xyXG4gIH07XHJcblxyXG5cclxuICBCcG1uSW1wb3J0ZXIucHJvdG90eXBlLl9nZXRFbGVtZW50ID0gZnVuY3Rpb24oc2VtYW50aWMpIHtcclxuICAgIHJldHVybiB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0KHNlbWFudGljLmlkKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLy8gaGVscGVycyAvLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuICBmdW5jdGlvbiBpc1BvaW50SW5zaWRlQkJveChiYm94LCBwb2ludCkge1xyXG4gICAgdmFyIHggPSBwb2ludC54LFxyXG4gICAgICAgIHkgPSBwb2ludC55O1xyXG5cclxuICAgIHJldHVybiB4ID49IGJib3gueCAmJlxyXG4gICAgICB4IDw9IGJib3gueCArIGJib3gud2lkdGggJiZcclxuICAgICAgeSA+PSBiYm94LnkgJiZcclxuICAgICAgeSA8PSBiYm94LnkgKyBiYm94LmhlaWdodDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzRnJhbWVFbGVtZW50JDEoc2VtYW50aWMpIHtcclxuICAgIHJldHVybiBpcyQxKHNlbWFudGljLCAnYnBtbjpHcm91cCcpO1xyXG4gIH1cblxuICB2YXIgSW1wb3J0TW9kdWxlID0ge1xyXG4gICAgX19kZXBlbmRzX186IFtcclxuICAgICAgVHJhbnNsYXRlTW9kdWxlXHJcbiAgICBdLFxyXG4gICAgYnBtbkltcG9ydGVyOiBbICd0eXBlJywgQnBtbkltcG9ydGVyIF1cclxuICB9O1xuXG4gIHZhciBDb3JlTW9kdWxlJDEgPSB7XHJcbiAgICBfX2RlcGVuZHNfXzogW1xyXG4gICAgICBEcmF3TW9kdWxlJDEsXHJcbiAgICAgIEltcG9ydE1vZHVsZVxyXG4gICAgXVxyXG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN1cnJvdW5kaW5nIGJib3ggZm9yIGFsbCBlbGVtZW50cyBpblxuICAgKiB0aGUgYXJyYXkgb3IgdGhlIGVsZW1lbnQgcHJpbWl0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8RWxlbWVudFtdfSBlbGVtZW50c1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdG9wUmVjdXJzaW9uPWZhbHNlXVxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWN0fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QkJveChlbGVtZW50cywgc3RvcFJlY3Vyc2lvbikge1xuXG4gICAgc3RvcFJlY3Vyc2lvbiA9ICEhc3RvcFJlY3Vyc2lvbjtcbiAgICBpZiAoIWlzQXJyYXkkMihlbGVtZW50cykpIHtcbiAgICAgIGVsZW1lbnRzID0gWyBlbGVtZW50cyBdO1xuICAgIH1cblxuICAgIHZhciBtaW5YLFxuICAgICAgICBtaW5ZLFxuICAgICAgICBtYXhYLFxuICAgICAgICBtYXhZO1xuXG4gICAgZm9yRWFjaCQxKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgICAgIC8vIElmIGVsZW1lbnQgaXMgYSBjb25uZWN0aW9uIHRoZSBiYm94IG11c3QgYmUgY29tcHV0ZWQgZmlyc3RcbiAgICAgIHZhciBiYm94ID0gZWxlbWVudDtcbiAgICAgIGlmIChlbGVtZW50LndheXBvaW50cyAmJiAhc3RvcFJlY3Vyc2lvbikge1xuICAgICAgICBiYm94ID0gZ2V0QkJveChlbGVtZW50LndheXBvaW50cywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB4ID0gYmJveC54LFxuICAgICAgICAgIHkgPSBiYm94LnksXG4gICAgICAgICAgaGVpZ2h0ID0gYmJveC5oZWlnaHQgfHwgMCxcbiAgICAgICAgICB3aWR0aCA9IGJib3gud2lkdGggfHwgMDtcblxuICAgICAgaWYgKHggPCBtaW5YIHx8IG1pblggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtaW5YID0geDtcbiAgICAgIH1cbiAgICAgIGlmICh5IDwgbWluWSB8fCBtaW5ZID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoeCArIHdpZHRoKSA+IG1heFggfHwgbWF4WCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1heFggPSB4ICsgd2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoKHkgKyBoZWlnaHQpID4gbWF4WSB8fCBtYXhZID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWF4WSA9IHkgKyBoZWlnaHQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogbWluWCxcbiAgICAgIHk6IG1pblksXG4gICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZLFxuICAgICAgd2lkdGg6IG1heFggLSBtaW5YXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQncyB0eXBlXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHsnY29ubmVjdGlvbicgfCAnc2hhcGUnIHwgJ3Jvb3QnfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VHlwZShlbGVtZW50KSB7XG5cbiAgICBpZiAoJ3dheXBvaW50cycgaW4gZWxlbWVudCkge1xuICAgICAgcmV0dXJuICdjb25uZWN0aW9uJztcbiAgICB9XG5cbiAgICBpZiAoJ3gnIGluIGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiAnc2hhcGUnO1xuICAgIH1cblxuICAgIHJldHVybiAncm9vdCc7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpc0ZyYW1lRWxlbWVudChlbGVtZW50KSB7XG4gICAgcmV0dXJuICEhKGVsZW1lbnQgJiYgZWxlbWVudC5pc0ZyYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsIHRoYXQgcHJvdmlkZXMgdW5pcXVlIElEcy5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBUaGUgaWRzIGNhbiBiZSBjdXN0b21pemVkIHZpYSBhIGdpdmVuIHByZWZpeCBhbmQgY29udGFpbiBhIHJhbmRvbSB2YWx1ZSB0byBhdm9pZCBjb2xsaXNpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeF0gYSBwcmVmaXggdG8gcHJlcGVuZCB0byBnZW5lcmF0ZWQgaWRzIChmb3IgYmV0dGVyIHJlYWRhYmlsaXR5KVxuICAgKi9cbiAgZnVuY3Rpb24gSWRHZW5lcmF0b3IocHJlZml4KSB7XG5cbiAgICB0aGlzLl9jb3VudGVyID0gMDtcbiAgICB0aGlzLl9wcmVmaXggPSAocHJlZml4ID8gcHJlZml4ICsgJy0nIDogJycpICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwMCkgKyAnLSc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5leHQgdW5pcXVlIElELlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBpZFxuICAgKi9cbiAgSWRHZW5lcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJlZml4ICsgKCsrdGhpcy5fY291bnRlcik7XG4gIH07XG5cbiAgLy8gZG9jdW1lbnQgd2lkZSB1bmlxdWUgb3ZlcmxheSBpZHNcbiAgdmFyIGlkcyA9IG5ldyBJZEdlbmVyYXRvcignb3YnKTtcblxuICB2YXIgTE9XX1BSSU9SSVRZJDMgPSA1MDA7XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL2NvcmUvQ2FudmFzJykuZGVmYXVsdH0gQ2FudmFzXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL2NvcmUvRWxlbWVudFJlZ2lzdHJ5JykuZGVmYXVsdH0gRWxlbWVudFJlZ2lzdHJ5XG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL2NvcmUvRXZlbnRCdXMnKS5kZWZhdWx0fSBFdmVudEJ1c1xuICAgKlxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi9tb2RlbC9UeXBlcycpLkVsZW1lbnR9IEVsZW1lbnRcbiAgICpcbiAgICogQHR5cGVkZWYgeyB7XG4gICAqICAgbWluWm9vbT86IG51bWJlcixcbiAgICogICBtYXhab29tPzogbnVtYmVyXG4gICAqIH0gfSBPdmVybGF5c0NvbmZpZ1Nob3dcbiAgICpcbiAgICogQHR5cGVkZWYgeyB7XG4gICAqICAgbWluPzogbnVtYmVyLFxuICAgKiAgIG1heD86IG51bWJlclxuICAgKiB9IH0gT3ZlcmxheXNDb25maWdTY2FsZVxuICAgKlxuICAgKiBAdHlwZWRlZiB7IHtcbiAgKiAgIGlkOiBzdHJpbmcsXG4gICogICB0eXBlOiBzdHJpbmcgfCBudWxsLFxuICAqICAgZWxlbWVudDogRWxlbWVudCB8IHN0cmluZ1xuICAqIH0gJiBPdmVybGF5QXR0cnMgfSBPdmVybGF5XG4gICpcbiAgICogQHR5cGVkZWYgeyB7XG4gICAqICAgaHRtbDogSFRNTEVsZW1lbnQgfCBzdHJpbmcsXG4gICAqICAgcG9zaXRpb246IHtcbiAgICogICAgIHRvcD86IG51bWJlcixcbiAgICogICAgIHJpZ2h0PzogbnVtYmVyLFxuICAgKiAgICAgYm90dG9tPzogbnVtYmVyLFxuICAgKiAgICAgbGVmdD86IG51bWJlclxuICAgKiAgIH1cbiAgICogfSAmIE92ZXJsYXlzQ29uZmlnRGVmYXVsdCB9IE92ZXJsYXlBdHRyc1xuICAgKlxuICAgKiBAdHlwZWRlZiB7IHtcbiAgICogICBodG1sOiBIVE1MRWxlbWVudCxcbiAgICogICBlbGVtZW50OiBFbGVtZW50LFxuICAgKiAgIG92ZXJsYXlzOiBPdmVybGF5W11cbiAgICogfSB9IE92ZXJsYXlDb250YWluZXJcbiAgICpcbiAgICogQHR5cGVkZWYge3tcbiAgICogICBkZWZhdWx0cz86IE92ZXJsYXlzQ29uZmlnRGVmYXVsdFxuICAgKiB9fSBPdmVybGF5c0NvbmZpZ1xuICAgKlxuICAgKiBAdHlwZWRlZiB7IHtcbiAgICogIHNob3c/OiBPdmVybGF5c0NvbmZpZ1Nob3csXG4gICAqICBzY2FsZT86IE92ZXJsYXlzQ29uZmlnU2NhbGUgfCBib29sZWFuXG4gICAqIH0gfSBPdmVybGF5c0NvbmZpZ0RlZmF1bHRcbiAgICpcbiAgICogQHR5cGVkZWYgeyB7XG4gICAqICAgaWQ/OiBzdHJpbmc7XG4gICAqICAgZWxlbWVudD86IEVsZW1lbnQgfCBzdHJpbmc7XG4gICAqICAgdHlwZT86IHN0cmluZztcbiAgICogfSB8IHN0cmluZyB9IE92ZXJsYXlzRmlsdGVyXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBIHNlcnZpY2UgdGhhdCBhbGxvd3MgdXNlcnMgdG8gYXR0YWNoIG92ZXJsYXlzIHRvIGRpYWdyYW0gZWxlbWVudHMuXG4gICAqXG4gICAqIFRoZSBvdmVybGF5IHNlcnZpY2Ugd2lsbCB0YWtlIGNhcmUgb2Ygb3ZlcmxheSBwb3NpdGlvbmluZyBkdXJpbmcgdXBkYXRlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBhZGQgYSBwaW5rIGJhZGdlIG9uIHRoZSB0b3AgbGVmdCBvZiB0aGUgc2hhcGVcbiAgICpcbiAgICogb3ZlcmxheXMuYWRkKHNvbWVTaGFwZSwge1xuICAgKiAgIHBvc2l0aW9uOiB7XG4gICAqICAgICB0b3A6IC01LFxuICAgKiAgICAgbGVmdDogLTVcbiAgICogICB9LFxuICAgKiAgIGh0bWw6ICc8ZGl2IHN0eWxlPVwid2lkdGg6IDEwcHg7IGJhY2tncm91bmQ6IGZ1Y2hzaWE7IGNvbG9yOiB3aGl0ZTtcIj4wPC9kaXY+J1xuICAgKiB9KTtcbiAgICpcbiAgICogLy8gb3IgYWRkIHZpYSBzaGFwZSBpZFxuICAgKlxuICAgKiBvdmVybGF5cy5hZGQoJ3NvbWUtZWxlbWVudC1pZCcsIHtcbiAgICogICBwb3NpdGlvbjoge1xuICAgKiAgICAgdG9wOiAtNSxcbiAgICogICAgIGxlZnQ6IC01XG4gICAqICAgfVxuICAgKiAgIGh0bWw6ICc8ZGl2IHN0eWxlPVwid2lkdGg6IDEwcHg7IGJhY2tncm91bmQ6IGZ1Y2hzaWE7IGNvbG9yOiB3aGl0ZTtcIj4wPC9kaXY+J1xuICAgKiB9KTtcbiAgICpcbiAgICogLy8gb3IgYWRkIHdpdGggb3B0aW9uYWwgdHlwZVxuICAgKlxuICAgKiBvdmVybGF5cy5hZGQoc29tZVNoYXBlLCAnYmFkZ2UnLCB7XG4gICAqICAgcG9zaXRpb246IHtcbiAgICogICAgIHRvcDogLTUsXG4gICAqICAgICBsZWZ0OiAtNVxuICAgKiAgIH1cbiAgICogICBodG1sOiAnPGRpdiBzdHlsZT1cIndpZHRoOiAxMHB4OyBiYWNrZ3JvdW5kOiBmdWNoc2lhOyBjb2xvcjogd2hpdGU7XCI+MDwvZGl2PidcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIHJlbW92ZSBhbiBvdmVybGF5XG4gICAqXG4gICAqIHZhciBpZCA9IG92ZXJsYXlzLmFkZCguLi4pO1xuICAgKiBvdmVybGF5cy5yZW1vdmUoaWQpO1xuICAgKlxuICAgKlxuICAgKiBZb3UgbWF5IGNvbmZpZ3VyZSBvdmVybGF5IGRlZmF1bHRzIGR1cmluZyB0b29sIGJ5IHByb3ZpZGluZyBhIGBjb25maWdgIG1vZHVsZVxuICAgKiB3aXRoIGBvdmVybGF5cy5kZWZhdWx0c2AgYXMgYW4gZW50cnk6XG4gICAqXG4gICAqIHtcbiAgICogICBvdmVybGF5czoge1xuICAgKiAgICAgZGVmYXVsdHM6IHtcbiAgICogICAgICAgc2hvdzoge1xuICAgKiAgICAgICAgIG1pblpvb206IDAuNyxcbiAgICogICAgICAgICBtYXhab29tOiA1LjBcbiAgICogICAgICAgfSxcbiAgICogICAgICAgc2NhbGU6IHtcbiAgICogICAgICAgICBtaW46IDFcbiAgICogICAgICAgfVxuICAgKiAgICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge092ZXJsYXlzQ29uZmlnfSBjb25maWdcbiAgICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICAgKiBAcGFyYW0ge0VsZW1lbnRSZWdpc3RyeX0gZWxlbWVudFJlZ2lzdHJ5XG4gICAqL1xuICBmdW5jdGlvbiBPdmVybGF5cyhjb25maWcsIGV2ZW50QnVzLCBjYW52YXMsIGVsZW1lbnRSZWdpc3RyeSkge1xuICAgIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuX2VsZW1lbnRSZWdpc3RyeSA9IGVsZW1lbnRSZWdpc3RyeTtcblxuICAgIHRoaXMuX2lkcyA9IGlkcztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPdmVybGF5c0NvbmZpZ0RlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5fb3ZlcmxheURlZmF1bHRzID0gYXNzaWduJDEoe1xuXG4gICAgICAvLyBubyBzaG93IGNvbnN0cmFpbnRzXG4gICAgICBzaG93OiBudWxsLFxuXG4gICAgICAvLyBhbHdheXMgc2NhbGVcbiAgICAgIHNjYWxlOiB0cnVlXG4gICAgfSwgY29uZmlnICYmIGNvbmZpZy5kZWZhdWx0cyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgT3ZlcmxheT59XG4gICAgICovXG4gICAgdGhpcy5fb3ZlcmxheXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPdmVybGF5Q29udGFpbmVyW119XG4gICAgICovXG4gICAgdGhpcy5fb3ZlcmxheUNvbnRhaW5lcnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLl9vdmVybGF5Um9vdCA9IGNyZWF0ZVJvb3QoY2FudmFzLmdldENvbnRhaW5lcigpKTtcblxuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuXG5cbiAgT3ZlcmxheXMuJGluamVjdCA9IFtcbiAgICAnY29uZmlnLm92ZXJsYXlzJyxcbiAgICAnZXZlbnRCdXMnLFxuICAgICdjYW52YXMnLFxuICAgICdlbGVtZW50UmVnaXN0cnknXG4gIF07XG5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3ZlcmxheSB3aXRoIHRoZSBzcGVjaWZpZWQgSUQgb3IgYSBsaXN0IG9mIG92ZXJsYXlzXG4gICAqIGZvciBhbiBlbGVtZW50IHdpdGggYSBnaXZlbiB0eXBlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIHJldHVybiB0aGUgc2luZ2xlIG92ZXJsYXkgd2l0aCB0aGUgZ2l2ZW4gSURcbiAgICogb3ZlcmxheXMuZ2V0KCdzb21lLWlkJyk7XG4gICAqXG4gICAqIC8vIHJldHVybiBhbGwgb3ZlcmxheXMgZm9yIHRoZSBzaGFwZVxuICAgKiBvdmVybGF5cy5nZXQoeyBlbGVtZW50OiBzb21lU2hhcGUgfSk7XG4gICAqXG4gICAqIC8vIHJldHVybiBhbGwgb3ZlcmxheXMgb24gc2hhcGUgd2l0aCB0eXBlICdiYWRnZSdcbiAgICogb3ZlcmxheXMuZ2V0KHsgZWxlbWVudDogc29tZVNoYXBlLCB0eXBlOiAnYmFkZ2UnIH0pO1xuICAgKlxuICAgKiAvLyBzaGFwZSBjYW4gYWxzbyBiZSBzcGVjaWZpZWQgYXMgSURcbiAgICogb3ZlcmxheXMuZ2V0KHsgZWxlbWVudDogJ2VsZW1lbnQtaWQnLCB0eXBlOiAnYmFkZ2UnIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtPdmVybGF5c0ZpbHRlcn0gc2VhcmNoIFRoZSBmaWx0ZXIgdG8gYmUgdXNlZCB0byBmaW5kIHRoZSBvdmVybGF5KHMpLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPdmVybGF5fE92ZXJsYXlbXX0gVGhlIG92ZXJsYXkocykuXG4gICAqL1xuICBPdmVybGF5cy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oc2VhcmNoKSB7XG5cbiAgICBpZiAoaXNTdHJpbmcoc2VhcmNoKSkge1xuICAgICAgc2VhcmNoID0geyBpZDogc2VhcmNoIH07XG4gICAgfVxuXG4gICAgaWYgKGlzU3RyaW5nKHNlYXJjaC5lbGVtZW50KSkge1xuICAgICAgc2VhcmNoLmVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0KHNlYXJjaC5lbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAoc2VhcmNoLmVsZW1lbnQpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9nZXRPdmVybGF5Q29udGFpbmVyKHNlYXJjaC5lbGVtZW50LCB0cnVlKTtcblxuICAgICAgLy8gcmV0dXJuIGEgbGlzdCBvZiBvdmVybGF5cyB3aGVuIHNlYXJjaGluZyBieSBlbGVtZW50ICgrdHlwZSlcbiAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlYXJjaC50eXBlID8gZmlsdGVyKGNvbnRhaW5lci5vdmVybGF5cywgbWF0Y2hQYXR0ZXJuKHsgdHlwZTogc2VhcmNoLnR5cGUgfSkpIDogY29udGFpbmVyLm92ZXJsYXlzLnNsaWNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzZWFyY2gudHlwZSkge1xuICAgICAgcmV0dXJuIGZpbHRlcih0aGlzLl9vdmVybGF5cywgbWF0Y2hQYXR0ZXJuKHsgdHlwZTogc2VhcmNoLnR5cGUgfSkpO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIHJldHVybiBzaW5nbGUgZWxlbWVudCB3aGVuIHNlYXJjaGluZyBieSBpZFxuICAgICAgcmV0dXJuIHNlYXJjaC5pZCA/IHRoaXMuX292ZXJsYXlzW3NlYXJjaC5pZF0gOiBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBhbiBIVE1MIG92ZXJsYXkgdG8gYW4gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fHN0cmluZ30gZWxlbWVudCBUaGUgZWxlbWVudCB0byBhZGQgdGhlIG92ZXJsYXkgdG8uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gQW4gb3B0aW9uYWwgdHlwZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGZpbHRlci5cbiAgICogQHBhcmFtIHtPdmVybGF5QXR0cnN9IG92ZXJsYXkgVGhlIG92ZXJsYXkuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG92ZXJsYXkncyBJRCB0aGF0IGNhbiBiZSB1c2VkIHRvIGdldCBvciByZW1vdmUgaXQuXG4gICAqL1xuICBPdmVybGF5cy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZWxlbWVudCwgdHlwZSwgb3ZlcmxheSkge1xuXG4gICAgaWYgKGlzT2JqZWN0KHR5cGUpKSB7XG4gICAgICBvdmVybGF5ID0gdHlwZTtcbiAgICAgIHR5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghZWxlbWVudC5pZCkge1xuICAgICAgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWdpc3RyeS5nZXQoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKCFvdmVybGF5LnBvc2l0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3BlY2lmaXkgb3ZlcmxheSBwb3NpdGlvbicpO1xuICAgIH1cblxuICAgIGlmICghb3ZlcmxheS5odG1sKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3BlY2lmaXkgb3ZlcmxheSBodG1sJyk7XG4gICAgfVxuXG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZWxlbWVudCBzcGVjaWZpZWQnKTtcbiAgICB9XG5cbiAgICB2YXIgaWQgPSB0aGlzLl9pZHMubmV4dCgpO1xuXG4gICAgb3ZlcmxheSA9IGFzc2lnbiQxKHt9LCB0aGlzLl9vdmVybGF5RGVmYXVsdHMsIG92ZXJsYXksIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgaHRtbDogb3ZlcmxheS5odG1sXG4gICAgfSk7XG5cbiAgICB0aGlzLl9hZGRPdmVybGF5KG92ZXJsYXkpO1xuXG4gICAgcmV0dXJuIGlkO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBvdmVybGF5IHdpdGggdGhlIGdpdmVuIElEIG9yIGFsbCBvdmVybGF5cyBtYXRjaGluZyB0aGUgZ2l2ZW4gZmlsdGVyLlxuICAgKlxuICAgKiBAc2VlIE92ZXJsYXlzI2dldCBmb3IgZmlsdGVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7T3ZlcmxheXNGaWx0ZXJ9IGZpbHRlciBUaGUgZmlsdGVyIHRvIGJlIHVzZWQgdG8gZmluZCB0aGUgb3ZlcmxheS5cbiAgICovXG4gIE92ZXJsYXlzLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihmaWx0ZXIpIHtcblxuICAgIHZhciBvdmVybGF5cyA9IHRoaXMuZ2V0KGZpbHRlcikgfHwgW107XG5cbiAgICBpZiAoIWlzQXJyYXkkMihvdmVybGF5cykpIHtcbiAgICAgIG92ZXJsYXlzID0gWyBvdmVybGF5cyBdO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZvckVhY2gkMShvdmVybGF5cywgZnVuY3Rpb24ob3ZlcmxheSkge1xuXG4gICAgICB2YXIgY29udGFpbmVyID0gc2VsZi5fZ2V0T3ZlcmxheUNvbnRhaW5lcihvdmVybGF5LmVsZW1lbnQsIHRydWUpO1xuXG4gICAgICBpZiAob3ZlcmxheSkge1xuICAgICAgICByZW1vdmUkMShvdmVybGF5Lmh0bWwpO1xuICAgICAgICByZW1vdmUkMShvdmVybGF5Lmh0bWxDb250YWluZXIpO1xuXG4gICAgICAgIGRlbGV0ZSBvdmVybGF5Lmh0bWxDb250YWluZXI7XG4gICAgICAgIGRlbGV0ZSBvdmVybGF5LmVsZW1lbnQ7XG5cbiAgICAgICAgZGVsZXRlIHNlbGYuX292ZXJsYXlzW292ZXJsYXkuaWRdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBpZHggPSBjb250YWluZXIub3ZlcmxheXMuaW5kZXhPZihvdmVybGF5KTtcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICBjb250YWluZXIub3ZlcmxheXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvdmVybGF5cyBhcmUgc2hvd24uXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3ZlcmxheXMgYXJlIHNob3duLlxuICAgKi9cbiAgT3ZlcmxheXMucHJvdG90eXBlLmlzU2hvd24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fb3ZlcmxheVJvb3Quc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IGFsbCBvdmVybGF5cy5cbiAgICovXG4gIE92ZXJsYXlzLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgc2V0VmlzaWJsZSh0aGlzLl9vdmVybGF5Um9vdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGUgYWxsIG92ZXJsYXlzLlxuICAgKi9cbiAgT3ZlcmxheXMucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICBzZXRWaXNpYmxlKHRoaXMuX292ZXJsYXlSb290LCBmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgb3ZlcmxheXMgYW5kIHRoZWlyIGNvbnRhaW5lci5cbiAgICovXG4gIE92ZXJsYXlzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX292ZXJsYXlzID0ge307XG5cbiAgICB0aGlzLl9vdmVybGF5Q29udGFpbmVycyA9IFtdO1xuXG4gICAgY2xlYXIodGhpcy5fb3ZlcmxheVJvb3QpO1xuICB9O1xuXG4gIE92ZXJsYXlzLnByb3RvdHlwZS5fdXBkYXRlT3ZlcmxheUNvbnRhaW5lciA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIHZhciBlbGVtZW50ID0gY29udGFpbmVyLmVsZW1lbnQsXG4gICAgICAgIGh0bWwgPSBjb250YWluZXIuaHRtbDtcblxuICAgIC8vIHVwZGF0ZSBjb250YWluZXIgbGVmdCx0b3AgYWNjb3JkaW5nIHRvIHRoZSBlbGVtZW50cyB4LHkgY29vcmRpbmF0ZXNcbiAgICAvLyB0aGlzIGVuc3VyZXMgd2UgY2FuIGF0dGFjaCBjaGlsZCBlbGVtZW50cyByZWxhdGl2ZSB0byB0aGlzIGNvbnRhaW5lclxuXG4gICAgdmFyIHggPSBlbGVtZW50LngsXG4gICAgICAgIHkgPSBlbGVtZW50Lnk7XG5cbiAgICBpZiAoZWxlbWVudC53YXlwb2ludHMpIHtcbiAgICAgIHZhciBiYm94ID0gZ2V0QkJveChlbGVtZW50KTtcbiAgICAgIHggPSBiYm94Lng7XG4gICAgICB5ID0gYmJveC55O1xuICAgIH1cblxuICAgIHNldFBvc2l0aW9uKGh0bWwsIHgsIHkpO1xuXG4gICAgYXR0cihjb250YWluZXIuaHRtbCwgJ2RhdGEtY29udGFpbmVyLWlkJywgZWxlbWVudC5pZCk7XG4gIH07XG5cblxuICBPdmVybGF5cy5wcm90b3R5cGUuX3VwZGF0ZU92ZXJsYXkgPSBmdW5jdGlvbihvdmVybGF5KSB7XG5cbiAgICB2YXIgcG9zaXRpb24gPSBvdmVybGF5LnBvc2l0aW9uLFxuICAgICAgICBodG1sQ29udGFpbmVyID0gb3ZlcmxheS5odG1sQ29udGFpbmVyLFxuICAgICAgICBlbGVtZW50ID0gb3ZlcmxheS5lbGVtZW50O1xuXG4gICAgLy8gdXBkYXRlIG92ZXJsYXkgaHRtbCByZWxhdGl2ZSB0byBzaGFwZSBiZWNhdXNlXG4gICAgLy8gaXQgaXMgYWxyZWFkeSBwb3NpdGlvbmVkIG9uIHRoZSBlbGVtZW50XG5cbiAgICAvLyB1cGRhdGUgcmVsYXRpdmVcbiAgICB2YXIgbGVmdCA9IHBvc2l0aW9uLmxlZnQsXG4gICAgICAgIHRvcCA9IHBvc2l0aW9uLnRvcDtcblxuICAgIGlmIChwb3NpdGlvbi5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgIHZhciB3aWR0aDtcblxuICAgICAgaWYgKGVsZW1lbnQud2F5cG9pbnRzKSB7XG4gICAgICAgIHdpZHRoID0gZ2V0QkJveChlbGVtZW50KS53aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoID0gZWxlbWVudC53aWR0aDtcbiAgICAgIH1cblxuICAgICAgbGVmdCA9IHBvc2l0aW9uLnJpZ2h0ICogLTEgKyB3aWR0aDtcbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24uYm90dG9tICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgdmFyIGhlaWdodDtcblxuICAgICAgaWYgKGVsZW1lbnQud2F5cG9pbnRzKSB7XG4gICAgICAgIGhlaWdodCA9IGdldEJCb3goZWxlbWVudCkuaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVpZ2h0ID0gZWxlbWVudC5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHRvcCA9IHBvc2l0aW9uLmJvdHRvbSAqIC0xICsgaGVpZ2h0O1xuICAgIH1cblxuICAgIHNldFBvc2l0aW9uKGh0bWxDb250YWluZXIsIGxlZnQgfHwgMCwgdG9wIHx8IDApO1xuICAgIHRoaXMuX3VwZGF0ZU92ZXJsYXlWaXNpYmlsdHkob3ZlcmxheSwgdGhpcy5fY2FudmFzLnZpZXdib3goKSk7XG4gIH07XG5cblxuICBPdmVybGF5cy5wcm90b3R5cGUuX2NyZWF0ZU92ZXJsYXlDb250YWluZXIgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIGh0bWwgPSBkb21pZnkkMSgnPGRpdiBjbGFzcz1cImRqcy1vdmVybGF5c1wiIC8+Jyk7XG4gICAgYXNzaWduKGh0bWwsIHsgcG9zaXRpb246ICdhYnNvbHV0ZScgfSk7XG5cbiAgICB0aGlzLl9vdmVybGF5Um9vdC5hcHBlbmRDaGlsZChodG1sKTtcblxuICAgIHZhciBjb250YWluZXIgPSB7XG4gICAgICBodG1sOiBodG1sLFxuICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgIG92ZXJsYXlzOiBbXVxuICAgIH07XG5cbiAgICB0aGlzLl91cGRhdGVPdmVybGF5Q29udGFpbmVyKGNvbnRhaW5lcik7XG5cbiAgICB0aGlzLl9vdmVybGF5Q29udGFpbmVycy5wdXNoKGNvbnRhaW5lcik7XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9O1xuXG5cbiAgT3ZlcmxheXMucHJvdG90eXBlLl91cGRhdGVSb290ID0gZnVuY3Rpb24odmlld2JveCkge1xuICAgIHZhciBzY2FsZSA9IHZpZXdib3guc2NhbGUgfHwgMTtcblxuICAgIHZhciBtYXRyaXggPSAnbWF0cml4KCcgK1xuICAgIFtcbiAgICAgIHNjYWxlLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBzY2FsZSxcbiAgICAgIC0xICogdmlld2JveC54ICogc2NhbGUsXG4gICAgICAtMSAqIHZpZXdib3gueSAqIHNjYWxlXG4gICAgXS5qb2luKCcsJykgK1xuICAgICcpJztcblxuICAgIHNldFRyYW5zZm9ybSh0aGlzLl9vdmVybGF5Um9vdCwgbWF0cml4KTtcbiAgfTtcblxuXG4gIE92ZXJsYXlzLnByb3RvdHlwZS5fZ2V0T3ZlcmxheUNvbnRhaW5lciA9IGZ1bmN0aW9uKGVsZW1lbnQsIHJhdykge1xuICAgIHZhciBjb250YWluZXIgPSBmaW5kKHRoaXMuX292ZXJsYXlDb250YWluZXJzLCBmdW5jdGlvbihjKSB7XG4gICAgICByZXR1cm4gYy5lbGVtZW50ID09PSBlbGVtZW50O1xuICAgIH0pO1xuXG5cbiAgICBpZiAoIWNvbnRhaW5lciAmJiAhcmF3KSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlT3ZlcmxheUNvbnRhaW5lcihlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9O1xuXG5cbiAgT3ZlcmxheXMucHJvdG90eXBlLl9hZGRPdmVybGF5ID0gZnVuY3Rpb24ob3ZlcmxheSkge1xuXG4gICAgdmFyIGlkID0gb3ZlcmxheS5pZCxcbiAgICAgICAgZWxlbWVudCA9IG92ZXJsYXkuZWxlbWVudCxcbiAgICAgICAgaHRtbCA9IG92ZXJsYXkuaHRtbCxcbiAgICAgICAgaHRtbENvbnRhaW5lcixcbiAgICAgICAgb3ZlcmxheUNvbnRhaW5lcjtcblxuICAgIC8vIHVud3JhcCBqcXVlcnkgKGZvciB0aG9zZSB3aG8gbmVlZCBpdClcbiAgICBpZiAoaHRtbC5nZXQgJiYgaHRtbC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuanF1ZXJ5KSB7XG4gICAgICBodG1sID0gaHRtbC5nZXQoMCk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHByb3BlciBodG1sIGVsZW1lbnRzIGZyb21cbiAgICAvLyBvdmVybGF5IEhUTUwgc3RyaW5nc1xuICAgIGlmIChpc1N0cmluZyhodG1sKSkge1xuICAgICAgaHRtbCA9IGRvbWlmeSQxKGh0bWwpO1xuICAgIH1cblxuICAgIG92ZXJsYXlDb250YWluZXIgPSB0aGlzLl9nZXRPdmVybGF5Q29udGFpbmVyKGVsZW1lbnQpO1xuXG4gICAgaHRtbENvbnRhaW5lciA9IGRvbWlmeSQxKCc8ZGl2IGNsYXNzPVwiZGpzLW92ZXJsYXlcIiBkYXRhLW92ZXJsYXktaWQ9XCInICsgaWQgKyAnXCI+Jyk7XG4gICAgYXNzaWduKGh0bWxDb250YWluZXIsIHsgcG9zaXRpb246ICdhYnNvbHV0ZScgfSk7XG5cbiAgICBodG1sQ29udGFpbmVyLmFwcGVuZENoaWxkKGh0bWwpO1xuXG4gICAgaWYgKG92ZXJsYXkudHlwZSkge1xuICAgICAgY2xhc3NlcyhodG1sQ29udGFpbmVyKS5hZGQoJ2Rqcy1vdmVybGF5LScgKyBvdmVybGF5LnR5cGUpO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50Um9vdCA9IHRoaXMuX2NhbnZhcy5maW5kUm9vdChlbGVtZW50KTtcbiAgICB2YXIgYWN0aXZlUm9vdCA9IHRoaXMuX2NhbnZhcy5nZXRSb290RWxlbWVudCgpO1xuXG4gICAgc2V0VmlzaWJsZShodG1sQ29udGFpbmVyLCBlbGVtZW50Um9vdCA9PT0gYWN0aXZlUm9vdCk7XG5cbiAgICBvdmVybGF5Lmh0bWxDb250YWluZXIgPSBodG1sQ29udGFpbmVyO1xuXG4gICAgb3ZlcmxheUNvbnRhaW5lci5vdmVybGF5cy5wdXNoKG92ZXJsYXkpO1xuICAgIG92ZXJsYXlDb250YWluZXIuaHRtbC5hcHBlbmRDaGlsZChodG1sQ29udGFpbmVyKTtcblxuICAgIHRoaXMuX292ZXJsYXlzW2lkXSA9IG92ZXJsYXk7XG5cbiAgICB0aGlzLl91cGRhdGVPdmVybGF5KG92ZXJsYXkpO1xuICAgIHRoaXMuX3VwZGF0ZU92ZXJsYXlWaXNpYmlsdHkob3ZlcmxheSwgdGhpcy5fY2FudmFzLnZpZXdib3goKSk7XG4gIH07XG5cblxuICBPdmVybGF5cy5wcm90b3R5cGUuX3VwZGF0ZU92ZXJsYXlWaXNpYmlsdHkgPSBmdW5jdGlvbihvdmVybGF5LCB2aWV3Ym94KSB7XG4gICAgdmFyIHNob3cgPSBvdmVybGF5LnNob3csXG4gICAgICAgIHJvb3RFbGVtZW50ID0gdGhpcy5fY2FudmFzLmZpbmRSb290KG92ZXJsYXkuZWxlbWVudCksXG4gICAgICAgIG1pblpvb20gPSBzaG93ICYmIHNob3cubWluWm9vbSxcbiAgICAgICAgbWF4Wm9vbSA9IHNob3cgJiYgc2hvdy5tYXhab29tLFxuICAgICAgICBodG1sQ29udGFpbmVyID0gb3ZlcmxheS5odG1sQ29udGFpbmVyLFxuICAgICAgICBhY3RpdmVSb290RWxlbWVudCA9IHRoaXMuX2NhbnZhcy5nZXRSb290RWxlbWVudCgpLFxuICAgICAgICB2aXNpYmxlID0gdHJ1ZTtcblxuICAgIGlmIChyb290RWxlbWVudCAhPT0gYWN0aXZlUm9vdEVsZW1lbnQpIHtcbiAgICAgIHZpc2libGUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHNob3cpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKGlzRGVmaW5lZChtaW5ab29tKSAmJiBtaW5ab29tID4gdmlld2JveC5zY2FsZSkgfHxcbiAgICAgICAgKGlzRGVmaW5lZChtYXhab29tKSAmJiBtYXhab29tIDwgdmlld2JveC5zY2FsZSlcbiAgICAgICkge1xuICAgICAgICB2aXNpYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0VmlzaWJsZShodG1sQ29udGFpbmVyLCB2aXNpYmxlKTtcblxuICAgIHRoaXMuX3VwZGF0ZU92ZXJsYXlTY2FsZShvdmVybGF5LCB2aWV3Ym94KTtcbiAgfTtcblxuXG4gIE92ZXJsYXlzLnByb3RvdHlwZS5fdXBkYXRlT3ZlcmxheVNjYWxlID0gZnVuY3Rpb24ob3ZlcmxheSwgdmlld2JveCkge1xuICAgIHZhciBzaG91bGRTY2FsZSA9IG92ZXJsYXkuc2NhbGUsXG4gICAgICAgIG1pblNjYWxlLFxuICAgICAgICBtYXhTY2FsZSxcbiAgICAgICAgaHRtbENvbnRhaW5lciA9IG92ZXJsYXkuaHRtbENvbnRhaW5lcjtcblxuICAgIHZhciBzY2FsZSwgdHJhbnNmb3JtID0gJyc7XG5cbiAgICBpZiAoc2hvdWxkU2NhbGUgIT09IHRydWUpIHtcblxuICAgICAgaWYgKHNob3VsZFNjYWxlID09PSBmYWxzZSkge1xuICAgICAgICBtaW5TY2FsZSA9IDE7XG4gICAgICAgIG1heFNjYWxlID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pblNjYWxlID0gc2hvdWxkU2NhbGUubWluO1xuICAgICAgICBtYXhTY2FsZSA9IHNob3VsZFNjYWxlLm1heDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRGVmaW5lZChtaW5TY2FsZSkgJiYgdmlld2JveC5zY2FsZSA8IG1pblNjYWxlKSB7XG4gICAgICAgIHNjYWxlID0gKDEgLyB2aWV3Ym94LnNjYWxlIHx8IDEpICogbWluU2NhbGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0RlZmluZWQobWF4U2NhbGUpICYmIHZpZXdib3guc2NhbGUgPiBtYXhTY2FsZSkge1xuICAgICAgICBzY2FsZSA9ICgxIC8gdmlld2JveC5zY2FsZSB8fCAxKSAqIG1heFNjYWxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0RlZmluZWQoc2NhbGUpKSB7XG4gICAgICB0cmFuc2Zvcm0gPSAnc2NhbGUoJyArIHNjYWxlICsgJywnICsgc2NhbGUgKyAnKSc7XG4gICAgfVxuXG4gICAgc2V0VHJhbnNmb3JtKGh0bWxDb250YWluZXIsIHRyYW5zZm9ybSk7XG4gIH07XG5cblxuICBPdmVybGF5cy5wcm90b3R5cGUuX3VwZGF0ZU92ZXJsYXlzVmlzaWJpbHR5ID0gZnVuY3Rpb24odmlld2JveCkge1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZm9yRWFjaCQxKHRoaXMuX292ZXJsYXlzLCBmdW5jdGlvbihvdmVybGF5KSB7XG4gICAgICBzZWxmLl91cGRhdGVPdmVybGF5VmlzaWJpbHR5KG92ZXJsYXksIHZpZXdib3gpO1xuICAgIH0pO1xuICB9O1xuXG5cbiAgT3ZlcmxheXMucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZXZlbnRCdXMgPSB0aGlzLl9ldmVudEJ1cztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuXG4gICAgLy8gc2Nyb2xsL3pvb20gaW50ZWdyYXRpb25cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVZpZXdib3godmlld2JveCkge1xuICAgICAgc2VsZi5fdXBkYXRlUm9vdCh2aWV3Ym94KTtcbiAgICAgIHNlbGYuX3VwZGF0ZU92ZXJsYXlzVmlzaWJpbHR5KHZpZXdib3gpO1xuXG4gICAgICBzZWxmLnNob3coKTtcbiAgICB9XG5cbiAgICBldmVudEJ1cy5vbignY2FudmFzLnZpZXdib3guY2hhbmdpbmcnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgc2VsZi5oaWRlKCk7XG4gICAgfSk7XG5cbiAgICBldmVudEJ1cy5vbignY2FudmFzLnZpZXdib3guY2hhbmdlZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB1cGRhdGVWaWV3Ym94KGV2ZW50LnZpZXdib3gpO1xuICAgIH0pO1xuXG5cbiAgICAvLyByZW1vdmUgaW50ZWdyYXRpb25cblxuICAgIGV2ZW50QnVzLm9uKFsgJ3NoYXBlLnJlbW92ZScsICdjb25uZWN0aW9uLnJlbW92ZScgXSwgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBlLmVsZW1lbnQ7XG4gICAgICB2YXIgb3ZlcmxheXMgPSBzZWxmLmdldCh7IGVsZW1lbnQ6IGVsZW1lbnQgfSk7XG5cbiAgICAgIGZvckVhY2gkMShvdmVybGF5cywgZnVuY3Rpb24obykge1xuICAgICAgICBzZWxmLnJlbW92ZShvLmlkKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgY29udGFpbmVyID0gc2VsZi5fZ2V0T3ZlcmxheUNvbnRhaW5lcihlbGVtZW50KTtcblxuICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICByZW1vdmUkMShjb250YWluZXIuaHRtbCk7XG4gICAgICAgIHZhciBpID0gc2VsZi5fb3ZlcmxheUNvbnRhaW5lcnMuaW5kZXhPZihjb250YWluZXIpO1xuICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICBzZWxmLl9vdmVybGF5Q29udGFpbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLy8gbW92ZSBpbnRlZ3JhdGlvblxuXG4gICAgZXZlbnRCdXMub24oJ2VsZW1lbnQuY2hhbmdlZCcsIExPV19QUklPUklUWSQzLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGUuZWxlbWVudDtcblxuICAgICAgdmFyIGNvbnRhaW5lciA9IHNlbGYuX2dldE92ZXJsYXlDb250YWluZXIoZWxlbWVudCwgdHJ1ZSk7XG5cbiAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgZm9yRWFjaCQxKGNvbnRhaW5lci5vdmVybGF5cywgZnVuY3Rpb24ob3ZlcmxheSkge1xuICAgICAgICAgIHNlbGYuX3VwZGF0ZU92ZXJsYXkob3ZlcmxheSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNlbGYuX3VwZGF0ZU92ZXJsYXlDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLy8gbWFya2VyIGludGVncmF0aW9uLCBzaW1wbHkgYWRkIHRoZW0gb24gdGhlIG92ZXJsYXlzIGFzIGNsYXNzZXMsIHRvby5cblxuICAgIGV2ZW50QnVzLm9uKCdlbGVtZW50Lm1hcmtlci51cGRhdGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gc2VsZi5fZ2V0T3ZlcmxheUNvbnRhaW5lcihlLmVsZW1lbnQsIHRydWUpO1xuICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICBjbGFzc2VzKGNvbnRhaW5lci5odG1sKVtlLmFkZCA/ICdhZGQnIDogJ3JlbW92ZSddKGUubWFya2VyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgZXZlbnRCdXMub24oJ3Jvb3Quc2V0JywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl91cGRhdGVPdmVybGF5c1Zpc2liaWx0eShzZWxmLl9jYW52YXMudmlld2JveCgpKTtcbiAgICB9KTtcblxuICAgIC8vIGNsZWFyIG92ZXJsYXlzIHdpdGggZGlhZ3JhbVxuXG4gICAgZXZlbnRCdXMub24oJ2RpYWdyYW0uY2xlYXInLCB0aGlzLmNsZWFyLCB0aGlzKTtcbiAgfTtcblxuXG5cbiAgLy8gaGVscGVycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJvb3QocGFyZW50Tm9kZSkge1xuICAgIHZhciByb290ID0gZG9taWZ5JDEoXG4gICAgICAnPGRpdiBjbGFzcz1cImRqcy1vdmVybGF5LWNvbnRhaW5lclwiIC8+J1xuICAgICk7XG5cbiAgICBhc3NpZ24ocm9vdCwge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH0pO1xuXG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUocm9vdCwgcGFyZW50Tm9kZS5maXJzdENoaWxkKTtcblxuICAgIHJldHVybiByb290O1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UG9zaXRpb24oZWwsIHgsIHkpIHtcbiAgICBhc3NpZ24oZWwsIHsgbGVmdDogeCArICdweCcsIHRvcDogeSArICdweCcgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGVsZW1lbnQgdmlzaWJsZVxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Zpc2libGU9dHJ1ZV1cbiAgICovXG4gIGZ1bmN0aW9uIHNldFZpc2libGUoZWwsIHZpc2libGUpIHtcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmlzaWJsZSA9PT0gZmFsc2UgPyAnbm9uZScgOiAnJztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbCwgdHJhbnNmb3JtKSB7XG5cbiAgICBlbC5zdHlsZVsndHJhbnNmb3JtLW9yaWdpbiddID0gJ3RvcCBsZWZ0JztcblxuICAgIFsgJycsICctbXMtJywgJy13ZWJraXQtJyBdLmZvckVhY2goZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgICBlbC5zdHlsZVtwcmVmaXggKyAndHJhbnNmb3JtJ10gPSB0cmFuc2Zvcm07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyBpbXBvcnQoJ2RpZGknKS5Nb2R1bGVEZWNsYXJhdGlvbiB9XG4gICAqL1xuICB2YXIgT3ZlcmxheXNNb2R1bGUgPSB7XG4gICAgX19pbml0X186IFsgJ292ZXJsYXlzJyBdLFxuICAgIG92ZXJsYXlzOiBbICd0eXBlJywgT3ZlcmxheXMgXVxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi9jb3JlL0NhbnZhcycpLmRlZmF1bHR9IENhbnZhc1xuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi9jb3JlL0VsZW1lbnRSZWdpc3RyeScpLmRlZmF1bHR9IEVsZW1lbnRSZWdpc3RyeVxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi9jb3JlL0V2ZW50QnVzJykuZGVmYXVsdH0gRXZlbnRCdXNcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vY29yZS9HcmFwaGljc0ZhY3RvcnknKS5kZWZhdWx0fSBHcmFwaGljc0ZhY3RvcnlcbiAgICovXG5cbiAgLyoqXG4gICAqIEFkZHMgY2hhbmdlIHN1cHBvcnQgdG8gdGhlIGRpYWdyYW0sIGluY2x1ZGluZ1xuICAgKlxuICAgKiA8dWw+XG4gICAqICAgPGxpPnJlZHJhd2luZyBzaGFwZXMgYW5kIGNvbm5lY3Rpb25zIG9uIGNoYW5nZTwvbGk+XG4gICAqIDwvdWw+XG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICogQHBhcmFtIHtFbGVtZW50UmVnaXN0cnl9IGVsZW1lbnRSZWdpc3RyeVxuICAgKiBAcGFyYW0ge0dyYXBoaWNzRmFjdG9yeX0gZ3JhcGhpY3NGYWN0b3J5XG4gICAqL1xuICBmdW5jdGlvbiBDaGFuZ2VTdXBwb3J0KFxuICAgICAgZXZlbnRCdXMsIGNhbnZhcywgZWxlbWVudFJlZ2lzdHJ5LFxuICAgICAgZ3JhcGhpY3NGYWN0b3J5KSB7XG5cblxuICAgIC8vIHJlZHJhdyBzaGFwZXMgLyBjb25uZWN0aW9ucyBvbiBjaGFuZ2VcblxuICAgIGV2ZW50QnVzLm9uKCdlbGVtZW50LmNoYW5nZWQnLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICB2YXIgZWxlbWVudCA9IGV2ZW50LmVsZW1lbnQ7XG5cbiAgICAgIC8vIGVsZW1lbnQgbWlnaHQgaGF2ZSBiZWVuIGRlbGV0ZWQgYW5kIHJlcGxhY2VkIGJ5IG5ldyBlbGVtZW50IHdpdGggc2FtZSBJRFxuICAgICAgLy8gdGh1cyBjaGVjayBmb3IgcGFyZW50IG9mIGVsZW1lbnQgZXhjZXB0IGZvciByb290IGVsZW1lbnRcbiAgICAgIGlmIChlbGVtZW50LnBhcmVudCB8fCBlbGVtZW50ID09PSBjYW52YXMuZ2V0Um9vdEVsZW1lbnQoKSkge1xuICAgICAgICBldmVudC5nZnggPSBlbGVtZW50UmVnaXN0cnkuZ2V0R3JhcGhpY3MoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNoYXBlICsgZ2Z4IG1heSBoYXZlIGJlZW4gZGVsZXRlZFxuICAgICAgaWYgKCFldmVudC5nZngpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBldmVudEJ1cy5maXJlKGdldFR5cGUoZWxlbWVudCkgKyAnLmNoYW5nZWQnLCBldmVudCk7XG4gICAgfSk7XG5cbiAgICBldmVudEJ1cy5vbignZWxlbWVudHMuY2hhbmdlZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgIHZhciBlbGVtZW50cyA9IGV2ZW50LmVsZW1lbnRzO1xuXG4gICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZXZlbnRCdXMuZmlyZSgnZWxlbWVudC5jaGFuZ2VkJywgeyBlbGVtZW50OiBlIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGdyYXBoaWNzRmFjdG9yeS51cGRhdGVDb250YWlubWVudHMoZWxlbWVudHMpO1xuICAgIH0pO1xuXG4gICAgZXZlbnRCdXMub24oJ3NoYXBlLmNoYW5nZWQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgZ3JhcGhpY3NGYWN0b3J5LnVwZGF0ZSgnc2hhcGUnLCBldmVudC5lbGVtZW50LCBldmVudC5nZngpO1xuICAgIH0pO1xuXG4gICAgZXZlbnRCdXMub24oJ2Nvbm5lY3Rpb24uY2hhbmdlZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBncmFwaGljc0ZhY3RvcnkudXBkYXRlKCdjb25uZWN0aW9uJywgZXZlbnQuZWxlbWVudCwgZXZlbnQuZ2Z4KTtcbiAgICB9KTtcbiAgfVxuXG4gIENoYW5nZVN1cHBvcnQuJGluamVjdCA9IFtcbiAgICAnZXZlbnRCdXMnLFxuICAgICdjYW52YXMnLFxuICAgICdlbGVtZW50UmVnaXN0cnknLFxuICAgICdncmFwaGljc0ZhY3RvcnknXG4gIF07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsgaW1wb3J0KCdkaWRpJykuTW9kdWxlRGVjbGFyYXRpb24gfVxuICAgKi9cbiAgdmFyIENoYW5nZVN1cHBvcnRNb2R1bGUgPSB7XG4gICAgX19pbml0X186IFsgJ2NoYW5nZVN1cHBvcnQnIF0sXG4gICAgY2hhbmdlU3VwcG9ydDogWyAndHlwZScsIENoYW5nZVN1cHBvcnQgXVxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9jb3JlL1R5cGVzJykuRWxlbWVudExpa2V9IEVsZW1lbnRMaWtlXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL2NvcmUvRXZlbnRCdXMnKS5kZWZhdWx0fSBFdmVudEJ1c1xuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuL0NvbW1hbmRTdGFjaycpLkNvbW1hbmRDb250ZXh0fSBDb21tYW5kQ29udGV4dFxuICAgKlxuICAgKiBAdHlwZWRlZiB7c3RyaW5nfHN0cmluZ1tdfSBFdmVudHNcbiAgICogQHR5cGVkZWYgeyAoY29udGV4dDogQ29tbWFuZENvbnRleHQpID0+IEVsZW1lbnRMaWtlW10gfCB2b2lkIH0gSGFuZGxlckZ1bmN0aW9uXG4gICAqIEB0eXBlZGVmIHsgKGNvbnRleHQ6IENvbW1hbmRDb250ZXh0KSA9PiB2b2lkIH0gQ29tcG9zZUhhbmRsZXJGdW5jdGlvblxuICAgKi9cblxuICB2YXIgREVGQVVMVF9QUklPUklUWSQyID0gMTAwMDtcblxuICAvKipcbiAgICogQSB1dGlsaXR5IHRoYXQgY2FuIGJlIHVzZWQgdG8gcGx1ZyBpbnRvIHRoZSBjb21tYW5kIGV4ZWN1dGlvbiBmb3JcbiAgICogZXh0ZW5zaW9uIGFuZC9vciB2YWxpZGF0aW9uLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogaW1wb3J0IENvbW1hbmRJbnRlcmNlcHRvciBmcm9tICdkaWFncmFtLWpzL2xpYi9jb21tYW5kL0NvbW1hbmRJbnRlcmNlcHRvcic7XG4gICAqXG4gICAqIGNsYXNzIENvbW1hbmRMb2dnZXIgZXh0ZW5kcyBDb21tYW5kSW50ZXJjZXB0b3Ige1xuICAgKiAgIGNvbnN0cnVjdG9yKGV2ZW50QnVzKSB7XG4gICAqICAgICBzdXBlcihldmVudEJ1cyk7XG4gICAqXG4gICAqICAgdGhpcy5wcmVFeGVjdXRlKCdzaGFwZS5jcmVhdGUnLCAoZXZlbnQpID0+IHtcbiAgICogICAgIGNvbnNvbGUubG9nKCdjb21tYW5kU3RhY2suc2hhcGUtY3JlYXRlLnByZUV4ZWN1dGUnLCBldmVudCk7XG4gICAqICAgfSk7XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gICAqL1xuICBmdW5jdGlvbiBDb21tYW5kSW50ZXJjZXB0b3IoZXZlbnRCdXMpIHtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtFdmVudEJ1c31cbiAgICAgKi9cbiAgICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICB9XG5cbiAgQ29tbWFuZEludGVyY2VwdG9yLiRpbmplY3QgPSBbICdldmVudEJ1cycgXTtcblxuICBmdW5jdGlvbiB1bndyYXBFdmVudChmbiwgdGhhdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCB8fCBudWxsLCBldmVudC5jb250ZXh0LCBldmVudC5jb21tYW5kLCBldmVudCk7XG4gICAgfTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEludGVyY2VwdCBhIGNvbW1hbmQgZHVyaW5nIG9uZSBvZiB0aGUgcGhhc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50c30gW2V2ZW50c10gY29tbWFuZChzKSB0byBpbnRlcmNlcHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtob29rXSBwaGFzZSB0byBpbnRlcmNlcHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eV1cbiAgICogQHBhcmFtIHtDb21wb3NlSGFuZGxlckZ1bmN0aW9ufEhhbmRsZXJGdW5jdGlvbn0gaGFuZGxlckZuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vud3JhcF0gd2hldGhlciB0aGUgZXZlbnQgc2hvdWxkIGJlIHVud3JhcHBlZFxuICAgKiBAcGFyYW0ge2FueX0gW3RoYXRdXG4gICAqL1xuICBDb21tYW5kSW50ZXJjZXB0b3IucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnRzLCBob29rLCBwcmlvcml0eSwgaGFuZGxlckZuLCB1bndyYXAsIHRoYXQpIHtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGhvb2spIHx8IGlzTnVtYmVyKGhvb2spKSB7XG4gICAgICB0aGF0ID0gdW53cmFwO1xuICAgICAgdW53cmFwID0gaGFuZGxlckZuO1xuICAgICAgaGFuZGxlckZuID0gcHJpb3JpdHk7XG4gICAgICBwcmlvcml0eSA9IGhvb2s7XG4gICAgICBob29rID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihwcmlvcml0eSkpIHtcbiAgICAgIHRoYXQgPSB1bndyYXA7XG4gICAgICB1bndyYXAgPSBoYW5kbGVyRm47XG4gICAgICBoYW5kbGVyRm4gPSBwcmlvcml0eTtcbiAgICAgIHByaW9yaXR5ID0gREVGQVVMVF9QUklPUklUWSQyO1xuICAgIH1cblxuICAgIGlmIChpc09iamVjdCh1bndyYXApKSB7XG4gICAgICB0aGF0ID0gdW53cmFwO1xuICAgICAgdW53cmFwID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKGhhbmRsZXJGbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaGFuZGxlckZuIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGlmICghaXNBcnJheSQyKGV2ZW50cykpIHtcbiAgICAgIGV2ZW50cyA9IFsgZXZlbnRzIF07XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXM7XG5cbiAgICBmb3JFYWNoJDEoZXZlbnRzLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAvLyBjb25jYXQgY29tbWFuZFN0YWNrKC5ldmVudCk/KC5ob29rKT9cbiAgICAgIHZhciBmdWxsRXZlbnQgPSBbICdjb21tYW5kU3RhY2snLCBldmVudCwgaG9vayBdLmZpbHRlcihmdW5jdGlvbihlKSB7IHJldHVybiBlOyB9KS5qb2luKCcuJyk7XG5cbiAgICAgIGV2ZW50QnVzLm9uKGZ1bGxFdmVudCwgcHJpb3JpdHksIHVud3JhcCA/IHVud3JhcEV2ZW50KGhhbmRsZXJGbiwgdGhhdCkgOiBoYW5kbGVyRm4sIHRoYXQpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSA8Y2FuRXhlY3V0ZT4gcGhhc2Ugb2YgY29tbWFuZCBpbnRlcmNlcHRvci5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudHN9IFtldmVudHNdIGNvbW1hbmQocykgdG8gaW50ZXJjZXB0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHldXG4gICAqIEBwYXJhbSB7Q29tcG9zZUhhbmRsZXJGdW5jdGlvbnxIYW5kbGVyRnVuY3Rpb259IGhhbmRsZXJGblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1bndyYXBdIHdoZXRoZXIgdGhlIGV2ZW50IHNob3VsZCBiZSB1bndyYXBwZWRcbiAgICogQHBhcmFtIHthbnl9IFt0aGF0XVxuICAgKi9cbiAgQ29tbWFuZEludGVyY2VwdG9yLnByb3RvdHlwZS5jYW5FeGVjdXRlID0gY3JlYXRlSG9vaygnY2FuRXhlY3V0ZScpO1xuXG4gIC8qKlxuICAgKiBBZGQgYSA8cHJlRXhlY3V0ZT4gcGhhc2Ugb2YgY29tbWFuZCBpbnRlcmNlcHRvci5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudHN9IFtldmVudHNdIGNvbW1hbmQocykgdG8gaW50ZXJjZXB0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHldXG4gICAqIEBwYXJhbSB7Q29tcG9zZUhhbmRsZXJGdW5jdGlvbnxIYW5kbGVyRnVuY3Rpb259IGhhbmRsZXJGblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1bndyYXBdIHdoZXRoZXIgdGhlIGV2ZW50IHNob3VsZCBiZSB1bndyYXBwZWRcbiAgICogQHBhcmFtIHthbnl9IFt0aGF0XVxuICAgKi9cbiAgQ29tbWFuZEludGVyY2VwdG9yLnByb3RvdHlwZS5wcmVFeGVjdXRlID0gY3JlYXRlSG9vaygncHJlRXhlY3V0ZScpO1xuXG4gIC8qKlxuICAgKiBBZGQgYSA8cHJlRXhlY3V0ZWQ+IHBoYXNlIG9mIGNvbW1hbmQgaW50ZXJjZXB0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRzfSBbZXZlbnRzXSBjb21tYW5kKHMpIHRvIGludGVyY2VwdFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5XVxuICAgKiBAcGFyYW0ge0NvbXBvc2VIYW5kbGVyRnVuY3Rpb258SGFuZGxlckZ1bmN0aW9ufSBoYW5kbGVyRm5cbiAgICogQHBhcmFtIHtib29sZWFufSBbdW53cmFwXSB3aGV0aGVyIHRoZSBldmVudCBzaG91bGQgYmUgdW53cmFwcGVkXG4gICAqIEBwYXJhbSB7YW55fSBbdGhhdF1cbiAgICovXG4gIENvbW1hbmRJbnRlcmNlcHRvci5wcm90b3R5cGUucHJlRXhlY3V0ZWQgPSBjcmVhdGVIb29rKCdwcmVFeGVjdXRlZCcpO1xuXG4gIC8qKlxuICAgKiBBZGQgYSA8ZXhlY3V0ZT4gcGhhc2Ugb2YgY29tbWFuZCBpbnRlcmNlcHRvci5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudHN9IFtldmVudHNdIGNvbW1hbmQocykgdG8gaW50ZXJjZXB0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHldXG4gICAqIEBwYXJhbSB7Q29tcG9zZUhhbmRsZXJGdW5jdGlvbnxIYW5kbGVyRnVuY3Rpb259IGhhbmRsZXJGblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1bndyYXBdIHdoZXRoZXIgdGhlIGV2ZW50IHNob3VsZCBiZSB1bndyYXBwZWRcbiAgICogQHBhcmFtIHthbnl9IFt0aGF0XVxuICAgKi9cbiAgQ29tbWFuZEludGVyY2VwdG9yLnByb3RvdHlwZS5leGVjdXRlID0gY3JlYXRlSG9vaygnZXhlY3V0ZScpO1xuXG4gIC8qKlxuICAgKiBBZGQgYSA8ZXhlY3V0ZWQ+IHBoYXNlIG9mIGNvbW1hbmQgaW50ZXJjZXB0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRzfSBbZXZlbnRzXSBjb21tYW5kKHMpIHRvIGludGVyY2VwdFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5XVxuICAgKiBAcGFyYW0ge0NvbXBvc2VIYW5kbGVyRnVuY3Rpb258SGFuZGxlckZ1bmN0aW9ufSBoYW5kbGVyRm5cbiAgICogQHBhcmFtIHtib29sZWFufSBbdW53cmFwXSB3aGV0aGVyIHRoZSBldmVudCBzaG91bGQgYmUgdW53cmFwcGVkXG4gICAqIEBwYXJhbSB7YW55fSBbdGhhdF1cbiAgICovXG4gIENvbW1hbmRJbnRlcmNlcHRvci5wcm90b3R5cGUuZXhlY3V0ZWQgPSBjcmVhdGVIb29rKCdleGVjdXRlZCcpO1xuXG4gIC8qKlxuICAgKiBBZGQgYSA8cG9zdEV4ZWN1dGU+IHBoYXNlIG9mIGNvbW1hbmQgaW50ZXJjZXB0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRzfSBbZXZlbnRzXSBjb21tYW5kKHMpIHRvIGludGVyY2VwdFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5XVxuICAgKiBAcGFyYW0ge0NvbXBvc2VIYW5kbGVyRnVuY3Rpb258SGFuZGxlckZ1bmN0aW9ufSBoYW5kbGVyRm5cbiAgICogQHBhcmFtIHtib29sZWFufSBbdW53cmFwXSB3aGV0aGVyIHRoZSBldmVudCBzaG91bGQgYmUgdW53cmFwcGVkXG4gICAqIEBwYXJhbSB7YW55fSBbdGhhdF1cbiAgICovXG4gIENvbW1hbmRJbnRlcmNlcHRvci5wcm90b3R5cGUucG9zdEV4ZWN1dGUgPSBjcmVhdGVIb29rKCdwb3N0RXhlY3V0ZScpO1xuXG4gIC8qKlxuICAgKiBBZGQgYSA8cG9zdEV4ZWN1dGVkPiBwaGFzZSBvZiBjb21tYW5kIGludGVyY2VwdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50c30gW2V2ZW50c10gY29tbWFuZChzKSB0byBpbnRlcmNlcHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eV1cbiAgICogQHBhcmFtIHtDb21wb3NlSGFuZGxlckZ1bmN0aW9ufEhhbmRsZXJGdW5jdGlvbn0gaGFuZGxlckZuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vud3JhcF0gd2hldGhlciB0aGUgZXZlbnQgc2hvdWxkIGJlIHVud3JhcHBlZFxuICAgKiBAcGFyYW0ge2FueX0gW3RoYXRdXG4gICAqL1xuICBDb21tYW5kSW50ZXJjZXB0b3IucHJvdG90eXBlLnBvc3RFeGVjdXRlZCA9IGNyZWF0ZUhvb2soJ3Bvc3RFeGVjdXRlZCcpO1xuXG4gIC8qKlxuICAgKiBBZGQgYSA8cmV2ZXJ0PiBwaGFzZSBvZiBjb21tYW5kIGludGVyY2VwdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50c30gW2V2ZW50c10gY29tbWFuZChzKSB0byBpbnRlcmNlcHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eV1cbiAgICogQHBhcmFtIHtDb21wb3NlSGFuZGxlckZ1bmN0aW9ufEhhbmRsZXJGdW5jdGlvbn0gaGFuZGxlckZuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vud3JhcF0gd2hldGhlciB0aGUgZXZlbnQgc2hvdWxkIGJlIHVud3JhcHBlZFxuICAgKiBAcGFyYW0ge2FueX0gW3RoYXRdXG4gICAqL1xuICBDb21tYW5kSW50ZXJjZXB0b3IucHJvdG90eXBlLnJldmVydCA9IGNyZWF0ZUhvb2soJ3JldmVydCcpO1xuXG4gIC8qKlxuICAgKiBBZGQgYSA8cmV2ZXJ0ZWQ+IHBoYXNlIG9mIGNvbW1hbmQgaW50ZXJjZXB0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRzfSBbZXZlbnRzXSBjb21tYW5kKHMpIHRvIGludGVyY2VwdFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5XVxuICAgKiBAcGFyYW0ge0NvbXBvc2VIYW5kbGVyRnVuY3Rpb258SGFuZGxlckZ1bmN0aW9ufSBoYW5kbGVyRm5cbiAgICogQHBhcmFtIHtib29sZWFufSBbdW53cmFwXSB3aGV0aGVyIHRoZSBldmVudCBzaG91bGQgYmUgdW53cmFwcGVkXG4gICAqIEBwYXJhbSB7YW55fSBbdGhhdF1cbiAgICovXG4gIENvbW1hbmRJbnRlcmNlcHRvci5wcm90b3R5cGUucmV2ZXJ0ZWQgPSBjcmVhdGVIb29rKCdyZXZlcnRlZCcpO1xuXG4gIC8qXG4gICAqIEFkZCBwcm90b3R5cGUgbWV0aG9kcyBmb3IgZWFjaCBwaGFzZSBvZiBjb21tYW5kIGV4ZWN1dGlvbiAoZS5nLiBleGVjdXRlLFxuICAgKiByZXZlcnQpLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaG9va1xuICAgKlxuICAgKiBAcmV0dXJuIHsgKFxuICAgKiAgIGV2ZW50cz86IEV2ZW50cyxcbiAgICogICBwcmlvcml0eT86IG51bWJlcixcbiAgICogICBoYW5kbGVyRm46IENvbXBvc2VIYW5kbGVyRnVuY3Rpb258SGFuZGxlckZ1bmN0aW9uLFxuICAgKiAgIHVud3JhcD86IGJvb2xlYW5cbiAgICogKSA9PiBhbnkgfVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlSG9vayhob29rKSB7XG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7Q29tbWFuZEludGVyY2VwdG9yfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudHN9IFtldmVudHNdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eV1cbiAgICAgKiBAcGFyYW0ge0NvbXBvc2VIYW5kbGVyRnVuY3Rpb258SGFuZGxlckZ1bmN0aW9ufSBoYW5kbGVyRm5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1bndyYXBdXG4gICAgICogQHBhcmFtIHthbnl9IFt0aGF0XVxuICAgICAqL1xuICAgIGNvbnN0IGhvb2tGbiA9IGZ1bmN0aW9uKGV2ZW50cywgcHJpb3JpdHksIGhhbmRsZXJGbiwgdW53cmFwLCB0aGF0KSB7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGV2ZW50cykgfHwgaXNOdW1iZXIoZXZlbnRzKSkge1xuICAgICAgICB0aGF0ID0gdW53cmFwO1xuICAgICAgICB1bndyYXAgPSBoYW5kbGVyRm47XG4gICAgICAgIGhhbmRsZXJGbiA9IHByaW9yaXR5O1xuICAgICAgICBwcmlvcml0eSA9IGV2ZW50cztcbiAgICAgICAgZXZlbnRzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vbihldmVudHMsIGhvb2ssIHByaW9yaXR5LCBoYW5kbGVyRm4sIHVud3JhcCwgdGhhdCk7XG4gICAgfTtcblxuICAgIHJldHVybiBob29rRm47XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnZGlkaScpLkluamVjdG9yfSBJbmplY3RvclxuICAgKlxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi9jb3JlL0NhbnZhcycpLmRlZmF1bHR9IENhbnZhc1xuICAgKi9cblxuICAvKipcbiAgICogQSBtb2RlbGluZyBiZWhhdmlvciB0aGF0IGVuc3VyZXMgd2Ugc2V0IHRoZSBjb3JyZWN0IHJvb3QgZWxlbWVudFxuICAgKiBhcyB3ZSB1bmRvIGFuZCByZWRvIGNvbW1hbmRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gICAqIEBwYXJhbSB7SW5qZWN0b3J9IGluamVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBSb290RWxlbWVudHNCZWhhdmlvcihjYW52YXMsIGluamVjdG9yKSB7XG5cbiAgICBpbmplY3Rvci5pbnZva2UoQ29tbWFuZEludGVyY2VwdG9yLCB0aGlzKTtcblxuICAgIHRoaXMuZXhlY3V0ZWQoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dDtcblxuICAgICAgaWYgKGNvbnRleHQucm9vdEVsZW1lbnQpIHtcbiAgICAgICAgY2FudmFzLnNldFJvb3RFbGVtZW50KGNvbnRleHQucm9vdEVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5yb290RWxlbWVudCA9IGNhbnZhcy5nZXRSb290RWxlbWVudCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5yZXZlcnQoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dDtcblxuICAgICAgaWYgKGNvbnRleHQucm9vdEVsZW1lbnQpIHtcbiAgICAgICAgY2FudmFzLnNldFJvb3RFbGVtZW50KGNvbnRleHQucm9vdEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZShSb290RWxlbWVudHNCZWhhdmlvciwgQ29tbWFuZEludGVyY2VwdG9yKTtcblxuICBSb290RWxlbWVudHNCZWhhdmlvci4kaW5qZWN0ID0gWyAnY2FudmFzJywgJ2luamVjdG9yJyBdO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7IGltcG9ydCgnZGlkaScpLk1vZHVsZURlY2xhcmF0aW9uIH1cbiAgICovXG4gIHZhciBSb290RWxlbWVudHNNb2R1bGUgPSB7XG4gICAgX19pbml0X186IFsgJ3Jvb3RFbGVtZW50c0JlaGF2aW9yJyBdLFxuICAgIHJvb3RFbGVtZW50c0JlaGF2aW9yOiBbICd0eXBlJywgUm9vdEVsZW1lbnRzQmVoYXZpb3IgXVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG5cbiAgdmFyIEhUTUxfRVNDQVBFX01BUCA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgJ1xcJyc6ICcmIzM5OydcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVIVE1MKHN0cikge1xuICAgIHN0ciA9ICcnICsgc3RyO1xuXG4gICAgcmV0dXJuIHN0ciAmJiBzdHIucmVwbGFjZSgvWyY8PlwiJ10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBIVE1MX0VTQ0FQRV9NQVBbbWF0Y2hdO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXHJcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vbW9kZWwvVHlwZXMnKS5FbGVtZW50fSBFbGVtZW50XHJcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vbW9kZWwvVHlwZXMnKS5Nb2RkbGVFbGVtZW50fSBNb2RkbGVFbGVtZW50XHJcbiAgICovXHJcblxyXG4gIHZhciBwbGFuZVN1ZmZpeCA9ICdfcGxhbmUnO1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgcGxhbmUgSUQgZm9yIGEgcHJpbWFyeSBzaGFwZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0VsZW1lbnR8TW9kZGxlRWxlbWVudH0gZWxlbWVudFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGdldFBsYW5lSWRGcm9tU2hhcGUoZWxlbWVudCkge1xyXG4gICAgdmFyIGlkID0gZWxlbWVudC5pZDtcclxuXHJcbiAgICBpZiAoaXMkMShlbGVtZW50LCAnYnBtbjpTdWJQcm9jZXNzJykpIHtcclxuICAgICAgcmV0dXJuIGFkZFBsYW5lU3VmZml4KGlkKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaWQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhZGRQbGFuZVN1ZmZpeChpZCkge1xyXG4gICAgcmV0dXJuIGlkICsgcGxhbmVTdWZmaXg7XHJcbiAgfVxuXG4gIC8qKlxyXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJ2RpYWdyYW0tanMvbGliL2NvcmUvQ2FudmFzJykuZGVmYXVsdH0gQ2FudmFzXHJcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnZGlhZ3JhbS1qcy9saWIvY29yZS9FbGVtZW50UmVnaXN0cnknKS5kZWZhdWx0fSBFbGVtZW50UmVnaXN0cnlcclxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCdkaWFncmFtLWpzL2xpYi9jb3JlL0V2ZW50QnVzJykuZGVmYXVsdH0gRXZlbnRCdXNcclxuICAgKlxyXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL21vZGVsL1R5cGVzJykuRWxlbWVudH0gRWxlbWVudFxyXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL21vZGVsL1R5cGVzJykuU2hhcGV9IFNoYXBlXHJcbiAgICovXHJcblxyXG4gIHZhciBPUEVOX0NMQVNTID0gJ2Jqcy1icmVhZGNydW1icy1zaG93bic7XHJcblxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIG92ZXJsYXlzIHRoYXQgYWxsb3cgc3dpdGNoaW5nIHBsYW5lcyBvbiBjb2xsYXBzZWQgc3VicHJvY2Vzc2VzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcclxuICAgKiBAcGFyYW0ge0VsZW1lbnRSZWdpc3RyeX0gZWxlbWVudFJlZ2lzdHJ5XHJcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIERyaWxsZG93bkJyZWFkY3J1bWJzKGV2ZW50QnVzLCBlbGVtZW50UmVnaXN0cnksIGNhbnZhcykge1xyXG4gICAgdmFyIGJyZWFkY3J1bWJzID0gZG9taWZ5JDEoJzx1bCBjbGFzcz1cImJqcy1icmVhZGNydW1ic1wiPjwvdWw+Jyk7XHJcbiAgICB2YXIgY29udGFpbmVyID0gY2FudmFzLmdldENvbnRhaW5lcigpO1xyXG4gICAgdmFyIGNvbnRhaW5lckNsYXNzZXMgPSBjbGFzc2VzKGNvbnRhaW5lcik7XHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYnJlYWRjcnVtYnMpO1xyXG5cclxuICAgIHZhciBidXNpbmVzc09iamVjdFBhcmVudHMgPSBbXTtcclxuXHJcbiAgICAvLyB1cGRhdGUgYnJlYWRjcnVtYnMgaWYgbmFtZSBvciBJRCBvZiB0aGUgcHJpbWFyeSBzaGFwZSBjaGFuZ2VzXHJcbiAgICBldmVudEJ1cy5vbignZWxlbWVudC5jaGFuZ2VkJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgdmFyIHNoYXBlID0gZXZlbnQuZWxlbWVudCxcclxuICAgICAgICAgIGJ1c2luZXNzT2JqZWN0ID0gZ2V0QnVzaW5lc3NPYmplY3Qoc2hhcGUpO1xyXG5cclxuICAgICAgdmFyIGlzUHJlc2VudCA9IGZpbmQoYnVzaW5lc3NPYmplY3RQYXJlbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQgPT09IGJ1c2luZXNzT2JqZWN0O1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICghaXNQcmVzZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB1cGRhdGVCcmVhZGNydW1icygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBkaXNwbGF5ZWQgYnJlYWRjcnVtYnMuIElmIG5vIGVsZW1lbnQgaXMgcHJvdmlkZWQsIG9ubHkgdGhlXHJcbiAgICAgKiBsYWJlbHMgYXJlIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBbZWxlbWVudF1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdXBkYXRlQnJlYWRjcnVtYnMoZWxlbWVudCkge1xyXG4gICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgIGJ1c2luZXNzT2JqZWN0UGFyZW50cyA9IGdldEJ1c2luZXNzT2JqZWN0UGFyZW50Q2hhaW4oZWxlbWVudCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBwYXRoID0gYnVzaW5lc3NPYmplY3RQYXJlbnRzLmZsYXRNYXAoZnVuY3Rpb24ocGFyZW50KSB7XHJcbiAgICAgICAgdmFyIHBhcmVudFBsYW5lID1cclxuICAgICAgICAgIGNhbnZhcy5maW5kUm9vdChnZXRQbGFuZUlkRnJvbVNoYXBlKHBhcmVudCkpIHx8XHJcbiAgICAgICAgICBjYW52YXMuZmluZFJvb3QocGFyZW50LmlkKTtcclxuXHJcbiAgICAgICAgLy8gd2hlbiB0aGUgcm9vdCBpcyBhIGNvbGxhYm9yYXRpb24sIHRoZSBwcm9jZXNzIGRvZXMgbm90IGhhdmUgYVxyXG4gICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBpbiB0aGUgZWxlbWVudFJlZ2lzdHkuIEluc3RlYWQsIHdlIHNlYXJjaFxyXG4gICAgICAgIC8vIGZvciB0aGUgY29ycmVzcG9uZGluZyBwYXJ0aWNpcGFudFxyXG4gICAgICAgIGlmICghcGFyZW50UGxhbmUgJiYgaXMkMShwYXJlbnQsICdicG1uOlByb2Nlc3MnKSkge1xyXG4gICAgICAgICAgdmFyIHBhcnRpY2lwYW50ID0gZWxlbWVudFJlZ2lzdHJ5LmZpbmQoZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICAgICAgICB2YXIgYnVzaW5lc3NPYmplY3QgPSBnZXRCdXNpbmVzc09iamVjdChlbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBidXNpbmVzc09iamVjdCAmJiBidXNpbmVzc09iamVjdC5nZXQoJ3Byb2Nlc3NSZWYnKSA9PT0gcGFyZW50O1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgcGFyZW50UGxhbmUgPSBwYXJ0aWNpcGFudCAmJiBjYW52YXMuZmluZFJvb3QocGFydGljaXBhbnQuaWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFwYXJlbnRQbGFuZSkge1xyXG4gICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRpdGxlID0gZXNjYXBlSFRNTChwYXJlbnQubmFtZSB8fCBwYXJlbnQuaWQpO1xyXG4gICAgICAgIHZhciBsaW5rID0gZG9taWZ5JDEoJzxsaT48c3BhbiBjbGFzcz1cImJqcy1jcnVtYlwiPjxhIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiPicgKyB0aXRsZSArICc8L2E+PC9zcGFuPjwvbGk+Jyk7XHJcblxyXG4gICAgICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGNhbnZhcy5zZXRSb290RWxlbWVudChwYXJlbnRQbGFuZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBsaW5rO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGJyZWFkY3J1bWJzLmlubmVySFRNTCA9ICcnO1xyXG5cclxuICAgICAgLy8gc2hvdyBicmVhZGNydW1icyBhbmQgZXhwb3NlIHN0YXRlIHRvIC5kanMtY29udGFpbmVyXHJcbiAgICAgIHZhciB2aXNpYmxlID0gcGF0aC5sZW5ndGggPiAxO1xyXG5cclxuICAgICAgY29udGFpbmVyQ2xhc3Nlcy50b2dnbGUoT1BFTl9DTEFTUywgdmlzaWJsZSk7XHJcblxyXG4gICAgICBwYXRoLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICAgIGJyZWFkY3J1bWJzLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBldmVudEJ1cy5vbigncm9vdC5zZXQnLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICB1cGRhdGVCcmVhZGNydW1icyhldmVudC5lbGVtZW50KTtcclxuICAgIH0pO1xyXG5cclxuICB9XHJcblxyXG4gIERyaWxsZG93bkJyZWFkY3J1bWJzLiRpbmplY3QgPSBbICdldmVudEJ1cycsICdlbGVtZW50UmVnaXN0cnknLCAnY2FudmFzJyBdO1xyXG5cclxuXHJcbiAgLy8gaGVscGVycyAvLy8vLy8vLy8vXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHBhcmVudHMgZm9yIHRoZSBlbGVtZW50IHVzaW5nIHRoZSBidXNpbmVzcyBvYmplY3QgY2hhaW4sXHJcbiAgICogc3RhcnRpbmcgd2l0aCB0aGUgcm9vdCBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTaGFwZX0gY2hpbGRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1NoYXBlfVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGdldEJ1c2luZXNzT2JqZWN0UGFyZW50Q2hhaW4oY2hpbGQpIHtcclxuICAgIHZhciBidXNpbmVzc09iamVjdCA9IGdldEJ1c2luZXNzT2JqZWN0KGNoaWxkKTtcclxuXHJcbiAgICB2YXIgcGFyZW50cyA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGVsZW1lbnQgPSBidXNpbmVzc09iamVjdDsgZWxlbWVudDsgZWxlbWVudCA9IGVsZW1lbnQuJHBhcmVudCkge1xyXG4gICAgICBpZiAoaXMkMShlbGVtZW50LCAnYnBtbjpTdWJQcm9jZXNzJykgfHwgaXMkMShlbGVtZW50LCAnYnBtbjpQcm9jZXNzJykpIHtcclxuICAgICAgICBwYXJlbnRzLnB1c2goZWxlbWVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFyZW50cy5yZXZlcnNlKCk7XHJcbiAgfVxuXG4gIC8qKlxyXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJ2RpYWdyYW0tanMvbGliL2NvcmUvQ2FudmFzJykuZGVmYXVsdH0gQ2FudmFzXHJcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnZGlhZ3JhbS1qcy9saWIvY29yZS9FdmVudEJ1cycpLmRlZmF1bHR9IEV2ZW50QnVzXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdmUgY29sbGFwc2VkIHN1YnByb2Nlc3NlcyBpbnRvIHZpZXcgd2hlbiBkcmlsbGluZyBkb3duLlxyXG4gICAqXHJcbiAgICogWm9vbSBhbmQgc2Nyb2xsIGFyZSBzYXZlZCBpbiBhIHNlc3Npb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xyXG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcclxuICAgKi9cclxuICBmdW5jdGlvbiBEcmlsbGRvd25DZW50ZXJpbmcoZXZlbnRCdXMsIGNhbnZhcykge1xyXG5cclxuICAgIHZhciBjdXJyZW50Um9vdCA9IG51bGw7XHJcbiAgICB2YXIgcG9zaXRpb25NYXAgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgZXZlbnRCdXMub24oJ3Jvb3Quc2V0JywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgdmFyIG5ld1Jvb3QgPSBldmVudC5lbGVtZW50O1xyXG4gICAgICB2YXIgY3VycmVudFZpZXdib3ggPSBjYW52YXMudmlld2JveCgpO1xyXG4gICAgICB2YXIgc3RvcmVkVmlld2JveCA9IHBvc2l0aW9uTWFwLmdldChuZXdSb290KTtcclxuXHJcbiAgICAgIHBvc2l0aW9uTWFwLnNldChjdXJyZW50Um9vdCwge1xyXG4gICAgICAgIHg6IGN1cnJlbnRWaWV3Ym94LngsXHJcbiAgICAgICAgeTogY3VycmVudFZpZXdib3gueSxcclxuICAgICAgICB6b29tOiBjdXJyZW50Vmlld2JveC5zY2FsZVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGN1cnJlbnRSb290ID0gbmV3Um9vdDtcclxuXHJcbiAgICAgIC8vIEtlZXAgdmlld2JveCB3aGVuIHJlcGxhY2luZyByb290IGVsZW1lbnRzXHJcbiAgICAgIGlmICghaXMkMShuZXdSb290LCAnYnBtbjpTdWJQcm9jZXNzJykgJiYgIXN0b3JlZFZpZXdib3gpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0b3JlZFZpZXdib3ggPSBzdG9yZWRWaWV3Ym94IHx8IHsgeDogMCwgeTogMCwgem9vbTogMSB9O1xyXG5cclxuICAgICAgdmFyIGR4ID0gKGN1cnJlbnRWaWV3Ym94LnggLSBzdG9yZWRWaWV3Ym94LngpICogY3VycmVudFZpZXdib3guc2NhbGUsXHJcbiAgICAgICAgICBkeSA9IChjdXJyZW50Vmlld2JveC55IC0gc3RvcmVkVmlld2JveC55KSAqIGN1cnJlbnRWaWV3Ym94LnNjYWxlO1xyXG5cclxuICAgICAgaWYgKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XHJcbiAgICAgICAgY2FudmFzLnNjcm9sbCh7XHJcbiAgICAgICAgICBkeDogZHgsXHJcbiAgICAgICAgICBkeTogZHlcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHN0b3JlZFZpZXdib3guem9vbSAhPT0gY3VycmVudFZpZXdib3guc2NhbGUpIHtcclxuICAgICAgICBjYW52YXMuem9vbShzdG9yZWRWaWV3Ym94Lnpvb20sIHsgeDogMCwgeTogMCB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZXZlbnRCdXMub24oJ2RpYWdyYW0uY2xlYXInLCBmdW5jdGlvbigpIHtcclxuICAgICAgcG9zaXRpb25NYXAuY2xlYXIoKTtcclxuICAgICAgY3VycmVudFJvb3QgPSBudWxsO1xyXG4gICAgfSk7XHJcblxyXG4gIH1cclxuXHJcbiAgRHJpbGxkb3duQ2VudGVyaW5nLiRpbmplY3QgPSBbICdldmVudEJ1cycsICdjYW52YXMnIF07XHJcblxyXG5cclxuICAvKipcclxuICAgKiBFUzUgTWFwIGltcGxlbWVudGF0aW9uLiBXb3Jrcy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBNYXAoKSB7XHJcblxyXG4gICAgdGhpcy5fZW50cmllcyA9IFtdO1xyXG5cclxuICAgIHRoaXMuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG5cclxuICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcblxyXG4gICAgICBmb3IgKHZhciBrIGluIHRoaXMuX2VudHJpZXMpIHtcclxuICAgICAgICBpZiAodGhpcy5fZW50cmllc1trXVswXSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICB0aGlzLl9lbnRyaWVzW2tdWzFdID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFmb3VuZCkge1xyXG4gICAgICAgIHRoaXMuX2VudHJpZXMucHVzaChbIGtleSwgdmFsdWUgXSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5nZXQgPSBmdW5jdGlvbihrZXkpIHtcclxuXHJcbiAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5fZW50cmllcykge1xyXG4gICAgICAgIGlmICh0aGlzLl9lbnRyaWVzW2tdWzBdID09PSBrZXkpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl9lbnRyaWVzW2tdWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY2xlYXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5fZW50cmllcy5sZW5ndGggPSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uKGtleSkge1xyXG5cclxuICAgICAgdmFyIGlkeCA9IC0xO1xyXG5cclxuICAgICAgZm9yICh2YXIgayBpbiB0aGlzLl9lbnRyaWVzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2VudHJpZXNba11bMF0gPT09IGtleSkge1xyXG4gICAgICAgICAgaWR4ID0gaztcclxuXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICAgICAgdGhpcy5fZW50cmllcy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XG5cbiAgLyoqXHJcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnZGlhZ3JhbS1qcy9saWIvY29yZS9FdmVudEJ1cycpLmRlZmF1bHR9IEV2ZW50QnVzXHJcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vbW9kZWwvVHlwZXMnKS5Nb2RkbGV9IE1vZGRsZVxyXG4gICAqXHJcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vbW9kZWwvVHlwZXMnKS5FbGVtZW50fSBFbGVtZW50XHJcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vbW9kZWwvVHlwZXMnKS5TaGFwZX0gU2hhcGVcclxuICAgKlxyXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJ2RpYWdyYW0tanMvbGliL2NvcmUvQ2FudmFzJykuQ2FudmFzUGxhbmV9IENhbnZhc1BsYW5lXHJcbiAgICpcclxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCdkaWFncmFtLWpzL2xpYi91dGlsL1R5cGVzJykuUmVjdH0gUmVjdFxyXG4gICAqL1xyXG5cclxuICB2YXIgREVGQVVMVF9QT1NJVElPTiA9IHtcclxuICAgIHg6IDE4MCxcclxuICAgIHk6IDE2MFxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEhvb2sgaW50byBgaW1wb3J0LnJlbmRlci5zdGFydGAgYW5kIGNyZWF0ZSBuZXcgcGxhbmVzIGZvciBkaWFncmFtcyB3aXRoXHJcbiAgICogY29sbGFwc2VkIHN1YnByb2Nlc3NlcyBhbmQgYWxsIERJIGVsZW1lbnRzIG9uIHRoZSBzYW1lIHBsYW5lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcclxuICAgKiBAcGFyYW0ge01vZGRsZX0gbW9kZGxlXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gU3VicHJvY2Vzc0NvbXBhdGliaWxpdHkoZXZlbnRCdXMsIG1vZGRsZSkge1xyXG4gICAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcclxuICAgIHRoaXMuX21vZGRsZSA9IG1vZGRsZTtcclxuXHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgZXZlbnRCdXMub24oJ2ltcG9ydC5yZW5kZXIuc3RhcnQnLCAxNTAwLCBmdW5jdGlvbihlLCBjb250ZXh0KSB7XHJcbiAgICAgIHNlbGYuX2hhbmRsZUltcG9ydChjb250ZXh0LmRlZmluaXRpb25zKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBkZWZpbml0aW9uc1xyXG4gICAqL1xyXG4gIFN1YnByb2Nlc3NDb21wYXRpYmlsaXR5LnByb3RvdHlwZS5faGFuZGxlSW1wb3J0ID0gZnVuY3Rpb24oZGVmaW5pdGlvbnMpIHtcclxuICAgIGlmICghZGVmaW5pdGlvbnMuZGlhZ3JhbXMpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHRoaXMuX2RlZmluaXRpb25zID0gZGVmaW5pdGlvbnM7XHJcbiAgICB0aGlzLl9wcm9jZXNzVG9EaWFncmFtTWFwID0ge307XHJcblxyXG4gICAgZGVmaW5pdGlvbnMuZGlhZ3JhbXMuZm9yRWFjaChmdW5jdGlvbihkaWFncmFtKSB7XHJcbiAgICAgIGlmICghZGlhZ3JhbS5wbGFuZSB8fCAhZGlhZ3JhbS5wbGFuZS5icG1uRWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2VsZi5fcHJvY2Vzc1RvRGlhZ3JhbU1hcFtkaWFncmFtLnBsYW5lLmJwbW5FbGVtZW50LmlkXSA9IGRpYWdyYW07XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgbmV3RGlhZ3JhbXMgPSBkZWZpbml0aW9ucy5kaWFncmFtc1xyXG4gICAgICAuZmlsdGVyKGRpYWdyYW0gPT4gZGlhZ3JhbS5wbGFuZSlcclxuICAgICAgLmZsYXRNYXAoZGlhZ3JhbSA9PiBzZWxmLl9jcmVhdGVOZXdEaWFncmFtcyhkaWFncmFtLnBsYW5lKSk7XHJcblxyXG4gICAgbmV3RGlhZ3JhbXMuZm9yRWFjaChmdW5jdGlvbihkaWFncmFtKSB7XHJcbiAgICAgIHNlbGYuX21vdmVQbGFuZUVsZW1lbnRzVG9PcmlnaW4oZGlhZ3JhbS5wbGFuZSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogTW92ZXMgYWxsIERJIGVsZW1lbnRzIGZyb20gY29sbGFwc2VkIHN1YnByb2Nlc3NlcyB0byBhIG5ldyBwbGFuZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Q2FudmFzUGxhbmV9IHBsYW5lXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtNb2RkbGVFbGVtZW50W119IG5ldyBkaWFncmFtcyBjcmVhdGVkIGZvciB0aGUgY29sbGFwc2VkIHN1YnByb2Nlc3Nlc1xyXG4gICAqL1xyXG4gIFN1YnByb2Nlc3NDb21wYXRpYmlsaXR5LnByb3RvdHlwZS5fY3JlYXRlTmV3RGlhZ3JhbXMgPSBmdW5jdGlvbihwbGFuZSkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHZhciBjb2xsYXBzZWRFbGVtZW50cyA9IFtdO1xyXG4gICAgdmFyIGVsZW1lbnRzVG9Nb3ZlID0gW107XHJcblxyXG4gICAgcGxhbmUuZ2V0KCdwbGFuZUVsZW1lbnQnKS5mb3JFYWNoKGZ1bmN0aW9uKGRpRWxlbWVudCkge1xyXG4gICAgICB2YXIgYnVzaW5lc3NPYmplY3QgPSBkaUVsZW1lbnQuYnBtbkVsZW1lbnQ7XHJcblxyXG4gICAgICBpZiAoIWJ1c2luZXNzT2JqZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcGFyZW50ID0gYnVzaW5lc3NPYmplY3QuJHBhcmVudDtcclxuXHJcbiAgICAgIGlmIChpcyQxKGJ1c2luZXNzT2JqZWN0LCAnYnBtbjpTdWJQcm9jZXNzJykgJiYgIWRpRWxlbWVudC5pc0V4cGFuZGVkKSB7XHJcbiAgICAgICAgY29sbGFwc2VkRWxlbWVudHMucHVzaChidXNpbmVzc09iamVjdCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzaG91bGRNb3ZlVG9QbGFuZShidXNpbmVzc09iamVjdCwgcGxhbmUpKSB7XHJcblxyXG4gICAgICAgIC8vIGRvbid0IGNoYW5nZSB0aGUgYXJyYXkgd2hpbGUgd2UgaXRlcmF0ZSBvdmVyIGl0XHJcbiAgICAgICAgZWxlbWVudHNUb01vdmUucHVzaCh7IGRpRWxlbWVudDogZGlFbGVtZW50LCBwYXJlbnQ6IHBhcmVudCB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIG5ld0RpYWdyYW1zID0gW107XHJcblxyXG4gICAgLy8gY3JlYXRlIG5ldyBwbGFuZXMgZm9yIGFsbCBjb2xsYXBzZWQgc3VicHJvY2Vzc2VzLCBldmVuIHdoZW4gdGhleSBhcmUgZW1wdHlcclxuICAgIGNvbGxhcHNlZEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICBpZiAoIXNlbGYuX3Byb2Nlc3NUb0RpYWdyYW1NYXBbIGVsZW1lbnQuaWQgXSkge1xyXG4gICAgICAgIHZhciBkaWFncmFtID0gc2VsZi5fY3JlYXRlRGlhZ3JhbShlbGVtZW50KTtcclxuXHJcbiAgICAgICAgc2VsZi5fcHJvY2Vzc1RvRGlhZ3JhbU1hcFtlbGVtZW50LmlkXSA9IGRpYWdyYW07XHJcblxyXG4gICAgICAgIG5ld0RpYWdyYW1zLnB1c2goZGlhZ3JhbSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGVsZW1lbnRzVG9Nb3ZlLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICB2YXIgZGlFbGVtZW50ID0gZWxlbWVudC5kaUVsZW1lbnQ7XHJcbiAgICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudDtcclxuXHJcbiAgICAgIC8vIHBhcmVudCBpcyBleHBhbmRlZCwgZ2V0IG5lYXJlc3QgY29sbGFwc2VkIHBhcmVudFxyXG4gICAgICB3aGlsZSAocGFyZW50ICYmIGNvbGxhcHNlZEVsZW1lbnRzLmluZGV4T2YocGFyZW50KSA9PT0gLTEpIHtcclxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZmFsc2UgcG9zaXRpdmUsIGFsbCBwYXJlbnRzIGFyZSBleHBhbmRlZFxyXG4gICAgICBpZiAoIXBhcmVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGRpYWdyYW0gPSBzZWxmLl9wcm9jZXNzVG9EaWFncmFtTWFwWyBwYXJlbnQuaWQgXTtcclxuXHJcbiAgICAgIHNlbGYuX21vdmVUb0RpUGxhbmUoZGlFbGVtZW50LCBkaWFncmFtLnBsYW5lKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBuZXdEaWFncmFtcztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0NhbnZhc1BsYW5lfSBwbGFuZVxyXG4gICAqL1xyXG4gIFN1YnByb2Nlc3NDb21wYXRpYmlsaXR5LnByb3RvdHlwZS5fbW92ZVBsYW5lRWxlbWVudHNUb09yaWdpbiA9IGZ1bmN0aW9uKHBsYW5lKSB7XHJcbiAgICB2YXIgZWxlbWVudHMgPSBwbGFuZS5nZXQoJ3BsYW5lRWxlbWVudCcpO1xyXG5cclxuICAgIC8vIGdldCBib3VuZGluZyBib3ggb2YgYWxsIGVsZW1lbnRzXHJcbiAgICB2YXIgcGxhbmVCb3VuZHMgPSBnZXRQbGFuZUJvdW5kcyhwbGFuZSk7XHJcblxyXG4gICAgdmFyIG9mZnNldCA9IHtcclxuICAgICAgeDogcGxhbmVCb3VuZHMueCAtIERFRkFVTFRfUE9TSVRJT04ueCxcclxuICAgICAgeTogcGxhbmVCb3VuZHMueSAtIERFRkFVTFRfUE9TSVRJT04ueVxyXG4gICAgfTtcclxuXHJcbiAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGRpRWxlbWVudCkge1xyXG4gICAgICBpZiAoZGlFbGVtZW50LndheXBvaW50KSB7XHJcbiAgICAgICAgZGlFbGVtZW50LndheXBvaW50LmZvckVhY2goZnVuY3Rpb24od2F5cG9pbnQpIHtcclxuICAgICAgICAgIHdheXBvaW50LnggPSB3YXlwb2ludC54IC0gb2Zmc2V0Lng7XHJcbiAgICAgICAgICB3YXlwb2ludC55ID0gd2F5cG9pbnQueSAtIG9mZnNldC55O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2UgaWYgKGRpRWxlbWVudC5ib3VuZHMpIHtcclxuICAgICAgICBkaUVsZW1lbnQuYm91bmRzLnggPSBkaUVsZW1lbnQuYm91bmRzLnggLSBvZmZzZXQueDtcclxuICAgICAgICBkaUVsZW1lbnQuYm91bmRzLnkgPSBkaUVsZW1lbnQuYm91bmRzLnkgLSBvZmZzZXQueTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBkaUVsZW1lbnRcclxuICAgKiBAcGFyYW0ge0NhbnZhc1BsYW5lfSBuZXdQbGFuZVxyXG4gICAqL1xyXG4gIFN1YnByb2Nlc3NDb21wYXRpYmlsaXR5LnByb3RvdHlwZS5fbW92ZVRvRGlQbGFuZSA9IGZ1bmN0aW9uKGRpRWxlbWVudCwgbmV3UGxhbmUpIHtcclxuICAgIHZhciBjb250YWluaW5nRGlhZ3JhbSA9IGZpbmRSb290RGlhZ3JhbShkaUVsZW1lbnQpO1xyXG5cclxuICAgIC8vIHJlbW92ZSBESSBmcm9tIG9sZCBQbGFuZSBhbmQgYWRkIGl0IHRvIHRoZSBuZXcgb25lXHJcbiAgICB2YXIgcGFyZW50UGxhbmVFbGVtZW50ID0gY29udGFpbmluZ0RpYWdyYW0ucGxhbmUuZ2V0KCdwbGFuZUVsZW1lbnQnKTtcclxuXHJcbiAgICBwYXJlbnRQbGFuZUVsZW1lbnQuc3BsaWNlKHBhcmVudFBsYW5lRWxlbWVudC5pbmRleE9mKGRpRWxlbWVudCksIDEpO1xyXG5cclxuICAgIG5ld1BsYW5lLmdldCgncGxhbmVFbGVtZW50JykucHVzaChkaUVsZW1lbnQpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gYnVzaW5lc3NPYmplY3RcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge01vZGRsZUVsZW1lbnR9XHJcbiAgICovXHJcbiAgU3VicHJvY2Vzc0NvbXBhdGliaWxpdHkucHJvdG90eXBlLl9jcmVhdGVEaWFncmFtID0gZnVuY3Rpb24oYnVzaW5lc3NPYmplY3QpIHtcclxuICAgIHZhciBwbGFuZSA9IHRoaXMuX21vZGRsZS5jcmVhdGUoJ2JwbW5kaTpCUE1OUGxhbmUnLCB7XHJcbiAgICAgIGJwbW5FbGVtZW50OiBidXNpbmVzc09iamVjdFxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIGRpYWdyYW0gPSB0aGlzLl9tb2RkbGUuY3JlYXRlKCdicG1uZGk6QlBNTkRpYWdyYW0nLCB7XHJcbiAgICAgIHBsYW5lOiBwbGFuZVxyXG4gICAgfSk7XHJcblxyXG4gICAgcGxhbmUuJHBhcmVudCA9IGRpYWdyYW07XHJcblxyXG4gICAgcGxhbmUuYnBtbkVsZW1lbnQgPSBidXNpbmVzc09iamVjdDtcclxuXHJcbiAgICBkaWFncmFtLiRwYXJlbnQgPSB0aGlzLl9kZWZpbml0aW9ucztcclxuXHJcbiAgICB0aGlzLl9kZWZpbml0aW9ucy5kaWFncmFtcy5wdXNoKGRpYWdyYW0pO1xyXG5cclxuICAgIHJldHVybiBkaWFncmFtO1xyXG4gIH07XHJcblxyXG4gIFN1YnByb2Nlc3NDb21wYXRpYmlsaXR5LiRpbmplY3QgPSBbICdldmVudEJ1cycsICdtb2RkbGUnIF07XHJcblxyXG5cclxuICAvLyBoZWxwZXJzIC8vLy8vLy8vLy9cclxuXHJcbiAgZnVuY3Rpb24gZmluZFJvb3REaWFncmFtKGVsZW1lbnQpIHtcclxuICAgIGlmIChpcyQxKGVsZW1lbnQsICdicG1uZGk6QlBNTkRpYWdyYW0nKSkge1xyXG4gICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBmaW5kUm9vdERpYWdyYW0oZWxlbWVudC4kcGFyZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Q2FudmFzUGxhbmV9IHBsYW5lXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtSZWN0fVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGdldFBsYW5lQm91bmRzKHBsYW5lKSB7XHJcbiAgICB2YXIgcGxhbmVUcmJsID0ge1xyXG4gICAgICB0b3A6IEluZmluaXR5LFxyXG4gICAgICByaWdodDogLUluZmluaXR5LFxyXG4gICAgICBib3R0b206IC1JbmZpbml0eSxcclxuICAgICAgbGVmdDogSW5maW5pdHlcclxuICAgIH07XHJcblxyXG4gICAgcGxhbmUucGxhbmVFbGVtZW50LmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICBpZiAoIWVsZW1lbnQuYm91bmRzKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgdHJibCA9IGFzVFJCTChlbGVtZW50LmJvdW5kcyk7XHJcblxyXG4gICAgICBwbGFuZVRyYmwudG9wID0gTWF0aC5taW4odHJibC50b3AsIHBsYW5lVHJibC50b3ApO1xyXG4gICAgICBwbGFuZVRyYmwubGVmdCA9IE1hdGgubWluKHRyYmwubGVmdCwgcGxhbmVUcmJsLmxlZnQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGFzQm91bmRzKHBsYW5lVHJibCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR9IGJ1c2luZXNzT2JqZWN0XHJcbiAgICogQHBhcmFtIHtDYW52YXNQbGFuZX0gcGxhbmVcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZnVuY3Rpb24gc2hvdWxkTW92ZVRvUGxhbmUoYnVzaW5lc3NPYmplY3QsIHBsYW5lKSB7XHJcbiAgICB2YXIgcGFyZW50ID0gYnVzaW5lc3NPYmplY3QuJHBhcmVudDtcclxuXHJcbiAgICAvLyBkb24ndCBtb3ZlIGVsZW1lbnRzIHRoYXQgYXJlIGFscmVhZHkgb24gdGhlIHBsYW5lXHJcbiAgICBpZiAoIWlzJDEocGFyZW50LCAnYnBtbjpTdWJQcm9jZXNzJykgfHwgcGFyZW50ID09PSBwbGFuZS5icG1uRWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZGF0YUFzc29jaWF0aW9ucyBhcmUgY2hpbGRyZW4gb2YgdGhlIHN1YnByb2Nlc3MgYnV0IHJlbmRlcmVkIG9uIHByb2Nlc3MgbGV2ZWxcclxuICAgIC8vIGNmLiBodHRwczovL2dpdGh1Yi5jb20vYnBtbi1pby9icG1uLWpzL2lzc3Vlcy8xNjE5XHJcbiAgICBpZiAoaXNBbnkoYnVzaW5lc3NPYmplY3QsIFsgJ2JwbW46RGF0YUlucHV0QXNzb2NpYXRpb24nLCAnYnBtbjpEYXRhT3V0cHV0QXNzb2NpYXRpb24nIF0pKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XG5cbiAgLyoqXHJcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnZGlhZ3JhbS1qcy9saWIvY29yZS9DYW52YXMnKS5kZWZhdWx0fSBDYW52YXNcclxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCdkaWFncmFtLWpzL2xpYi9jb3JlL0VsZW1lbnRSZWdpc3RyeScpLmRlZmF1bHR9IEVsZW1lbnRSZWdpc3RyeVxyXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJ2RpYWdyYW0tanMvbGliL2NvcmUvRXZlbnRCdXMnKS5kZWZhdWx0fSBFdmVudEJ1c1xyXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJ2RpYWdyYW0tanMvbGliL2ZlYXR1cmVzL292ZXJsYXlzL092ZXJsYXlzJykuZGVmYXVsdH0gT3ZlcmxheXNcclxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCdkaWFncmFtLWpzL2xpYi9pMThuL3RyYW5zbGF0ZS90cmFuc2xhdGUnKS5kZWZhdWx0fSBUcmFuc2xhdGVcclxuICAgKlxyXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL21vZGVsL1R5cGVzJykuRWxlbWVudH0gRWxlbWVudFxyXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL21vZGVsL1R5cGVzJykuUGFyZW50fSBQYXJlbnRcclxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi9tb2RlbC9UeXBlcycpLlNoYXBlfSBTaGFwZVxyXG4gICAqL1xyXG5cclxuICB2YXIgTE9XX1BSSU9SSVRZJDIgPSAyNTA7XHJcbiAgdmFyIEFSUk9XX0RPV05fU1ZHID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjBcIiBoZWlnaHQ9XCIyMFwiIHZpZXdCb3g9XCIwIDAgMTYgMTZcIj48cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk00LjgxODAxOTQ4LDMuNTA3MzU5MzEgTDEwLjQ5OTY4OTQsOS4xODk2ODk0IEwxMC41LDQgTDEyLDQgTDEyLDEyIEw0LDEyIEw0LDEwLjUgTDkuNjg5Njg5NCwxMC40OTk2ODk0IEwzLjc1NzM1OTMxLDQuNTY4MDE5NDggQzMuNDY0NDY2MDksNC4yNzUxMjYyNyAzLjQ2NDQ2NjA5LDMuODAwMjUyNTMgMy43NTczNTkzMSwzLjUwNzM1OTMxIEM0LjA1MDI1MjUzLDMuMjE0NDY2MDkgNC41MjUxMjYyNywzLjIxNDQ2NjA5IDQuODE4MDE5NDgsMy41MDczNTkzMSBaXCIvPjwvc3ZnPic7XHJcblxyXG4gIHZhciBFTVBUWV9NQVJLRVIgPSAnYmpzLWRyaWxsZG93bi1lbXB0eSc7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcclxuICAgKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xyXG4gICAqIEBwYXJhbSB7RWxlbWVudFJlZ2lzdHJ5fSBlbGVtZW50UmVnaXN0cnlcclxuICAgKiBAcGFyYW0ge092ZXJsYXlzfSBvdmVybGF5c1xyXG4gICAqIEBwYXJhbSB7VHJhbnNsYXRlfSB0cmFuc2xhdGVcclxuICAgKi9cclxuICBmdW5jdGlvbiBEcmlsbGRvd25PdmVybGF5QmVoYXZpb3IoXHJcbiAgICAgIGNhbnZhcywgZXZlbnRCdXMsIGVsZW1lbnRSZWdpc3RyeSwgb3ZlcmxheXMsIHRyYW5zbGF0ZVxyXG4gICkge1xyXG4gICAgQ29tbWFuZEludGVyY2VwdG9yLmNhbGwodGhpcywgZXZlbnRCdXMpO1xyXG5cclxuICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcclxuICAgIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XHJcbiAgICB0aGlzLl9lbGVtZW50UmVnaXN0cnkgPSBlbGVtZW50UmVnaXN0cnk7XHJcbiAgICB0aGlzLl9vdmVybGF5cyA9IG92ZXJsYXlzO1xyXG4gICAgdGhpcy5fdHJhbnNsYXRlID0gdHJhbnNsYXRlO1xyXG5cclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICB0aGlzLmV4ZWN1dGVkKCdzaGFwZS50b2dnbGVDb2xsYXBzZScsIExPV19QUklPUklUWSQyLCBmdW5jdGlvbihjb250ZXh0KSB7XHJcbiAgICAgIHZhciBzaGFwZSA9IGNvbnRleHQuc2hhcGU7XHJcblxyXG4gICAgICAvLyBBZGQgb3ZlcmxheSB0byB0aGUgY29sbGFwc2VkIHNoYXBlXHJcbiAgICAgIGlmIChzZWxmLl9jYW5EcmlsbERvd24oc2hhcGUpKSB7XHJcbiAgICAgICAgc2VsZi5fYWRkT3ZlcmxheShzaGFwZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2VsZi5fcmVtb3ZlT3ZlcmxheShzaGFwZSk7XHJcbiAgICAgIH1cclxuICAgIH0sIHRydWUpO1xyXG5cclxuXHJcbiAgICB0aGlzLnJldmVydGVkKCdzaGFwZS50b2dnbGVDb2xsYXBzZScsIExPV19QUklPUklUWSQyLCBmdW5jdGlvbihjb250ZXh0KSB7XHJcbiAgICAgIHZhciBzaGFwZSA9IGNvbnRleHQuc2hhcGU7XHJcblxyXG4gICAgICAvLyBBZGQgb3ZlcmxheSB0byB0aGUgY29sbGFwc2VkIHNoYXBlXHJcbiAgICAgIGlmIChzZWxmLl9jYW5EcmlsbERvd24oc2hhcGUpKSB7XHJcbiAgICAgICAgc2VsZi5fYWRkT3ZlcmxheShzaGFwZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2VsZi5fcmVtb3ZlT3ZlcmxheShzaGFwZSk7XHJcbiAgICAgIH1cclxuICAgIH0sIHRydWUpO1xyXG5cclxuXHJcbiAgICB0aGlzLmV4ZWN1dGVkKFsgJ3NoYXBlLmNyZWF0ZScsICdzaGFwZS5tb3ZlJywgJ3NoYXBlLmRlbGV0ZScgXSwgTE9XX1BSSU9SSVRZJDIsXHJcbiAgICAgIGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgb2xkUGFyZW50ID0gY29udGV4dC5vbGRQYXJlbnQsXHJcbiAgICAgICAgICAgIG5ld1BhcmVudCA9IGNvbnRleHQubmV3UGFyZW50IHx8IGNvbnRleHQucGFyZW50LFxyXG4gICAgICAgICAgICBzaGFwZSA9IGNvbnRleHQuc2hhcGU7XHJcblxyXG4gICAgICAgIC8vIEFkZCBvdmVybGF5IHRvIHRoZSBjb2xsYXBzZWQgc2hhcGVcclxuICAgICAgICBpZiAoc2VsZi5fY2FuRHJpbGxEb3duKHNoYXBlKSkge1xyXG4gICAgICAgICAgc2VsZi5fYWRkT3ZlcmxheShzaGFwZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZWxmLl91cGRhdGVEcmlsbGRvd25PdmVybGF5KG9sZFBhcmVudCk7XHJcbiAgICAgICAgc2VsZi5fdXBkYXRlRHJpbGxkb3duT3ZlcmxheShuZXdQYXJlbnQpO1xyXG4gICAgICAgIHNlbGYuX3VwZGF0ZURyaWxsZG93bk92ZXJsYXkoc2hhcGUpO1xyXG4gICAgICB9LCB0cnVlKTtcclxuXHJcblxyXG4gICAgdGhpcy5yZXZlcnRlZChbICdzaGFwZS5jcmVhdGUnLCAnc2hhcGUubW92ZScsICdzaGFwZS5kZWxldGUnIF0sIExPV19QUklPUklUWSQyLFxyXG4gICAgICBmdW5jdGlvbihjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIG9sZFBhcmVudCA9IGNvbnRleHQub2xkUGFyZW50LFxyXG4gICAgICAgICAgICBuZXdQYXJlbnQgPSBjb250ZXh0Lm5ld1BhcmVudCB8fCBjb250ZXh0LnBhcmVudCxcclxuICAgICAgICAgICAgc2hhcGUgPSBjb250ZXh0LnNoYXBlO1xyXG5cclxuICAgICAgICAvLyBBZGQgb3ZlcmxheSB0byB0aGUgY29sbGFwc2VkIHNoYXBlXHJcbiAgICAgICAgaWYgKHNlbGYuX2NhbkRyaWxsRG93bihzaGFwZSkpIHtcclxuICAgICAgICAgIHNlbGYuX2FkZE92ZXJsYXkoc2hhcGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2VsZi5fdXBkYXRlRHJpbGxkb3duT3ZlcmxheShvbGRQYXJlbnQpO1xyXG4gICAgICAgIHNlbGYuX3VwZGF0ZURyaWxsZG93bk92ZXJsYXkobmV3UGFyZW50KTtcclxuICAgICAgICBzZWxmLl91cGRhdGVEcmlsbGRvd25PdmVybGF5KHNoYXBlKTtcclxuICAgICAgfSwgdHJ1ZSk7XHJcblxyXG5cclxuICAgIGV2ZW50QnVzLm9uKCdpbXBvcnQucmVuZGVyLmNvbXBsZXRlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgIGVsZW1lbnRSZWdpc3RyeS5maWx0ZXIoZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIHJldHVybiBzZWxmLl9jYW5EcmlsbERvd24oZSk7XHJcbiAgICAgIH0pLm1hcChmdW5jdGlvbihlbCkge1xyXG4gICAgICAgIHNlbGYuX2FkZE92ZXJsYXkoZWwpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICB9XHJcblxyXG4gIGUoRHJpbGxkb3duT3ZlcmxheUJlaGF2aW9yLCBDb21tYW5kSW50ZXJjZXB0b3IpO1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1NoYXBlfSBzaGFwZVxyXG4gICAqL1xyXG4gIERyaWxsZG93bk92ZXJsYXlCZWhhdmlvci5wcm90b3R5cGUuX3VwZGF0ZURyaWxsZG93bk92ZXJsYXkgPSBmdW5jdGlvbihzaGFwZSkge1xyXG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcclxuXHJcbiAgICBpZiAoIXNoYXBlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcm9vdCA9IGNhbnZhcy5maW5kUm9vdChzaGFwZSk7XHJcblxyXG4gICAgaWYgKHJvb3QpIHtcclxuICAgICAgdGhpcy5fdXBkYXRlT3ZlcmxheVZpc2liaWxpdHkocm9vdCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIERyaWxsZG93bk92ZXJsYXlCZWhhdmlvci5wcm90b3R5cGUuX2NhbkRyaWxsRG93biA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XHJcblxyXG4gICAgcmV0dXJuIGlzJDEoZWxlbWVudCwgJ2JwbW46U3ViUHJvY2VzcycpICYmIGNhbnZhcy5maW5kUm9vdChnZXRQbGFuZUlkRnJvbVNoYXBlKGVsZW1lbnQpKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGRyaWxsZG93biBvdmVybGF5LiBJZiB0aGUgcGxhbmUgaGFzIG5vIGVsZW1lbnRzLFxyXG4gICAqIHRoZSBkcmlsbGRvd24gd2lsbCBvbmx5IGJlIHNob3duIHdoZW4gdGhlIGVsZW1lbnQgaXMgc2VsZWN0ZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1BhcmVudH0gZWxlbWVudCBUaGUgY29sbGFwc2VkIHJvb3Qgb3Igc2hhcGUuXHJcbiAgICovXHJcbiAgRHJpbGxkb3duT3ZlcmxheUJlaGF2aW9yLnByb3RvdHlwZS5fdXBkYXRlT3ZlcmxheVZpc2liaWxpdHkgPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICB2YXIgb3ZlcmxheXMgPSB0aGlzLl9vdmVybGF5cztcclxuXHJcbiAgICB2YXIgYnVzaW5lc3NPYmplY3QgPSBnZXRCdXNpbmVzc09iamVjdChlbGVtZW50KTtcclxuXHJcbiAgICB2YXIgb3ZlcmxheSA9IG92ZXJsYXlzLmdldCh7IGVsZW1lbnQ6IGJ1c2luZXNzT2JqZWN0LmlkLCB0eXBlOiAnZHJpbGxkb3duJyB9KVswXTtcclxuXHJcbiAgICBpZiAoIW92ZXJsYXkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBoYXNGbG93RWxlbWVudHMgPSBidXNpbmVzc09iamVjdFxyXG4gICAgICAmJiBidXNpbmVzc09iamVjdC5nZXQoJ2Zsb3dFbGVtZW50cycpXHJcbiAgICAgICYmIGJ1c2luZXNzT2JqZWN0LmdldCgnZmxvd0VsZW1lbnRzJykubGVuZ3RoO1xyXG5cclxuICAgIGNsYXNzZXMob3ZlcmxheS5odG1sKS50b2dnbGUoRU1QVFlfTUFSS0VSLCAhaGFzRmxvd0VsZW1lbnRzKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSBkcmlsbGRvd24gYnV0dG9uIHRvIHRoZSBnaXZlbiBlbGVtZW50IGFzc3VtaW5nIHRoZSBwbGFuZSBoYXMgdGhlIHNhbWVcclxuICAgKiBJRCBhcyB0aGUgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U2hhcGV9IGVsZW1lbnQgVGhlIGNvbGxhcHNlZCBzaGFwZS5cclxuICAgKi9cclxuICBEcmlsbGRvd25PdmVybGF5QmVoYXZpb3IucHJvdG90eXBlLl9hZGRPdmVybGF5ID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcyxcclxuICAgICAgICBvdmVybGF5cyA9IHRoaXMuX292ZXJsYXlzLFxyXG4gICAgICAgIGJvID0gZ2V0QnVzaW5lc3NPYmplY3QoZWxlbWVudCk7XHJcblxyXG4gICAgdmFyIGV4aXN0aW5nT3ZlcmxheXMgPSBvdmVybGF5cy5nZXQoeyBlbGVtZW50OiBlbGVtZW50LCB0eXBlOiAnZHJpbGxkb3duJyB9KTtcclxuXHJcbiAgICBpZiAoZXhpc3RpbmdPdmVybGF5cy5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5fcmVtb3ZlT3ZlcmxheShlbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYnV0dG9uID0gZG9taWZ5JDEoJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYmpzLWRyaWxsZG93blwiPicgKyBBUlJPV19ET1dOX1NWRyArICc8L2J1dHRvbj4nKSxcclxuICAgICAgICBlbGVtZW50TmFtZSA9IGJvLmdldCgnbmFtZScpIHx8IGJvLmdldCgnaWQnKSxcclxuICAgICAgICB0aXRsZSA9IHRoaXMuX3RyYW5zbGF0ZSgnT3BlbiB7ZWxlbWVudH0nLCB7IGVsZW1lbnQ6IGVsZW1lbnROYW1lIH0pO1xyXG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCB0aXRsZSk7XHJcblxyXG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgIGNhbnZhcy5zZXRSb290RWxlbWVudChjYW52YXMuZmluZFJvb3QoZ2V0UGxhbmVJZEZyb21TaGFwZShlbGVtZW50KSkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgb3ZlcmxheXMuYWRkKGVsZW1lbnQsICdkcmlsbGRvd24nLCB7XHJcbiAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgYm90dG9tOiAtNyxcclxuICAgICAgICByaWdodDogLThcclxuICAgICAgfSxcclxuICAgICAgaHRtbDogYnV0dG9uXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl91cGRhdGVPdmVybGF5VmlzaWJpbGl0eShlbGVtZW50KTtcclxuICB9O1xyXG5cclxuICBEcmlsbGRvd25PdmVybGF5QmVoYXZpb3IucHJvdG90eXBlLl9yZW1vdmVPdmVybGF5ID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgdmFyIG92ZXJsYXlzID0gdGhpcy5fb3ZlcmxheXM7XHJcblxyXG4gICAgb3ZlcmxheXMucmVtb3ZlKHtcclxuICAgICAgZWxlbWVudDogZWxlbWVudCxcclxuICAgICAgdHlwZTogJ2RyaWxsZG93bidcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIERyaWxsZG93bk92ZXJsYXlCZWhhdmlvci4kaW5qZWN0ID0gW1xyXG4gICAgJ2NhbnZhcycsXHJcbiAgICAnZXZlbnRCdXMnLFxyXG4gICAgJ2VsZW1lbnRSZWdpc3RyeScsXHJcbiAgICAnb3ZlcmxheXMnLFxyXG4gICAgJ3RyYW5zbGF0ZSdcclxuICBdO1xuXG4gIHZhciBEcmlsbGRvd25Nb2RkdWxlID0ge1xyXG4gICAgX19kZXBlbmRzX186IFsgT3ZlcmxheXNNb2R1bGUsIENoYW5nZVN1cHBvcnRNb2R1bGUsIFJvb3RFbGVtZW50c01vZHVsZSBdLFxyXG4gICAgX19pbml0X186IFsgJ2RyaWxsZG93bkJyZWFkY3J1bWJzJywgJ2RyaWxsZG93bk92ZXJsYXlCZWhhdmlvcicsICdkcmlsbGRvd25DZW50ZXJpbmcnLCAnc3VicHJvY2Vzc0NvbXBhdGliaWxpdHknIF0sXHJcbiAgICBkcmlsbGRvd25CcmVhZGNydW1iczogWyAndHlwZScsIERyaWxsZG93bkJyZWFkY3J1bWJzIF0sXHJcbiAgICBkcmlsbGRvd25DZW50ZXJpbmc6IFsgJ3R5cGUnLCBEcmlsbGRvd25DZW50ZXJpbmcgXSxcclxuICAgIGRyaWxsZG93bk92ZXJsYXlCZWhhdmlvcjogWyAndHlwZScsIERyaWxsZG93bk92ZXJsYXlCZWhhdmlvciBdLFxyXG4gICAgc3VicHJvY2Vzc0NvbXBhdGliaWxpdHk6IFsgJ3R5cGUnLCBTdWJwcm9jZXNzQ29tcGF0aWJpbGl0eSBdXHJcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdXRpbC9UeXBlcycpLlBvaW50fSBQb2ludFxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29yZS9FdmVudEJ1cycpLkV2ZW50fSBldmVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFdmVudH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldE9yaWdpbmFsKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lm9yaWdpbmFsRXZlbnQgfHwgZXZlbnQuc3JjRXZlbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICpcbiAgICogQHJldHVybiB7UG9pbnR8bnVsbH1cbiAgICovXG4gIGZ1bmN0aW9uIHRvUG9pbnQoZXZlbnQpIHtcblxuICAgIGlmIChldmVudC5wb2ludGVycyAmJiBldmVudC5wb2ludGVycy5sZW5ndGgpIHtcbiAgICAgIGV2ZW50ID0gZXZlbnQucG9pbnRlcnNbMF07XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgIGV2ZW50ID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnQgPyB7XG4gICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgIH0gOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNNYWMoKSB7XG4gICAgcmV0dXJuICgvbWFjL2kpLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBidXR0b25cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGlzQnV0dG9uKGV2ZW50LCBidXR0b24pIHtcbiAgICByZXR1cm4gKGdldE9yaWdpbmFsKGV2ZW50KSB8fCBldmVudCkuYnV0dG9uID09PSBidXR0b247XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaXNQcmltYXJ5QnV0dG9uKGV2ZW50KSB7XG5cbiAgICAvLyBidXR0b24gPT09IDAgLT4gbGVmdCDDoWthIHByaW1hcnkgbW91c2UgYnV0dG9uXG4gICAgcmV0dXJuIGlzQnV0dG9uKGV2ZW50LCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50XG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpc0F1eGlsaWFyeUJ1dHRvbihldmVudCkge1xuXG4gICAgLy8gYnV0dG9uID09PSAxIC0+IGF1eGlsaWFyeSDDoWthIHdoZWVsIGJ1dHRvblxuICAgIHJldHVybiBpc0J1dHRvbihldmVudCwgMSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzU2Vjb25kYXJ5TW9kaWZpZXIoZXZlbnQpIHtcbiAgICB2YXIgb3JpZ2luYWxFdmVudCA9IGdldE9yaWdpbmFsKGV2ZW50KSB8fCBldmVudDtcblxuICAgIHJldHVybiBpc1ByaW1hcnlCdXR0b24oZXZlbnQpICYmIG9yaWdpbmFsRXZlbnQuc2hpZnRLZXk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vbW9kZWwvVHlwZXMnKS5FbGVtZW50fSBFbGVtZW50XG4gICAqXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL2NvcmUvRWxlbWVudFJlZ2lzdHJ5JykuZGVmYXVsdH0gRWxlbWVudFJlZ2lzdHJ5XG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL2NvcmUvRXZlbnRCdXMnKS5kZWZhdWx0fSBFdmVudEJ1c1xuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi9kcmF3L1N0eWxlcycpLmRlZmF1bHR9IFN0eWxlc1xuICAgKlxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi91dGlsL1R5cGVzJykuUG9pbnR9IFBvaW50XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFsbG93QWxsKGV2ZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgZnVuY3Rpb24gYWxsb3dQcmltYXJ5QW5kQXV4aWxpYXJ5KGV2ZW50KSB7XG4gICAgcmV0dXJuIGlzUHJpbWFyeUJ1dHRvbihldmVudCkgfHwgaXNBdXhpbGlhcnlCdXR0b24oZXZlbnQpO1xuICB9XG5cbiAgdmFyIExPV19QUklPUklUWSQxID0gNTAwO1xuXG5cbiAgLyoqXG4gICAqIEEgcGx1Z2luIHRoYXQgcHJvdmlkZXMgaW50ZXJhY3Rpb24gZXZlbnRzIGZvciBkaWFncmFtIGVsZW1lbnRzLlxuICAgKlxuICAgKiBJdCBlbWl0cyB0aGUgZm9sbG93aW5nIGV2ZW50czpcbiAgICpcbiAgICogICAqIGVsZW1lbnQuY2xpY2tcbiAgICogICAqIGVsZW1lbnQuY29udGV4dG1lbnVcbiAgICogICAqIGVsZW1lbnQuZGJsY2xpY2tcbiAgICogICAqIGVsZW1lbnQuaG92ZXJcbiAgICogICAqIGVsZW1lbnQubW91c2Vkb3duXG4gICAqICAgKiBlbGVtZW50Lm1vdXNlbW92ZVxuICAgKiAgICogZWxlbWVudC5tb3VzZXVwXG4gICAqICAgKiBlbGVtZW50Lm91dFxuICAgKlxuICAgKiBFYWNoIGV2ZW50IGlzIGEgdHVwbGUgeyBlbGVtZW50LCBnZngsIG9yaWdpbmFsRXZlbnQgfS5cbiAgICpcbiAgICogQ2FuY2VsaW5nIHRoZSBldmVudCB2aWEgRXZlbnQjcHJldmVudERlZmF1bHQoKVxuICAgKiBwcmV2ZW50cyB0aGUgb3JpZ2luYWwgRE9NIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAgICogQHBhcmFtIHtFbGVtZW50UmVnaXN0cnl9IGVsZW1lbnRSZWdpc3RyeVxuICAgKiBAcGFyYW0ge1N0eWxlc30gc3R5bGVzXG4gICAqL1xuICBmdW5jdGlvbiBJbnRlcmFjdGlvbkV2ZW50cyhldmVudEJ1cywgZWxlbWVudFJlZ2lzdHJ5LCBzdHlsZXMpIHtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8qKlxuICAgICAqIEZpcmUgYW4gaW50ZXJhY3Rpb24gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBsb2NhbCBldmVudCBuYW1lLCBlLmcuIGVsZW1lbnQuY2xpY2suXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fFRvdWNoRXZlbnR9IGV2ZW50IG5hdGl2ZSBldmVudFxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gW2VsZW1lbnRdIHRoZSBkaWFncmFtIGVsZW1lbnQgdG8gZW1pdCB0aGUgZXZlbnQgb247XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzIHRvIHRoZSBldmVudCB0YXJnZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaXJlKHR5cGUsIGV2ZW50LCBlbGVtZW50KSB7XG5cbiAgICAgIGlmIChpc0lnbm9yZWQodHlwZSwgZXZlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhcmdldCwgZ2Z4LCByZXR1cm5WYWx1ZTtcblxuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHRhcmdldCA9IGV2ZW50LmRlbGVnYXRlVGFyZ2V0IHx8IGV2ZW50LnRhcmdldDtcblxuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgZ2Z4ID0gdGFyZ2V0O1xuICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50UmVnaXN0cnkuZ2V0KGdmeCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdmeCA9IGVsZW1lbnRSZWdpc3RyeS5nZXRHcmFwaGljcyhlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFnZnggfHwgIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm5WYWx1ZSA9IGV2ZW50QnVzLmZpcmUodHlwZSwge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBnZng6IGdmeCxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmV0dXJuVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8obmlra3UpOiBkb2N1bWVudCB0aGlzXG4gICAgdmFyIGhhbmRsZXJzID0ge307XG5cbiAgICBmdW5jdGlvbiBtb3VzZUhhbmRsZXIobG9jYWxFdmVudE5hbWUpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyc1tsb2NhbEV2ZW50TmFtZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZ25vcmVkKGxvY2FsRXZlbnROYW1lLCBldmVudCkge1xuXG4gICAgICB2YXIgZmlsdGVyID0gaWdub3JlZEZpbHRlcnNbbG9jYWxFdmVudE5hbWVdIHx8IGlzUHJpbWFyeUJ1dHRvbjtcblxuICAgICAgLy8gb25seSByZWFjdCBvbiBsZWZ0IG1vdXNlIGJ1dHRvbiBpbnRlcmFjdGlvbnNcbiAgICAgIC8vIGV4Y2VwdCBmb3IgaW50ZXJhY3Rpb24gZXZlbnRzIHRoYXQgYXJlIGVuYWJsZWRcbiAgICAgIC8vIGZvciBzZWN1bmRhcnkgbW91c2UgYnV0dG9uXG4gICAgICByZXR1cm4gIWZpbHRlcihldmVudCk7XG4gICAgfVxuXG4gICAgdmFyIGJpbmRpbmdzID0ge1xuICAgICAgY2xpY2s6ICdlbGVtZW50LmNsaWNrJyxcbiAgICAgIGNvbnRleHRtZW51OiAnZWxlbWVudC5jb250ZXh0bWVudScsXG4gICAgICBkYmxjbGljazogJ2VsZW1lbnQuZGJsY2xpY2snLFxuICAgICAgbW91c2Vkb3duOiAnZWxlbWVudC5tb3VzZWRvd24nLFxuICAgICAgbW91c2Vtb3ZlOiAnZWxlbWVudC5tb3VzZW1vdmUnLFxuICAgICAgbW91c2VvdmVyOiAnZWxlbWVudC5ob3ZlcicsXG4gICAgICBtb3VzZW91dDogJ2VsZW1lbnQub3V0JyxcbiAgICAgIG1vdXNldXA6ICdlbGVtZW50Lm1vdXNldXAnLFxuICAgIH07XG5cbiAgICB2YXIgaWdub3JlZEZpbHRlcnMgPSB7XG4gICAgICAnZWxlbWVudC5jb250ZXh0bWVudSc6IGFsbG93QWxsLFxuICAgICAgJ2VsZW1lbnQubW91c2Vkb3duJzogYWxsb3dQcmltYXJ5QW5kQXV4aWxpYXJ5LFxuICAgICAgJ2VsZW1lbnQubW91c2V1cCc6IGFsbG93UHJpbWFyeUFuZEF1eGlsaWFyeSxcbiAgICAgICdlbGVtZW50LmNsaWNrJzogYWxsb3dQcmltYXJ5QW5kQXV4aWxpYXJ5LFxuICAgICAgJ2VsZW1lbnQuZGJsY2xpY2snOiBhbGxvd1ByaW1hcnlBbmRBdXhpbGlhcnlcbiAgICB9O1xuXG5cbiAgICAvLyBtYW51YWwgZXZlbnQgdHJpZ2dlciAvLy8vLy8vLy8vXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGFuIGludGVyYWN0aW9uIGV2ZW50IChiYXNlZCBvbiBhIG5hdGl2ZSBkb20gZXZlbnQpXG4gICAgICogb24gdGhlIHRhcmdldCBzaGFwZSBvciBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSB0aGUgbmFtZSBvZiB0aGUgdHJpZ2dlcmVkIERPTSBldmVudFxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudHxUb3VjaEV2ZW50fSBldmVudFxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0RWxlbWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaWdnZXJNb3VzZUV2ZW50KGV2ZW50TmFtZSwgZXZlbnQsIHRhcmdldEVsZW1lbnQpIHtcblxuICAgICAgLy8gaS5lLiBlbGVtZW50Lm1vdXNlZG93bi4uLlxuICAgICAgdmFyIGxvY2FsRXZlbnROYW1lID0gYmluZGluZ3NbZXZlbnROYW1lXTtcblxuICAgICAgaWYgKCFsb2NhbEV2ZW50TmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VubWFwcGVkIERPTSBldmVudCBuYW1lIDwnICsgZXZlbnROYW1lICsgJz4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpcmUobG9jYWxFdmVudE5hbWUsIGV2ZW50LCB0YXJnZXRFbGVtZW50KTtcbiAgICB9XG5cblxuICAgIHZhciBFTEVNRU5UX1NFTEVDVE9SID0gJ3N2ZywgLmRqcy1lbGVtZW50JztcblxuICAgIC8vIGV2ZW50IGhhbmRsaW5nIC8vLy8vLy9cblxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnQobm9kZSwgZXZlbnQsIGxvY2FsRXZlbnQsIGlnbm9yZWRGaWx0ZXIpIHtcblxuICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc1tsb2NhbEV2ZW50XSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGZpcmUobG9jYWxFdmVudCwgZXZlbnQpO1xuICAgICAgfTtcblxuICAgICAgaWYgKGlnbm9yZWRGaWx0ZXIpIHtcbiAgICAgICAgaWdub3JlZEZpbHRlcnNbbG9jYWxFdmVudF0gPSBpZ25vcmVkRmlsdGVyO1xuICAgICAgfVxuXG4gICAgICBoYW5kbGVyLiRkZWxlZ2F0ZSA9IGRlbGVnYXRlLmJpbmQobm9kZSwgRUxFTUVOVF9TRUxFQ1RPUiwgZXZlbnQsIGhhbmRsZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVucmVnaXN0ZXJFdmVudChub2RlLCBldmVudCwgbG9jYWxFdmVudCkge1xuXG4gICAgICB2YXIgaGFuZGxlciA9IG1vdXNlSGFuZGxlcihsb2NhbEV2ZW50KTtcblxuICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGVsZWdhdGUudW5iaW5kKG5vZGUsIGV2ZW50LCBoYW5kbGVyLiRkZWxlZ2F0ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMoc3ZnKSB7XG4gICAgICBmb3JFYWNoJDEoYmluZGluZ3MsIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICAgIHJlZ2lzdGVyRXZlbnQoc3ZnLCBrZXksIHZhbCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnJlZ2lzdGVyRXZlbnRzKHN2Zykge1xuICAgICAgZm9yRWFjaCQxKGJpbmRpbmdzLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgICB1bnJlZ2lzdGVyRXZlbnQoc3ZnLCBrZXksIHZhbCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBldmVudEJ1cy5vbignY2FudmFzLmRlc3Ryb3knLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgdW5yZWdpc3RlckV2ZW50cyhldmVudC5zdmcpO1xuICAgIH0pO1xuXG4gICAgZXZlbnRCdXMub24oJ2NhbnZhcy5pbml0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHJlZ2lzdGVyRXZlbnRzKGV2ZW50LnN2Zyk7XG4gICAgfSk7XG5cblxuICAgIC8vIGhpdCBib3ggdXBkYXRpbmcgLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgZXZlbnRCdXMub24oWyAnc2hhcGUuYWRkZWQnLCAnY29ubmVjdGlvbi5hZGRlZCcgXSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gZXZlbnQuZWxlbWVudCxcbiAgICAgICAgICBnZnggPSBldmVudC5nZng7XG5cbiAgICAgIGV2ZW50QnVzLmZpcmUoJ2ludGVyYWN0aW9uRXZlbnRzLmNyZWF0ZUhpdCcsIHsgZWxlbWVudDogZWxlbWVudCwgZ2Z4OiBnZnggfSk7XG4gICAgfSk7XG5cbiAgICAvLyBVcGRhdGUgZGpzLWhpdCBvbiBjaGFuZ2UuXG4gICAgLy8gQSBsb3cgcHJpb3J0aXR5IGlzIG5lY2Vzc2FyeSwgYmVjYXVzZSBkanMtaGl0IG9mIGxhYmVscyBoYXMgdG8gYmUgdXBkYXRlZFxuICAgIC8vIGFmdGVyIHRoZSBsYWJlbCBib3VuZHMgaGF2ZSBiZWVuIHVwZGF0ZWQgaW4gdGhlIHJlbmRlcmVyLlxuICAgIGV2ZW50QnVzLm9uKFtcbiAgICAgICdzaGFwZS5jaGFuZ2VkJyxcbiAgICAgICdjb25uZWN0aW9uLmNoYW5nZWQnXG4gICAgXSwgTE9XX1BSSU9SSVRZJDEsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgIHZhciBlbGVtZW50ID0gZXZlbnQuZWxlbWVudCxcbiAgICAgICAgICBnZnggPSBldmVudC5nZng7XG5cbiAgICAgIGV2ZW50QnVzLmZpcmUoJ2ludGVyYWN0aW9uRXZlbnRzLnVwZGF0ZUhpdCcsIHsgZWxlbWVudDogZWxlbWVudCwgZ2Z4OiBnZnggfSk7XG4gICAgfSk7XG5cbiAgICBldmVudEJ1cy5vbignaW50ZXJhY3Rpb25FdmVudHMuY3JlYXRlSGl0JywgTE9XX1BSSU9SSVRZJDEsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGV2ZW50LmVsZW1lbnQsXG4gICAgICAgICAgZ2Z4ID0gZXZlbnQuZ2Z4O1xuXG4gICAgICBzZWxmLmNyZWF0ZURlZmF1bHRIaXQoZWxlbWVudCwgZ2Z4KTtcbiAgICB9KTtcblxuICAgIGV2ZW50QnVzLm9uKCdpbnRlcmFjdGlvbkV2ZW50cy51cGRhdGVIaXQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBldmVudC5lbGVtZW50LFxuICAgICAgICAgIGdmeCA9IGV2ZW50LmdmeDtcblxuICAgICAgc2VsZi51cGRhdGVEZWZhdWx0SGl0KGVsZW1lbnQsIGdmeCk7XG4gICAgfSk7XG5cblxuICAgIC8vIGhpdCBzdHlsZXMgLy8vLy8vLy8vLy8vXG5cbiAgICB2YXIgU1RST0tFX0hJVF9TVFlMRSA9IGNyZWF0ZUhpdFN0eWxlKCdkanMtaGl0IGRqcy1oaXQtc3Ryb2tlJyk7XG5cbiAgICB2YXIgQ0xJQ0tfU1RST0tFX0hJVF9TVFlMRSA9IGNyZWF0ZUhpdFN0eWxlKCdkanMtaGl0IGRqcy1oaXQtY2xpY2stc3Ryb2tlJyk7XG5cbiAgICB2YXIgQUxMX0hJVF9TVFlMRSA9IGNyZWF0ZUhpdFN0eWxlKCdkanMtaGl0IGRqcy1oaXQtYWxsJyk7XG5cbiAgICB2YXIgTk9fTU9WRV9ISVRfU1RZTEUgPSBjcmVhdGVIaXRTdHlsZSgnZGpzLWhpdCBkanMtaGl0LW5vLW1vdmUnKTtcblxuICAgIHZhciBISVRfVFlQRVMgPSB7XG4gICAgICAnYWxsJzogQUxMX0hJVF9TVFlMRSxcbiAgICAgICdjbGljay1zdHJva2UnOiBDTElDS19TVFJPS0VfSElUX1NUWUxFLFxuICAgICAgJ3N0cm9rZSc6IFNUUk9LRV9ISVRfU1RZTEUsXG4gICAgICAnbm8tbW92ZSc6IE5PX01PVkVfSElUX1NUWUxFXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhpdFN0eWxlKGNsYXNzTmFtZXMsIGF0dHJzKSB7XG5cbiAgICAgIGF0dHJzID0gYXNzaWduJDEoe1xuICAgICAgICBzdHJva2U6ICd3aGl0ZScsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAxNVxuICAgICAgfSwgYXR0cnMgfHwge30pO1xuXG4gICAgICByZXR1cm4gc3R5bGVzLmNscyhjbGFzc05hbWVzLCBbICduby1maWxsJywgJ25vLWJvcmRlcicgXSwgYXR0cnMpO1xuICAgIH1cblxuXG4gICAgLy8gc3R5bGUgaGVscGVycyAvLy8vLy8vLy8vLy8vLy9cblxuICAgIGZ1bmN0aW9uIGFwcGx5U3R5bGUoaGl0LCB0eXBlKSB7XG5cbiAgICAgIHZhciBhdHRycyA9IEhJVF9UWVBFU1t0eXBlXTtcblxuICAgICAgaWYgKCFhdHRycykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaGl0IHR5cGUgPCcgKyB0eXBlICsgJz4nKTtcbiAgICAgIH1cblxuICAgICAgYXR0ciQxKGhpdCwgYXR0cnMpO1xuXG4gICAgICByZXR1cm4gaGl0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGVuZEhpdChnZngsIGhpdCkge1xuICAgICAgYXBwZW5kKGdmeCwgaGl0KTtcbiAgICB9XG5cblxuICAgIC8vIEFQSVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGhpbnRzIG9uIHRoZSBnaXZlbiBncmFwaGljcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZ2Z4XG4gICAgICovXG4gICAgdGhpcy5yZW1vdmVIaXRzID0gZnVuY3Rpb24oZ2Z4KSB7XG4gICAgICB2YXIgaGl0cyA9IGFsbCgnLmRqcy1oaXQnLCBnZngpO1xuXG4gICAgICBmb3JFYWNoJDEoaGl0cywgcmVtb3ZlJDIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZGVmYXVsdCBoaXQgZm9yIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBnZnhcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NWR0VsZW1lbnR9IGNyZWF0ZWQgaGl0XG4gICAgICovXG4gICAgdGhpcy5jcmVhdGVEZWZhdWx0SGl0ID0gZnVuY3Rpb24oZWxlbWVudCwgZ2Z4KSB7XG4gICAgICB2YXIgd2F5cG9pbnRzID0gZWxlbWVudC53YXlwb2ludHMsXG4gICAgICAgICAgaXNGcmFtZSA9IGVsZW1lbnQuaXNGcmFtZSxcbiAgICAgICAgICBib3hUeXBlO1xuXG4gICAgICBpZiAod2F5cG9pbnRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVdheXBvaW50c0hpdChnZngsIHdheXBvaW50cyk7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGJveFR5cGUgPSBpc0ZyYW1lID8gJ3N0cm9rZScgOiAnYWxsJztcblxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVCb3hIaXQoZ2Z4LCBib3hUeXBlLCB7XG4gICAgICAgICAgd2lkdGg6IGVsZW1lbnQud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBlbGVtZW50LmhlaWdodFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGhpdHMgZm9yIHRoZSBnaXZlbiB3YXlwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGdmeFxuICAgICAqIEBwYXJhbSB7UG9pbnRbXX0gd2F5cG9pbnRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuY3JlYXRlV2F5cG9pbnRzSGl0ID0gZnVuY3Rpb24oZ2Z4LCB3YXlwb2ludHMpIHtcblxuICAgICAgdmFyIGhpdCA9IGNyZWF0ZUxpbmUod2F5cG9pbnRzKTtcblxuICAgICAgYXBwbHlTdHlsZShoaXQsICdzdHJva2UnKTtcblxuICAgICAgYXBwZW5kSGl0KGdmeCwgaGl0KTtcblxuICAgICAgcmV0dXJuIGhpdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGhpdHMgZm9yIGEgYm94LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBnZnhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyc1xuICAgICAqXG4gICAgICogQHJldHVybiB7U1ZHRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNyZWF0ZUJveEhpdCA9IGZ1bmN0aW9uKGdmeCwgdHlwZSwgYXR0cnMpIHtcblxuICAgICAgYXR0cnMgPSBhc3NpZ24kMSh7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIGF0dHJzKTtcblxuICAgICAgdmFyIGhpdCA9IGNyZWF0ZSQxKCdyZWN0Jyk7XG5cbiAgICAgIGFwcGx5U3R5bGUoaGl0LCB0eXBlKTtcblxuICAgICAgYXR0ciQxKGhpdCwgYXR0cnMpO1xuXG4gICAgICBhcHBlbmRIaXQoZ2Z4LCBoaXQpO1xuXG4gICAgICByZXR1cm4gaGl0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZGVmYXVsdCBoaXQgb2YgdGhlIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGdmeFxuICAgICAqXG4gICAgICogQHJldHVybiB7U1ZHRWxlbWVudH0gdXBkYXRlZCBoaXRcbiAgICAgKi9cbiAgICB0aGlzLnVwZGF0ZURlZmF1bHRIaXQgPSBmdW5jdGlvbihlbGVtZW50LCBnZngpIHtcblxuICAgICAgdmFyIGhpdCA9IHF1ZXJ5KCcuZGpzLWhpdCcsIGdmeCk7XG5cbiAgICAgIGlmICghaGl0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQud2F5cG9pbnRzKSB7XG4gICAgICAgIHVwZGF0ZUxpbmUoaGl0LCBlbGVtZW50LndheXBvaW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyJDEoaGl0LCB7XG4gICAgICAgICAgd2lkdGg6IGVsZW1lbnQud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBlbGVtZW50LmhlaWdodFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhpdDtcbiAgICB9O1xuXG4gICAgdGhpcy5maXJlID0gZmlyZTtcblxuICAgIHRoaXMudHJpZ2dlck1vdXNlRXZlbnQgPSB0cmlnZ2VyTW91c2VFdmVudDtcblxuICAgIHRoaXMubW91c2VIYW5kbGVyID0gbW91c2VIYW5kbGVyO1xuXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50ID0gcmVnaXN0ZXJFdmVudDtcbiAgICB0aGlzLnVucmVnaXN0ZXJFdmVudCA9IHVucmVnaXN0ZXJFdmVudDtcbiAgfVxuXG5cbiAgSW50ZXJhY3Rpb25FdmVudHMuJGluamVjdCA9IFtcbiAgICAnZXZlbnRCdXMnLFxuICAgICdlbGVtZW50UmVnaXN0cnknLFxuICAgICdzdHlsZXMnXG4gIF07XG5cblxuICAvKipcbiAgICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IHRoZSBtb3VzZSBob3ZlcmVkIG92ZXIgYW4gZWxlbWVudFxuICAgKlxuICAgKiBAZXZlbnQgZWxlbWVudC5ob3ZlclxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvcGVydHkge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHByb3BlcnR5IHtTVkdFbGVtZW50fSBnZnhcbiAgICogQHByb3BlcnR5IHtFdmVudH0gb3JpZ2luYWxFdmVudFxuICAgKi9cblxuICAvKipcbiAgICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IHRoZSBtb3VzZSBoYXMgbGVmdCBhbiBlbGVtZW50XG4gICAqXG4gICAqIEBldmVudCBlbGVtZW50Lm91dFxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvcGVydHkge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHByb3BlcnR5IHtTVkdFbGVtZW50fSBnZnhcbiAgICogQHByb3BlcnR5IHtFdmVudH0gb3JpZ2luYWxFdmVudFxuICAgKi9cblxuICAvKipcbiAgICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IHRoZSBtb3VzZSBoYXMgY2xpY2tlZCBhbiBlbGVtZW50XG4gICAqXG4gICAqIEBldmVudCBlbGVtZW50LmNsaWNrXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcHJvcGVydHkge1NWR0VsZW1lbnR9IGdmeFxuICAgKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50XG4gICAqL1xuXG4gIC8qKlxuICAgKiBBbiBldmVudCBpbmRpY2F0aW5nIHRoYXQgdGhlIG1vdXNlIGhhcyBkb3VibGUgY2xpY2tlZCBhbiBlbGVtZW50XG4gICAqXG4gICAqIEBldmVudCBlbGVtZW50LmRibGNsaWNrXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcHJvcGVydHkge1NWR0VsZW1lbnR9IGdmeFxuICAgKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50XG4gICAqL1xuXG4gIC8qKlxuICAgKiBBbiBldmVudCBpbmRpY2F0aW5nIHRoYXQgdGhlIG1vdXNlIGhhcyBnb25lIGRvd24gb24gYW4gZWxlbWVudC5cbiAgICpcbiAgICogQGV2ZW50IGVsZW1lbnQubW91c2Vkb3duXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcHJvcGVydHkge1NWR0VsZW1lbnR9IGdmeFxuICAgKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50XG4gICAqL1xuXG4gIC8qKlxuICAgKiBBbiBldmVudCBpbmRpY2F0aW5nIHRoYXQgdGhlIG1vdXNlIGhhcyBnb25lIHVwIG9uIGFuIGVsZW1lbnQuXG4gICAqXG4gICAqIEBldmVudCBlbGVtZW50Lm1vdXNldXBcbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByb3BlcnR5IHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwcm9wZXJ0eSB7U1ZHRWxlbWVudH0gZ2Z4XG4gICAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnRcbiAgICovXG5cbiAgLyoqXG4gICAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCB0aGUgY29udGV4dCBtZW51IGFjdGlvbiBpcyB0cmlnZ2VyZWRcbiAgICogdmlhIG1vdXNlIG9yIHRvdWNoIGNvbnRyb2xzLlxuICAgKlxuICAgKiBAZXZlbnQgZWxlbWVudC5jb250ZXh0bWVudVxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvcGVydHkge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHByb3BlcnR5IHtTVkdFbGVtZW50fSBnZnhcbiAgICogQHByb3BlcnR5IHtFdmVudH0gb3JpZ2luYWxFdmVudFxuICAgKi9cblxuICAvKipcbiAgICogQHR5cGUgeyBpbXBvcnQoJ2RpZGknKS5Nb2R1bGVEZWNsYXJhdGlvbiB9XG4gICAqL1xuICB2YXIgSW50ZXJhY3Rpb25FdmVudHNNb2R1bGUgPSB7XG4gICAgX19pbml0X186IFsgJ2ludGVyYWN0aW9uRXZlbnRzJyBdLFxuICAgIGludGVyYWN0aW9uRXZlbnRzOiBbICd0eXBlJywgSW50ZXJhY3Rpb25FdmVudHMgXVxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi9jb3JlL0NhbnZhcycpLmRlZmF1bHR9IENhbnZhc1xuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi9jb3JlL0V2ZW50QnVzJykuZGVmYXVsdH0gRXZlbnRCdXNcbiAgICovXG5cbiAgLyoqXG4gICAqIEEgc2VydmljZSB0aGF0IG9mZmVycyB0aGUgY3VycmVudCBzZWxlY3Rpb24gaW4gYSBkaWFncmFtLlxuICAgKiBPZmZlcnMgdGhlIGFwaSB0byBjb250cm9sIHRoZSBzZWxlY3Rpb24sIHRvby5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICAgKi9cbiAgZnVuY3Rpb24gU2VsZWN0aW9uKGV2ZW50QnVzLCBjYW52YXMpIHtcblxuICAgIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdFtdfVxuICAgICAqL1xuICAgIHRoaXMuX3NlbGVjdGVkRWxlbWVudHMgPSBbXTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGV2ZW50QnVzLm9uKFsgJ3NoYXBlLnJlbW92ZScsICdjb25uZWN0aW9uLnJlbW92ZScgXSwgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBlLmVsZW1lbnQ7XG4gICAgICBzZWxmLmRlc2VsZWN0KGVsZW1lbnQpO1xuICAgIH0pO1xuXG4gICAgZXZlbnRCdXMub24oWyAnZGlhZ3JhbS5jbGVhcicsICdyb290LnNldCcgXSwgZnVuY3Rpb24oZSkge1xuICAgICAgc2VsZi5zZWxlY3QobnVsbCk7XG4gICAgfSk7XG4gIH1cblxuICBTZWxlY3Rpb24uJGluamVjdCA9IFsgJ2V2ZW50QnVzJywgJ2NhbnZhcycgXTtcblxuICAvKipcbiAgICogRGVzZWxlY3QgYW4gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gZGVzZWxlY3QuXG4gICAqL1xuICBTZWxlY3Rpb24ucHJvdG90eXBlLmRlc2VsZWN0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHZhciBzZWxlY3RlZEVsZW1lbnRzID0gdGhpcy5fc2VsZWN0ZWRFbGVtZW50cztcblxuICAgIHZhciBpZHggPSBzZWxlY3RlZEVsZW1lbnRzLmluZGV4T2YoZWxlbWVudCk7XG5cbiAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgdmFyIG9sZFNlbGVjdGlvbiA9IHNlbGVjdGVkRWxlbWVudHMuc2xpY2UoKTtcblxuICAgICAgc2VsZWN0ZWRFbGVtZW50cy5zcGxpY2UoaWR4LCAxKTtcblxuICAgICAgdGhpcy5fZXZlbnRCdXMuZmlyZSgnc2VsZWN0aW9uLmNoYW5nZWQnLCB7IG9sZFNlbGVjdGlvbjogb2xkU2VsZWN0aW9uLCBuZXdTZWxlY3Rpb246IHNlbGVjdGVkRWxlbWVudHMgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlbGVjdGVkIGVsZW1lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gVGhlIHNlbGVjdGVkIGVsZW1lbnRzLlxuICAgKi9cbiAgU2VsZWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRFbGVtZW50cztcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBhbiBlbGVtZW50IGlzIHNlbGVjdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCBUaGUgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZWxlbWVudCBpcyBzZWxlY3RlZC5cbiAgICovXG4gIFNlbGVjdGlvbi5wcm90b3R5cGUuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRFbGVtZW50cy5pbmRleE9mKGVsZW1lbnQpICE9PSAtMTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBTZWxlY3Qgb25lIG9yIG1hbnkgZWxlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfSBlbGVtZW50cyBUaGUgZWxlbWVudChzKSB0byBzZWxlY3QuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FkZF0gV2hldGhlciB0byBhZGQgdGhlIGVsZW1lbnQocykgdG8gdGhlIHNlbGVjdGVkIGVsZW1lbnRzLlxuICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgKi9cbiAgU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihlbGVtZW50cywgYWRkKSB7XG4gICAgdmFyIHNlbGVjdGVkRWxlbWVudHMgPSB0aGlzLl9zZWxlY3RlZEVsZW1lbnRzLFxuICAgICAgICBvbGRTZWxlY3Rpb24gPSBzZWxlY3RlZEVsZW1lbnRzLnNsaWNlKCk7XG5cbiAgICBpZiAoIWlzQXJyYXkkMihlbGVtZW50cykpIHtcbiAgICAgIGVsZW1lbnRzID0gZWxlbWVudHMgPyBbIGVsZW1lbnRzIF0gOiBbXTtcbiAgICB9XG5cbiAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xuXG4gICAgdmFyIHJvb3RFbGVtZW50ID0gY2FudmFzLmdldFJvb3RFbGVtZW50KCk7XG5cbiAgICBlbGVtZW50cyA9IGVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICB2YXIgZWxlbWVudFJvb3QgPSBjYW52YXMuZmluZFJvb3QoZWxlbWVudCk7XG5cbiAgICAgIHJldHVybiByb290RWxlbWVudCA9PT0gZWxlbWVudFJvb3Q7XG4gICAgfSk7XG5cbiAgICAvLyBzZWxlY3Rpb24gbWF5IGJlIGNsZWFyZWQgYnkgcGFzc2luZyBhbiBlbXB0eSBhcnJheSBvciBudWxsXG4gICAgLy8gdG8gdGhlIG1ldGhvZFxuICAgIGlmIChhZGQpIHtcbiAgICAgIGZvckVhY2gkMShlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICBpZiAoc2VsZWN0ZWRFbGVtZW50cy5pbmRleE9mKGVsZW1lbnQpICE9PSAtMSkge1xuXG4gICAgICAgICAgLy8gYWxyZWFkeSBzZWxlY3RlZFxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxlY3RlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZWxlY3RlZEVsZW1lbnRzID0gc2VsZWN0ZWRFbGVtZW50cyA9IGVsZW1lbnRzLnNsaWNlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZXZlbnRCdXMuZmlyZSgnc2VsZWN0aW9uLmNoYW5nZWQnLCB7IG9sZFNlbGVjdGlvbjogb2xkU2VsZWN0aW9uLCBuZXdTZWxlY3Rpb246IHNlbGVjdGVkRWxlbWVudHMgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL2NvcmUvQ2FudmFzJykuZGVmYXVsdH0gQ2FudmFzXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL2NvcmUvRXZlbnRCdXMnKS5kZWZhdWx0fSBFdmVudEJ1c1xuICAgKi9cblxuICB2YXIgTUFSS0VSX0hPVkVSID0gJ2hvdmVyJyxcbiAgICAgIE1BUktFUl9TRUxFQ1RFRCA9ICdzZWxlY3RlZCc7XG5cbiAgLyoqXG4gICAqIEEgcGx1Z2luIHRoYXQgYWRkcyBhIHZpc2libGUgc2VsZWN0aW9uIFVJIHRvIHNoYXBlcyBhbmQgY29ubmVjdGlvbnNcbiAgICogYnkgYXBwZW5kaW5nIHRoZSA8Y29kZT5ob3ZlcjwvY29kZT4gYW5kIDxjb2RlPnNlbGVjdGVkPC9jb2RlPiBjbGFzc2VzIHRvIHRoZW0uXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKlxuICAgKiBNYWtlcyBlbGVtZW50cyBzZWxlY3RhYmxlLCB0b28uXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAgICovXG4gIGZ1bmN0aW9uIFNlbGVjdGlvblZpc3VhbHMoY2FudmFzLCBldmVudEJ1cykge1xuICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcblxuICAgIGZ1bmN0aW9uIGFkZE1hcmtlcihlLCBjbHMpIHtcbiAgICAgIGNhbnZhcy5hZGRNYXJrZXIoZSwgY2xzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVNYXJrZXIoZSwgY2xzKSB7XG4gICAgICBjYW52YXMucmVtb3ZlTWFya2VyKGUsIGNscyk7XG4gICAgfVxuXG4gICAgZXZlbnRCdXMub24oJ2VsZW1lbnQuaG92ZXInLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgYWRkTWFya2VyKGV2ZW50LmVsZW1lbnQsIE1BUktFUl9IT1ZFUik7XG4gICAgfSk7XG5cbiAgICBldmVudEJ1cy5vbignZWxlbWVudC5vdXQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgcmVtb3ZlTWFya2VyKGV2ZW50LmVsZW1lbnQsIE1BUktFUl9IT1ZFUik7XG4gICAgfSk7XG5cbiAgICBldmVudEJ1cy5vbignc2VsZWN0aW9uLmNoYW5nZWQnLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICBmdW5jdGlvbiBkZXNlbGVjdChzKSB7XG4gICAgICAgIHJlbW92ZU1hcmtlcihzLCBNQVJLRVJfU0VMRUNURUQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZWxlY3Qocykge1xuICAgICAgICBhZGRNYXJrZXIocywgTUFSS0VSX1NFTEVDVEVEKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9sZFNlbGVjdGlvbiA9IGV2ZW50Lm9sZFNlbGVjdGlvbixcbiAgICAgICAgICBuZXdTZWxlY3Rpb24gPSBldmVudC5uZXdTZWxlY3Rpb247XG5cbiAgICAgIGZvckVhY2gkMShvbGRTZWxlY3Rpb24sIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKG5ld1NlbGVjdGlvbi5pbmRleE9mKGUpID09PSAtMSkge1xuICAgICAgICAgIGRlc2VsZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZm9yRWFjaCQxKG5ld1NlbGVjdGlvbiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAob2xkU2VsZWN0aW9uLmluZGV4T2YoZSkgPT09IC0xKSB7XG4gICAgICAgICAgc2VsZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIFNlbGVjdGlvblZpc3VhbHMuJGluamVjdCA9IFtcbiAgICAnY2FudmFzJyxcbiAgICAnZXZlbnRCdXMnXG4gIF07XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL2NvcmUvQ2FudmFzJykuZGVmYXVsdH0gQ2FudmFzXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL2NvcmUvRWxlbWVudFJlZ2lzdHJ5JykuZGVmYXVsdH0gRWxlbWVudFJlZ2lzdHJ5XG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL2NvcmUvRXZlbnRCdXMnKS5kZWZhdWx0fSBFdmVudEJ1c1xuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuL1NlbGVjdGlvbicpLmRlZmF1bHR9IFNlbGVjdGlvblxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAgICogQHBhcmFtIHtTZWxlY3Rpb259IHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gICAqIEBwYXJhbSB7RWxlbWVudFJlZ2lzdHJ5fSBlbGVtZW50UmVnaXN0cnlcbiAgICovXG4gIGZ1bmN0aW9uIFNlbGVjdGlvbkJlaGF2aW9yKGV2ZW50QnVzLCBzZWxlY3Rpb24sIGNhbnZhcywgZWxlbWVudFJlZ2lzdHJ5KSB7XG5cbiAgICAvLyBTZWxlY3QgZWxlbWVudHMgb24gY3JlYXRlXG4gICAgZXZlbnRCdXMub24oJ2NyZWF0ZS5lbmQnLCA1MDAsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgICAgY2FuRXhlY3V0ZSA9IGNvbnRleHQuY2FuRXhlY3V0ZSxcbiAgICAgICAgICBlbGVtZW50cyA9IGNvbnRleHQuZWxlbWVudHMsXG4gICAgICAgICAgaGludHMgPSBjb250ZXh0LmhpbnRzIHx8IHt9LFxuICAgICAgICAgIGF1dG9TZWxlY3QgPSBoaW50cy5hdXRvU2VsZWN0O1xuXG4gICAgICBpZiAoY2FuRXhlY3V0ZSkge1xuICAgICAgICBpZiAoYXV0b1NlbGVjdCA9PT0gZmFsc2UpIHtcblxuICAgICAgICAgIC8vIFNlbGVjdCBubyBlbGVtZW50c1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0FycmF5JDIoYXV0b1NlbGVjdCkpIHtcbiAgICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KGF1dG9TZWxlY3QpO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gU2VsZWN0IGFsbCBlbGVtZW50cyBieSBkZWZhdWx0XG4gICAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChlbGVtZW50cy5maWx0ZXIoaXNTaG93bikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTZWxlY3QgY29ubmVjdGlvbiB0YXJnZXRzIG9uIGNvbm5lY3RcbiAgICBldmVudEJ1cy5vbignY29ubmVjdC5lbmQnLCA1MDAsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQsXG4gICAgICAgICAgY29ubmVjdGlvbiA9IGNvbnRleHQuY29ubmVjdGlvbjtcblxuICAgICAgaWYgKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChjb25uZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNlbGVjdCBzaGFwZXMgb24gbW92ZVxuICAgIGV2ZW50QnVzLm9uKCdzaGFwZS5tb3ZlLmVuZCcsIDUwMCwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBwcmV2aW91c1NlbGVjdGlvbiA9IGV2ZW50LnByZXZpb3VzU2VsZWN0aW9uIHx8IFtdO1xuXG4gICAgICB2YXIgc2hhcGUgPSBlbGVtZW50UmVnaXN0cnkuZ2V0KGV2ZW50LmNvbnRleHQuc2hhcGUuaWQpO1xuXG4gICAgICAvLyBBbHdheXMgc2VsZWN0IG1haW4gc2hhcGUgb24gbW92ZVxuICAgICAgdmFyIGlzU2VsZWN0ZWQgPSBmaW5kKHByZXZpb3VzU2VsZWN0aW9uLCBmdW5jdGlvbihzZWxlY3RlZFNoYXBlKSB7XG4gICAgICAgIHJldHVybiBzaGFwZS5pZCA9PT0gc2VsZWN0ZWRTaGFwZS5pZDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWlzU2VsZWN0ZWQpIHtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChzaGFwZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTZWxlY3QgZWxlbWVudHMgb24gY2xpY2tcbiAgICBldmVudEJ1cy5vbignZWxlbWVudC5jbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgIGlmICghaXNQcmltYXJ5QnV0dG9uKGV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50ID0gZXZlbnQuZWxlbWVudDtcblxuICAgICAgaWYgKGVsZW1lbnQgPT09IGNhbnZhcy5nZXRSb290RWxlbWVudCgpKSB7XG4gICAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNTZWxlY3RlZCA9IHNlbGVjdGlvbi5pc1NlbGVjdGVkKGVsZW1lbnQpLFxuICAgICAgICAgIGlzTXVsdGlTZWxlY3QgPSBzZWxlY3Rpb24uZ2V0KCkubGVuZ3RoID4gMTtcblxuICAgICAgLy8gQWRkIHRvIHNlbGVjdGlvbiBpZiBTSElGVCBwcmVzc2VkXG4gICAgICB2YXIgYWRkID0gaGFzU2Vjb25kYXJ5TW9kaWZpZXIoZXZlbnQpO1xuXG4gICAgICBpZiAoaXNTZWxlY3RlZCAmJiBpc011bHRpU2VsZWN0KSB7XG4gICAgICAgIGlmIChhZGQpIHtcblxuICAgICAgICAgIC8vIERlc2VsZWN0IGVsZW1lbnRcbiAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uLmRlc2VsZWN0KGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gU2VsZWN0IGVsZW1lbnQgb25seVxuICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24uc2VsZWN0KGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc1NlbGVjdGVkKSB7XG5cbiAgICAgICAgLy8gU2VsZWN0IGVsZW1lbnRcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChlbGVtZW50LCBhZGQpO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBEZXNlbGVjdCBlbGVtZW50XG4gICAgICAgIHNlbGVjdGlvbi5kZXNlbGVjdChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIFNlbGVjdGlvbkJlaGF2aW9yLiRpbmplY3QgPSBbXG4gICAgJ2V2ZW50QnVzJyxcbiAgICAnc2VsZWN0aW9uJyxcbiAgICAnY2FudmFzJyxcbiAgICAnZWxlbWVudFJlZ2lzdHJ5J1xuICBdO1xuXG5cbiAgZnVuY3Rpb24gaXNTaG93bihlbGVtZW50KSB7XG4gICAgcmV0dXJuICFlbGVtZW50LmhpZGRlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7IGltcG9ydCgnZGlkaScpLk1vZHVsZURlY2xhcmF0aW9uIH1cbiAgICovXG4gIHZhciBTZWxlY3Rpb25Nb2R1bGUgPSB7XG4gICAgX19pbml0X186IFsgJ3NlbGVjdGlvblZpc3VhbHMnLCAnc2VsZWN0aW9uQmVoYXZpb3InIF0sXG4gICAgX19kZXBlbmRzX186IFtcbiAgICAgIEludGVyYWN0aW9uRXZlbnRzTW9kdWxlLFxuICAgIF0sXG4gICAgc2VsZWN0aW9uOiBbICd0eXBlJywgU2VsZWN0aW9uIF0sXG4gICAgc2VsZWN0aW9uVmlzdWFsczogWyAndHlwZScsIFNlbGVjdGlvblZpc3VhbHMgXSxcbiAgICBzZWxlY3Rpb25CZWhhdmlvcjogWyAndHlwZScsIFNlbGVjdGlvbkJlaGF2aW9yIF1cbiAgfTtcblxuICBjb25zdCBDTEFTU19QQVRURVJOID0gL15jbGFzc1sge10vO1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpc0NsYXNzKGZuKSB7XG4gICAgcmV0dXJuIENMQVNTX1BBVFRFUk4udGVzdChmbi50b1N0cmluZygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gb2JqXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iaik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IG9ialxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzT3duUHJvcChvYmosIHByb3ApIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi9pbmRleC5qcycpLkluamVjdEFubm90YXRlZCB9IEluamVjdEFubm90YXRlZFxuICAgKi9cblxuICAvKipcbiAgICogQHRlbXBsYXRlIFRcbiAgICpcbiAgICogQHBhcmFtcyB7Wy4uLnN0cmluZ1tdLCBUXSB8IC4uLnN0cmluZ1tdLCBUfSBhcmdzXG4gICAqXG4gICAqIEByZXR1cm4ge1QgJiBJbmplY3RBbm5vdGF0ZWR9XG4gICAqL1xuICBmdW5jdGlvbiBhbm5vdGF0ZSguLi5hcmdzKSB7XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgfVxuXG4gICAgYXJncyA9IFsgLi4uYXJncyBdO1xuXG4gICAgY29uc3QgZm4gPSBhcmdzLnBvcCgpO1xuXG4gICAgZm4uJGluamVjdCA9IGFyZ3M7XG5cbiAgICByZXR1cm4gZm47XG4gIH1cblxuXG4gIC8vIEN1cnJlbnQgbGltaXRhdGlvbnM6XG4gIC8vIC0gY2FuJ3QgcHV0IGludG8gXCJmdW5jdGlvbiBhcmdcIiBjb21tZW50c1xuICAvLyBmdW5jdGlvbiAvKiAobm8gcGFyZW50aGVzaXMgbGlrZSB0aGlzKSAqLyAoKXt9XG4gIC8vIGZ1bmN0aW9uIGFiYyggLyogeHggKG5vIHBhcmVudGhlc2lzIGxpa2UgdGhpcykgKi8gYSwgYikge31cbiAgLy9cbiAgLy8gSnVzdCBwdXQgdGhlIGNvbW1lbnQgYmVmb3JlIGZ1bmN0aW9uIG9yIGluc2lkZTpcbiAgLy8gLyogKCgodGhpcyBpcyBmaW5lKSkpICovIGZ1bmN0aW9uKGEsIGIpIHt9XG4gIC8vIGZ1bmN0aW9uIGFiYyhhKSB7IC8qICgoKHRoaXMgaXMgZmluZSkpKSAqL31cbiAgLy9cbiAgLy8gLSBjYW4ndCByZWxpYWJseSBhdXRvLWFubm90YXRlIGNvbnN0cnVjdG9yOyB3ZSdsbCBtYXRjaCB0aGVcbiAgLy8gZmlyc3QgY29uc3RydWN0b3IoLi4uKSBwYXR0ZXJuIGZvdW5kIHdoaWNoIG1heSBiZSB0aGUgb25lXG4gIC8vIG9mIGEgbmVzdGVkIGNsYXNzLCB0b28uXG5cbiAgY29uc3QgQ09OU1RSVUNUT1JfQVJHUyA9IC9jb25zdHJ1Y3RvclxccypbXihdKlxcKFxccyooW14pXSopXFwpL207XG4gIGNvbnN0IEZOX0FSR1MgPSAvXig/OmFzeW5jXFxzKyk/KD86ZnVuY3Rpb25cXHMqW14oXSopPyg/OlxcKFxccyooW14pXSopXFwpfChcXHcrKSkvbTtcbiAgY29uc3QgRk5fQVJHID0gL1xcL1xcKihbXipdKilcXCpcXC8vbTtcblxuICAvKipcbiAgICogQHBhcmFtIHt1bmtub3dufSBmblxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXX1cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQW5ub3RhdGlvbnMoZm4pIHtcblxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGFubm90YXRlIFwiJHtmbn1cIi4gRXhwZWN0ZWQgYSBmdW5jdGlvbiFgKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXRjaCA9IGZuLnRvU3RyaW5nKCkubWF0Y2goaXNDbGFzcyhmbikgPyBDT05TVFJVQ1RPUl9BUkdTIDogRk5fQVJHUyk7XG5cbiAgICAvLyBtYXkgcGFyc2UgY2xhc3Mgd2l0aG91dCBjb25zdHJ1Y3RvclxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBhcmdzID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl07XG5cbiAgICByZXR1cm4gYXJncyAmJiBhcmdzLnNwbGl0KCcsJykubWFwKGFyZyA9PiB7XG4gICAgICBjb25zdCBhcmdNYXRjaCA9IGFyZy5tYXRjaChGTl9BUkcpO1xuICAgICAgcmV0dXJuIChhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXSB8fCBhcmcpLnRyaW0oKTtcbiAgICB9KSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9pbmRleC5qcycpLk1vZHVsZURlY2xhcmF0aW9uIH0gTW9kdWxlRGVjbGFyYXRpb25cbiAgICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vaW5kZXguanMnKS5Nb2R1bGVEZWZpbml0aW9uIH0gTW9kdWxlRGVmaW5pdGlvblxuICAgKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9pbmRleC5qcycpLkluamVjdG9yQ29udGV4dCB9IEluamVjdG9yQ29udGV4dFxuICAgKlxuICAgKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9pbmRleC5qcycpLlR5cGVkRGVjbGFyYXRpb248YW55LCBhbnk+IH0gVHlwZWREZWNsYXJhdGlvblxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluamVjdG9yIHdpdGggdGhlIGdpdmVuIG1vZHVsZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kdWxlRGVmaW5pdGlvbltdfSBtb2R1bGVzXG4gICAqIEBwYXJhbSB7SW5qZWN0b3JDb250ZXh0fSBbX3BhcmVudF1cbiAgICovXG4gIGZ1bmN0aW9uIEluamVjdG9yKG1vZHVsZXMsIF9wYXJlbnQpIHtcblxuICAgIGNvbnN0IHBhcmVudCA9IF9wYXJlbnQgfHwgLyoqIEB0eXBlIEluamVjdG9yQ29udGV4dCAqLyAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbihuYW1lLCBzdHJpY3QpIHtcbiAgICAgICAgY3VycmVudGx5UmVzb2x2aW5nLnB1c2gobmFtZSk7XG5cbiAgICAgICAgaWYgKHN0cmljdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcihgTm8gcHJvdmlkZXIgZm9yIFwiJHsgbmFtZSB9XCIhYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGN1cnJlbnRseVJlc29sdmluZyA9IFtdO1xuICAgIGNvbnN0IHByb3ZpZGVycyA9IHRoaXMuX3Byb3ZpZGVycyA9IE9iamVjdC5jcmVhdGUocGFyZW50Ll9wcm92aWRlcnMgfHwgbnVsbCk7XG4gICAgY29uc3QgaW5zdGFuY2VzID0gdGhpcy5faW5zdGFuY2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIGNvbnN0IHNlbGYgPSBpbnN0YW5jZXMuaW5qZWN0b3IgPSB0aGlzO1xuXG4gICAgY29uc3QgZXJyb3IgPSBmdW5jdGlvbihtc2cpIHtcbiAgICAgIGNvbnN0IHN0YWNrID0gY3VycmVudGx5UmVzb2x2aW5nLmpvaW4oJyAtPiAnKTtcbiAgICAgIGN1cnJlbnRseVJlc29sdmluZy5sZW5ndGggPSAwO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihzdGFjayA/IGAkeyBtc2cgfSAoUmVzb2x2aW5nOiAkeyBzdGFjayB9KWAgOiBtc2cpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuYW1lZCBzZXJ2aWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdHJpY3Q9dHJ1ZV0gaWYgZmFsc2UsIHJlc29sdmUgbWlzc2luZyBzZXJ2aWNlcyB0byBudWxsXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHthbnl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KG5hbWUsIHN0cmljdCkge1xuICAgICAgaWYgKCFwcm92aWRlcnNbbmFtZV0gJiYgbmFtZS5pbmNsdWRlcygnLicpKSB7XG5cbiAgICAgICAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgIGxldCBwaXZvdCA9IGdldCgvKiogQHR5cGUgeyBzdHJpbmcgfSAqLyAocGFydHMuc2hpZnQoKSkpO1xuXG4gICAgICAgIHdoaWxlIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICBwaXZvdCA9IHBpdm90Wy8qKiBAdHlwZSB7IHN0cmluZyB9ICovIChwYXJ0cy5zaGlmdCgpKV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGl2b3Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNPd25Qcm9wKGluc3RhbmNlcywgbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlc1tuYW1lXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc093blByb3AocHJvdmlkZXJzLCBuYW1lKSkge1xuICAgICAgICBpZiAoY3VycmVudGx5UmVzb2x2aW5nLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgY3VycmVudGx5UmVzb2x2aW5nLnB1c2gobmFtZSk7XG4gICAgICAgICAgdGhyb3cgZXJyb3IoJ0Nhbm5vdCByZXNvbHZlIGNpcmN1bGFyIGRlcGVuZGVuY3khJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50bHlSZXNvbHZpbmcucHVzaChuYW1lKTtcbiAgICAgICAgaW5zdGFuY2VzW25hbWVdID0gcHJvdmlkZXJzW25hbWVdWzBdKHByb3ZpZGVyc1tuYW1lXVsxXSk7XG4gICAgICAgIGN1cnJlbnRseVJlc29sdmluZy5wb3AoKTtcblxuICAgICAgICByZXR1cm4gaW5zdGFuY2VzW25hbWVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50LmdldChuYW1lLCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZuRGVmKGZuLCBsb2NhbHMpIHtcblxuICAgICAgaWYgKHR5cGVvZiBsb2NhbHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGxvY2FscyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChpc0FycmF5KGZuKSkge1xuICAgICAgICAgIGZuID0gYW5ub3RhdGUoZm4uc2xpY2UoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3IoYENhbm5vdCBpbnZva2UgXCIkeyBmbiB9XCIuIEV4cGVjdGVkIGEgZnVuY3Rpb24hYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGluamVjdCA9IGZuLiRpbmplY3QgfHwgcGFyc2VBbm5vdGF0aW9ucyhmbik7XG4gICAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBpbmplY3QubWFwKGRlcCA9PiB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGxvY2FscywgZGVwKSkge1xuICAgICAgICAgIHJldHVybiBsb2NhbHNbZGVwXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZ2V0KGRlcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBmbjogZm4sXG4gICAgICAgIGRlcGVuZGVuY2llc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSB0aGUgZ2l2ZW4gdHlwZSwgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy5cbiAgICAgKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyBGdW5jdGlvbiB8IFsuLi5zdHJpbmdbXSwgRnVuY3Rpb24gXX0gdHlwZVxuICAgICAqXG4gICAgICogQHJldHVybiBUXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zdGFudGlhdGUodHlwZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmbixcbiAgICAgICAgZGVwZW5kZW5jaWVzXG4gICAgICB9ID0gZm5EZWYodHlwZSk7XG5cbiAgICAgIC8vIGluc3RhbnRpYXRlIHZhciBhcmdzIGNvbnN0cnVjdG9yXG4gICAgICBjb25zdCBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoZm4sIG51bGwsIC4uLmRlcGVuZGVuY2llcyk7XG5cbiAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2UgdGhlIGdpdmVuIGZ1bmN0aW9uLCBpbmplY3RpbmcgZGVwZW5kZW5jaWVzLiBSZXR1cm4gdGhlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyBGdW5jdGlvbiB8IFsuLi5zdHJpbmdbXSwgRnVuY3Rpb24gXX0gZnVuY1xuICAgICAqIEBwYXJhbSB7IE9iamVjdCB9IFtjb250ZXh0XVxuICAgICAqIEBwYXJhbSB7IE9iamVjdCB9IFtsb2NhbHNdXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtUfSBpbnZvY2F0aW9uIHJlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludm9rZShmdW5jLCBjb250ZXh0LCBsb2NhbHMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZm4sXG4gICAgICAgIGRlcGVuZGVuY2llc1xuICAgICAgfSA9IGZuRGVmKGZ1bmMsIGxvY2Fscyk7XG5cbiAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBkZXBlbmRlbmNpZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SW5qZWN0b3J9IGNoaWxkSW5qZWN0b3JcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVByaXZhdGVJbmplY3RvckZhY3RvcnkoY2hpbGRJbmplY3Rvcikge1xuICAgICAgcmV0dXJuIGFubm90YXRlKGtleSA9PiBjaGlsZEluamVjdG9yLmdldChrZXkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01vZHVsZURlZmluaXRpb25bXX0gbW9kdWxlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFtmb3JjZU5ld0luc3RhbmNlc11cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0luamVjdG9yfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKG1vZHVsZXMsIGZvcmNlTmV3SW5zdGFuY2VzKSB7XG4gICAgICBpZiAoZm9yY2VOZXdJbnN0YW5jZXMgJiYgZm9yY2VOZXdJbnN0YW5jZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZyb21QYXJlbnRNb2R1bGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBjb25zdCBtYXRjaGVkU2NvcGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICBjb25zdCBwcml2YXRlSW5qZWN0b3JzQ2FjaGUgPSBbXTtcbiAgICAgICAgY29uc3QgcHJpdmF0ZUNoaWxkSW5qZWN0b3JzID0gW107XG4gICAgICAgIGNvbnN0IHByaXZhdGVDaGlsZEZhY3RvcmllcyA9IFtdO1xuXG4gICAgICAgIGxldCBwcm92aWRlcjtcbiAgICAgICAgbGV0IGNhY2hlSWR4O1xuICAgICAgICBsZXQgcHJpdmF0ZUNoaWxkSW5qZWN0b3I7XG4gICAgICAgIGxldCBwcml2YXRlQ2hpbGRJbmplY3RvckZhY3Rvcnk7XG5cbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcm92aWRlcnMpIHtcbiAgICAgICAgICBwcm92aWRlciA9IHByb3ZpZGVyc1tuYW1lXTtcblxuICAgICAgICAgIGlmIChmb3JjZU5ld0luc3RhbmNlcy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyWzJdID09PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgICAgY2FjaGVJZHggPSBwcml2YXRlSW5qZWN0b3JzQ2FjaGUuaW5kZXhPZihwcm92aWRlclszXSk7XG4gICAgICAgICAgICAgIGlmIChjYWNoZUlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBwcml2YXRlQ2hpbGRJbmplY3RvciA9IHByb3ZpZGVyWzNdLmNyZWF0ZUNoaWxkKFtdLCBmb3JjZU5ld0luc3RhbmNlcyk7XG4gICAgICAgICAgICAgICAgcHJpdmF0ZUNoaWxkSW5qZWN0b3JGYWN0b3J5ID0gY3JlYXRlUHJpdmF0ZUluamVjdG9yRmFjdG9yeShwcml2YXRlQ2hpbGRJbmplY3Rvcik7XG4gICAgICAgICAgICAgICAgcHJpdmF0ZUluamVjdG9yc0NhY2hlLnB1c2gocHJvdmlkZXJbM10pO1xuICAgICAgICAgICAgICAgIHByaXZhdGVDaGlsZEluamVjdG9ycy5wdXNoKHByaXZhdGVDaGlsZEluamVjdG9yKTtcbiAgICAgICAgICAgICAgICBwcml2YXRlQ2hpbGRGYWN0b3JpZXMucHVzaChwcml2YXRlQ2hpbGRJbmplY3RvckZhY3RvcnkpO1xuICAgICAgICAgICAgICAgIGZyb21QYXJlbnRNb2R1bGVbbmFtZV0gPSBbIHByaXZhdGVDaGlsZEluamVjdG9yRmFjdG9yeSwgbmFtZSwgJ3ByaXZhdGUnLCBwcml2YXRlQ2hpbGRJbmplY3RvciBdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyb21QYXJlbnRNb2R1bGVbbmFtZV0gPSBbIHByaXZhdGVDaGlsZEZhY3Rvcmllc1tjYWNoZUlkeF0sIG5hbWUsICdwcml2YXRlJywgcHJpdmF0ZUNoaWxkSW5qZWN0b3JzW2NhY2hlSWR4XSBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tUGFyZW50TW9kdWxlW25hbWVdID0gWyBwcm92aWRlclsyXSwgcHJvdmlkZXJbMV0gXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoZWRTY29wZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgocHJvdmlkZXJbMl0gPT09ICdmYWN0b3J5JyB8fCBwcm92aWRlclsyXSA9PT0gJ3R5cGUnKSAmJiBwcm92aWRlclsxXS4kc2NvcGUpIHtcbiAgICAgICAgICAgIC8qIGpzaGludCAtVzA4MyAqL1xuICAgICAgICAgICAgZm9yY2VOZXdJbnN0YW5jZXMuZm9yRWFjaChzY29wZSA9PiB7XG4gICAgICAgICAgICAgIGlmIChwcm92aWRlclsxXS4kc2NvcGUuaW5kZXhPZihzY29wZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZnJvbVBhcmVudE1vZHVsZVtuYW1lXSA9IFsgcHJvdmlkZXJbMl0sIHByb3ZpZGVyWzFdIF07XG4gICAgICAgICAgICAgICAgbWF0Y2hlZFNjb3Blc1tzY29wZV0gPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3JjZU5ld0luc3RhbmNlcy5mb3JFYWNoKHNjb3BlID0+IHtcbiAgICAgICAgICBpZiAoIW1hdGNoZWRTY29wZXNbc2NvcGVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHByb3ZpZGVyIGZvciBcIicgKyBzY29wZSArICdcIi4gQ2Fubm90IHVzZSBwcm92aWRlciBmcm9tIHRoZSBwYXJlbnQhJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtb2R1bGVzLnVuc2hpZnQoZnJvbVBhcmVudE1vZHVsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgSW5qZWN0b3IobW9kdWxlcywgc2VsZik7XG4gICAgfVxuXG4gICAgY29uc3QgZmFjdG9yeU1hcCA9IHtcbiAgICAgIGZhY3Rvcnk6IGludm9rZSxcbiAgICAgIHR5cGU6IGluc3RhbnRpYXRlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNb2R1bGVEZWZpbml0aW9ufSBtb2R1bGVEZWZpbml0aW9uXG4gICAgICogQHBhcmFtIHtJbmplY3Rvcn0gaW5qZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVJbml0aWFsaXplcihtb2R1bGVEZWZpbml0aW9uLCBpbmplY3Rvcikge1xuXG4gICAgICBjb25zdCBpbml0aWFsaXplcnMgPSBtb2R1bGVEZWZpbml0aW9uLl9faW5pdF9fIHx8IFtdO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGluaXRpYWxpemVycy5mb3JFYWNoKGluaXRpYWxpemVyID0+IHtcblxuICAgICAgICAgIC8vIGVhZ2VybHkgcmVzb2x2ZSBjb21wb25lbnQgKGZuIG9yIHN0cmluZylcbiAgICAgICAgICBpZiAodHlwZW9mIGluaXRpYWxpemVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaW5qZWN0b3IuZ2V0KGluaXRpYWxpemVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5qZWN0b3IuaW52b2tlKGluaXRpYWxpemVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01vZHVsZURlZmluaXRpb259IG1vZHVsZURlZmluaXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2FkTW9kdWxlKG1vZHVsZURlZmluaXRpb24pIHtcblxuICAgICAgY29uc3QgbW9kdWxlRXhwb3J0cyA9IG1vZHVsZURlZmluaXRpb24uX19leHBvcnRzX187XG5cbiAgICAgIC8vIHByaXZhdGUgbW9kdWxlXG4gICAgICBpZiAobW9kdWxlRXhwb3J0cykge1xuICAgICAgICBjb25zdCBuZXN0ZWRNb2R1bGVzID0gbW9kdWxlRGVmaW5pdGlvbi5fX21vZHVsZXNfXztcblxuICAgICAgICBjb25zdCBjbG9uZWRNb2R1bGUgPSBPYmplY3Qua2V5cyhtb2R1bGVEZWZpbml0aW9uKS5yZWR1Y2UoKGNsb25lZE1vZHVsZSwga2V5KSA9PiB7XG5cbiAgICAgICAgICBpZiAoa2V5ICE9PSAnX19leHBvcnRzX18nICYmIGtleSAhPT0gJ19fbW9kdWxlc19fJyAmJiBrZXkgIT09ICdfX2luaXRfXycgJiYga2V5ICE9PSAnX19kZXBlbmRzX18nKSB7XG4gICAgICAgICAgICBjbG9uZWRNb2R1bGVba2V5XSA9IG1vZHVsZURlZmluaXRpb25ba2V5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY2xvbmVkTW9kdWxlO1xuICAgICAgICB9LCBPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuICAgICAgICBjb25zdCBjaGlsZE1vZHVsZXMgPSAobmVzdGVkTW9kdWxlcyB8fCBbXSkuY29uY2F0KGNsb25lZE1vZHVsZSk7XG5cbiAgICAgICAgY29uc3QgcHJpdmF0ZUluamVjdG9yID0gY3JlYXRlQ2hpbGQoY2hpbGRNb2R1bGVzKTtcbiAgICAgICAgY29uc3QgZ2V0RnJvbVByaXZhdGVJbmplY3RvciA9IGFubm90YXRlKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIHJldHVybiBwcml2YXRlSW5qZWN0b3IuZ2V0KGtleSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1vZHVsZUV4cG9ydHMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICBwcm92aWRlcnNba2V5XSA9IFsgZ2V0RnJvbVByaXZhdGVJbmplY3Rvciwga2V5LCAncHJpdmF0ZScsIHByaXZhdGVJbmplY3RvciBdO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBlbnN1cmUgY2hpbGQgaW5qZWN0b3IgaW5pdGlhbGl6ZXNcbiAgICAgICAgY29uc3QgaW5pdGlhbGl6ZXJzID0gKG1vZHVsZURlZmluaXRpb24uX19pbml0X18gfHwgW10pLnNsaWNlKCk7XG5cbiAgICAgICAgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcHJpdmF0ZUluamVjdG9yLmluaXQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9kdWxlRGVmaW5pdGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIG1vZHVsZURlZmluaXRpb24sIHtcbiAgICAgICAgICBfX2luaXRfXzogaW5pdGlhbGl6ZXJzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVJbml0aWFsaXplcihtb2R1bGVEZWZpbml0aW9uLCBwcml2YXRlSW5qZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICAvLyBub3JtYWwgbW9kdWxlXG4gICAgICBPYmplY3Qua2V5cyhtb2R1bGVEZWZpbml0aW9uKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdfX2luaXRfXycgfHwga2V5ID09PSAnX19kZXBlbmRzX18nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHlwZURlY2xhcmF0aW9uID0gLyoqIEB0eXBlIHsgVHlwZWREZWNsYXJhdGlvbiB9ICovIChcbiAgICAgICAgICBtb2R1bGVEZWZpbml0aW9uW2tleV1cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodHlwZURlY2xhcmF0aW9uWzJdID09PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICBwcm92aWRlcnNba2V5XSA9IHR5cGVEZWNsYXJhdGlvbjtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0eXBlID0gdHlwZURlY2xhcmF0aW9uWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGVEZWNsYXJhdGlvblsxXTtcblxuICAgICAgICBwcm92aWRlcnNba2V5XSA9IFsgZmFjdG9yeU1hcFt0eXBlXSwgYXJyYXlVbndyYXAodHlwZSwgdmFsdWUpLCB0eXBlIF07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGNyZWF0ZUluaXRpYWxpemVyKG1vZHVsZURlZmluaXRpb24sIHNlbGYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TW9kdWxlRGVmaW5pdGlvbltdfSBtb2R1bGVEZWZpbml0aW9uc1xuICAgICAqIEBwYXJhbSB7TW9kdWxlRGVmaW5pdGlvbn0gbW9kdWxlRGVmaW5pdGlvblxuICAgICAqXG4gICAgICogQHJldHVybiB7TW9kdWxlRGVmaW5pdGlvbltdfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVEZXBlbmRlbmNpZXMobW9kdWxlRGVmaW5pdGlvbnMsIG1vZHVsZURlZmluaXRpb24pIHtcblxuICAgICAgaWYgKG1vZHVsZURlZmluaXRpb25zLmluZGV4T2YobW9kdWxlRGVmaW5pdGlvbikgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGVEZWZpbml0aW9ucztcbiAgICAgIH1cblxuICAgICAgbW9kdWxlRGVmaW5pdGlvbnMgPSAobW9kdWxlRGVmaW5pdGlvbi5fX2RlcGVuZHNfXyB8fCBbXSkucmVkdWNlKHJlc29sdmVEZXBlbmRlbmNpZXMsIG1vZHVsZURlZmluaXRpb25zKTtcblxuICAgICAgaWYgKG1vZHVsZURlZmluaXRpb25zLmluZGV4T2YobW9kdWxlRGVmaW5pdGlvbikgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGVEZWZpbml0aW9ucztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1vZHVsZURlZmluaXRpb25zLmNvbmNhdChtb2R1bGVEZWZpbml0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01vZHVsZURlZmluaXRpb25bXX0gbW9kdWxlRGVmaW5pdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm4geyAoKSA9PiB2b2lkIH0gaW5pdGlhbGl6ZXJGblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJvb3RzdHJhcChtb2R1bGVEZWZpbml0aW9ucykge1xuXG4gICAgICBjb25zdCBpbml0aWFsaXplcnMgPSBtb2R1bGVEZWZpbml0aW9uc1xuICAgICAgICAucmVkdWNlKHJlc29sdmVEZXBlbmRlbmNpZXMsIFtdKVxuICAgICAgICAubWFwKGxvYWRNb2R1bGUpO1xuXG4gICAgICBsZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmIChpbml0aWFsaXplZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgICBpbml0aWFsaXplcnMuZm9yRWFjaChpbml0aWFsaXplciA9PiBpbml0aWFsaXplcigpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gcHVibGljIEFQSVxuICAgIHRoaXMuZ2V0ID0gZ2V0O1xuICAgIHRoaXMuaW52b2tlID0gaW52b2tlO1xuICAgIHRoaXMuaW5zdGFudGlhdGUgPSBpbnN0YW50aWF0ZTtcbiAgICB0aGlzLmNyZWF0ZUNoaWxkID0gY3JlYXRlQ2hpbGQ7XG5cbiAgICAvLyBzZXR1cFxuICAgIHRoaXMuaW5pdCA9IGJvb3RzdHJhcChtb2R1bGVzKTtcbiAgfVxuXG5cbiAgLy8gaGVscGVycyAvLy8vLy8vLy8vLy8vLy9cblxuICBmdW5jdGlvbiBhcnJheVVud3JhcCh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlICE9PSAndmFsdWUnICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IGFubm90YXRlKHZhbHVlLnNsaWNlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9jb3JlL0V2ZW50QnVzJykuZGVmYXVsdH0gRXZlbnRCdXNcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi9TdHlsZXMnKS5kZWZhdWx0fSBTdHlsZXNcbiAgICovXG5cbiAgLy8gYXBwbHkgZGVmYXVsdCByZW5kZXJlciB3aXRoIGxvd2VzdCBwb3NzaWJsZSBwcmlvcml0eVxuICAvLyBzbyB0aGF0IGl0IG9ubHkga2lja3MgaW4gaWYgbm9vbmUgZWxzZSBjb3VsZCByZW5kZXJcbiAgdmFyIERFRkFVTFRfUkVOREVSX1BSSU9SSVRZID0gMTtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgcmVuZGVyZXIgdXNlZCBmb3Igc2hhcGVzIGFuZCBjb25uZWN0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAgICogQHBhcmFtIHtTdHlsZXN9IHN0eWxlc1xuICAgKi9cbiAgZnVuY3Rpb24gRGVmYXVsdFJlbmRlcmVyKGV2ZW50QnVzLCBzdHlsZXMpIHtcblxuICAgIEJhc2VSZW5kZXJlci5jYWxsKHRoaXMsIGV2ZW50QnVzLCBERUZBVUxUX1JFTkRFUl9QUklPUklUWSk7XG5cbiAgICB0aGlzLkNPTk5FQ1RJT05fU1RZTEUgPSBzdHlsZXMuc3R5bGUoWyAnbm8tZmlsbCcgXSwgeyBzdHJva2VXaWR0aDogNSwgc3Ryb2tlOiAnZnVjaHNpYScgfSk7XG4gICAgdGhpcy5TSEFQRV9TVFlMRSA9IHN0eWxlcy5zdHlsZSh7IGZpbGw6ICd3aGl0ZScsIHN0cm9rZTogJ2Z1Y2hzaWEnLCBzdHJva2VXaWR0aDogMiB9KTtcbiAgICB0aGlzLkZSQU1FX1NUWUxFID0gc3R5bGVzLnN0eWxlKFsgJ25vLWZpbGwnIF0sIHsgc3Ryb2tlOiAnZnVjaHNpYScsIHN0cm9rZURhc2hhcnJheTogNCwgc3Ryb2tlV2lkdGg6IDIgfSk7XG4gIH1cblxuICBlKERlZmF1bHRSZW5kZXJlciwgQmFzZVJlbmRlcmVyKTtcblxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRGVmYXVsdFJlbmRlcmVyLnByb3RvdHlwZS5jYW5SZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIERlZmF1bHRSZW5kZXJlci5wcm90b3R5cGUuZHJhd1NoYXBlID0gZnVuY3Rpb24gZHJhd1NoYXBlKHZpc3VhbHMsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgdmFyIHJlY3QgPSBjcmVhdGUkMSgncmVjdCcpO1xuXG4gICAgYXR0ciQxKHJlY3QsIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGVsZW1lbnQud2lkdGggfHwgMCxcbiAgICAgIGhlaWdodDogZWxlbWVudC5oZWlnaHQgfHwgMFxuICAgIH0pO1xuXG4gICAgaWYgKGlzRnJhbWVFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICBhdHRyJDEocmVjdCwgYXNzaWduJDEoe30sIHRoaXMuRlJBTUVfU1RZTEUsIGF0dHJzIHx8IHt9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHIkMShyZWN0LCBhc3NpZ24kMSh7fSwgdGhpcy5TSEFQRV9TVFlMRSwgYXR0cnMgfHwge30pKTtcbiAgICB9XG5cbiAgICBhcHBlbmQodmlzdWFscywgcmVjdCk7XG5cbiAgICByZXR1cm4gcmVjdDtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIERlZmF1bHRSZW5kZXJlci5wcm90b3R5cGUuZHJhd0Nvbm5lY3Rpb24gPSBmdW5jdGlvbiBkcmF3Q29ubmVjdGlvbih2aXN1YWxzLCBjb25uZWN0aW9uLCBhdHRycykge1xuXG4gICAgdmFyIGxpbmUgPSBjcmVhdGVMaW5lKGNvbm5lY3Rpb24ud2F5cG9pbnRzLCBhc3NpZ24kMSh7fSwgdGhpcy5DT05ORUNUSU9OX1NUWUxFLCBhdHRycyB8fCB7fSkpO1xuICAgIGFwcGVuZCh2aXN1YWxzLCBsaW5lKTtcblxuICAgIHJldHVybiBsaW5lO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRGVmYXVsdFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTaGFwZVBhdGggPSBmdW5jdGlvbiBnZXRTaGFwZVBhdGgoc2hhcGUpIHtcblxuICAgIHZhciB4ID0gc2hhcGUueCxcbiAgICAgICAgeSA9IHNoYXBlLnksXG4gICAgICAgIHdpZHRoID0gc2hhcGUud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcblxuICAgIHZhciBzaGFwZVBhdGggPSBbXG4gICAgICBbICdNJywgeCwgeSBdLFxuICAgICAgWyAnbCcsIHdpZHRoLCAwIF0sXG4gICAgICBbICdsJywgMCwgaGVpZ2h0IF0sXG4gICAgICBbICdsJywgLXdpZHRoLCAwIF0sXG4gICAgICBbICd6JyBdXG4gICAgXTtcblxuICAgIHJldHVybiBjb21wb25lbnRzVG9QYXRoKHNoYXBlUGF0aCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEZWZhdWx0UmVuZGVyZXIucHJvdG90eXBlLmdldENvbm5lY3Rpb25QYXRoID0gZnVuY3Rpb24gZ2V0Q29ubmVjdGlvblBhdGgoY29ubmVjdGlvbikge1xuICAgIHZhciB3YXlwb2ludHMgPSBjb25uZWN0aW9uLndheXBvaW50cztcblxuICAgIHZhciBpZHgsIHBvaW50LCBjb25uZWN0aW9uUGF0aCA9IFtdO1xuXG4gICAgZm9yIChpZHggPSAwOyAocG9pbnQgPSB3YXlwb2ludHNbaWR4XSk7IGlkeCsrKSB7XG5cbiAgICAgIC8vIHRha2UgaW52aXNpYmxlIGRvY2tpbmcgaW50byBhY2NvdW50XG4gICAgICAvLyB3aGVuIGNyZWF0aW5nIHRoZSBwYXRoXG4gICAgICBwb2ludCA9IHBvaW50Lm9yaWdpbmFsIHx8IHBvaW50O1xuXG4gICAgICBjb25uZWN0aW9uUGF0aC5wdXNoKFsgaWR4ID09PSAwID8gJ00nIDogJ0wnLCBwb2ludC54LCBwb2ludC55IF0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wb25lbnRzVG9QYXRoKGNvbm5lY3Rpb25QYXRoKTtcbiAgfTtcblxuICBEZWZhdWx0UmVuZGVyZXIuJGluamVjdCA9IFsgJ2V2ZW50QnVzJywgJ3N0eWxlcycgXTtcblxuICAvKipcbiAgICogQSBjb21wb25lbnQgdGhhdCBtYW5hZ2VzIHNoYXBlIHN0eWxlc1xuICAgKi9cbiAgZnVuY3Rpb24gU3R5bGVzKCkge1xuXG4gICAgdmFyIGRlZmF1bHRUcmFpdHMgPSB7XG5cbiAgICAgICduby1maWxsJzoge1xuICAgICAgICBmaWxsOiAnbm9uZSdcbiAgICAgIH0sXG4gICAgICAnbm8tYm9yZGVyJzoge1xuICAgICAgICBzdHJva2VPcGFjaXR5OiAwLjBcbiAgICAgIH0sXG4gICAgICAnbm8tZXZlbnRzJzoge1xuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIGEgc3R5bGUgZGVmaW5pdGlvbiBmcm9tIGEgY2xhc3NOYW1lLCBhIGxpc3Qgb2YgdHJhaXRzIGFuZCBhbiBvYmplY3RcbiAgICAgKiBvZiBhZGRpdGlvbmFsIGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW3RyYWl0c11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2FkZGl0aW9uYWxBdHRyc11cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIHN0eWxlIGRlZmluaXRpb25cbiAgICAgKi9cbiAgICB0aGlzLmNscyA9IGZ1bmN0aW9uKGNsYXNzTmFtZSwgdHJhaXRzLCBhZGRpdGlvbmFsQXR0cnMpIHtcbiAgICAgIHZhciBhdHRycyA9IHRoaXMuc3R5bGUodHJhaXRzLCBhZGRpdGlvbmFsQXR0cnMpO1xuXG4gICAgICByZXR1cm4gYXNzaWduJDEoYXR0cnMsIHsgJ2NsYXNzJzogY2xhc3NOYW1lIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYSBzdHlsZSBkZWZpbml0aW9uIGZyb20gYSBsaXN0IG9mIHRyYWl0cyBhbmQgYW4gb2JqZWN0IG9mIGFkZGl0aW9uYWxcbiAgICAgKiBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW3RyYWl0c11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWRkaXRpb25hbEF0dHJzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBzdHlsZSBkZWZpbml0aW9uXG4gICAgICovXG4gICAgdGhpcy5zdHlsZSA9IGZ1bmN0aW9uKHRyYWl0cywgYWRkaXRpb25hbEF0dHJzKSB7XG5cbiAgICAgIGlmICghaXNBcnJheSQyKHRyYWl0cykgJiYgIWFkZGl0aW9uYWxBdHRycykge1xuICAgICAgICBhZGRpdGlvbmFsQXR0cnMgPSB0cmFpdHM7XG4gICAgICAgIHRyYWl0cyA9IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0cnMgPSByZWR1Y2UodHJhaXRzLCBmdW5jdGlvbihhdHRycywgdCkge1xuICAgICAgICByZXR1cm4gYXNzaWduJDEoYXR0cnMsIGRlZmF1bHRUcmFpdHNbdF0gfHwge30pO1xuICAgICAgfSwge30pO1xuXG4gICAgICByZXR1cm4gYWRkaXRpb25hbEF0dHJzID8gYXNzaWduJDEoYXR0cnMsIGFkZGl0aW9uYWxBdHRycykgOiBhdHRycztcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhIHN0eWxlIGRlZmluaXRpb24gZnJvbSBhIGxpc3Qgb2YgdHJhaXRzIGFuZCBhbiBvYmplY3Qgb2ZcbiAgICAgKiBhZGRpdGlvbmFsIGF0dHJpYnV0ZXMsIHdpdGggY3VzdG9tIHN0eWxlIGRlZmluaXRpb24gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGN1c3RvbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFt0cmFpdHNdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRTdHlsZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIHN0eWxlIGRlZmluaXRpb25cbiAgICAgKi9cbiAgICB0aGlzLmNvbXB1dGVTdHlsZSA9IGZ1bmN0aW9uKGN1c3RvbSwgdHJhaXRzLCBkZWZhdWx0U3R5bGVzKSB7XG4gICAgICBpZiAoIWlzQXJyYXkkMih0cmFpdHMpKSB7XG4gICAgICAgIGRlZmF1bHRTdHlsZXMgPSB0cmFpdHM7XG4gICAgICAgIHRyYWl0cyA9IFtdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zdHlsZSh0cmFpdHMgfHwgW10sIGFzc2lnbiQxKHt9LCBkZWZhdWx0U3R5bGVzLCBjdXN0b20gfHwge30pKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsgaW1wb3J0KCdkaWRpJykuTW9kdWxlRGVjbGFyYXRpb24gfVxuICAgKi9cbiAgdmFyIERyYXdNb2R1bGUgPSB7XG4gICAgX19pbml0X186IFsgJ2RlZmF1bHRSZW5kZXJlcicgXSxcbiAgICBkZWZhdWx0UmVuZGVyZXI6IFsgJ3R5cGUnLCBEZWZhdWx0UmVuZGVyZXIgXSxcbiAgICBzdHlsZXM6IFsgJ3R5cGUnLCBTdHlsZXMgXVxuICB9O1xuXG4gIC8qKlxuICAgKiBGYWlsc2FmZSByZW1vdmUgYW4gZWxlbWVudCBmcm9tIGEgY29sbGVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IFtjb2xsZWN0aW9uXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2VsZW1lbnRdXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gdGhlIHByZXZpb3VzIGluZGV4IG9mIHRoZSBlbGVtZW50XG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmUoY29sbGVjdGlvbiwgZWxlbWVudCkge1xuXG4gICAgaWYgKCFjb2xsZWN0aW9uIHx8ICFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgdmFyIGlkeCA9IGNvbGxlY3Rpb24uaW5kZXhPZihlbGVtZW50KTtcblxuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICBjb2xsZWN0aW9uLnNwbGljZShpZHgsIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBpZHg7XG4gIH1cblxuICAvKipcbiAgICogRmFpbCBzYXZlIGFkZCBhbiBlbGVtZW50IHRvIHRoZSBnaXZlbiBjb25uZWN0aW9uLCBlbnN1cmluZ1xuICAgKiBpdCBkb2VzIG5vdCB5ZXQgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gY29sbGVjdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2lkeF1cbiAgICovXG4gIGZ1bmN0aW9uIGFkZChjb2xsZWN0aW9uLCBlbGVtZW50LCBpZHgpIHtcblxuICAgIGlmICghY29sbGVjdGlvbiB8fCAhZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaWR4ICE9PSAnbnVtYmVyJykge1xuICAgICAgaWR4ID0gLTE7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRJZHggPSBjb2xsZWN0aW9uLmluZGV4T2YoZWxlbWVudCk7XG5cbiAgICBpZiAoY3VycmVudElkeCAhPT0gLTEpIHtcblxuICAgICAgaWYgKGN1cnJlbnRJZHggPT09IGlkeCkge1xuXG4gICAgICAgIC8vIG5vdGhpbmcgdG8gZG8sIHBvc2l0aW9uIGhhcyBub3QgY2hhbmdlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XG5cbiAgICAgICAgICAvLyByZW1vdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgICAgY29sbGVjdGlvbi5zcGxpY2UoY3VycmVudElkeCwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAvLyBhbHJlYWR5IGV4aXN0cyBpbiBjb2xsZWN0aW9uXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlkeCAhPT0gLTEpIHtcblxuICAgICAgLy8gaW5zZXJ0IGF0IHNwZWNpZmllZCBwb3NpdGlvblxuICAgICAgY29sbGVjdGlvbi5zcGxpY2UoaWR4LCAwLCBlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBwdXNoIHRvIGVuZFxuICAgICAgY29sbGVjdGlvbi5wdXNoKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuL1R5cGVzJykuQ29ubmVjdGlvbkxpa2V9IENvbm5lY3Rpb25MaWtlXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vVHlwZXMnKS5Sb290TGlrZX0gUm9vdExpa2VcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi9UeXBlcycpLlBhcmVudExpa2UgfSBQYXJlbnRMaWtlXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vVHlwZXMnKS5TaGFwZUxpa2V9IFNoYXBlTGlrZVxuICAgKlxuICAgKiBAdHlwZWRlZiB7IHtcbiAgICogICBjb250YWluZXI/OiBIVE1MRWxlbWVudDtcbiAgICogICBkZWZlclVwZGF0ZT86IGJvb2xlYW47XG4gICAqICAgd2lkdGg/OiBudW1iZXI7XG4gICAqICAgaGVpZ2h0PzogbnVtYmVyO1xuICAgKiAgIGF1dG9Gb2N1cz86IGJvb2xlYW47XG4gICAqIH0gfSBDYW52YXNDb25maWdcbiAgICogQHR5cGVkZWYgeyB7XG4gICAqICAgZ3JvdXA6IFNWR0VsZW1lbnQ7XG4gICAqICAgaW5kZXg6IG51bWJlcjtcbiAgICogICB2aXNpYmxlOiBib29sZWFuO1xuICAgKiB9IH0gQ2FudmFzTGF5ZXJcbiAgICogQHR5cGVkZWYgeyB7XG4gICAqICAgW2tleTogc3RyaW5nXTogQ2FudmFzTGF5ZXI7XG4gICAqIH0gfSBDYW52YXNMYXllcnNcbiAgICogQHR5cGVkZWYgeyB7XG4gICAqICAgcm9vdEVsZW1lbnQ6IFNoYXBlTGlrZTtcbiAgICogICBsYXllcjogQ2FudmFzTGF5ZXI7XG4gICAqIH0gfSBDYW52YXNQbGFuZVxuICAgKiBAdHlwZWRlZiB7IHtcbiAgICogICBzY2FsZTogbnVtYmVyO1xuICAgKiAgIGlubmVyOiBSZWN0O1xuICAgKiAgIG91dGVyOiBEaW1lbnNpb25zO1xuICAgKiB9ICYgUmVjdCB9IENhbnZhc1ZpZXdib3hcbiAgICpcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi9FbGVtZW50UmVnaXN0cnknKS5kZWZhdWx0fSBFbGVtZW50UmVnaXN0cnlcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi9FdmVudEJ1cycpLmRlZmF1bHR9IEV2ZW50QnVzXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vR3JhcGhpY3NGYWN0b3J5JykuZGVmYXVsdH0gR3JhcGhpY3NGYWN0b3J5XG4gICAqXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3V0aWwvVHlwZXMnKS5EaW1lbnNpb25zfSBEaW1lbnNpb25zXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3V0aWwvVHlwZXMnKS5Qb2ludH0gUG9pbnRcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdXRpbC9UeXBlcycpLlJlY3R9IFJlY3RcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdXRpbC9UeXBlcycpLlJlY3RUUkJMfSBSZWN0VFJCTFxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi91dGlsL1R5cGVzJykuU2Nyb2xsRGVsdGF9IFNjcm9sbERlbHRhXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJvdW5kKG51bWJlciwgcmVzb2x1dGlvbikge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuc3VyZVB4KG51bWJlcikge1xuICAgIHJldHVybiBpc051bWJlcihudW1iZXIpID8gbnVtYmVyICsgJ3B4JyA6IG51bWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRSb290KGVsZW1lbnQpIHtcbiAgICB3aGlsZSAoZWxlbWVudC5wYXJlbnQpIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgSFRNTCBjb250YWluZXIgZWxlbWVudCBmb3IgYSBTVkcgZWxlbWVudCB3aXRoXG4gICAqIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzQ29uZmlnfSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSB0aGUgY29udGFpbmVyIGVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lcihvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gYXNzaWduJDEoe30sIHsgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScgfSwgb3B0aW9ucyk7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuXG4gICAgLy8gY3JlYXRlIGEgPGRpdj4gYXJvdW5kIHRoZSBzdmcgZWxlbWVudCB3aXRoIHRoZSByZXNwZWN0aXZlIHNpemVcbiAgICAvLyB0aGlzIHdheSB3ZSBjYW4gYWx3YXlzIGdldCB0aGUgY29ycmVjdCBjb250YWluZXIgc2l6ZVxuICAgIC8vICh0aGlzIGlzIGltcG9zc2libGUgZm9yIDxzdmc+IGVsZW1lbnRzIGF0IHRoZSBtb21lbnQpXG4gICAgY29uc3QgcGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcGFyZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZGpzLWNvbnRhaW5lciBkanMtcGFyZW50Jyk7XG5cbiAgICBhc3NpZ24ocGFyZW50LCB7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgIHdpZHRoOiBlbnN1cmVQeChvcHRpb25zLndpZHRoKSxcbiAgICAgIGhlaWdodDogZW5zdXJlUHgob3B0aW9ucy5oZWlnaHQpXG4gICAgfSk7XG5cbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQocGFyZW50KTtcblxuICAgIHJldHVybiBwYXJlbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVHcm91cChwYXJlbnQsIGNscywgY2hpbGRJbmRleCkge1xuICAgIGNvbnN0IGdyb3VwID0gY3JlYXRlJDEoJ2cnKTtcbiAgICBjbGFzc2VzJDEoZ3JvdXApLmFkZChjbHMpO1xuXG4gICAgY29uc3QgaW5kZXggPSBjaGlsZEluZGV4ICE9PSB1bmRlZmluZWQgPyBjaGlsZEluZGV4IDogcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoIC0gMTtcblxuICAgIC8vIG11c3QgZW5zdXJlIHNlY29uZCBhcmd1bWVudCBpcyBub2RlIG9yIF9udWxsX1xuICAgIC8vIGNmLiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS9pbnNlcnRCZWZvcmVcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGdyb3VwLCBwYXJlbnQuY2hpbGROb2Rlc1tpbmRleF0gfHwgbnVsbCk7XG5cbiAgICByZXR1cm4gZ3JvdXA7XG4gIH1cblxuICBjb25zdCBCQVNFX0xBWUVSID0gJ2Jhc2UnO1xuXG4gIC8vIHJlbmRlciBwbGFuZSBjb250ZW50cyBiZWhpbmQgdXRpbGl0eSBsYXllcnNcbiAgY29uc3QgUExBTkVfTEFZRVJfSU5ERVggPSAwO1xuICBjb25zdCBVVElMSVRZX0xBWUVSX0lOREVYID0gMTtcblxuXG4gIGNvbnN0IFJFUVVJUkVEX01PREVMX0FUVFJTID0ge1xuICAgIHNoYXBlOiBbICd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0JyBdLFxuICAgIGNvbm5lY3Rpb246IFsgJ3dheXBvaW50cycgXVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgbWFpbiBkcmF3aW5nIGNhbnZhcy5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAZW1pdHMgQ2FudmFzI2NhbnZhcy5pbml0XG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzQ29uZmlnfG51bGx9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICAgKiBAcGFyYW0ge0dyYXBoaWNzRmFjdG9yeX0gZ3JhcGhpY3NGYWN0b3J5XG4gICAqIEBwYXJhbSB7RWxlbWVudFJlZ2lzdHJ5fSBlbGVtZW50UmVnaXN0cnlcbiAgICovXG4gIGZ1bmN0aW9uIENhbnZhcyhjb25maWcsIGV2ZW50QnVzLCBncmFwaGljc0ZhY3RvcnksIGVsZW1lbnRSZWdpc3RyeSkge1xuICAgIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gICAgdGhpcy5fZWxlbWVudFJlZ2lzdHJ5ID0gZWxlbWVudFJlZ2lzdHJ5O1xuICAgIHRoaXMuX2dyYXBoaWNzRmFjdG9yeSA9IGdyYXBoaWNzRmFjdG9yeTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fcm9vdHNJZHggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NhbnZhc0xheWVyc31cbiAgICAgKi9cbiAgICB0aGlzLl9sYXllcnMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtDYW52YXNQbGFuZVtdfVxuICAgICAqL1xuICAgIHRoaXMuX3BsYW5lcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1Jvb3RMaWtlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fZm9jdXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdChjb25maWcgfHwge30pO1xuICB9XG5cbiAgQ2FudmFzLiRpbmplY3QgPSBbXG4gICAgJ2NvbmZpZy5jYW52YXMnLFxuICAgICdldmVudEJ1cycsXG4gICAgJ2dyYXBoaWNzRmFjdG9yeScsXG4gICAgJ2VsZW1lbnRSZWdpc3RyeSdcbiAgXTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIDxzdmc+IGVsZW1lbnQgdGhhdCBpcyB3cmFwcGVkIGludG8gYSA8ZGl2Pi5cbiAgICogVGhpcyB3YXkgd2UgYXJlIGFsd2F5cyBhYmxlIHRvIGNvcnJlY3RseSBmaWd1cmUgb3V0IHRoZSBzaXplIG9mIHRoZSBzdmcgZWxlbWVudFxuICAgKiBieSBxdWVyeWluZyB0aGUgcGFyZW50IG5vZGUuXG5cbiAgICogKEl0IGlzIG5vdCBwb3NzaWJsZSB0byBnZXQgdGhlIHNpemUgb2YgYSBzdmcgZWxlbWVudCBjcm9zcyBicm93c2VyIEAgMjAxNC0wNC0wMSlcblxuICAgKiA8ZGl2IGNsYXNzPVwiZGpzLWNvbnRhaW5lclwiIHN0eWxlPVwid2lkdGg6IHtkZXNpcmVkLXdpZHRofSwgaGVpZ2h0OiB7ZGVzaXJlZC1oZWlnaHR9XCI+XG4gICAqICAgPHN2ZyB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCI+XG4gICAqICAgIC4uLlxuICAgKiAgIDwvc3ZnPlxuICAgKiA8L2Rpdj5cbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNDb25maWd9IGNvbmZpZ1xuICAgKi9cbiAgQ2FudmFzLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIGNvbnN0IGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXM7XG5cbiAgICAvLyBodG1sIGNvbnRhaW5lclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZUNvbnRhaW5lcihjb25maWcpO1xuXG4gICAgY29uc3Qgc3ZnID0gdGhpcy5fc3ZnID0gY3JlYXRlJDEoJ3N2ZycpO1xuXG4gICAgYXR0ciQxKHN2Zywge1xuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgfSk7XG5cbiAgICBhdHRyKHN2ZywgJ3RhYmluZGV4JywgMCk7XG5cbiAgICBjb25maWcuYXV0b0ZvY3VzICYmIGV2ZW50QnVzLm9uKCdlbGVtZW50LmhvdmVyJywgKCkgPT4ge1xuICAgICAgdGhpcy5yZXN0b3JlRm9jdXMoKTtcbiAgICB9KTtcblxuICAgIGV2ZW50QnVzLm9uKCdlbGVtZW50Lm1vdXNlZG93bicsIDUwMCwgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLmZvY3VzKCk7XG4gICAgfSk7XG5cbiAgICBzdmcuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsICgpID0+IHtcbiAgICAgIHRoaXMuX3NldEZvY3VzZWQodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBzdmcuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zZXRGb2N1c2VkKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGFwcGVuZChjb250YWluZXIsIHN2Zyk7XG5cbiAgICBjb25zdCB2aWV3cG9ydCA9IHRoaXMuX3ZpZXdwb3J0ID0gY3JlYXRlR3JvdXAoc3ZnLCAndmlld3BvcnQnKTtcblxuICAgIC8vIGRlYm91bmNlIGNhbnZhcy52aWV3Ym94LmNoYW5nZWQgZXZlbnRzIHdoZW4gZGVmZXJVcGRhdGUgaXMgc2V0XG4gICAgLy8gdG8gaGVscCB3aXRoIHBvdGVudGlhbCBwZXJmb3JtYW5jZSBpc3N1ZXNcbiAgICBpZiAoY29uZmlnLmRlZmVyVXBkYXRlKSB7XG4gICAgICB0aGlzLl92aWV3Ym94Q2hhbmdlZCA9IGRlYm91bmNlKGJpbmQkMih0aGlzLl92aWV3Ym94Q2hhbmdlZCwgdGhpcyksIDMwMCk7XG4gICAgfVxuXG4gICAgZXZlbnRCdXMub24oJ2RpYWdyYW0uaW5pdCcsICgpID0+IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBBbiBldmVudCBpbmRpY2F0aW5nIHRoYXQgdGhlIGNhbnZhcyBpcyByZWFkeSB0byBiZSBkcmF3biBvbi5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgQ2FudmFzXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IGNhbnZhcy5pbml0XG4gICAgICAgKlxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqIEBwcm9wZXJ0eSB7U1ZHRWxlbWVudH0gc3ZnIHRoZSBjcmVhdGVkIHN2ZyBlbGVtZW50XG4gICAgICAgKiBAcHJvcGVydHkge1NWR0VsZW1lbnR9IHZpZXdwb3J0IHRoZSBkaXJlY3QgcGFyZW50IG9mIGRpYWdyYW0gZWxlbWVudHMgYW5kIHNoYXBlc1xuICAgICAgICovXG4gICAgICBldmVudEJ1cy5maXJlKCdjYW52YXMuaW5pdCcsIHtcbiAgICAgICAgc3ZnOiBzdmcsXG4gICAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydFxuICAgICAgfSk7XG5cbiAgICB9KTtcblxuICAgIC8vIHJlc2V0IHZpZXdib3ggb24gc2hhcGUgY2hhbmdlcyB0b1xuICAgIC8vIHJlY29tcHV0ZSB0aGUgdmlld2JveFxuICAgIGV2ZW50QnVzLm9uKFtcbiAgICAgICdzaGFwZS5hZGRlZCcsXG4gICAgICAnY29ubmVjdGlvbi5hZGRlZCcsXG4gICAgICAnc2hhcGUucmVtb3ZlZCcsXG4gICAgICAnY29ubmVjdGlvbi5yZW1vdmVkJyxcbiAgICAgICdlbGVtZW50cy5jaGFuZ2VkJyxcbiAgICAgICdyb290LnNldCdcbiAgICBdLCAoKSA9PiB7XG4gICAgICBkZWxldGUgdGhpcy5fY2FjaGVkVmlld2JveDtcbiAgICB9KTtcblxuICAgIGV2ZW50QnVzLm9uKCdkaWFncmFtLmRlc3Ryb3knLCA1MDAsIHRoaXMuX2Rlc3Ryb3ksIHRoaXMpO1xuICAgIGV2ZW50QnVzLm9uKCdkaWFncmFtLmNsZWFyJywgNTAwLCB0aGlzLl9jbGVhciwgdGhpcyk7XG4gIH07XG5cbiAgQ2FudmFzLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2NhbnZhcy5kZXN0cm95Jywge1xuICAgICAgc3ZnOiB0aGlzLl9zdmcsXG4gICAgICB2aWV3cG9ydDogdGhpcy5fdmlld3BvcnRcbiAgICB9KTtcblxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX2NvbnRhaW5lci5wYXJlbnROb2RlO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuX3N2ZztcbiAgICBkZWxldGUgdGhpcy5fY29udGFpbmVyO1xuICAgIGRlbGV0ZSB0aGlzLl9sYXllcnM7XG4gICAgZGVsZXRlIHRoaXMuX3BsYW5lcztcbiAgICBkZWxldGUgdGhpcy5fcm9vdEVsZW1lbnQ7XG4gICAgZGVsZXRlIHRoaXMuX3ZpZXdwb3J0O1xuICB9O1xuXG4gIENhbnZhcy5wcm90b3R5cGUuX3NldEZvY3VzZWQgPSBmdW5jdGlvbihmb2N1c2VkKSB7XG5cbiAgICBpZiAoZm9jdXNlZCA9PSB0aGlzLl9mb2N1c2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZm9jdXNlZCA9IGZvY3VzZWQ7XG5cbiAgICB0aGlzLl9ldmVudEJ1cy5maXJlKCdjYW52YXMuZm9jdXMuY2hhbmdlZCcsIHsgZm9jdXNlZCB9KTtcbiAgfTtcblxuICBDYW52YXMucHJvdG90eXBlLl9jbGVhciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgY29uc3QgYWxsRWxlbWVudHMgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0QWxsKCk7XG5cbiAgICAvLyByZW1vdmUgYWxsIGVsZW1lbnRzXG4gICAgYWxsRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlKGVsZW1lbnQpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUm9vdEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW1vdmVFbGVtZW50KGVsZW1lbnQsIHR5cGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gcmVtb3ZlIGFsbCBwbGFuZXNcbiAgICB0aGlzLl9wbGFuZXMgPSBbXTtcbiAgICB0aGlzLl9yb290RWxlbWVudCA9IG51bGw7XG5cbiAgICAvLyBmb3JjZSByZWNvbXB1dGF0aW9uIG9mIHZpZXcgYm94XG4gICAgZGVsZXRlIHRoaXMuX2NhY2hlZFZpZXdib3g7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgZm9jdXMgb24gdGhlIGNhbnZhcyBTVkcgZWxlbWVudC5cbiAgICovXG4gIENhbnZhcy5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9zdmcuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuXG4gICAgdGhpcy5fc2V0Rm9jdXNlZCh0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgKiBTZXRzIGZvY3VzIG9uIHRoZSBjYW52YXMgU1ZHIGVsZW1lbnQgaWYgYGRvY3VtZW50LmJvZHlgIGlzIGN1cnJlbnRseSBmb2N1c2VkLlxuICAqL1xuICBDYW52YXMucHJvdG90eXBlLnJlc3RvcmVGb2N1cyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICB0aGlzLmZvY3VzKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2FudmFzIGlzIGZvY3VzZWQuXG4gICpcbiAgKiBAcmV0dXJuIHtib29sZWFufVxuICAqL1xuICBDYW52YXMucHJvdG90eXBlLmlzRm9jdXNlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9mb2N1c2VkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGxheWVyIG9uIHdoaWNoXG4gICAqIGFsbCBlbGVtZW50cyBhcmUgZHJhd24uXG4gICAqXG4gICAqIEByZXR1cm4ge1NWR0VsZW1lbnR9ICBUaGUgU1ZHIGVsZW1lbnQgb2YgdGhlIGxheWVyLlxuICAgKi9cbiAgQ2FudmFzLnByb3RvdHlwZS5nZXREZWZhdWx0TGF5ZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXllcihCQVNFX0xBWUVSLCBQTEFORV9MQVlFUl9JTkRFWCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsYXllciB0aGF0IGlzIHVzZWQgdG8gZHJhdyBlbGVtZW50c1xuICAgKiBvciBhbm5vdGF0aW9ucyBvbiBpdC5cbiAgICpcbiAgICogTm9uLWV4aXN0aW5nIGxheWVycyByZXRyaWV2ZWQgdGhyb3VnaCB0aGlzIG1ldGhvZFxuICAgKiB3aWxsIGJlIGNyZWF0ZWQuIER1cmluZyBjcmVhdGlvbiwgdGhlIG9wdGlvbmFsIGluZGV4XG4gICAqIG1heSBiZSB1c2VkIHRvIGNyZWF0ZSBsYXllcnMgYmVsb3cgb3IgYWJvdmUgZXhpc3RpbmcgbGF5ZXJzLlxuICAgKiBBIGxheWVyIHdpdGggYSBjZXJ0YWluIGluZGV4IGlzIGFsd2F5cyBjcmVhdGVkIGFib3ZlIGFsbFxuICAgKiBleGlzdGluZyBsYXllcnMgd2l0aCB0aGUgc2FtZSBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGxheWVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XSBUaGUgaW5kZXggb2YgdGhlIGxheWVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fSBUaGUgU1ZHIGVsZW1lbnQgb2YgdGhlIGxheWVyLlxuICAgKi9cbiAgQ2FudmFzLnByb3RvdHlwZS5nZXRMYXllciA9IGZ1bmN0aW9uKG5hbWUsIGluZGV4KSB7XG5cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBzcGVjaWZ5IGEgbmFtZScpO1xuICAgIH1cblxuICAgIGxldCBsYXllciA9IHRoaXMuX2xheWVyc1tuYW1lXTtcblxuICAgIGlmICghbGF5ZXIpIHtcbiAgICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW25hbWVdID0gdGhpcy5fY3JlYXRlTGF5ZXIobmFtZSwgaW5kZXgpO1xuICAgIH1cblxuICAgIC8vIHRocm93IGFuIGVycm9yIGlmIGxheWVyIGNyZWF0aW9uIC8gcmV0cml2YWwgaXNcbiAgICAvLyByZXF1ZXN0ZWQgb24gZGlmZmVyZW50IGluZGV4XG4gICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgbGF5ZXIuaW5kZXggIT09IGluZGV4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xheWVyIDwnICsgbmFtZSArICc+IGFscmVhZHkgY3JlYXRlZCBhdCBpbmRleCA8JyArIGluZGV4ICsgJz4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXIuZ3JvdXA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvciBhIGdpdmVuIGluZGV4LCByZXR1cm4gdGhlIG51bWJlciBvZiBsYXllcnMgdGhhdCBoYXZlIGEgaGlnaGVyIGluZGV4IGFuZFxuICAgKiBhcmUgdmlzaWJsZS5cbiAgICpcbiAgICogVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgbm9kZSBhIGxheWVyIHNob3VsZCBiZSBpbnNlcnRlZCBhdC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIENhbnZhcy5wcm90b3R5cGUuX2dldENoaWxkSW5kZXggPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHJldHVybiByZWR1Y2UodGhpcy5fbGF5ZXJzLCBmdW5jdGlvbihjaGlsZEluZGV4LCBsYXllcikge1xuICAgICAgaWYgKGxheWVyLnZpc2libGUgJiYgaW5kZXggPj0gbGF5ZXIuaW5kZXgpIHtcbiAgICAgICAgY2hpbGRJbmRleCsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hpbGRJbmRleDtcbiAgICB9LCAwKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGdpdmVuIGxheWVyIGFuZCByZXR1cm5zIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PTBdXG4gICAqXG4gICAqIEByZXR1cm4ge0NhbnZhc0xheWVyfVxuICAgKi9cbiAgQ2FudmFzLnByb3RvdHlwZS5fY3JlYXRlTGF5ZXIgPSBmdW5jdGlvbihuYW1lLCBpbmRleCkge1xuXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGluZGV4ID0gVVRJTElUWV9MQVlFUl9JTkRFWDtcbiAgICB9XG5cbiAgICBjb25zdCBjaGlsZEluZGV4ID0gdGhpcy5fZ2V0Q2hpbGRJbmRleChpbmRleCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ3JvdXA6IGNyZWF0ZUdyb3VwKHRoaXMuX3ZpZXdwb3J0LCAnbGF5ZXItJyArIG5hbWUsIGNoaWxkSW5kZXgpLFxuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgIH07XG4gIH07XG5cblxuICAvKipcbiAgICogU2hvd3MgYSBnaXZlbiBsYXllci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGxheWVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fSBUaGUgU1ZHIGVsZW1lbnQgb2YgdGhlIGxheWVyLlxuICAgKi9cbiAgQ2FudmFzLnByb3RvdHlwZS5zaG93TGF5ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG5cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBzcGVjaWZ5IGEgbmFtZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJzW25hbWVdO1xuXG4gICAgaWYgKCFsYXllcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYXllciA8JyArIG5hbWUgKyAnPiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHZpZXdwb3J0ID0gdGhpcy5fdmlld3BvcnQ7XG4gICAgY29uc3QgZ3JvdXAgPSBsYXllci5ncm91cDtcbiAgICBjb25zdCBpbmRleCA9IGxheWVyLmluZGV4O1xuXG4gICAgaWYgKGxheWVyLnZpc2libGUpIHtcbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG5cbiAgICBjb25zdCBjaGlsZEluZGV4ID0gdGhpcy5fZ2V0Q2hpbGRJbmRleChpbmRleCk7XG5cbiAgICB2aWV3cG9ydC5pbnNlcnRCZWZvcmUoZ3JvdXAsIHZpZXdwb3J0LmNoaWxkTm9kZXNbY2hpbGRJbmRleF0gfHwgbnVsbCk7XG5cbiAgICBsYXllci52aXNpYmxlID0gdHJ1ZTtcblxuICAgIHJldHVybiBncm91cDtcbiAgfTtcblxuICAvKipcbiAgICogSGlkZXMgYSBnaXZlbiBsYXllci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGxheWVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fSBUaGUgU1ZHIGVsZW1lbnQgb2YgdGhlIGxheWVyLlxuICAgKi9cbiAgQ2FudmFzLnByb3RvdHlwZS5oaWRlTGF5ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG5cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBzcGVjaWZ5IGEgbmFtZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJzW25hbWVdO1xuXG4gICAgaWYgKCFsYXllcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYXllciA8JyArIG5hbWUgKyAnPiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGdyb3VwID0gbGF5ZXIuZ3JvdXA7XG5cbiAgICBpZiAoIWxheWVyLnZpc2libGUpIHtcbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG5cbiAgICByZW1vdmUkMihncm91cCk7XG5cbiAgICBsYXllci52aXNpYmxlID0gZmFsc2U7XG5cbiAgICByZXR1cm4gZ3JvdXA7XG4gIH07XG5cblxuICBDYW52YXMucHJvdG90eXBlLl9yZW1vdmVMYXllciA9IGZ1bmN0aW9uKG5hbWUpIHtcblxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJzW25hbWVdO1xuXG4gICAgaWYgKGxheWVyKSB7XG4gICAgICBkZWxldGUgdGhpcy5fbGF5ZXJzW25hbWVdO1xuXG4gICAgICByZW1vdmUkMihsYXllci5ncm91cCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgYWN0aXZlIGxheWVyLiBDYW4gYmUgbnVsbC5cbiAgICpcbiAgICogQHJldHVybiB7Q2FudmFzTGF5ZXJ8bnVsbH0gVGhlIGFjdGl2ZSBsYXllciBvZiBgbnVsbGAuXG4gICAqL1xuICBDYW52YXMucHJvdG90eXBlLmdldEFjdGl2ZUxheWVyID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgcGxhbmUgPSB0aGlzLl9maW5kUGxhbmVGb3JSb290KHRoaXMuZ2V0Um9vdEVsZW1lbnQoKSk7XG5cbiAgICBpZiAoIXBsYW5lKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGxhbmUubGF5ZXI7XG4gIH07XG5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGxhbmUgd2hpY2ggY29udGFpbnMgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U2hhcGVMaWtlfENvbm5lY3Rpb25MaWtlfHN0cmluZ30gZWxlbWVudCBUaGUgZWxlbWVudCBvciBpdHMgSUQuXG4gICAqXG4gICAqIEByZXR1cm4ge1Jvb3RMaWtlfHVuZGVmaW5lZH0gVGhlIHJvb3Qgb2YgdGhlIGVsZW1lbnQuXG4gICAqL1xuICBDYW52YXMucHJvdG90eXBlLmZpbmRSb290ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0KGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBsYW5lID0gdGhpcy5fZmluZFBsYW5lRm9yUm9vdChcbiAgICAgIGZpbmRSb290KGVsZW1lbnQpXG4gICAgKSB8fCB7fTtcblxuICAgIHJldHVybiBwbGFuZS5yb290RWxlbWVudDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIGEgbGlzdCBvZiBhbGwgcm9vdCBlbGVtZW50cyBvbiB0aGUgZGlhZ3JhbS5cbiAgICpcbiAgICogQHJldHVybiB7KFJvb3RMaWtlKVtdfSBUaGUgbGlzdCBvZiByb290IGVsZW1lbnRzLlxuICAgKi9cbiAgQ2FudmFzLnByb3RvdHlwZS5nZXRSb290RWxlbWVudHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGxhbmVzLm1hcChmdW5jdGlvbihwbGFuZSkge1xuICAgICAgcmV0dXJuIHBsYW5lLnJvb3RFbGVtZW50O1xuICAgIH0pO1xuICB9O1xuXG4gIENhbnZhcy5wcm90b3R5cGUuX2ZpbmRQbGFuZUZvclJvb3QgPSBmdW5jdGlvbihyb290RWxlbWVudCkge1xuICAgIHJldHVybiBmaW5kKHRoaXMuX3BsYW5lcywgZnVuY3Rpb24ocGxhbmUpIHtcbiAgICAgIHJldHVybiBwbGFuZS5yb290RWxlbWVudCA9PT0gcm9vdEVsZW1lbnQ7XG4gICAgfSk7XG4gIH07XG5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaHRtbCBlbGVtZW50IHRoYXQgZW5jbG9zZXMgdGhlXG4gICAqIGRyYXdpbmcgY2FudmFzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gVGhlIEhUTUwgZWxlbWVudCBvZiB0aGUgY29udGFpbmVyLlxuICAgKi9cbiAgQ2FudmFzLnByb3RvdHlwZS5nZXRDb250YWluZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICB9O1xuXG5cbiAgLy8gbWFya2VycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgQ2FudmFzLnByb3RvdHlwZS5fdXBkYXRlTWFya2VyID0gZnVuY3Rpb24oZWxlbWVudCwgbWFya2VyLCBhZGQpIHtcbiAgICBsZXQgY29udGFpbmVyO1xuXG4gICAgaWYgKCFlbGVtZW50LmlkKSB7XG4gICAgICBlbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldChlbGVtZW50KTtcbiAgICB9XG5cbiAgICBlbGVtZW50Lm1hcmtlcnMgPSBlbGVtZW50Lm1hcmtlcnMgfHwgbmV3IFNldCgpO1xuXG4gICAgLy8gd2UgbmVlZCB0byBhY2Nlc3MgYWxsXG4gICAgY29udGFpbmVyID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5Ll9lbGVtZW50c1tlbGVtZW50LmlkXTtcblxuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yRWFjaCQxKFsgY29udGFpbmVyLmdmeCwgY29udGFpbmVyLnNlY29uZGFyeUdmeCBdLCBmdW5jdGlvbihnZngpIHtcbiAgICAgIGlmIChnZngpIHtcblxuICAgICAgICAvLyBpbnZva2UgZWl0aGVyIGFkZENsYXNzIG9yIHJlbW92ZUNsYXNzIGJhc2VkIG9uIG1vZGVcbiAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgIGVsZW1lbnQubWFya2Vycy5hZGQobWFya2VyKTtcbiAgICAgICAgICBjbGFzc2VzJDEoZ2Z4KS5hZGQobWFya2VyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50Lm1hcmtlcnMuZGVsZXRlKG1hcmtlcik7XG4gICAgICAgICAgY2xhc3NlcyQxKGdmeCkucmVtb3ZlKG1hcmtlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCBhIG1hcmtlciBoYXMgYmVlbiB1cGRhdGVkIGZvciBhbiBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAZXZlbnQgZWxlbWVudC5tYXJrZXIudXBkYXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0VsZW1lbnR9IGVsZW1lbnQgdGhlIHNoYXBlXG4gICAgICogQHByb3BlcnR5IHtTVkdFbGVtZW50fSBnZnggdGhlIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2hhcGVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbWFya2VyXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBhZGQgdHJ1ZSBpZiB0aGUgbWFya2VyIHdhcyBhZGRlZCwgZmFsc2UgaWYgaXQgZ290IHJlbW92ZWRcbiAgICAgKi9cbiAgICB0aGlzLl9ldmVudEJ1cy5maXJlKCdlbGVtZW50Lm1hcmtlci51cGRhdGUnLCB7IGVsZW1lbnQ6IGVsZW1lbnQsIGdmeDogY29udGFpbmVyLmdmeCwgbWFya2VyOiBtYXJrZXIsIGFkZDogISFhZGQgfSk7XG4gIH07XG5cblxuICAvKipcbiAgICogQWRkcyBhIG1hcmtlciB0byBhbiBlbGVtZW50IChiYXNpY2FsbHkgYSBjc3MgY2xhc3MpLlxuICAgKlxuICAgKiBGaXJlcyB0aGUgZWxlbWVudC5tYXJrZXIudXBkYXRlIGV2ZW50LCBtYWtpbmcgaXQgcG9zc2libGUgdG9cbiAgICogaW50ZWdyYXRlIGV4dGVuc2lvbiBpbnRvIHRoZSBtYXJrZXIgbGlmZS1jeWNsZSwgdG9vLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGNhbnZhcy5hZGRNYXJrZXIoJ2ZvbycsICdzb21lLW1hcmtlcicpO1xuICAgKlxuICAgKiBjb25zdCBmb29HZnggPSBjYW52YXMuZ2V0R3JhcGhpY3MoJ2ZvbycpO1xuICAgKlxuICAgKiBmb29HZng7IC8vIDxnIGNsYXNzPVwiLi4uIHNvbWUtbWFya2VyXCI+IC4uLiA8L2c+XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge1NoYXBlTGlrZXxDb25uZWN0aW9uTGlrZXxzdHJpbmd9IGVsZW1lbnQgVGhlIGVsZW1lbnQgb3IgaXRzIElELlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya2VyIFRoZSBtYXJrZXIuXG4gICAqL1xuICBDYW52YXMucHJvdG90eXBlLmFkZE1hcmtlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIG1hcmtlcikge1xuICAgIHRoaXMuX3VwZGF0ZU1hcmtlcihlbGVtZW50LCBtYXJrZXIsIHRydWUpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIG1hcmtlciBmcm9tIGFuIGVsZW1lbnQuXG4gICAqXG4gICAqIEZpcmVzIHRoZSBlbGVtZW50Lm1hcmtlci51cGRhdGUgZXZlbnQsIG1ha2luZyBpdCBwb3NzaWJsZSB0b1xuICAgKiBpbnRlZ3JhdGUgZXh0ZW5zaW9uIGludG8gdGhlIG1hcmtlciBsaWZlLWN5Y2xlLCB0b28uXG4gICAqXG4gICAqIEBwYXJhbSB7U2hhcGVMaWtlfENvbm5lY3Rpb25MaWtlfHN0cmluZ30gZWxlbWVudCBUaGUgZWxlbWVudCBvciBpdHMgSUQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrZXIgVGhlIG1hcmtlci5cbiAgICovXG4gIENhbnZhcy5wcm90b3R5cGUucmVtb3ZlTWFya2VyID0gZnVuY3Rpb24oZWxlbWVudCwgbWFya2VyKSB7XG4gICAgdGhpcy5fdXBkYXRlTWFya2VyKGVsZW1lbnQsIG1hcmtlciwgZmFsc2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIGFuIGVsZW1lbnQgaGFzIGEgZ2l2ZW4gbWFya2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge1NoYXBlTGlrZXxDb25uZWN0aW9uTGlrZXxzdHJpbmd9IGVsZW1lbnQgVGhlIGVsZW1lbnQgb3IgaXRzIElELlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya2VyIFRoZSBtYXJrZXIuXG4gICAqL1xuICBDYW52YXMucHJvdG90eXBlLmhhc01hcmtlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIG1hcmtlcikge1xuICAgIGlmICghZWxlbWVudC5pZCkge1xuICAgICAgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWdpc3RyeS5nZXQoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKCFlbGVtZW50Lm1hcmtlcnMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudC5tYXJrZXJzLmhhcyhtYXJrZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUb2dnbGVzIGEgbWFya2VyIG9uIGFuIGVsZW1lbnQuXG4gICAqXG4gICAqIEZpcmVzIHRoZSBlbGVtZW50Lm1hcmtlci51cGRhdGUgZXZlbnQsIG1ha2luZyBpdCBwb3NzaWJsZSB0b1xuICAgKiBpbnRlZ3JhdGUgZXh0ZW5zaW9uIGludG8gdGhlIG1hcmtlciBsaWZlLWN5Y2xlLCB0b28uXG4gICAqXG4gICAqIEBwYXJhbSB7U2hhcGVMaWtlfENvbm5lY3Rpb25MaWtlfHN0cmluZ30gZWxlbWVudCBUaGUgZWxlbWVudCBvciBpdHMgSUQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrZXIgVGhlIG1hcmtlci5cbiAgICovXG4gIENhbnZhcy5wcm90b3R5cGUudG9nZ2xlTWFya2VyID0gZnVuY3Rpb24oZWxlbWVudCwgbWFya2VyKSB7XG4gICAgaWYgKHRoaXMuaGFzTWFya2VyKGVsZW1lbnQsIG1hcmtlcikpIHtcbiAgICAgIHRoaXMucmVtb3ZlTWFya2VyKGVsZW1lbnQsIG1hcmtlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkTWFya2VyKGVsZW1lbnQsIG1hcmtlcik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJvb3QgZWxlbWVudC5cbiAgICpcbiAgICogU3VwcG9ydHMgdHdvIGRpZmZlcmVudCBtb2RlcyBmb3IgaGFuZGxpbmcgcm9vdCBlbGVtZW50czpcbiAgICpcbiAgICogMS4gaWYgbm8gcm9vdCBlbGVtZW50IGhhcyBiZWVuIGFkZGVkIGJlZm9yZSwgYW4gaW1wbGljaXQgcm9vdCB3aWxsIGJlIGFkZGVkXG4gICAqIGFuZCByZXR1cm5lZC4gVGhpcyBpcyB1c2VkIGluIGFwcGxpY2F0aW9ucyB0aGF0IGRvbid0IHJlcXVpcmUgZXhwbGljaXRcbiAgICogcm9vdCBlbGVtZW50cy5cbiAgICpcbiAgICogMi4gd2hlbiByb290IGVsZW1lbnRzIGhhdmUgYmVlbiBhZGRlZCBiZWZvcmUgY2FsbGluZyBgZ2V0Um9vdEVsZW1lbnRgLFxuICAgKiByb290IGVsZW1lbnRzIGNhbiBiZSBudWxsLiBUaGlzIGlzIHVzZWQgZm9yIGFwcGxpY2F0aW9ucyB0aGF0IHdhbnQgdG8gbWFuYWdlXG4gICAqIHJvb3QgZWxlbWVudHMgdGhlbXNlbHZlcy5cbiAgICpcbiAgICogQHJldHVybiB7Um9vdExpa2V9IFRoZSBjdXJyZW50IHJvb3QgZWxlbWVudC5cbiAgICovXG4gIENhbnZhcy5wcm90b3R5cGUuZ2V0Um9vdEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50O1xuXG4gICAgLy8gY2FuIHJldHVybiBudWxsIGlmIHJvb3QgZWxlbWVudHMgYXJlIHByZXNlbnQgYnV0IG5vbmUgd2FzIHNldCB5ZXRcbiAgICBpZiAocm9vdEVsZW1lbnQgfHwgdGhpcy5fcGxhbmVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJvb3RFbGVtZW50O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldFJvb3RFbGVtZW50KHRoaXMuYWRkUm9vdEVsZW1lbnQobnVsbCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGEgZ2l2ZW4gcm9vdCBlbGVtZW50IGFuZCByZXR1cm5zIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge1Jvb3RMaWtlfSBbcm9vdEVsZW1lbnRdIFRoZSByb290IGVsZW1lbnQgdG8gYmUgYWRkZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge1Jvb3RMaWtlfSBUaGUgYWRkZWQgcm9vdCBlbGVtZW50IG9yIGFuIGltcGxpY2l0IHJvb3QgZWxlbWVudC5cbiAgICovXG4gIENhbnZhcy5wcm90b3R5cGUuYWRkUm9vdEVsZW1lbnQgPSBmdW5jdGlvbihyb290RWxlbWVudCkge1xuICAgIGNvbnN0IGlkeCA9IHRoaXMuX3Jvb3RzSWR4Kys7XG5cbiAgICBpZiAoIXJvb3RFbGVtZW50KSB7XG4gICAgICByb290RWxlbWVudCA9IHtcbiAgICAgICAgaWQ6ICdfX2ltcGxpY2l0cm9vdF8nICsgaWR4LFxuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIGlzSW1wbGljaXQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgbGF5ZXJOYW1lID0gcm9vdEVsZW1lbnQubGF5ZXIgPSAncm9vdC0nICsgaWR4O1xuXG4gICAgdGhpcy5fZW5zdXJlVmFsaWQoJ3Jvb3QnLCByb290RWxlbWVudCk7XG5cbiAgICBjb25zdCBsYXllciA9IHRoaXMuZ2V0TGF5ZXIobGF5ZXJOYW1lLCBQTEFORV9MQVlFUl9JTkRFWCk7XG5cbiAgICB0aGlzLmhpZGVMYXllcihsYXllck5hbWUpO1xuXG4gICAgdGhpcy5fYWRkUm9vdChyb290RWxlbWVudCwgbGF5ZXIpO1xuXG4gICAgdGhpcy5fcGxhbmVzLnB1c2goe1xuICAgICAgcm9vdEVsZW1lbnQ6IHJvb3RFbGVtZW50LFxuICAgICAgbGF5ZXI6IGxheWVyXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcm9vdEVsZW1lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBnaXZlbiByb290IGVsZW1lbnQgYW5kIHJldHVybnMgaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7Um9vdExpa2V8c3RyaW5nfSByb290RWxlbWVudCBlbGVtZW50IG9yIGVsZW1lbnQgSURcbiAgICpcbiAgICogQHJldHVybiB7Um9vdExpa2V8dW5kZWZpbmVkfSByZW1vdmVkIGVsZW1lbnRcbiAgICovXG4gIENhbnZhcy5wcm90b3R5cGUucmVtb3ZlUm9vdEVsZW1lbnQgPSBmdW5jdGlvbihyb290RWxlbWVudCkge1xuXG4gICAgaWYgKHR5cGVvZiByb290RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJvb3RFbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldChyb290RWxlbWVudCk7XG4gICAgfVxuXG4gICAgY29uc3QgcGxhbmUgPSB0aGlzLl9maW5kUGxhbmVGb3JSb290KHJvb3RFbGVtZW50KTtcblxuICAgIGlmICghcGxhbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBob29rIHVwIGxpZmUtY3ljbGUgZXZlbnRzXG4gICAgdGhpcy5fcmVtb3ZlUm9vdChyb290RWxlbWVudCk7XG5cbiAgICAvLyBjbGVhbiB1cCBsYXllclxuICAgIHRoaXMuX3JlbW92ZUxheWVyKHJvb3RFbGVtZW50LmxheWVyKTtcblxuICAgIC8vIGNsZWFuIHVwIHBsYW5lXG4gICAgdGhpcy5fcGxhbmVzID0gdGhpcy5fcGxhbmVzLmZpbHRlcihmdW5jdGlvbihwbGFuZSkge1xuICAgICAgcmV0dXJuIHBsYW5lLnJvb3RFbGVtZW50ICE9PSByb290RWxlbWVudDtcbiAgICB9KTtcblxuICAgIC8vIGNsZWFuIHVwIGFjdGl2ZSByb290XG4gICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50ID09PSByb290RWxlbWVudCkge1xuICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByb290RWxlbWVudDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBTZXRzIGEgZ2l2ZW4gZWxlbWVudCBhcyB0aGUgbmV3IHJvb3QgZWxlbWVudCBmb3IgdGhlIGNhbnZhc1xuICAgKiBhbmQgcmV0dXJucyB0aGUgbmV3IHJvb3QgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSb290TGlrZX0gcm9vdEVsZW1lbnQgVGhlIHJvb3QgZWxlbWVudCB0byBiZSBzZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge1Jvb3RMaWtlfSBUaGUgc2V0IHJvb3QgZWxlbWVudC5cbiAgICovXG4gIENhbnZhcy5wcm90b3R5cGUuc2V0Um9vdEVsZW1lbnQgPSBmdW5jdGlvbihyb290RWxlbWVudCkge1xuXG4gICAgaWYgKHJvb3RFbGVtZW50ID09PSB0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgcmV0dXJuIHJvb3RFbGVtZW50O1xuICAgIH1cblxuICAgIGxldCBwbGFuZTtcblxuICAgIGlmICghcm9vdEVsZW1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncm9vdEVsZW1lbnQgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBwbGFuZSA9IHRoaXMuX2ZpbmRQbGFuZUZvclJvb3Qocm9vdEVsZW1lbnQpO1xuXG4gICAgLy8gZ2l2ZSBzZXQgYWRkIHNlbWFudGljcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICBpZiAoIXBsYW5lKSB7XG4gICAgICByb290RWxlbWVudCA9IHRoaXMuYWRkUm9vdEVsZW1lbnQocm9vdEVsZW1lbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX3NldFJvb3Qocm9vdEVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIHJvb3RFbGVtZW50O1xuICB9O1xuXG5cbiAgQ2FudmFzLnByb3RvdHlwZS5fcmVtb3ZlUm9vdCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBjb25zdCBlbGVtZW50UmVnaXN0cnkgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnksXG4gICAgICAgICAgZXZlbnRCdXMgPSB0aGlzLl9ldmVudEJ1cztcblxuICAgIC8vIHNpbXVsYXRlIGVsZW1lbnQgcmVtb3ZlIGV2ZW50IHNlcXVlbmNlXG4gICAgZXZlbnRCdXMuZmlyZSgncm9vdC5yZW1vdmUnLCB7IGVsZW1lbnQ6IGVsZW1lbnQgfSk7XG4gICAgZXZlbnRCdXMuZmlyZSgncm9vdC5yZW1vdmVkJywgeyBlbGVtZW50OiBlbGVtZW50IH0pO1xuXG4gICAgZWxlbWVudFJlZ2lzdHJ5LnJlbW92ZShlbGVtZW50KTtcbiAgfTtcblxuXG4gIENhbnZhcy5wcm90b3R5cGUuX2FkZFJvb3QgPSBmdW5jdGlvbihlbGVtZW50LCBnZngpIHtcbiAgICBjb25zdCBlbGVtZW50UmVnaXN0cnkgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnksXG4gICAgICAgICAgZXZlbnRCdXMgPSB0aGlzLl9ldmVudEJ1cztcblxuICAgIC8vIHJlc2VtYmxlIGVsZW1lbnQgYWRkIGV2ZW50IHNlcXVlbmNlXG4gICAgZXZlbnRCdXMuZmlyZSgncm9vdC5hZGQnLCB7IGVsZW1lbnQ6IGVsZW1lbnQgfSk7XG5cbiAgICBlbGVtZW50UmVnaXN0cnkuYWRkKGVsZW1lbnQsIGdmeCk7XG5cbiAgICBldmVudEJ1cy5maXJlKCdyb290LmFkZGVkJywgeyBlbGVtZW50OiBlbGVtZW50LCBnZng6IGdmeCB9KTtcbiAgfTtcblxuXG4gIENhbnZhcy5wcm90b3R5cGUuX3NldFJvb3QgPSBmdW5jdGlvbihyb290RWxlbWVudCwgbGF5ZXIpIHtcblxuICAgIGNvbnN0IGN1cnJlbnRSb290ID0gdGhpcy5fcm9vdEVsZW1lbnQ7XG5cbiAgICBpZiAoY3VycmVudFJvb3QpIHtcblxuICAgICAgLy8gdW4tYXNzb2NpYXRlIHByZXZpb3VzIHJvb3QgZWxlbWVudCA8c3ZnPlxuICAgICAgdGhpcy5fZWxlbWVudFJlZ2lzdHJ5LnVwZGF0ZUdyYXBoaWNzKGN1cnJlbnRSb290LCBudWxsLCB0cnVlKTtcblxuICAgICAgLy8gaGlkZSBwcmV2aW91cyBsYXllclxuICAgICAgdGhpcy5oaWRlTGF5ZXIoY3VycmVudFJvb3QubGF5ZXIpO1xuICAgIH1cblxuICAgIGlmIChyb290RWxlbWVudCkge1xuXG4gICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgIGxheWVyID0gdGhpcy5fZmluZFBsYW5lRm9yUm9vdChyb290RWxlbWVudCkubGF5ZXI7XG4gICAgICB9XG5cbiAgICAgIC8vIGFzc29jaWF0ZSBlbGVtZW50IHdpdGggPHN2Zz5cbiAgICAgIHRoaXMuX2VsZW1lbnRSZWdpc3RyeS51cGRhdGVHcmFwaGljcyhyb290RWxlbWVudCwgdGhpcy5fc3ZnLCB0cnVlKTtcblxuICAgICAgLy8gc2hvdyByb290IGxheWVyXG4gICAgICB0aGlzLnNob3dMYXllcihyb290RWxlbWVudC5sYXllcik7XG4gICAgfVxuXG4gICAgdGhpcy5fcm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcblxuICAgIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ3Jvb3Quc2V0JywgeyBlbGVtZW50OiByb290RWxlbWVudCB9KTtcbiAgfTtcblxuICBDYW52YXMucHJvdG90eXBlLl9lbnN1cmVWYWxpZCA9IGZ1bmN0aW9uKHR5cGUsIGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQuaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZWxlbWVudCBtdXN0IGhhdmUgYW4gaWQnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZWxlbWVudFJlZ2lzdHJ5LmdldChlbGVtZW50LmlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbGVtZW50IDwnICsgZWxlbWVudC5pZCArICc+IGFscmVhZHkgZXhpc3RzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWlyZWRBdHRycyA9IFJFUVVJUkVEX01PREVMX0FUVFJTW3R5cGVdO1xuXG4gICAgY29uc3QgdmFsaWQgPSBldmVyeShyZXF1aXJlZEF0dHJzLCBmdW5jdGlvbihhdHRyKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGVsZW1lbnRbYXR0cl0gIT09ICd1bmRlZmluZWQnO1xuICAgIH0pO1xuXG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnbXVzdCBzdXBwbHkgeyAnICsgcmVxdWlyZWRBdHRycy5qb2luKCcsICcpICsgJyB9IHdpdGggJyArIHR5cGUpO1xuICAgIH1cbiAgfTtcblxuICBDYW52YXMucHJvdG90eXBlLl9zZXRQYXJlbnQgPSBmdW5jdGlvbihlbGVtZW50LCBwYXJlbnQsIHBhcmVudEluZGV4KSB7XG4gICAgYWRkKHBhcmVudC5jaGlsZHJlbiwgZWxlbWVudCwgcGFyZW50SW5kZXgpO1xuICAgIGVsZW1lbnQucGFyZW50ID0gcGFyZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGVsZW1lbnQgdG8gdGhlIGNhbnZhcy5cbiAgICpcbiAgICogVGhpcyB3aXJlcyB0aGUgcGFyZW50IDwtPiBjaGlsZCByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGUgZWxlbWVudCBhbmRcbiAgICogYSBleHBsaWNpdGx5IHNwZWNpZmllZCBwYXJlbnQgb3IgYW4gaW1wbGljaXQgcm9vdCBlbGVtZW50LlxuICAgKlxuICAgKiBEdXJpbmcgYWRkIGl0IGVtaXRzIHRoZSBldmVudHNcbiAgICpcbiAgICogICogPHt0eXBlfS5hZGQ+IChlbGVtZW50LCBwYXJlbnQpXG4gICAqICAqIDx7dHlwZX0uYWRkZWQ+IChlbGVtZW50LCBnZngpXG4gICAqXG4gICAqIEV4dGVuc2lvbnMgbWF5IGhvb2sgaW50byB0aGVzZSBldmVudHMgdG8gcGVyZm9ybSB0aGVpciBtYWdpYy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtDb25uZWN0aW9uTGlrZXxTaGFwZUxpa2V9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTaGFwZUxpa2V9IFtwYXJlbnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyZW50SW5kZXhdXG4gICAqXG4gICAqIEByZXR1cm4ge0Nvbm5lY3Rpb25MaWtlfFNoYXBlTGlrZX0gVGhlIGFkZGVkIGVsZW1lbnQuXG4gICAqL1xuICBDYW52YXMucHJvdG90eXBlLl9hZGRFbGVtZW50ID0gZnVuY3Rpb24odHlwZSwgZWxlbWVudCwgcGFyZW50LCBwYXJlbnRJbmRleCkge1xuXG4gICAgcGFyZW50ID0gcGFyZW50IHx8IHRoaXMuZ2V0Um9vdEVsZW1lbnQoKTtcblxuICAgIGNvbnN0IGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXMsXG4gICAgICAgICAgZ3JhcGhpY3NGYWN0b3J5ID0gdGhpcy5fZ3JhcGhpY3NGYWN0b3J5O1xuXG4gICAgdGhpcy5fZW5zdXJlVmFsaWQodHlwZSwgZWxlbWVudCk7XG5cbiAgICBldmVudEJ1cy5maXJlKHR5cGUgKyAnLmFkZCcsIHsgZWxlbWVudDogZWxlbWVudCwgcGFyZW50OiBwYXJlbnQgfSk7XG5cbiAgICB0aGlzLl9zZXRQYXJlbnQoZWxlbWVudCwgcGFyZW50LCBwYXJlbnRJbmRleCk7XG5cbiAgICAvLyBjcmVhdGUgZ3JhcGhpY3NcbiAgICBjb25zdCBnZnggPSBncmFwaGljc0ZhY3RvcnkuY3JlYXRlKHR5cGUsIGVsZW1lbnQsIHBhcmVudEluZGV4KTtcblxuICAgIHRoaXMuX2VsZW1lbnRSZWdpc3RyeS5hZGQoZWxlbWVudCwgZ2Z4KTtcblxuICAgIC8vIHVwZGF0ZSBpdHMgdmlzdWFsXG4gICAgZ3JhcGhpY3NGYWN0b3J5LnVwZGF0ZSh0eXBlLCBlbGVtZW50LCBnZngpO1xuXG4gICAgZXZlbnRCdXMuZmlyZSh0eXBlICsgJy5hZGRlZCcsIHsgZWxlbWVudDogZWxlbWVudCwgZ2Z4OiBnZnggfSk7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBhIHNoYXBlIHRvIHRoZSBjYW52YXMuXG4gICAqXG4gICAqIEBwYXJhbSB7U2hhcGVMaWtlfSBzaGFwZSBUaGUgc2hhcGUgdG8gYmUgYWRkZWRcbiAgICogQHBhcmFtIHtQYXJlbnRMaWtlfSBbcGFyZW50XSBUaGUgc2hhcGUncyBwYXJlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyZW50SW5kZXhdIFRoZSBpbmRleCBhdCB3aGljaCB0byBhZGQgdGhlIHNoYXBlIHRvIHRoZSBwYXJlbnQncyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHJldHVybiB7U2hhcGVMaWtlfSBUaGUgYWRkZWQgc2hhcGUuXG4gICAqL1xuICBDYW52YXMucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24oc2hhcGUsIHBhcmVudCwgcGFyZW50SW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkRWxlbWVudCgnc2hhcGUnLCBzaGFwZSwgcGFyZW50LCBwYXJlbnRJbmRleCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjb25uZWN0aW9uIHRvIHRoZSBjYW52YXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbkxpa2V9IGNvbm5lY3Rpb24gVGhlIGNvbm5lY3Rpb24gdG8gYmUgYWRkZWQuXG4gICAqIEBwYXJhbSB7UGFyZW50TGlrZX0gW3BhcmVudF0gVGhlIGNvbm5lY3Rpb24ncyBwYXJlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyZW50SW5kZXhdIFRoZSBpbmRleCBhdCB3aGljaCB0byBhZGQgdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHBhcmVudCdzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb25uZWN0aW9uTGlrZX0gVGhlIGFkZGVkIGNvbm5lY3Rpb24uXG4gICAqL1xuICBDYW52YXMucHJvdG90eXBlLmFkZENvbm5lY3Rpb24gPSBmdW5jdGlvbihjb25uZWN0aW9uLCBwYXJlbnQsIHBhcmVudEluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZEVsZW1lbnQoJ2Nvbm5lY3Rpb24nLCBjb25uZWN0aW9uLCBwYXJlbnQsIHBhcmVudEluZGV4KTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCByZW1vdmUgZWxlbWVudFxuICAgKi9cbiAgQ2FudmFzLnByb3RvdHlwZS5fcmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUpIHtcblxuICAgIGNvbnN0IGVsZW1lbnRSZWdpc3RyeSA9IHRoaXMuX2VsZW1lbnRSZWdpc3RyeSxcbiAgICAgICAgICBncmFwaGljc0ZhY3RvcnkgPSB0aGlzLl9ncmFwaGljc0ZhY3RvcnksXG4gICAgICAgICAgZXZlbnRCdXMgPSB0aGlzLl9ldmVudEJ1cztcblxuICAgIGVsZW1lbnQgPSBlbGVtZW50UmVnaXN0cnkuZ2V0KGVsZW1lbnQuaWQgfHwgZWxlbWVudCk7XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcblxuICAgICAgLy8gZWxlbWVudCB3YXMgcmVtb3ZlZCBhbHJlYWR5XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnRCdXMuZmlyZSh0eXBlICsgJy5yZW1vdmUnLCB7IGVsZW1lbnQ6IGVsZW1lbnQgfSk7XG5cbiAgICBncmFwaGljc0ZhY3RvcnkucmVtb3ZlKGVsZW1lbnQpO1xuXG4gICAgLy8gdW5zZXQgcGFyZW50IDwtPiBjaGlsZCByZWxhdGlvbnNoaXBcbiAgICByZW1vdmUoZWxlbWVudC5wYXJlbnQgJiYgZWxlbWVudC5wYXJlbnQuY2hpbGRyZW4sIGVsZW1lbnQpO1xuICAgIGVsZW1lbnQucGFyZW50ID0gbnVsbDtcblxuICAgIGV2ZW50QnVzLmZpcmUodHlwZSArICcucmVtb3ZlZCcsIHsgZWxlbWVudDogZWxlbWVudCB9KTtcblxuICAgIGVsZW1lbnRSZWdpc3RyeS5yZW1vdmUoZWxlbWVudCk7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgc2hhcGUgZnJvbSB0aGUgY2FudmFzLlxuICAgKlxuICAgKiBAZmlyZXMgU2hhcGVSZW1vdmVFdmVudFxuICAgKiBAZmlyZXMgU2hhcGVSZW1vdmVkRXZlbnRcbiAgICpcbiAgICogQHBhcmFtIHtTaGFwZUxpa2V8c3RyaW5nfSBzaGFwZSBUaGUgc2hhcGUgb3IgaXRzIElELlxuICAgKlxuICAgKiBAcmV0dXJuIHtTaGFwZUxpa2V9IFRoZSByZW1vdmVkIHNoYXBlLlxuICAgKi9cbiAgQ2FudmFzLnByb3RvdHlwZS5yZW1vdmVTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlKSB7XG5cbiAgICAvKipcbiAgICAgKiBBbiBldmVudCBpbmRpY2F0aW5nIHRoYXQgYSBzaGFwZSBpcyBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gdGhlIGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBDYW52YXNcbiAgICAgKlxuICAgICAqIEBldmVudCBTaGFwZVJlbW92ZUV2ZW50XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge1NoYXBlTGlrZX0gZWxlbWVudCBUaGUgc2hhcGUuXG4gICAgICogQHByb3BlcnR5IHtTVkdFbGVtZW50fSBnZnggVGhlIGdyYXBoaWNhbCBlbGVtZW50LlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IGEgc2hhcGUgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgQ2FudmFzXG4gICAgICpcbiAgICAgKiBAZXZlbnQgU2hhcGVSZW1vdmVkRXZlbnRcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7U2hhcGVMaWtlfSBlbGVtZW50IFRoZSBzaGFwZS5cbiAgICAgKiBAcHJvcGVydHkge1NWR0VsZW1lbnR9IGdmeCBUaGUgZ3JhcGhpY2FsIGVsZW1lbnQuXG4gICAgICovXG4gICAgcmV0dXJuIHRoaXMuX3JlbW92ZUVsZW1lbnQoc2hhcGUsICdzaGFwZScpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjb25uZWN0aW9uIGZyb20gdGhlIGNhbnZhcy5cbiAgICpcbiAgICogQGZpcmVzIENvbm5lY3Rpb25SZW1vdmVFdmVudFxuICAgKiBAZmlyZXMgQ29ubmVjdGlvblJlbW92ZWRFdmVudFxuICAgKlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb25MaWtlfHN0cmluZ30gY29ubmVjdGlvbiBUaGUgY29ubmVjdGlvbiBvciBpdHMgSUQuXG4gICAqXG4gICAqIEByZXR1cm4ge0Nvbm5lY3Rpb25MaWtlfSBUaGUgcmVtb3ZlZCBjb25uZWN0aW9uLlxuICAgKi9cbiAgQ2FudmFzLnByb3RvdHlwZS5yZW1vdmVDb25uZWN0aW9uID0gZnVuY3Rpb24oY29ubmVjdGlvbikge1xuXG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IGEgY29ubmVjdGlvbiBpcyBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gdGhlIGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBDYW52YXNcbiAgICAgKlxuICAgICAqIEBldmVudCBDb25uZWN0aW9uUmVtb3ZlRXZlbnRcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7Q29ubmVjdGlvbkxpa2V9IGVsZW1lbnQgVGhlIGNvbm5lY3Rpb24uXG4gICAgICogQHByb3BlcnR5IHtTVkdFbGVtZW50fSBnZnggVGhlIGdyYXBoaWNhbCBlbGVtZW50LlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IGEgY29ubmVjdGlvbiBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBDYW52YXNcbiAgICAgKlxuICAgICAqIEBldmVudCBDb25uZWN0aW9uUmVtb3ZlZEV2ZW50XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0Nvbm5lY3Rpb25MaWtlfSBlbGVtZW50IFRoZSBjb25uZWN0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7U1ZHRWxlbWVudH0gZ2Z4IFRoZSBncmFwaGljYWwgZWxlbWVudC5cbiAgICAgKi9cbiAgICByZXR1cm4gdGhpcy5fcmVtb3ZlRWxlbWVudChjb25uZWN0aW9uLCAnY29ubmVjdGlvbicpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdyYXBoaWNhbCBlbGVtZW50IG9mIGFuIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U2hhcGVMaWtlfENvbm5lY3Rpb25MaWtlfHN0cmluZ30gZWxlbWVudCBUaGUgZWxlbWVudCBvciBpdHMgSUQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlY29uZGFyeT1mYWxzZV0gV2hldGhlciB0byByZXR1cm4gdGhlIHNlY29uZGFyeSBncmFwaGljYWwgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7U1ZHRWxlbWVudH0gVGhlIGdyYXBoaWNhbCBlbGVtZW50LlxuICAgKi9cbiAgQ2FudmFzLnByb3RvdHlwZS5nZXRHcmFwaGljcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIHNlY29uZGFyeSkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0R3JhcGhpY3MoZWxlbWVudCwgc2Vjb25kYXJ5KTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgdmlld2JveCB1cGRhdGUgdmlhIGEgZ2l2ZW4gY2hhbmdlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGFuZ2VGblxuICAgKi9cbiAgQ2FudmFzLnByb3RvdHlwZS5fY2hhbmdlVmlld2JveCA9IGZ1bmN0aW9uKGNoYW5nZUZuKSB7XG5cbiAgICAvLyBub3RpZnkgb3RoZXJzIG9mIHRoZSB1cGNvbWluZyB2aWV3Ym94IGNoYW5nZVxuICAgIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2NhbnZhcy52aWV3Ym94LmNoYW5naW5nJyk7XG5cbiAgICAvLyBwZXJmb3JtIGFjdHVhbCBjaGFuZ2VcbiAgICBjaGFuZ2VGbi5hcHBseSh0aGlzKTtcblxuICAgIC8vIHJlc2V0IHRoZSBjYWNoZWQgdmlld2JveCBzbyB0aGF0XG4gICAgLy8gYSBuZXcgZ2V0IG9wZXJhdGlvbiBvbiB2aWV3Ym94IG9yIHpvb21cbiAgICAvLyB0cmlnZ2VycyBhIHZpZXdib3ggcmUtY29tcHV0YXRpb25cbiAgICB0aGlzLl9jYWNoZWRWaWV3Ym94ID0gbnVsbDtcblxuICAgIC8vIG5vdGlmeSBvdGhlcnMgb2YgdGhlIGNoYW5nZTsgdGhpcyBzdGVwXG4gICAgLy8gbWF5IG9yIG1heSBub3QgYmUgZGVib3VuY2VkXG4gICAgdGhpcy5fdmlld2JveENoYW5nZWQoKTtcbiAgfTtcblxuICBDYW52YXMucHJvdG90eXBlLl92aWV3Ym94Q2hhbmdlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2NhbnZhcy52aWV3Ym94LmNoYW5nZWQnLCB7IHZpZXdib3g6IHRoaXMudmlld2JveCgpIH0pO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgdmlldyBib3ggb2YgdGhlIGNhbnZhcywgaS5lLiB0aGVcbiAgICogYXJlYSB0aGF0IGlzIGN1cnJlbnRseSBkaXNwbGF5ZWQuXG4gICAqXG4gICAqIFRoZSBnZXR0ZXIgbWF5IHJldHVybiBhIGNhY2hlZCB2aWV3Ym94IChpZiBpdCBpcyBjdXJyZW50bHlcbiAgICogY2hhbmdpbmcpLiBUbyBmb3JjZSBhIHJlY29tcHV0YXRpb24sIHBhc3MgYGZhbHNlYCBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogY2FudmFzLnZpZXdib3goeyB4OiAxMDAsIHk6IDEwMCwgd2lkdGg6IDUwMCwgaGVpZ2h0OiA1MDAgfSlcbiAgICpcbiAgICogLy8gc2V0cyB0aGUgdmlzaWJsZSBhcmVhIG9mIHRoZSBkaWFncmFtIHRvICgxMDB8MTAwKSAtPiAoNjAwfDEwMClcbiAgICogLy8gYW5kIGFuZCBzY2FsZXMgaXQgYWNjb3JkaW5nIHRvIHRoZSBkaWFncmFtIHdpZHRoXG4gICAqXG4gICAqIGNvbnN0IHZpZXdib3ggPSBjYW52YXMudmlld2JveCgpOyAvLyBwYXNzIGBmYWxzZWAgdG8gZm9yY2UgcmVjb21wdXRpbmcgdGhlIGJveC5cbiAgICpcbiAgICogY29uc29sZS5sb2codmlld2JveCk7XG4gICAqIC8vIHtcbiAgICogLy8gICBpbm5lcjogRGltZW5zaW9ucyxcbiAgICogLy8gICBvdXRlcjogRGltZW5zaW9ucyxcbiAgICogLy8gICBzY2FsZSxcbiAgICogLy8gICB4LCB5LFxuICAgKiAvLyAgIHdpZHRoLCBoZWlnaHRcbiAgICogLy8gfVxuICAgKlxuICAgKiAvLyBpZiB0aGUgY3VycmVudCBkaWFncmFtIGlzIHpvb21lZCBhbmQgc2Nyb2xsZWQsIHlvdSBtYXkgcmVzZXQgaXQgdG8gdGhlXG4gICAqIC8vIGRlZmF1bHQgem9vbSB2aWEgdGhpcyBtZXRob2QsIHRvbzpcbiAgICpcbiAgICogY29uc3Qgem9vbWVkQW5kU2Nyb2xsZWRWaWV3Ym94ID0gY2FudmFzLnZpZXdib3goKTtcbiAgICpcbiAgICogY2FudmFzLnZpZXdib3goe1xuICAgKiAgIHg6IDAsXG4gICAqICAgeTogMCxcbiAgICogICB3aWR0aDogem9vbWVkQW5kU2Nyb2xsZWRWaWV3Ym94Lm91dGVyLndpZHRoLFxuICAgKiAgIGhlaWdodDogem9vbWVkQW5kU2Nyb2xsZWRWaWV3Ym94Lm91dGVyLmhlaWdodFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7UmVjdH0gW2JveF0gVGhlIHZpZXdib3ggdG8gYmUgc2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtDYW52YXNWaWV3Ym94fSBUaGUgc2V0IHZpZXdib3guXG4gICAqL1xuICBDYW52YXMucHJvdG90eXBlLnZpZXdib3ggPSBmdW5jdGlvbihib3gpIHtcblxuICAgIGlmIChib3ggPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9jYWNoZWRWaWV3Ym94KSB7XG4gICAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKHRoaXMuX2NhY2hlZFZpZXdib3gpO1xuICAgIH1cblxuICAgIGNvbnN0IHZpZXdwb3J0ID0gdGhpcy5fdmlld3BvcnQsXG4gICAgICAgICAgb3V0ZXJCb3ggPSB0aGlzLmdldFNpemUoKTtcbiAgICBsZXQgaW5uZXJCb3gsXG4gICAgICAgIG1hdHJpeCxcbiAgICAgICAgYWN0aXZlTGF5ZXIsXG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgc2NhbGUsXG4gICAgICAgIHgsIHk7XG5cbiAgICBpZiAoIWJveCkge1xuXG4gICAgICAvLyBjb21wdXRlIHRoZSBpbm5lciBib3ggYmFzZWQgb24gdGhlXG4gICAgICAvLyBkaWFncmFtcyBhY3RpdmUgbGF5ZXIuIFRoaXMgYWxsb3dzIHVzIHRvIGV4Y2x1ZGVcbiAgICAgIC8vIGV4dGVybmFsIGNvbXBvbmVudHMsIHN1Y2ggYXMgb3ZlcmxheXNcblxuICAgICAgYWN0aXZlTGF5ZXIgPSB0aGlzLl9yb290RWxlbWVudCA/IHRoaXMuZ2V0QWN0aXZlTGF5ZXIoKSA6IG51bGw7XG4gICAgICBpbm5lckJveCA9IGFjdGl2ZUxheWVyICYmIGFjdGl2ZUxheWVyLmdldEJCb3goKSB8fCB7fTtcblxuICAgICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtJDEodmlld3BvcnQpO1xuICAgICAgbWF0cml4ID0gdHJhbnNmb3JtID8gdHJhbnNmb3JtLm1hdHJpeCA6IGNyZWF0ZU1hdHJpeCgpO1xuICAgICAgc2NhbGUgPSByb3VuZChtYXRyaXguYSwgMTAwMCk7XG5cbiAgICAgIHggPSByb3VuZCgtbWF0cml4LmUgfHwgMCwgMTAwMCk7XG4gICAgICB5ID0gcm91bmQoLW1hdHJpeC5mIHx8IDAsIDEwMDApO1xuXG4gICAgICBib3ggPSB0aGlzLl9jYWNoZWRWaWV3Ym94ID0ge1xuICAgICAgICB4OiB4ID8geCAvIHNjYWxlIDogMCxcbiAgICAgICAgeTogeSA/IHkgLyBzY2FsZSA6IDAsXG4gICAgICAgIHdpZHRoOiBvdXRlckJveC53aWR0aCAvIHNjYWxlLFxuICAgICAgICBoZWlnaHQ6IG91dGVyQm94LmhlaWdodCAvIHNjYWxlLFxuICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgIGlubmVyOiB7XG4gICAgICAgICAgd2lkdGg6IGlubmVyQm94LndpZHRoIHx8IDAsXG4gICAgICAgICAgaGVpZ2h0OiBpbm5lckJveC5oZWlnaHQgfHwgMCxcbiAgICAgICAgICB4OiBpbm5lckJveC54IHx8IDAsXG4gICAgICAgICAgeTogaW5uZXJCb3gueSB8fCAwXG4gICAgICAgIH0sXG4gICAgICAgIG91dGVyOiBvdXRlckJveFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGJveDtcbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aGlzLl9jaGFuZ2VWaWV3Ym94KGZ1bmN0aW9uKCkge1xuICAgICAgICBzY2FsZSA9IE1hdGgubWluKG91dGVyQm94LndpZHRoIC8gYm94LndpZHRoLCBvdXRlckJveC5oZWlnaHQgLyBib3guaGVpZ2h0KTtcblxuICAgICAgICBjb25zdCBtYXRyaXggPSB0aGlzLl9zdmcuY3JlYXRlU1ZHTWF0cml4KClcbiAgICAgICAgICAuc2NhbGUoc2NhbGUpXG4gICAgICAgICAgLnRyYW5zbGF0ZSgtYm94LngsIC1ib3gueSk7XG5cbiAgICAgICAgdHJhbnNmb3JtJDEodmlld3BvcnQsIG1hdHJpeCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYm94O1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgc2Nyb2xsIG9mIHRoZSBjYW52YXMuXG4gICAqXG4gICAqIEBwYXJhbSB7U2Nyb2xsRGVsdGF9IFtkZWx0YV0gVGhlIHNjcm9sbCB0byBiZSBzZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge1BvaW50fVxuICAgKi9cbiAgQ2FudmFzLnByb3RvdHlwZS5zY3JvbGwgPSBmdW5jdGlvbihkZWx0YSkge1xuXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuX3ZpZXdwb3J0O1xuICAgIGxldCBtYXRyaXggPSBub2RlLmdldENUTSgpO1xuXG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICB0aGlzLl9jaGFuZ2VWaWV3Ym94KGZ1bmN0aW9uKCkge1xuICAgICAgICBkZWx0YSA9IGFzc2lnbiQxKHsgZHg6IDAsIGR5OiAwIH0sIGRlbHRhIHx8IHt9KTtcblxuICAgICAgICBtYXRyaXggPSB0aGlzLl9zdmcuY3JlYXRlU1ZHTWF0cml4KCkudHJhbnNsYXRlKGRlbHRhLmR4LCBkZWx0YS5keSkubXVsdGlwbHkobWF0cml4KTtcblxuICAgICAgICBzZXRDVE0obm9kZSwgbWF0cml4KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7IHg6IG1hdHJpeC5lLCB5OiBtYXRyaXguZiB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBTY3JvbGxzIHRoZSB2aWV3Ym94IHRvIGNvbnRhaW4gdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqIE9wdGlvbmFsbHkgc3BlY2lmeSBhIHBhZGRpbmcgdG8gYmUgYXBwbGllZCB0byB0aGUgZWRnZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7U2hhcGVMaWtlfENvbm5lY3Rpb25MaWtlfHN0cmluZ30gZWxlbWVudCBUaGUgZWxlbWVudCB0byBzY3JvbGwgdG8gb3IgaXRzIElELlxuICAgKiBAcGFyYW0ge1JlY3RUUkJMfG51bWJlcn0gW3BhZGRpbmc9MTAwXSBUaGUgcGFkZGluZyB0byBiZSBhcHBsaWVkLiBDYW4gYWxzbyBzcGVjaWZ5IHRvcCwgYm90dG9tLCBsZWZ0IGFuZCByaWdodC5cbiAgICovXG4gIENhbnZhcy5wcm90b3R5cGUuc2Nyb2xsVG9FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgcGFkZGluZykge1xuICAgIGxldCBkZWZhdWx0UGFkZGluZyA9IDEwMDtcblxuICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0KGVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIHNldCB0byBjb3JyZWN0IHJvb3RFbGVtZW50XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSB0aGlzLmZpbmRSb290KGVsZW1lbnQpO1xuXG4gICAgaWYgKHJvb3RFbGVtZW50ICE9PSB0aGlzLmdldFJvb3RFbGVtZW50KCkpIHtcbiAgICAgIHRoaXMuc2V0Um9vdEVsZW1lbnQocm9vdEVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIGVsZW1lbnQgaXMgcm9vdEVsZW1lbnQsIGRvIG5vdCBjaGFuZ2Ugdmlld3BvcnRcbiAgICBpZiAocm9vdEVsZW1lbnQgPT09IGVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXBhZGRpbmcpIHtcbiAgICAgIHBhZGRpbmcgPSB7fTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnbnVtYmVyJykge1xuICAgICAgZGVmYXVsdFBhZGRpbmcgPSBwYWRkaW5nO1xuICAgIH1cblxuICAgIHBhZGRpbmcgPSB7XG4gICAgICB0b3A6IHBhZGRpbmcudG9wIHx8IGRlZmF1bHRQYWRkaW5nLFxuICAgICAgcmlnaHQ6IHBhZGRpbmcucmlnaHQgfHwgZGVmYXVsdFBhZGRpbmcsXG4gICAgICBib3R0b206IHBhZGRpbmcuYm90dG9tIHx8IGRlZmF1bHRQYWRkaW5nLFxuICAgICAgbGVmdDogcGFkZGluZy5sZWZ0IHx8IGRlZmF1bHRQYWRkaW5nXG4gICAgfTtcblxuICAgIGNvbnN0IGVsZW1lbnRCb3VuZHMgPSBnZXRCQm94KGVsZW1lbnQpLFxuICAgICAgICAgIGVsZW1lbnRUcmJsID0gYXNUUkJMKGVsZW1lbnRCb3VuZHMpLFxuICAgICAgICAgIHZpZXdib3hCb3VuZHMgPSB0aGlzLnZpZXdib3goKSxcbiAgICAgICAgICB6b29tID0gdGhpcy56b29tKCk7XG4gICAgbGV0IGR4LCBkeTtcblxuICAgIC8vIHNocmluayB2aWV3Ym94Qm91bmRzIHdpdGggcGFkZGluZ1xuICAgIHZpZXdib3hCb3VuZHMueSArPSBwYWRkaW5nLnRvcCAvIHpvb207XG4gICAgdmlld2JveEJvdW5kcy54ICs9IHBhZGRpbmcubGVmdCAvIHpvb207XG4gICAgdmlld2JveEJvdW5kcy53aWR0aCAtPSAocGFkZGluZy5yaWdodCArIHBhZGRpbmcubGVmdCkgLyB6b29tO1xuICAgIHZpZXdib3hCb3VuZHMuaGVpZ2h0IC09IChwYWRkaW5nLmJvdHRvbSArIHBhZGRpbmcudG9wKSAvIHpvb207XG5cbiAgICBjb25zdCB2aWV3Ym94VHJibCA9IGFzVFJCTCh2aWV3Ym94Qm91bmRzKTtcblxuICAgIGNvbnN0IGNhbkZpdCA9IGVsZW1lbnRCb3VuZHMud2lkdGggPCB2aWV3Ym94Qm91bmRzLndpZHRoICYmIGVsZW1lbnRCb3VuZHMuaGVpZ2h0IDwgdmlld2JveEJvdW5kcy5oZWlnaHQ7XG5cbiAgICBpZiAoIWNhbkZpdCkge1xuXG4gICAgICAvLyB0b3AtbGVmdCB3aGVuIGVsZW1lbnQgY2FuJ3QgZml0XG4gICAgICBkeCA9IGVsZW1lbnRCb3VuZHMueCAtIHZpZXdib3hCb3VuZHMueDtcbiAgICAgIGR5ID0gZWxlbWVudEJvdW5kcy55IC0gdmlld2JveEJvdW5kcy55O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgY29uc3QgZFJpZ2h0ID0gTWF0aC5tYXgoMCwgZWxlbWVudFRyYmwucmlnaHQgLSB2aWV3Ym94VHJibC5yaWdodCksXG4gICAgICAgICAgICBkTGVmdCA9IE1hdGgubWluKDAsIGVsZW1lbnRUcmJsLmxlZnQgLSB2aWV3Ym94VHJibC5sZWZ0KSxcbiAgICAgICAgICAgIGRCb3R0b20gPSBNYXRoLm1heCgwLCBlbGVtZW50VHJibC5ib3R0b20gLSB2aWV3Ym94VHJibC5ib3R0b20pLFxuICAgICAgICAgICAgZFRvcCA9IE1hdGgubWluKDAsIGVsZW1lbnRUcmJsLnRvcCAtIHZpZXdib3hUcmJsLnRvcCk7XG5cbiAgICAgIGR4ID0gZFJpZ2h0IHx8IGRMZWZ0O1xuICAgICAgZHkgPSBkQm90dG9tIHx8IGRUb3A7XG5cbiAgICB9XG5cbiAgICB0aGlzLnNjcm9sbCh7IGR4OiAtZHggKiB6b29tLCBkeTogLWR5ICogem9vbSB9KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSBjdXJyZW50IHpvb20gb2YgdGhlIGNhbnZhcywgb3B0aW9uYWxseSB6b29taW5nIHRvIHRoZVxuICAgKiBzcGVjaWZpZWQgcG9zaXRpb24uXG4gICAqXG4gICAqIFRoZSBnZXR0ZXIgbWF5IHJldHVybiBhIGNhY2hlZCB6b29tIGxldmVsLiBDYWxsIGl0IHdpdGggYGZhbHNlYCBhcyB0aGUgZmlyc3RcbiAgICogYXJndW1lbnQgdG8gZm9yY2UgcmVjb21wdXRhdGlvbiBvZiB0aGUgY3VycmVudCBsZXZlbC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8J2ZpdC12aWV3cG9ydCd9IFtuZXdTY2FsZV0gVGhlIG5ldyB6b29tIGxldmVsLCBlaXRoZXIgYSBudW1iZXIsXG4gICAqIGkuZS4gMC45LCBvciBgZml0LXZpZXdwb3J0YCB0byBhZGp1c3QgdGhlIHNpemUgdG8gZml0IHRoZSBjdXJyZW50IHZpZXdwb3J0LlxuICAgKiBAcGFyYW0ge1BvaW50fSBbY2VudGVyXSBUaGUgcmVmZXJlbmNlIHBvaW50IHsgeDogLi4uLCB5OiAuLi59IHRvIHpvb20gdG8uXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNldCB6b29tIGxldmVsLlxuICAgKi9cbiAgQ2FudmFzLnByb3RvdHlwZS56b29tID0gZnVuY3Rpb24obmV3U2NhbGUsIGNlbnRlcikge1xuXG4gICAgaWYgKCFuZXdTY2FsZSkge1xuICAgICAgcmV0dXJuIHRoaXMudmlld2JveChuZXdTY2FsZSkuc2NhbGU7XG4gICAgfVxuXG4gICAgaWYgKG5ld1NjYWxlID09PSAnZml0LXZpZXdwb3J0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpdFZpZXdwb3J0KGNlbnRlcik7XG4gICAgfVxuXG4gICAgbGV0IG91dGVyLFxuICAgICAgICBtYXRyaXg7XG5cbiAgICB0aGlzLl9jaGFuZ2VWaWV3Ym94KGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAodHlwZW9mIGNlbnRlciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3V0ZXIgPSB0aGlzLnZpZXdib3goKS5vdXRlcjtcblxuICAgICAgICBjZW50ZXIgPSB7XG4gICAgICAgICAgeDogb3V0ZXIud2lkdGggLyAyLFxuICAgICAgICAgIHk6IG91dGVyLmhlaWdodCAvIDJcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbWF0cml4ID0gdGhpcy5fc2V0Wm9vbShuZXdTY2FsZSwgY2VudGVyKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByb3VuZChtYXRyaXguYSwgMTAwMCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0Q1RNKG5vZGUsIG0pIHtcbiAgICBjb25zdCBtc3RyID0gJ21hdHJpeCgnICsgbS5hICsgJywnICsgbS5iICsgJywnICsgbS5jICsgJywnICsgbS5kICsgJywnICsgbS5lICsgJywnICsgbS5mICsgJyknO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBtc3RyKTtcbiAgfVxuXG4gIENhbnZhcy5wcm90b3R5cGUuX2ZpdFZpZXdwb3J0ID0gZnVuY3Rpb24oY2VudGVyKSB7XG5cbiAgICBjb25zdCB2Ym94ID0gdGhpcy52aWV3Ym94KCksXG4gICAgICAgICAgb3V0ZXIgPSB2Ym94Lm91dGVyLFxuICAgICAgICAgIGlubmVyID0gdmJveC5pbm5lcjtcbiAgICBsZXQgbmV3U2NhbGUsXG4gICAgICAgIG5ld1ZpZXdib3g7XG5cbiAgICAvLyBkaXNwbGF5IHRoZSBjb21wbGV0ZSBkaWFncmFtIHdpdGhvdXQgem9vbWluZyBpbi5cbiAgICAvLyBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gaW50ZXJuYWwgem9vbSwgd2UgcGVyZm9ybSBhXG4gICAgLy8gaGFyZCByZXNldCBvbiB0aGUgY2FudmFzIHZpZXdib3ggdG8gcmVhbGl6ZSB0aGlzXG4gICAgLy9cbiAgICAvLyBpZiBkaWFncmFtIGRvZXMgbm90IG5lZWQgdG8gYmUgem9vbWVkIGluLCB3ZSBmb2N1cyBpdCBhcm91bmRcbiAgICAvLyB0aGUgZGlhZ3JhbSBvcmlnaW4gaW5zdGVhZFxuXG4gICAgaWYgKGlubmVyLnggPj0gMCAmJlxuICAgICAgICBpbm5lci55ID49IDAgJiZcbiAgICAgICAgaW5uZXIueCArIGlubmVyLndpZHRoIDw9IG91dGVyLndpZHRoICYmXG4gICAgICAgIGlubmVyLnkgKyBpbm5lci5oZWlnaHQgPD0gb3V0ZXIuaGVpZ2h0ICYmXG4gICAgICAgICFjZW50ZXIpIHtcblxuICAgICAgbmV3Vmlld2JveCA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IE1hdGgubWF4KGlubmVyLndpZHRoICsgaW5uZXIueCwgb3V0ZXIud2lkdGgpLFxuICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KGlubmVyLmhlaWdodCArIGlubmVyLnksIG91dGVyLmhlaWdodClcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcblxuICAgICAgbmV3U2NhbGUgPSBNYXRoLm1pbigxLCBvdXRlci53aWR0aCAvIGlubmVyLndpZHRoLCBvdXRlci5oZWlnaHQgLyBpbm5lci5oZWlnaHQpO1xuICAgICAgbmV3Vmlld2JveCA9IHtcbiAgICAgICAgeDogaW5uZXIueCArIChjZW50ZXIgPyBpbm5lci53aWR0aCAvIDIgLSBvdXRlci53aWR0aCAvIG5ld1NjYWxlIC8gMiA6IDApLFxuICAgICAgICB5OiBpbm5lci55ICsgKGNlbnRlciA/IGlubmVyLmhlaWdodCAvIDIgLSBvdXRlci5oZWlnaHQgLyBuZXdTY2FsZSAvIDIgOiAwKSxcbiAgICAgICAgd2lkdGg6IG91dGVyLndpZHRoIC8gbmV3U2NhbGUsXG4gICAgICAgIGhlaWdodDogb3V0ZXIuaGVpZ2h0IC8gbmV3U2NhbGVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy52aWV3Ym94KG5ld1ZpZXdib3gpO1xuXG4gICAgcmV0dXJuIHRoaXMudmlld2JveChmYWxzZSkuc2NhbGU7XG4gIH07XG5cblxuICBDYW52YXMucHJvdG90eXBlLl9zZXRab29tID0gZnVuY3Rpb24oc2NhbGUsIGNlbnRlcikge1xuXG4gICAgY29uc3Qgc3ZnID0gdGhpcy5fc3ZnLFxuICAgICAgICAgIHZpZXdwb3J0ID0gdGhpcy5fdmlld3BvcnQ7XG5cbiAgICBjb25zdCBtYXRyaXggPSBzdmcuY3JlYXRlU1ZHTWF0cml4KCk7XG4gICAgY29uc3QgcG9pbnQgPSBzdmcuY3JlYXRlU1ZHUG9pbnQoKTtcblxuICAgIGxldCBjZW50ZXJQb2ludCxcbiAgICAgICAgb3JpZ2luYWxQb2ludCxcbiAgICAgICAgY3VycmVudE1hdHJpeCxcbiAgICAgICAgc2NhbGVNYXRyaXgsXG4gICAgICAgIG5ld01hdHJpeDtcblxuICAgIGN1cnJlbnRNYXRyaXggPSB2aWV3cG9ydC5nZXRDVE0oKTtcblxuICAgIGNvbnN0IGN1cnJlbnRTY2FsZSA9IGN1cnJlbnRNYXRyaXguYTtcblxuICAgIGlmIChjZW50ZXIpIHtcbiAgICAgIGNlbnRlclBvaW50ID0gYXNzaWduJDEocG9pbnQsIGNlbnRlcik7XG5cbiAgICAgIC8vIHJldmVydCBhcHBsaWVkIHZpZXdwb3J0IHRyYW5zZm9ybWF0aW9uc1xuICAgICAgb3JpZ2luYWxQb2ludCA9IGNlbnRlclBvaW50Lm1hdHJpeFRyYW5zZm9ybShjdXJyZW50TWF0cml4LmludmVyc2UoKSk7XG5cbiAgICAgIC8vIGNyZWF0ZSBzY2FsZSBtYXRyaXhcbiAgICAgIHNjYWxlTWF0cml4ID0gbWF0cml4XG4gICAgICAgIC50cmFuc2xhdGUob3JpZ2luYWxQb2ludC54LCBvcmlnaW5hbFBvaW50LnkpXG4gICAgICAgIC5zY2FsZSgxIC8gY3VycmVudFNjYWxlICogc2NhbGUpXG4gICAgICAgIC50cmFuc2xhdGUoLW9yaWdpbmFsUG9pbnQueCwgLW9yaWdpbmFsUG9pbnQueSk7XG5cbiAgICAgIG5ld01hdHJpeCA9IGN1cnJlbnRNYXRyaXgubXVsdGlwbHkoc2NhbGVNYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdNYXRyaXggPSBtYXRyaXguc2NhbGUoc2NhbGUpO1xuICAgIH1cblxuICAgIHNldENUTSh0aGlzLl92aWV3cG9ydCwgbmV3TWF0cml4KTtcblxuICAgIHJldHVybiBuZXdNYXRyaXg7XG4gIH07XG5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtEaW1lbnNpb25zfSBUaGUgc2l6ZSBvZiB0aGUgY2FudmFzLlxuICAgKi9cbiAgQ2FudmFzLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHRcbiAgICB9O1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFic29sdXRlIGJvdW5kaW5nIGJveCBvZiBhbiBlbGVtZW50LlxuICAgKlxuICAgKiBUaGUgYWJzb2x1dGUgYm91bmRpbmcgYm94IG1heSBiZSB1c2VkIHRvIGRpc3BsYXkgb3ZlcmxheXMgaW4gdGhlIGNhbGxlcnNcbiAgICogKGJyb3dzZXIpIGNvb3JkaW5hdGUgc3lzdGVtIHJhdGhlciB0aGFuIHRoZSB6b29tZWQgaW4vb3V0IGNhbnZhcyBjb29yZGluYXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtTaGFwZUxpa2V8Q29ubmVjdGlvbkxpa2V9IGVsZW1lbnQgVGhlIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge1JlY3R9IFRoZSBlbGVtZW50J3MgYWJzb2x1dGUgYm91bmRpbmcgYm94LlxuICAgKi9cbiAgQ2FudmFzLnByb3RvdHlwZS5nZXRBYnNvbHV0ZUJCb3ggPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgY29uc3QgdmJveCA9IHRoaXMudmlld2JveCgpO1xuICAgIGxldCBiYm94O1xuXG4gICAgLy8gY29ubmVjdGlvblxuICAgIC8vIHVzZSBzdmcgYmJveFxuICAgIGlmIChlbGVtZW50LndheXBvaW50cykge1xuICAgICAgY29uc3QgZ2Z4ID0gdGhpcy5nZXRHcmFwaGljcyhlbGVtZW50KTtcblxuICAgICAgYmJveCA9IGdmeC5nZXRCQm94KCk7XG4gICAgfVxuXG4gICAgLy8gc2hhcGVzXG4gICAgLy8gdXNlIGRhdGFcbiAgICBlbHNlIHtcbiAgICAgIGJib3ggPSBlbGVtZW50O1xuICAgIH1cblxuICAgIGNvbnN0IHggPSBiYm94LnggKiB2Ym94LnNjYWxlIC0gdmJveC54ICogdmJveC5zY2FsZTtcbiAgICBjb25zdCB5ID0gYmJveC55ICogdmJveC5zY2FsZSAtIHZib3gueSAqIHZib3guc2NhbGU7XG5cbiAgICBjb25zdCB3aWR0aCA9IGJib3gud2lkdGggKiB2Ym94LnNjYWxlO1xuICAgIGNvbnN0IGhlaWdodCA9IGJib3guaGVpZ2h0ICogdmJveC5zY2FsZTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogRmlyZXMgYW4gZXZlbnQgc28gb3RoZXIgbW9kdWxlcyBjYW4gcmVhY3QgdG8gdGhlIGNhbnZhcyByZXNpemluZy5cbiAgICovXG4gIENhbnZhcy5wcm90b3R5cGUucmVzaXplZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gZm9yY2UgcmVjb21wdXRhdGlvbiBvZiB2aWV3IGJveFxuICAgIGRlbGV0ZSB0aGlzLl9jYWNoZWRWaWV3Ym94O1xuXG4gICAgdGhpcy5fZXZlbnRCdXMuZmlyZSgnY2FudmFzLnJlc2l6ZWQnKTtcbiAgfTtcblxuICB2YXIgRUxFTUVOVF9JRCA9ICdkYXRhLWVsZW1lbnQtaWQnO1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuL1R5cGVzJykuRWxlbWVudExpa2V9IEVsZW1lbnRMaWtlXG4gICAqXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vRXZlbnRCdXMnKS5kZWZhdWx0fSBFdmVudEJ1c1xuICAgKlxuICAgKiBAdHlwZWRlZiB7IChlbGVtZW50OiBFbGVtZW50TGlrZSwgZ2Z4OiBTVkdFbGVtZW50KSA9PiBib29sZWFufGFueSB9IEVsZW1lbnRSZWdpc3RyeUZpbHRlckNhbGxiYWNrXG4gICAqIEB0eXBlZGVmIHsgKGVsZW1lbnQ6IEVsZW1lbnRMaWtlLCBnZng6IFNWR0VsZW1lbnQpID0+IGFueSB9IEVsZW1lbnRSZWdpc3RyeUZvckVhY2hDYWxsYmFja1xuICAgKi9cblxuICAvKipcbiAgICogQSByZWdpc3RyeSB0aGF0IGtlZXBzIHRyYWNrIG9mIGFsbCBzaGFwZXMgaW4gdGhlIGRpYWdyYW0uXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAgICovXG4gIGZ1bmN0aW9uIEVsZW1lbnRSZWdpc3RyeShldmVudEJ1cykge1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyB7XG4gICAgICogICBbaWQ6IHN0cmluZ106IHtcbiAgICAgKiAgICAgZWxlbWVudDogRWxlbWVudExpa2U7XG4gICAgICogICAgIGdmeD86IFNWR0VsZW1lbnQ7XG4gICAgICogICAgIHNlY29uZGFyeUdmeD86IFNWR0VsZW1lbnQ7XG4gICAgICogICB9XG4gICAgICogfSB9XG4gICAgICovXG4gICAgdGhpcy5fZWxlbWVudHMgPSB7fTtcblxuICAgIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gIH1cblxuICBFbGVtZW50UmVnaXN0cnkuJGluamVjdCA9IFsgJ2V2ZW50QnVzJyBdO1xuXG4gIC8qKlxuICAgKiBBZGQgYW4gZWxlbWVudCBhbmQgaXRzIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbihzKSB0byB0aGUgcmVnaXN0cnkuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudExpa2V9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gYmUgYWRkZWQuXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZ2Z4IFRoZSBwcmltYXJ5IGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbi5cbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBbc2Vjb25kYXJ5R2Z4XSBUaGUgc2Vjb25kYXJ5IGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbi5cbiAgICovXG4gIEVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZWxlbWVudCwgZ2Z4LCBzZWNvbmRhcnlHZngpIHtcblxuICAgIHZhciBpZCA9IGVsZW1lbnQuaWQ7XG5cbiAgICB0aGlzLl92YWxpZGF0ZUlkKGlkKTtcblxuICAgIC8vIGFzc29jaWF0ZSBkb20gbm9kZSB3aXRoIGVsZW1lbnRcbiAgICBhdHRyJDEoZ2Z4LCBFTEVNRU5UX0lELCBpZCk7XG5cbiAgICBpZiAoc2Vjb25kYXJ5R2Z4KSB7XG4gICAgICBhdHRyJDEoc2Vjb25kYXJ5R2Z4LCBFTEVNRU5UX0lELCBpZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudHNbaWRdID0geyBlbGVtZW50OiBlbGVtZW50LCBnZng6IGdmeCwgc2Vjb25kYXJ5R2Z4OiBzZWNvbmRhcnlHZnggfTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGVsZW1lbnQgZnJvbSB0aGUgcmVnaXN0cnkuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudExpa2V8c3RyaW5nfSBlbGVtZW50XG4gICAqL1xuICBFbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLl9lbGVtZW50cyxcbiAgICAgICAgaWQgPSBlbGVtZW50LmlkIHx8IGVsZW1lbnQsXG4gICAgICAgIGNvbnRhaW5lciA9IGlkICYmIGVsZW1lbnRzW2lkXTtcblxuICAgIGlmIChjb250YWluZXIpIHtcblxuICAgICAgLy8gdW5zZXQgZWxlbWVudCBpZCBvbiBnZnhcbiAgICAgIGF0dHIkMShjb250YWluZXIuZ2Z4LCBFTEVNRU5UX0lELCAnJyk7XG5cbiAgICAgIGlmIChjb250YWluZXIuc2Vjb25kYXJ5R2Z4KSB7XG4gICAgICAgIGF0dHIkMShjb250YWluZXIuc2Vjb25kYXJ5R2Z4LCBFTEVNRU5UX0lELCAnJyk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBlbGVtZW50c1tpZF07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgYW4gZWxlbWVudHMgSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudExpa2V8c3RyaW5nfSBlbGVtZW50IFRoZSBlbGVtZW50IG9yIGl0cyBJRC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0lkIFRoZSBuZXcgSUQuXG4gICAqL1xuICBFbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLnVwZGF0ZUlkID0gZnVuY3Rpb24oZWxlbWVudCwgbmV3SWQpIHtcblxuICAgIHRoaXMuX3ZhbGlkYXRlSWQobmV3SWQpO1xuXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgZWxlbWVudCA9IHRoaXMuZ2V0KGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2VsZW1lbnQudXBkYXRlSWQnLCB7XG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgbmV3SWQ6IG5ld0lkXG4gICAgfSk7XG5cbiAgICB2YXIgZ2Z4ID0gdGhpcy5nZXRHcmFwaGljcyhlbGVtZW50KSxcbiAgICAgICAgc2Vjb25kYXJ5R2Z4ID0gdGhpcy5nZXRHcmFwaGljcyhlbGVtZW50LCB0cnVlKTtcblxuICAgIHRoaXMucmVtb3ZlKGVsZW1lbnQpO1xuXG4gICAgZWxlbWVudC5pZCA9IG5ld0lkO1xuXG4gICAgdGhpcy5hZGQoZWxlbWVudCwgZ2Z4LCBzZWNvbmRhcnlHZngpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbiBvZiBhbiBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnRMaWtlfHN0cmluZ30gZmlsdGVyIFRoZSBlbGVtZW50IG9yIGl0cyBJRC5cbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBnZnggVGhlIG5ldyBncmFwaGljYWwgcmVwcmVzZW50YXRpb24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlY29uZGFyeT1mYWxzZV0gV2hldGhlciB0byB1cGRhdGUgdGhlIHNlY29uZGFyeSBncmFwaGljYWwgcmVwcmVzZW50YXRpb24uXG4gICAqL1xuICBFbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLnVwZGF0ZUdyYXBoaWNzID0gZnVuY3Rpb24oZmlsdGVyLCBnZngsIHNlY29uZGFyeSkge1xuICAgIHZhciBpZCA9IGZpbHRlci5pZCB8fCBmaWx0ZXI7XG5cbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fZWxlbWVudHNbaWRdO1xuXG4gICAgaWYgKHNlY29uZGFyeSkge1xuICAgICAgY29udGFpbmVyLnNlY29uZGFyeUdmeCA9IGdmeDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyLmdmeCA9IGdmeDtcbiAgICB9XG5cbiAgICBpZiAoZ2Z4KSB7XG4gICAgICBhdHRyJDEoZ2Z4LCBFTEVNRU5UX0lELCBpZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdmeDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBlbGVtZW50IHdpdGggdGhlIGdpdmVuIElEIG9yIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBlbGVtZW50UmVnaXN0cnkuZ2V0KCdTb21lRWxlbWVudElkXzEnKTtcbiAgICpcbiAgICogZWxlbWVudFJlZ2lzdHJ5LmdldChnZngpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8U1ZHRWxlbWVudH0gZmlsdGVyIFRoZSBlbGVtZW50cyBJRCBvciBncmFwaGljYWwgcmVwcmVzZW50YXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnRMaWtlfHVuZGVmaW5lZH0gVGhlIGVsZW1lbnQuXG4gICAqL1xuICBFbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciBpZDtcblxuICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJykge1xuICAgICAgaWQgPSBmaWx0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkID0gZmlsdGVyICYmIGF0dHIkMShmaWx0ZXIsIEVMRU1FTlRfSUQpO1xuICAgIH1cblxuICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9lbGVtZW50c1tpZF07XG4gICAgcmV0dXJuIGNvbnRhaW5lciAmJiBjb250YWluZXIuZWxlbWVudDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIGFsbCBlbGVtZW50cyB0aGF0IG1hdGNoIGEgZ2l2ZW4gZmlsdGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnRSZWdpc3RyeUZpbHRlckNhbGxiYWNrfSBmbiBUaGUgZmlsdGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50TGlrZVtdfSBUaGUgbWF0Y2hpbmcgZWxlbWVudHMuXG4gICAqL1xuICBFbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKGZuKSB7XG5cbiAgICB2YXIgZmlsdGVyZWQgPSBbXTtcblxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50LCBnZngpIHtcbiAgICAgIGlmIChmbihlbGVtZW50LCBnZngpKSB7XG4gICAgICAgIGZpbHRlcmVkLnB1c2goZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZmlsdGVyZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuIGZpbHRlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50UmVnaXN0cnlGaWx0ZXJDYWxsYmFja30gZm4gVGhlIGZpbHRlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudExpa2V8dW5kZWZpbmVkfSBUaGUgbWF0Y2hpbmcgZWxlbWVudC5cbiAgICovXG4gIEVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgdmFyIG1hcCA9IHRoaXMuX2VsZW1lbnRzLFxuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMobWFwKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkID0ga2V5c1tpXSxcbiAgICAgICAgICBjb250YWluZXIgPSBtYXBbaWRdLFxuICAgICAgICAgIGVsZW1lbnQgPSBjb250YWluZXIuZWxlbWVudCxcbiAgICAgICAgICBnZnggPSBjb250YWluZXIuZ2Z4O1xuXG4gICAgICBpZiAoZm4oZWxlbWVudCwgZ2Z4KSkge1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgZWxlbWVudHMuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnRMaWtlW119IEFsbCBlbGVtZW50cy5cbiAgICovXG4gIEVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGU7IH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50UmVnaXN0cnlGb3JFYWNoQ2FsbGJhY2t9IGZuIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlLlxuICAgKi9cbiAgRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oZm4pIHtcblxuICAgIHZhciBtYXAgPSB0aGlzLl9lbGVtZW50cztcblxuICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IG1hcFtpZF0sXG4gICAgICAgICAgZWxlbWVudCA9IGNvbnRhaW5lci5lbGVtZW50LFxuICAgICAgICAgIGdmeCA9IGNvbnRhaW5lci5nZng7XG5cbiAgICAgIHJldHVybiBmbihlbGVtZW50LCBnZngpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbiBvZiBhbiBlbGVtZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGVsZW1lbnRSZWdpc3RyeS5nZXRHcmFwaGljcygnU29tZUVsZW1lbnRJZF8xJyk7XG4gICAqXG4gICAqIGVsZW1lbnRSZWdpc3RyeS5nZXRHcmFwaGljcyhyb290RWxlbWVudCk7IC8vIDxnIC4uLj5cbiAgICpcbiAgICogZWxlbWVudFJlZ2lzdHJ5LmdldEdyYXBoaWNzKHJvb3RFbGVtZW50LCB0cnVlKTsgLy8gPHN2ZyAuLi4+XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnRMaWtlfHN0cmluZ30gZmlsdGVyIFRoZSBlbGVtZW50IG9yIGl0cyBJRC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc2Vjb25kYXJ5PWZhbHNlXSBXaGV0aGVyIHRvIHJldHVybiB0aGUgc2Vjb25kYXJ5IGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7U1ZHRWxlbWVudH0gVGhlIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbi5cbiAgICovXG4gIEVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUuZ2V0R3JhcGhpY3MgPSBmdW5jdGlvbihmaWx0ZXIsIHNlY29uZGFyeSkge1xuICAgIHZhciBpZCA9IGZpbHRlci5pZCB8fCBmaWx0ZXI7XG5cbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fZWxlbWVudHNbaWRdO1xuICAgIHJldHVybiBjb250YWluZXIgJiYgKHNlY29uZGFyeSA/IGNvbnRhaW5lci5zZWNvbmRhcnlHZnggOiBjb250YWluZXIuZ2Z4KTtcbiAgfTtcblxuICAvKipcbiAgICogVmFsaWRhdGUgYW4gSUQgYW5kIHRocm93IGFuIGVycm9yIGlmIGludmFsaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gRXJyb3IgaW5kaWNhdGluZyB0aGF0IHRoZSBJRCBpcyBpbnZhbGlkIG9yIGFscmVhZHkgYXNzaWduZWQuXG4gICAqL1xuICBFbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLl92YWxpZGF0ZUlkID0gZnVuY3Rpb24oaWQpIHtcbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgbXVzdCBoYXZlIGFuIGlkJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VsZW1lbnRzW2lkXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbGVtZW50IHdpdGggaWQgJyArIGlkICsgJyBhbHJlYWR5IGFkZGVkJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRlbmRzIGEgY29sbGVjdGlvbiB3aXRoIHtAbGluayBSZWZzfSBhd2FyZSBtZXRob2RzXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gY29sbGVjdGlvblxuICAgKiBAcGFyYW0ge1JlZnN9IHJlZnMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnR5IHJlcHJlc2VudGVkIGJ5IHRoZSBjb2xsZWN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgb2JqZWN0IHRoZSBjb2xsZWN0aW9uIGlzIGF0dGFjaGVkIHRvXG4gICAqXG4gICAqIEByZXR1cm4ge1JlZnNDb2xsZWN0aW9uPE9iamVjdD59IHRoZSBleHRlbmRlZCBhcnJheVxuICAgKi9cbiAgZnVuY3Rpb24gZXh0ZW5kKGNvbGxlY3Rpb24sIHJlZnMsIHByb3BlcnR5LCB0YXJnZXQpIHtcbiAgICB2YXIgaW52ZXJzZVByb3BlcnR5ID0gcHJvcGVydHkuaW52ZXJzZTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIGVsZW1lbnQgZnJvbSB0aGUgYXJyYXkgYW5kIHJldHVybnMgaXQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIFJlZnNDb2xsZWN0aW9uI3JlbW92ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbGxlY3Rpb24sICdyZW1vdmUnLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuaW5kZXhPZihlbGVtZW50KTtcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLnNwbGljZShpZHgsIDEpO1xuXG4gICAgICAgICAgLy8gdW5zZXQgaW52ZXJzZVxuICAgICAgICAgIHJlZnMudW5zZXQoZWxlbWVudCwgaW52ZXJzZVByb3BlcnR5LCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb2xsZWN0aW9uIGNvbnRhaW5zIHRoZSBnaXZlbiBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIFJlZnNDb2xsZWN0aW9uI2NvbnRhaW5zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBjaGVjayBmb3JcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29sbGVjdGlvbiwgJ2NvbnRhaW5zJywge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4T2YoZWxlbWVudCkgIT09IC0xO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoZSBhcnJheSwgdW5sZXNzIGl0IGV4aXN0cyBhbHJlYWR5IChzZXQgc2VtYW50aWNzKS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgUmVmc0NvbGxlY3Rpb24jYWRkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBhZGRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgaW5kZXggdG8gYWRkIGVsZW1lbnQgdG9cbiAgICAgKiAgICAgICAgICAgICAgICAgKHBvc3NpYmx5IG1vdmluZyBvdGhlciBlbGVtZW50cyBhcm91bmQpXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbGxlY3Rpb24sICdhZGQnLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGlkeCkge1xuICAgICAgICB2YXIgY3VycmVudElkeCA9IHRoaXMuaW5kZXhPZihlbGVtZW50KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpZHggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRJZHggIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBlbGVtZW50IGFscmVhZHkgaW4gY29sbGVjdGlvbiAoISlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBhZGQgdG8gZW5kIG9mIGFycmF5LCBhcyBubyBpZHggaXMgc3BlY2lmaWVkXG4gICAgICAgICAgaWR4ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgYWxyZWFkeSBpbiBjb2xsZWN0aW9uXG4gICAgICAgIGlmIChjdXJyZW50SWR4ICE9PSAtMSkge1xuICAgICAgICAgIC8vIHJlbW92ZSBlbGVtZW50IGZyb20gY3VycmVudElkeFxuICAgICAgICAgIHRoaXMuc3BsaWNlKGN1cnJlbnRJZHgsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGVsZW1lbnQgYXQgaWR4XG4gICAgICAgIHRoaXMuc3BsaWNlKGlkeCwgMCwgZWxlbWVudCk7XG4gICAgICAgIGlmIChjdXJyZW50SWR4ID09PSAtMSkge1xuICAgICAgICAgIC8vIHNldCBpbnZlcnNlLCB1bmxlc3MgZWxlbWVudCB3YXNcbiAgICAgICAgICAvLyBpbiBjb2xsZWN0aW9uIGFscmVhZHlcbiAgICAgICAgICByZWZzLnNldChlbGVtZW50LCBpbnZlcnNlUHJvcGVydHksIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGEgc2ltcGxlIG1hcmtlciwgaWRlbnRpZnlpbmcgdGhpcyBlbGVtZW50XG4gICAgLy8gYXMgYmVpbmcgYSByZWZzIGNvbGxlY3Rpb25cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29sbGVjdGlvbiwgJ19fcmVmc19jb2xsZWN0aW9uJywge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBnaXZlbiBjb2xsZWN0aW9uIGlzIGV4dGVuZGVkXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gY29sbGVjdGlvblxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaXNFeHRlbmRlZChjb2xsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uX19yZWZzX2NvbGxlY3Rpb24gPT09IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eSQxKGUsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCBwcm9wZXJ0eS5uYW1lIHx8IHByb3BlcnR5KTtcbiAgfVxuICBmdW5jdGlvbiBkZWZpbmVDb2xsZWN0aW9uUHJvcGVydHkocmVmLCBwcm9wZXJ0eSwgdGFyZ2V0KSB7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSBleHRlbmQodGFyZ2V0W3Byb3BlcnR5Lm5hbWVdIHx8IFtdLCByZWYsIHByb3BlcnR5LCB0YXJnZXQpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5Lm5hbWUsIHtcbiAgICAgIGVudW1lcmFibGU6IHByb3BlcnR5LmVudW1lcmFibGUsXG4gICAgICB2YWx1ZTogY29sbGVjdGlvblxuICAgIH0pO1xuICAgIGlmIChjb2xsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJlZi5zZXQobywgcHJvcGVydHkuaW52ZXJzZSwgdGFyZ2V0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSQxKHJlZiwgcHJvcGVydHksIHRhcmdldCkge1xuICAgIHZhciBpbnZlcnNlUHJvcGVydHkgPSBwcm9wZXJ0eS5pbnZlcnNlO1xuICAgIHZhciBfdmFsdWUgPSB0YXJnZXRbcHJvcGVydHkubmFtZV07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkubmFtZSwge1xuICAgICAgY29uZmlndXJhYmxlOiBwcm9wZXJ0eS5jb25maWd1cmFibGUsXG4gICAgICBlbnVtZXJhYmxlOiBwcm9wZXJ0eS5lbnVtZXJhYmxlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gcmV0dXJuIGlmIHdlIGFscmVhZHkgcGVyZm9ybWVkIGFsbCBjaGFuZ2VzXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gX3ZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbGQgPSBfdmFsdWU7XG5cbiAgICAgICAgLy8gdGVtcG9yYXJ5IHNldCBudWxsXG4gICAgICAgIF92YWx1ZSA9IG51bGw7XG4gICAgICAgIGlmIChvbGQpIHtcbiAgICAgICAgICByZWYudW5zZXQob2xkLCBpbnZlcnNlUHJvcGVydHksIHRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICAgIF92YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIC8vIHNldCBpbnZlcnNlIHZhbHVlXG4gICAgICAgIHJlZi5zZXQoX3ZhbHVlLCBpbnZlcnNlUHJvcGVydHksIHRhcmdldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyByZWZlcmVuY2VzIG9iamVjdCBkZWZpbmluZyB0d28gaW52ZXJzbHkgcmVsYXRlZFxuICAgKiBhdHRyaWJ1dGUgZGVzY3JpcHRvcnMgYSBhbmQgYi5cbiAgICpcbiAgICogPHA+XG4gICAqICAgV2hlbiBib3VuZCB0byBhbiBvYmplY3QgdXNpbmcge0BsaW5rIFJlZnMjYmluZH0gdGhlIHJlZmVyZW5jZXNcbiAgICogICBnZXQgYWN0aXZhdGVkIGFuZCBlbnN1cmUgdGhhdCBhZGQgYW5kIHJlbW92ZSBvcGVyYXRpb25zIGFyZSBhcHBsaWVkXG4gICAqICAgcmV2ZXJzZWx5LCB0b28uXG4gICAqIDwvcD5cbiAgICpcbiAgICogPHA+XG4gICAqICAgRm9yIGF0dHJpYnV0ZXMgcmVwcmVzZW50ZWQgYXMgY29sbGVjdGlvbnMge0BsaW5rIFJlZnN9IHByb3ZpZGVzIHRoZVxuICAgKiAgIHtAbGluayBSZWZzQ29sbGVjdGlvbiNhZGR9LCB7QGxpbmsgUmVmc0NvbGxlY3Rpb24jcmVtb3ZlfSBhbmQge0BsaW5rIFJlZnNDb2xsZWN0aW9uI2NvbnRhaW5zfSBleHRlbnNpb25zXG4gICAqICAgdGhhdCBtdXN0IGJlIHVzZWQgdG8gcHJvcGVybHkgaG9vayBpbnRvIHRoZSBpbnZlcnNlIGNoYW5nZSBtZWNoYW5pc20uXG4gICAqIDwvcD5cbiAgICpcbiAgICogQGNsYXNzIFJlZnNcbiAgICpcbiAgICogQGNsYXNzZGVzYyBBIGJpLWRpcmVjdGlvbmFsIHJlZmVyZW5jZSBiZXR3ZWVuIHR3byBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlZnMuQXR0cmlidXRlRGVzY3JpcHRvcn0gYSBwcm9wZXJ0eSBkZXNjcmlwdG9yXG4gICAqIEBwYXJhbSB7UmVmcy5BdHRyaWJ1dGVEZXNjcmlwdG9yfSBiIHByb3BlcnR5IGRlc2NyaXB0b3JcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIHJlZnMgPSBSZWZzKHsgbmFtZTogJ3doZWVscycsIGNvbGxlY3Rpb246IHRydWUsIGVudW1lcmFibGU6IHRydWUgfSwgeyBuYW1lOiAnY2FyJyB9KTtcbiAgICpcbiAgICogdmFyIGNhciA9IHsgbmFtZTogJ3RveW90YScgfTtcbiAgICogdmFyIHdoZWVscyA9IFt7IHBvczogJ2Zyb250LWxlZnQnIH0sIHsgcG9zOiAnZnJvbnQtcmlnaHQnIH1dO1xuICAgKlxuICAgKiByZWZzLmJpbmQoY2FyLCAnd2hlZWxzJyk7XG4gICAqXG4gICAqIGNhci53aGVlbHMgLy8gW11cbiAgICogY2FyLndoZWVscy5hZGQod2hlZWxzWzBdKTtcbiAgICogY2FyLndoZWVscy5hZGQod2hlZWxzWzFdKTtcbiAgICpcbiAgICogY2FyLndoZWVscyAvLyBbeyBwb3M6ICdmcm9udC1sZWZ0JyB9LCB7IHBvczogJ2Zyb250LXJpZ2h0JyB9XVxuICAgKlxuICAgKiB3aGVlbHNbMF0uY2FyIC8vIHsgbmFtZTogJ3RveW90YScgfTtcbiAgICogY2FyLndoZWVscy5yZW1vdmUod2hlZWxzWzBdKTtcbiAgICpcbiAgICogd2hlZWxzWzBdLmNhciAvLyB1bmRlZmluZWRcbiAgICovXG4gIGZ1bmN0aW9uIFJlZnMoYSwgYikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWZzKSkge1xuICAgICAgcmV0dXJuIG5ldyBSZWZzKGEsIGIpO1xuICAgIH1cblxuICAgIC8vIGxpbmtcbiAgICBhLmludmVyc2UgPSBiO1xuICAgIGIuaW52ZXJzZSA9IGE7XG4gICAgdGhpcy5wcm9wcyA9IHt9O1xuICAgIHRoaXMucHJvcHNbYS5uYW1lXSA9IGE7XG4gICAgdGhpcy5wcm9wc1tiLm5hbWVdID0gYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBvbmUgc2lkZSBvZiBhIGJpLWRpcmVjdGlvbmFsIHJlZmVyZW5jZSB0byBhXG4gICAqIHRhcmdldCBvYmplY3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBSZWZzXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gICAqIEBwYXJhbSAge1N0cmluZ30gcHJvcGVydHlcbiAgICovXG4gIFJlZnMucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoIXRoaXMucHJvcHNbcHJvcGVydHldKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gcHJvcGVydHkgPCcgKyBwcm9wZXJ0eSArICc+IGluIHJlZicpO1xuICAgICAgfVxuICAgICAgcHJvcGVydHkgPSB0aGlzLnByb3BzW3Byb3BlcnR5XTtcbiAgICB9XG4gICAgaWYgKHByb3BlcnR5LmNvbGxlY3Rpb24pIHtcbiAgICAgIGRlZmluZUNvbGxlY3Rpb25Qcm9wZXJ0eSh0aGlzLCBwcm9wZXJ0eSwgdGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUHJvcGVydHkkMSh0aGlzLCBwcm9wZXJ0eSwgdGFyZ2V0KTtcbiAgICB9XG4gIH07XG4gIFJlZnMucHJvdG90eXBlLmVuc3VyZVJlZnNDb2xsZWN0aW9uID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgICB2YXIgY29sbGVjdGlvbiA9IHRhcmdldFtwcm9wZXJ0eS5uYW1lXTtcbiAgICBpZiAoIWlzRXh0ZW5kZWQoY29sbGVjdGlvbikpIHtcbiAgICAgIGRlZmluZUNvbGxlY3Rpb25Qcm9wZXJ0eSh0aGlzLCBwcm9wZXJ0eSwgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG4gIFJlZnMucHJvdG90eXBlLmVuc3VyZUJvdW5kID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5JDEodGFyZ2V0LCBwcm9wZXJ0eSkpIHtcbiAgICAgIHRoaXMuYmluZCh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICB9XG4gIH07XG4gIFJlZnMucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5lbnN1cmVCb3VuZCh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgIGlmIChwcm9wZXJ0eS5jb2xsZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmVmc0NvbGxlY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eSkucmVtb3ZlKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtwcm9wZXJ0eS5uYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFJlZnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMuZW5zdXJlQm91bmQodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBpZiAocHJvcGVydHkuY29sbGVjdGlvbikge1xuICAgICAgICB0aGlzLmVuc3VyZVJlZnNDb2xsZWN0aW9uKHRhcmdldCwgcHJvcGVydHkpLmFkZCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRbcHJvcGVydHkubmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHBhcmVudFJlZnMgPSBuZXcgUmVmcyh7IG5hbWU6ICdjaGlsZHJlbicsIGVudW1lcmFibGU6IHRydWUsIGNvbGxlY3Rpb246IHRydWUgfSwgeyBuYW1lOiAncGFyZW50JyB9KSxcbiAgICAgIGxhYmVsUmVmcyA9IG5ldyBSZWZzKHsgbmFtZTogJ2xhYmVscycsIGVudW1lcmFibGU6IHRydWUsIGNvbGxlY3Rpb246IHRydWUgfSwgeyBuYW1lOiAnbGFiZWxUYXJnZXQnIH0pLFxuICAgICAgYXR0YWNoZXJSZWZzID0gbmV3IFJlZnMoeyBuYW1lOiAnYXR0YWNoZXJzJywgY29sbGVjdGlvbjogdHJ1ZSB9LCB7IG5hbWU6ICdob3N0JyB9KSxcbiAgICAgIG91dGdvaW5nUmVmcyA9IG5ldyBSZWZzKHsgbmFtZTogJ291dGdvaW5nJywgY29sbGVjdGlvbjogdHJ1ZSB9LCB7IG5hbWU6ICdzb3VyY2UnIH0pLFxuICAgICAgaW5jb21pbmdSZWZzID0gbmV3IFJlZnMoeyBuYW1lOiAnaW5jb21pbmcnLCBjb2xsZWN0aW9uOiB0cnVlIH0sIHsgbmFtZTogJ3RhcmdldCcgfSk7XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vVHlwZXMnKS5FbGVtZW50fSBFbGVtZW50XG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vVHlwZXMnKS5TaGFwZX0gU2hhcGVcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi9UeXBlcycpLlJvb3R9IFJvb3RcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi9UeXBlcycpLkxhYmVsfSBMYWJlbFxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuL1R5cGVzJykuQ29ubmVjdGlvbn0gQ29ubmVjdGlvblxuICAgKi9cblxuICAvKipcbiAgICogVGhlIGJhc2ljIGdyYXBoaWNhbCByZXByZXNlbnRhdGlvblxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBFbGVtZW50SW1wbCgpIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvYmplY3QgdGhhdCBiYWNrcyB1cCB0aGUgc2hhcGVcbiAgICAgKlxuICAgICAqIEBuYW1lIEVsZW1lbnQjYnVzaW5lc3NPYmplY3RcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2J1c2luZXNzT2JqZWN0Jywge1xuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcblxuXG4gICAgLyoqXG4gICAgICogU2luZ2xlIGxhYmVsIHN1cHBvcnQsIHdpbGwgbWFwcGVkIHRvIG11bHRpIGxhYmVsIGFycmF5XG4gICAgICpcbiAgICAgKiBAbmFtZSBFbGVtZW50I2xhYmVsXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdsYWJlbCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsc1swXTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKG5ld0xhYmVsKSB7XG5cbiAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5sYWJlbCxcbiAgICAgICAgICAgIGxhYmVscyA9IHRoaXMubGFiZWxzO1xuXG4gICAgICAgIGlmICghbmV3TGFiZWwgJiYgbGFiZWwpIHtcbiAgICAgICAgICBsYWJlbHMucmVtb3ZlKGxhYmVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYWJlbHMuYWRkKG5ld0xhYmVsLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBhcmVudCBzaGFwZVxuICAgICAqXG4gICAgICogQG5hbWUgRWxlbWVudCNwYXJlbnRcbiAgICAgKiBAdHlwZSBTaGFwZVxuICAgICAqL1xuICAgIHBhcmVudFJlZnMuYmluZCh0aGlzLCAncGFyZW50Jyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGlzdCBvZiBsYWJlbHNcbiAgICAgKlxuICAgICAqIEBuYW1lIEVsZW1lbnQjbGFiZWxzXG4gICAgICogQHR5cGUgTGFiZWxcbiAgICAgKi9cbiAgICBsYWJlbFJlZnMuYmluZCh0aGlzLCAnbGFiZWxzJyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGlzdCBvZiBvdXRnb2luZyBjb25uZWN0aW9uc1xuICAgICAqXG4gICAgICogQG5hbWUgRWxlbWVudCNvdXRnb2luZ1xuICAgICAqIEB0eXBlIEFycmF5PENvbm5lY3Rpb24+XG4gICAgICovXG4gICAgb3V0Z29pbmdSZWZzLmJpbmQodGhpcywgJ291dGdvaW5nJyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGlzdCBvZiBpbmNvbWluZyBjb25uZWN0aW9uc1xuICAgICAqXG4gICAgICogQG5hbWUgRWxlbWVudCNpbmNvbWluZ1xuICAgICAqIEB0eXBlIEFycmF5PENvbm5lY3Rpb24+XG4gICAgICovXG4gICAgaW5jb21pbmdSZWZzLmJpbmQodGhpcywgJ2luY29taW5nJyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBBIGdyYXBoaWNhbCBvYmplY3RcbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAZXh0ZW5kcyBFbGVtZW50SW1wbFxuICAgKi9cbiAgZnVuY3Rpb24gU2hhcGVJbXBsKCkge1xuICAgIEVsZW1lbnRJbXBsLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgZnJhbWUgc2hhcGVzXG4gICAgICpcbiAgICAgKiBAbmFtZSBTaGFwZUltcGwjaXNGcmFtZVxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBsaXN0IG9mIGNoaWxkcmVuXG4gICAgICpcbiAgICAgKiBAbmFtZSBTaGFwZUltcGwjY2hpbGRyZW5cbiAgICAgKiBAdHlwZSBFbGVtZW50W11cbiAgICAgKi9cbiAgICBwYXJlbnRSZWZzLmJpbmQodGhpcywgJ2NoaWxkcmVuJyk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBTaGFwZUltcGwjaG9zdFxuICAgICAqIEB0eXBlIFNoYXBlXG4gICAgICovXG4gICAgYXR0YWNoZXJSZWZzLmJpbmQodGhpcywgJ2hvc3QnKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFNoYXBlSW1wbCNhdHRhY2hlcnNcbiAgICAgKiBAdHlwZSBTaGFwZVxuICAgICAqL1xuICAgIGF0dGFjaGVyUmVmcy5iaW5kKHRoaXMsICdhdHRhY2hlcnMnKTtcbiAgfVxuXG4gIGUoU2hhcGVJbXBsLCBFbGVtZW50SW1wbCk7XG5cblxuICAvKipcbiAgICogQSByb290IGdyYXBoaWNhbCBvYmplY3RcbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAZXh0ZW5kcyBFbGVtZW50SW1wbFxuICAgKi9cbiAgZnVuY3Rpb24gUm9vdEltcGwoKSB7XG4gICAgRWxlbWVudEltcGwuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsaXN0IG9mIGNoaWxkcmVuXG4gICAgICpcbiAgICAgKiBAbmFtZSBSb290SW1wbCNjaGlsZHJlblxuICAgICAqIEB0eXBlIEVsZW1lbnRbXVxuICAgICAqL1xuICAgIHBhcmVudFJlZnMuYmluZCh0aGlzLCAnY2hpbGRyZW4nKTtcbiAgfVxuXG4gIGUoUm9vdEltcGwsIFNoYXBlSW1wbCk7XG5cblxuICAvKipcbiAgICogQSBsYWJlbCBmb3IgYW4gZWxlbWVudFxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBleHRlbmRzIFNoYXBlSW1wbFxuICAgKi9cbiAgZnVuY3Rpb24gTGFiZWxJbXBsKCkge1xuICAgIFNoYXBlSW1wbC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsZWQgZWxlbWVudFxuICAgICAqXG4gICAgICogQG5hbWUgTGFiZWxJbXBsI2xhYmVsVGFyZ2V0XG4gICAgICogQHR5cGUgRWxlbWVudFxuICAgICAqL1xuICAgIGxhYmVsUmVmcy5iaW5kKHRoaXMsICdsYWJlbFRhcmdldCcpO1xuICB9XG5cbiAgZShMYWJlbEltcGwsIFNoYXBlSW1wbCk7XG5cblxuICAvKipcbiAgICogQSBjb25uZWN0aW9uIGJldHdlZW4gdHdvIGVsZW1lbnRzXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAY29uc3RydWN0b3JcbiAgICpcbiAgICogQGV4dGVuZHMgRWxlbWVudEltcGxcbiAgICovXG4gIGZ1bmN0aW9uIENvbm5lY3Rpb25JbXBsKCkge1xuICAgIEVsZW1lbnRJbXBsLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWxlbWVudCB0aGlzIGNvbm5lY3Rpb24gb3JpZ2luYXRlcyBmcm9tXG4gICAgICpcbiAgICAgKiBAbmFtZSBDb25uZWN0aW9uSW1wbCNzb3VyY2VcbiAgICAgKiBAdHlwZSBFbGVtZW50XG4gICAgICovXG4gICAgb3V0Z29pbmdSZWZzLmJpbmQodGhpcywgJ3NvdXJjZScpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVsZW1lbnQgdGhpcyBjb25uZWN0aW9uIHBvaW50cyB0b1xuICAgICAqXG4gICAgICogQG5hbWUgQ29ubmVjdGlvbkltcGwjdGFyZ2V0XG4gICAgICogQHR5cGUgRWxlbWVudFxuICAgICAqL1xuICAgIGluY29taW5nUmVmcy5iaW5kKHRoaXMsICd0YXJnZXQnKTtcbiAgfVxuXG4gIGUoQ29ubmVjdGlvbkltcGwsIEVsZW1lbnRJbXBsKTtcblxuXG4gIHZhciB0eXBlcyQ2ID0ge1xuICAgIGNvbm5lY3Rpb246IENvbm5lY3Rpb25JbXBsLFxuICAgIHNoYXBlOiBTaGFwZUltcGwsXG4gICAgbGFiZWw6IExhYmVsSW1wbCxcbiAgICByb290OiBSb290SW1wbFxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcm9vdCBlbGVtZW50LlxuICAgKlxuICAgKiBAb3ZlcmxvcmRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBpbXBvcnQgKiBhcyBNb2RlbCBmcm9tICdkaWFncmFtLWpzL2xpYi9tb2RlbCc7XG4gICAqXG4gICAqIGNvbnN0IHJvb3QgPSBNb2RlbC5jcmVhdGUoJ3Jvb3QnLCB7XG4gICAqICAgeDogMTAwLFxuICAgKiAgIHk6IDEwMCxcbiAgICogICB3aWR0aDogMTAwLFxuICAgKiAgIGhlaWdodDogMTAwXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHsncm9vdCd9IHR5cGVcbiAgICogQHBhcmFtIHthbnl9IFthdHRyc11cbiAgICpcbiAgICogQHJldHVybiB7Um9vdH1cbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAb3ZlcmxvcmRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBpbXBvcnQgKiBhcyBNb2RlbCBmcm9tICdkaWFncmFtLWpzL2xpYi9tb2RlbCc7XG4gICAqXG4gICAqIGNvbnN0IGNvbm5lY3Rpb24gPSBNb2RlbC5jcmVhdGUoJ2Nvbm5lY3Rpb24nLCB7XG4gICAqICAgd2F5cG9pbnRzOiBbXG4gICAqICAgICB7IHg6IDEwMCwgeTogMTAwIH0sXG4gICAqICAgICB7IHg6IDIwMCwgeTogMTAwIH1cbiAgICogICBdXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHsnY29ubmVjdGlvbid9IHR5cGVcbiAgICogQHBhcmFtIHthbnl9IFthdHRyc11cbiAgICpcbiAgICogQHJldHVybiB7Q29ubmVjdGlvbn1cbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzaGFwZS5cbiAgICpcbiAgICogQG92ZXJsb3JkXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogaW1wb3J0ICogYXMgTW9kZWwgZnJvbSAnZGlhZ3JhbS1qcy9saWIvbW9kZWwnO1xuICAgKlxuICAgKiBjb25zdCBzaGFwZSA9IE1vZGVsLmNyZWF0ZSgnc2hhcGUnLCB7XG4gICAqICAgeDogMTAwLFxuICAgKiAgIHk6IDEwMCxcbiAgICogICB3aWR0aDogMTAwLFxuICAgKiAgIGhlaWdodDogMTAwXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHsnc2hhcGUnfSB0eXBlXG4gICAqIEBwYXJhbSB7YW55fSBbYXR0cnNdXG4gICAqXG4gICAqIEByZXR1cm4ge1NoYXBlfVxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGxhYmVsLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGltcG9ydCAqIGFzIE1vZGVsIGZyb20gJ2RpYWdyYW0tanMvbGliL21vZGVsJztcbiAgICpcbiAgICogY29uc3QgbGFiZWwgPSBNb2RlbC5jcmVhdGUoJ2xhYmVsJywge1xuICAgKiAgIHg6IDEwMCxcbiAgICogICB5OiAxMDAsXG4gICAqICAgd2lkdGg6IDEwMCxcbiAgICogICBoZWlnaHQ6IDEwMCxcbiAgICogICBsYWJlbFRhcmdldDogc2hhcGVcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0geydsYWJlbCd9IHR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyc11cbiAgICpcbiAgICogQHJldHVybiB7TGFiZWx9XG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGUodHlwZSwgYXR0cnMpIHtcbiAgICB2YXIgVHlwZSA9IHR5cGVzJDZbdHlwZV07XG4gICAgaWYgKCFUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gdHlwZTogPCcgKyB0eXBlICsgJz4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc2lnbiQxKG5ldyBUeXBlKCksIGF0dHJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9tb2RlbC9UeXBlcycpLkVsZW1lbnR9IEVsZW1lbnRcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vbW9kZWwvVHlwZXMnKS5Db25uZWN0aW9ufSBDb25uZWN0aW9uXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL21vZGVsL1R5cGVzJykuTGFiZWx9IExhYmVsXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL21vZGVsL1R5cGVzJykuUm9vdH0gUm9vdFxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9tb2RlbC9UeXBlcycpLlNoYXBlfSBTaGFwZVxuICAgKi9cblxuICAvKipcbiAgICogQSBmYWN0b3J5IGZvciBtb2RlbCBlbGVtZW50cy5cbiAgICpcbiAgICogQHRlbXBsYXRlIHtDb25uZWN0aW9ufSBbVD1Db25uZWN0aW9uXVxuICAgKiBAdGVtcGxhdGUge0xhYmVsfSBbVT1MYWJlbF1cbiAgICogQHRlbXBsYXRlIHtSb290fSBbVj1Sb290XVxuICAgKiBAdGVtcGxhdGUge1NoYXBlfSBbVz1TaGFwZV1cbiAgICovXG4gIGZ1bmN0aW9uIEVsZW1lbnRGYWN0b3J5KCkge1xuICAgIHRoaXMuX3VpZCA9IDEyO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJvb3QgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtQYXJ0aWFsPFJvb3Q+fSBbYXR0cnNdXG4gICAqXG4gICAqIEByZXR1cm4ge1Z9IFRoZSBjcmVhdGVkIHJvb3QgZWxlbWVudC5cbiAgICovXG4gIEVsZW1lbnRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVSb290ID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGUoJ3Jvb3QnLCBhdHRycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGxhYmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge1BhcnRpYWw8TGFiZWw+fSBbYXR0cnNdXG4gICAqXG4gICAqIEByZXR1cm4ge1V9IFRoZSBjcmVhdGVkIGxhYmVsLlxuICAgKi9cbiAgRWxlbWVudEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUxhYmVsID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGUoJ2xhYmVsJywgYXR0cnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzaGFwZS5cbiAgICpcbiAgICogQHBhcmFtIHtQYXJ0aWFsPFNoYXBlPn0gW2F0dHJzXVxuICAgKlxuICAgKiBAcmV0dXJuIHtXfSBUaGUgY3JlYXRlZCBzaGFwZS5cbiAgICovXG4gIEVsZW1lbnRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVTaGFwZSA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlKCdzaGFwZScsIGF0dHJzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtQYXJ0aWFsPENvbm5lY3Rpb24+fSBbYXR0cnNdXG4gICAqXG4gICAqIEByZXR1cm4ge1R9IFRoZSBjcmVhdGVkIGNvbm5lY3Rpb24uXG4gICAqL1xuICBFbGVtZW50RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlKCdjb25uZWN0aW9uJywgYXR0cnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSByb290IGVsZW1lbnQuXG4gICAqXG4gICAqIEBvdmVybG9yZFxuICAgKiBAcGFyYW0geydyb290J30gdHlwZVxuICAgKiBAcGFyYW0ge1BhcnRpYWw8Um9vdD59IFthdHRyc11cbiAgICogQHJldHVybiB7Vn1cbiAgICovXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzaGFwZS5cbiAgICpcbiAgICogQG92ZXJsb3JkXG4gICAqIEBwYXJhbSB7J3NoYXBlJ30gdHlwZVxuICAgKiBAcGFyYW0ge1BhcnRpYWw8U2hhcGU+fSBbYXR0cnNdXG4gICAqIEByZXR1cm4ge1d9XG4gICAqL1xuICAvKipcbiAgICogQ3JlYXRlIGEgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQG92ZXJsb3JkXG4gICAqIEBwYXJhbSB7J2Nvbm5lY3Rpb24nfSB0eXBlXG4gICAqIEBwYXJhbSB7UGFydGlhbDxDb25uZWN0aW9uPn0gW2F0dHJzXVxuICAgKiBAcmV0dXJuIHtUfVxuICAgKi9cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGxhYmVsLlxuICAgKlxuICAgKiBAcGFyYW0geydsYWJlbCd9IHR5cGVcbiAgICogQHBhcmFtIHtQYXJ0aWFsPExhYmVsPn0gW2F0dHJzXVxuICAgKiBAcmV0dXJuIHtVfVxuICAgKi9cbiAgRWxlbWVudEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKHR5cGUsIGF0dHJzKSB7XG5cbiAgICBhdHRycyA9IGFzc2lnbiQxKHt9LCBhdHRycyB8fCB7fSk7XG5cbiAgICBpZiAoIWF0dHJzLmlkKSB7XG4gICAgICBhdHRycy5pZCA9IHR5cGUgKyAnXycgKyAodGhpcy5fdWlkKyspO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGUodHlwZSwgYXR0cnMpO1xuICB9O1xuXG4gIHZhciBGTl9SRUYgPSAnX19mbic7XG5cbiAgdmFyIERFRkFVTFRfUFJJT1JJVFkkMSA9IDEwMDA7XG5cbiAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7IHtcbiAgICogICBzdG9wUHJvcGFnYXRpb24oKTogdm9pZDtcbiAgICogICBwcmV2ZW50RGVmYXVsdCgpOiB2b2lkO1xuICAgKiAgIGNhbmNlbEJ1YmJsZTogYm9vbGVhbjtcbiAgICogICBkZWZhdWx0UHJldmVudGVkOiBib29sZWFuO1xuICAgKiAgIHJldHVyblZhbHVlOiBhbnk7XG4gICAqIH0gfSBFdmVudFxuICAgKi9cblxuICAvKipcbiAgICogQHRlbXBsYXRlIEVcbiAgICpcbiAgICogQHR5cGVkZWYgeyAoZXZlbnQ6IEUgJiBFdmVudCwgLi4uYW55KSA9PiBhbnkgfSBFdmVudEJ1c0V2ZW50Q2FsbGJhY2tcbiAgICovXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHsge1xuICAgKiAgcHJpb3JpdHk6IG51bWJlcjtcbiAgICogIG5leHQ6IEV2ZW50QnVzTGlzdGVuZXIgfCBudWxsO1xuICAgKiAgY2FsbGJhY2s6IEV2ZW50QnVzRXZlbnRDYWxsYmFjazxhbnk+O1xuICAgKiB9IH0gRXZlbnRCdXNMaXN0ZW5lclxuICAgKi9cblxuICAvKipcbiAgICogQSBnZW5lcmFsIHB1cnBvc2UgZXZlbnQgYnVzLlxuICAgKlxuICAgKiBUaGlzIGNvbXBvbmVudCBpcyB1c2VkIHRvIGNvbW11bmljYXRlIGFjcm9zcyBhIGRpYWdyYW0gaW5zdGFuY2UuXG4gICAqIE90aGVyIHBhcnRzIG9mIGEgZGlhZ3JhbSBjYW4gdXNlIGl0IHRvIGxpc3RlbiB0byBhbmQgYnJvYWRjYXN0IGV2ZW50cy5cbiAgICpcbiAgICpcbiAgICogIyMgUmVnaXN0ZXJpbmcgZm9yIEV2ZW50c1xuICAgKlxuICAgKiBUaGUgZXZlbnQgYnVzIHByb3ZpZGVzIHRoZSB7QGxpbmsgRXZlbnRCdXMjb259IGFuZCB7QGxpbmsgRXZlbnRCdXMjb25jZX1cbiAgICogbWV0aG9kcyB0byByZWdpc3RlciBmb3IgZXZlbnRzLiB7QGxpbmsgRXZlbnRCdXMjb2ZmfSBjYW4gYmUgdXNlZCB0b1xuICAgKiByZW1vdmUgZXZlbnQgcmVnaXN0cmF0aW9ucy4gTGlzdGVuZXJzIHJlY2VpdmUgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIEV2ZW50fVxuICAgKiBhcyB0aGUgZmlyc3QgYXJndW1lbnQuIEl0IGFsbG93cyB0aGVtIHRvIGhvb2sgaW50byB0aGUgZXZlbnQgZXhlY3V0aW9uLlxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqXG4gICAqIC8vIGxpc3RlbiBmb3IgZXZlbnRcbiAgICogZXZlbnRCdXMub24oJ2ZvbycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAqXG4gICAqICAgLy8gYWNjZXNzIGV2ZW50IHR5cGVcbiAgICogICBldmVudC50eXBlOyAvLyAnZm9vJ1xuICAgKlxuICAgKiAgIC8vIHN0b3AgcHJvcGFnYXRpb24gdG8gb3RoZXIgbGlzdGVuZXJzXG4gICAqICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAqXG4gICAqICAgLy8gcHJldmVudCBldmVudCBkZWZhdWx0XG4gICAqICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICogfSk7XG4gICAqXG4gICAqIC8vIGxpc3RlbiBmb3IgZXZlbnQgd2l0aCBjdXN0b20gcGF5bG9hZFxuICAgKiBldmVudEJ1cy5vbignYmFyJywgZnVuY3Rpb24oZXZlbnQsIHBheWxvYWQpIHtcbiAgICogICBjb25zb2xlLmxvZyhwYXlsb2FkKTtcbiAgICogfSk7XG4gICAqXG4gICAqIC8vIGxpc3RlbiBmb3IgZXZlbnQgcmV0dXJuaW5nIHZhbHVlXG4gICAqIGV2ZW50QnVzLm9uKCdmb29iYXInLCBmdW5jdGlvbihldmVudCkge1xuICAgKlxuICAgKiAgIC8vIHN0b3AgZXZlbnQgcHJvcGFnYXRpb24gKyBwcmV2ZW50IGRlZmF1bHRcbiAgICogICByZXR1cm4gZmFsc2U7XG4gICAqXG4gICAqICAgLy8gc3RvcCBldmVudCBwcm9wYWdhdGlvbiArIHJldHVybiBjdXN0b20gcmVzdWx0XG4gICAqICAgcmV0dXJuIHtcbiAgICogICAgIGNvbXBsZXg6ICdsaXN0ZW5pbmcgcmVzdWx0J1xuICAgKiAgIH07XG4gICAqIH0pO1xuICAgKlxuICAgKlxuICAgKiAvLyBsaXN0ZW4gd2l0aCBjdXN0b20gcHJpb3JpdHkgKGRlZmF1bHQ9MTAwMCwgaGlnaGVyIGlzIGJldHRlcilcbiAgICogZXZlbnRCdXMub24oJ3ByaW9yaXR5Zm9vJywgMTUwMCwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICogICBjb25zb2xlLmxvZygnaW52b2tlZCBmaXJzdCEnKTtcbiAgICogfSk7XG4gICAqXG4gICAqXG4gICAqIC8vIGxpc3RlbiBmb3IgZXZlbnQgYW5kIHBhc3MgdGhlIGNvbnRleHQgKGB0aGlzYClcbiAgICogZXZlbnRCdXMub24oJ2Zvb2JhcicsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAqICAgdGhpcy5mb28oKTtcbiAgICogfSwgdGhpcyk7XG4gICAqIGBgYFxuICAgKlxuICAgKlxuICAgKiAjIyBFbWl0dGluZyBFdmVudHNcbiAgICpcbiAgICogRXZlbnRzIGNhbiBiZSBlbWl0dGVkIHZpYSB0aGUgZXZlbnQgYnVzIHVzaW5nIHtAbGluayBFdmVudEJ1cyNmaXJlfS5cbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKlxuICAgKiAvLyBmYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgZGVmYXVsdCBhY3Rpb25cbiAgICogLy8gd2FzIHByZXZlbnRlZCBieSBsaXN0ZW5lcnNcbiAgICogaWYgKGV2ZW50QnVzLmZpcmUoJ2ZvbycpID09PSBmYWxzZSkge1xuICAgKiAgIGNvbnNvbGUubG9nKCdkZWZhdWx0IGhhcyBiZWVuIHByZXZlbnRlZCEnKTtcbiAgICogfTtcbiAgICpcbiAgICpcbiAgICogLy8gY3VzdG9tIGFyZ3MgKyByZXR1cm4gdmFsdWUgbGlzdGVuZXJcbiAgICogZXZlbnRCdXMub24oJ3N1bScsIGZ1bmN0aW9uKGV2ZW50LCBhLCBiKSB7XG4gICAqICAgcmV0dXJuIGEgKyBiO1xuICAgKiB9KTtcbiAgICpcbiAgICogLy8geW91IGNhbiBwYXNzIGN1c3RvbSBhcmd1bWVudHMgKyByZXRyaWV2ZSByZXN1bHQgdmFsdWVzLlxuICAgKiB2YXIgc3VtID0gZXZlbnRCdXMuZmlyZSgnc3VtJywgMSwgMik7XG4gICAqIGNvbnNvbGUubG9nKHN1bSk7IC8vIDNcbiAgICogYGBgXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBbRXZlbnRNYXA9bnVsbF1cbiAgICovXG4gIGZ1bmN0aW9uIEV2ZW50QnVzKCkge1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyBSZWNvcmQ8c3RyaW5nLCBFdmVudEJ1c0xpc3RlbmVyPiB9XG4gICAgICovXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG5cbiAgICAvLyBjbGVhbnVwIG9uIGRlc3Ryb3kgb24gbG93ZXN0IHByaW9yaXR5IHRvIGFsbG93XG4gICAgLy8gbWVzc2FnZSBwYXNzaW5nIHVudGlsIHRoZSBiaXR0ZXIgZW5kXG4gICAgdGhpcy5vbignZGlhZ3JhbS5kZXN0cm95JywgMSwgdGhpcy5fZGVzdHJveSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJsb3JkXG4gICAqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyIGZvciBldmVudHMgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICpcbiAgICogVGhlIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCB3aXRoIGBldmVudCwgLi4uYWRkaXRpb25hbEFyZ3VtZW50c2BcbiAgICogdGhhdCBoYXZlIGJlZW4gcGFzc2VkIHRvIHtAbGluayBFdmVudEJ1cyNmaXJlfS5cbiAgICpcbiAgICogUmV0dXJuaW5nIGZhbHNlIGZyb20gYSBsaXN0ZW5lciB3aWxsIHByZXZlbnQgdGhlIGV2ZW50cyBkZWZhdWx0IGFjdGlvblxuICAgKiAoaWYgYW55IGlzIHNwZWNpZmllZCkuIFRvIHN0b3AgYW4gZXZlbnQgZnJvbSBiZWluZyBwcm9jZXNzZWQgZnVydGhlciBpblxuICAgKiBvdGhlciBsaXN0ZW5lcnMgZXhlY3V0ZSB7QGxpbmsgRXZlbnQjc3RvcFByb3BhZ2F0aW9ufS5cbiAgICpcbiAgICogUmV0dXJuaW5nIGFueXRoaW5nIGJ1dCBgdW5kZWZpbmVkYCBmcm9tIGEgbGlzdGVuZXIgd2lsbCBzdG9wIHRoZSBsaXN0ZW5lciBwcm9wYWdhdGlvbi5cbiAgICpcbiAgICogQHRlbXBsYXRlIFRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGV2ZW50cyB0byBzdWJzY3JpYmUgdG9cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT0xMDAwXSBsaXN0ZW4gcHJpb3JpdHlcbiAgICogQHBhcmFtIHtFdmVudEJ1c0V2ZW50Q2FsbGJhY2s8VD59IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7YW55fSBbdGhhdF0gY2FsbGJhY2sgY29udGV4dFxuICAgKi9cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyIGZvciBldmVudHMgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICpcbiAgICogVGhlIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCB3aXRoIGBldmVudCwgLi4uYWRkaXRpb25hbEFyZ3VtZW50c2BcbiAgICogdGhhdCBoYXZlIGJlZW4gcGFzc2VkIHRvIHtAbGluayBFdmVudEJ1cyNmaXJlfS5cbiAgICpcbiAgICogUmV0dXJuaW5nIGZhbHNlIGZyb20gYSBsaXN0ZW5lciB3aWxsIHByZXZlbnQgdGhlIGV2ZW50cyBkZWZhdWx0IGFjdGlvblxuICAgKiAoaWYgYW55IGlzIHNwZWNpZmllZCkuIFRvIHN0b3AgYW4gZXZlbnQgZnJvbSBiZWluZyBwcm9jZXNzZWQgZnVydGhlciBpblxuICAgKiBvdGhlciBsaXN0ZW5lcnMgZXhlY3V0ZSB7QGxpbmsgRXZlbnQjc3RvcFByb3BhZ2F0aW9ufS5cbiAgICpcbiAgICogUmV0dXJuaW5nIGFueXRoaW5nIGJ1dCBgdW5kZWZpbmVkYCBmcm9tIGEgbGlzdGVuZXIgd2lsbCBzdG9wIHRoZSBsaXN0ZW5lciBwcm9wYWdhdGlvbi5cbiAgICpcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBFdmVudE1hcH0gRXZlbnROYW1lXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnROYW1lfSBldmVudHMgdG8gc3Vic2NyaWJlIHRvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHk9MTAwMF0gbGlzdGVuIHByaW9yaXR5XG4gICAqIEBwYXJhbSB7RXZlbnRCdXNFdmVudENhbGxiYWNrPEV2ZW50TWFwW0V2ZW50TmFtZV0+fSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge2FueX0gW3RoYXRdIGNhbGxiYWNrIGNvbnRleHRcbiAgICovXG4gIEV2ZW50QnVzLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50cywgcHJpb3JpdHksIGNhbGxiYWNrLCB0aGF0KSB7XG5cbiAgICBldmVudHMgPSBpc0FycmF5JDIoZXZlbnRzKSA/IGV2ZW50cyA6IFsgZXZlbnRzIF07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihwcmlvcml0eSkpIHtcbiAgICAgIHRoYXQgPSBjYWxsYmFjaztcbiAgICAgIGNhbGxiYWNrID0gcHJpb3JpdHk7XG4gICAgICBwcmlvcml0eSA9IERFRkFVTFRfUFJJT1JJVFkkMTtcbiAgICB9XG5cbiAgICBpZiAoIWlzTnVtYmVyKHByaW9yaXR5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmlvcml0eSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuXG4gICAgdmFyIGFjdHVhbENhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICBpZiAodGhhdCkge1xuICAgICAgYWN0dWFsQ2FsbGJhY2sgPSBiaW5kJDIoY2FsbGJhY2ssIHRoYXQpO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgd2UgcmVtZW1iZXIgYW5kIGFyZSBhYmxlIHRvIHJlbW92ZVxuICAgICAgLy8gYm91bmQgY2FsbGJhY2tzIHZpYSB7QGxpbmsgI29mZn0gdXNpbmcgdGhlIG9yaWdpbmFsXG4gICAgICAvLyBjYWxsYmFja1xuICAgICAgYWN0dWFsQ2FsbGJhY2tbRk5fUkVGXSA9IGNhbGxiYWNrW0ZOX1JFRl0gfHwgY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgc2VsZi5fYWRkTGlzdGVuZXIoZSwge1xuICAgICAgICBwcmlvcml0eTogcHJpb3JpdHksXG4gICAgICAgIGNhbGxiYWNrOiBhY3R1YWxDYWxsYmFjayxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVybG9yZFxuICAgKlxuICAgKiBSZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBldmVudHMgdG8gc3Vic2NyaWJlIHRvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHk9MTAwMF0gdGhlIGxpc3RlbiBwcmlvcml0eVxuICAgKiBAcGFyYW0ge0V2ZW50QnVzRXZlbnRDYWxsYmFjazxUPn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHthbnl9IFt0aGF0XSBjYWxsYmFjayBjb250ZXh0XG4gICAqL1xuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBpcyBjYWxsZWQgb25seSBvbmNlLlxuICAgKlxuICAgKiBAdGVtcGxhdGUge2tleW9mIEV2ZW50TWFwfSBFdmVudE5hbWVcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudE5hbWV9IGV2ZW50cyB0byBzdWJzY3JpYmUgdG9cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT0xMDAwXSBsaXN0ZW4gcHJpb3JpdHlcbiAgICogQHBhcmFtIHtFdmVudEJ1c0V2ZW50Q2FsbGJhY2s8RXZlbnRNYXBbRXZlbnROYW1lXT59IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7YW55fSBbdGhhdF0gY2FsbGJhY2sgY29udGV4dFxuICAgKi9cbiAgRXZlbnRCdXMucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudHMsIHByaW9yaXR5LCBjYWxsYmFjaywgdGhhdCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChpc0Z1bmN0aW9uKHByaW9yaXR5KSkge1xuICAgICAgdGhhdCA9IGNhbGxiYWNrO1xuICAgICAgY2FsbGJhY2sgPSBwcmlvcml0eTtcbiAgICAgIHByaW9yaXR5ID0gREVGQVVMVF9QUklPUklUWSQxO1xuICAgIH1cblxuICAgIGlmICghaXNOdW1iZXIocHJpb3JpdHkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByaW9yaXR5IG11c3QgYmUgYSBudW1iZXInKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwcGVkQ2FsbGJhY2soKSB7XG4gICAgICB3cmFwcGVkQ2FsbGJhY2suX19pc1RvbWIgPSB0cnVlO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2suYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcblxuICAgICAgc2VsZi5vZmYoZXZlbnRzLCB3cmFwcGVkQ2FsbGJhY2spO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB3ZSByZW1lbWJlciBhbmQgYXJlIGFibGUgdG8gcmVtb3ZlXG4gICAgLy8gYm91bmQgY2FsbGJhY2tzIHZpYSB7QGxpbmsgI29mZn0gdXNpbmcgdGhlIG9yaWdpbmFsXG4gICAgLy8gY2FsbGJhY2tcbiAgICB3cmFwcGVkQ2FsbGJhY2tbRk5fUkVGXSA9IGNhbGxiYWNrO1xuXG4gICAgdGhpcy5vbihldmVudHMsIHByaW9yaXR5LCB3cmFwcGVkQ2FsbGJhY2spO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzIGJ5IGV2ZW50IGFuZCBjYWxsYmFjay5cbiAgICpcbiAgICogSWYgbm8gY2FsbGJhY2sgaXMgZ2l2ZW4sIGFsbCBsaXN0ZW5lcnMgZm9yIGEgZ2l2ZW4gZXZlbnQgbmFtZSBhcmUgYmVpbmcgcmVtb3ZlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGV2ZW50c1xuICAgKiBAcGFyYW0ge0V2ZW50QnVzRXZlbnRDYWxsYmFjazx1bmtub3duPn0gW2NhbGxiYWNrXVxuICAgKi9cbiAgRXZlbnRCdXMucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKGV2ZW50cywgY2FsbGJhY2spIHtcblxuICAgIGV2ZW50cyA9IGlzQXJyYXkkMihldmVudHMpID8gZXZlbnRzIDogWyBldmVudHMgXTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBzZWxmLl9yZW1vdmVMaXN0ZW5lcihldmVudCwgY2FsbGJhY2spO1xuICAgIH0pO1xuXG4gIH07XG5cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGV2ZW50IHJlY29nbml6ZWQgYmUgdGhlIGV2ZW50IGJ1cy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgRXZlbnQgZGF0YS5cbiAgICpcbiAgICogQHJldHVybiB7RXZlbnR9IEFuIGV2ZW50IHRoYXQgd2lsbCBiZSByZWNvZ25pemVkIGJ5IHRoZSBldmVudCBidXMuXG4gICAqL1xuICBFdmVudEJ1cy5wcm90b3R5cGUuY3JlYXRlRXZlbnQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IEludGVybmFsRXZlbnQoKTtcblxuICAgIGV2ZW50LmluaXQoZGF0YSk7XG5cbiAgICByZXR1cm4gZXZlbnQ7XG4gIH07XG5cblxuICAvKipcbiAgICogRmlyZXMgYW4gZXZlbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gZmlyZSBldmVudCBieSBuYW1lXG4gICAqIGV2ZW50cy5maXJlKCdmb28nKTtcbiAgICpcbiAgICogLy8gZmlyZSBldmVudCBvYmplY3Qgd2l0aCBuZXN0ZWQgdHlwZVxuICAgKiB2YXIgZXZlbnQgPSB7IHR5cGU6ICdmb28nIH07XG4gICAqIGV2ZW50cy5maXJlKGV2ZW50KTtcbiAgICpcbiAgICogLy8gZmlyZSBldmVudCB3aXRoIGV4cGxpY2l0IHR5cGVcbiAgICogdmFyIGV2ZW50ID0geyB4OiAxMCwgeTogMjAgfTtcbiAgICogZXZlbnRzLmZpcmUoJ2VsZW1lbnQubW92ZWQnLCBldmVudCk7XG4gICAqXG4gICAqIC8vIHBhc3MgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gdGhlIGV2ZW50XG4gICAqIGV2ZW50cy5vbignZm9vJywgZnVuY3Rpb24oZXZlbnQsIGJhcikge1xuICAgKiAgIGFsZXJ0KGJhcik7XG4gICAqIH0pO1xuICAgKlxuICAgKiBldmVudHMuZmlyZSh7IHR5cGU6ICdmb28nIH0sICdJIGFtIGJhciEnKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIGV2ZW50IG9yIGV2ZW50IGRhdGFcbiAgICogQHBhcmFtIHsuLi5hbnl9IFthcmdzXSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aC5cbiAgICpcbiAgICogQHJldHVybiB7YW55fSBUaGUgcmV0dXJuIHZhbHVlLiBXaWxsIGJlIHNldCB0byBgZmFsc2VgIGlmIHRoZSBkZWZhdWx0IHdhcyBwcmV2ZW50ZWQuXG4gICAqL1xuICBFdmVudEJ1cy5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICB2YXIgZXZlbnQsXG4gICAgICAgIGZpcnN0TGlzdGVuZXIsXG4gICAgICAgIHJldHVyblZhbHVlLFxuICAgICAgICBhcmdzO1xuXG4gICAgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGRhdGEgPSB0eXBlO1xuICAgICAgdHlwZSA9IGRhdGEudHlwZTtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gZXZlbnQgdHlwZSBzcGVjaWZpZWQnKTtcbiAgICB9XG5cbiAgICBmaXJzdExpc3RlbmVyID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuXG4gICAgaWYgKCFmaXJzdExpc3RlbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gd2UgbWFrZSBzdXJlIHdlIGZpcmUgaW5zdGFuY2VzIG9mIG91ciBob21lIG1hZGVcbiAgICAvLyBldmVudHMgaGVyZS4gV2Ugd3JhcCB0aGVtIG9ubHkgb25jZSwgdGhvdWdoXG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBJbnRlcm5hbEV2ZW50KSB7XG5cbiAgICAgIC8vIHdlIGFyZSBmaW5lLCB3ZSBhbHJlYWQgaGF2ZSBhbiBldmVudFxuICAgICAgZXZlbnQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudCA9IHRoaXMuY3JlYXRlRXZlbnQoZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHdlIHBhc3MgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXJcbiAgICBhcmdzWzBdID0gZXZlbnQ7XG5cbiAgICAvLyBvcmlnaW5hbCBldmVudCB0eXBlIChpbiBjYXNlIHdlIGRlbGVnYXRlKVxuICAgIHZhciBvcmlnaW5hbFR5cGUgPSBldmVudC50eXBlO1xuXG4gICAgLy8gdXBkYXRlIGV2ZW50IHR5cGUgYmVmb3JlIGRlbGVnYXRpb25cbiAgICBpZiAodHlwZSAhPT0gb3JpZ2luYWxUeXBlKSB7XG4gICAgICBldmVudC50eXBlID0gdHlwZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuVmFsdWUgPSB0aGlzLl9pbnZva2VMaXN0ZW5lcnMoZXZlbnQsIGFyZ3MsIGZpcnN0TGlzdGVuZXIpO1xuICAgIH0gZmluYWxseSB7XG5cbiAgICAgIC8vIHJlc2V0IGV2ZW50IHR5cGUgYWZ0ZXIgZGVsZWdhdGlvblxuICAgICAgaWYgKHR5cGUgIT09IG9yaWdpbmFsVHlwZSkge1xuICAgICAgICBldmVudC50eXBlID0gb3JpZ2luYWxUeXBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldCB0aGUgcmV0dXJuIHZhbHVlIHRvIGZhbHNlIGlmIHRoZSBldmVudCBkZWZhdWx0XG4gICAgLy8gZ290IHByZXZlbnRlZCBhbmQgbm8gb3RoZXIgcmV0dXJuIHZhbHVlIGV4aXN0c1xuICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gdW5kZWZpbmVkICYmIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYW4gZXJyb3IgYnkgZmlyaW5nIGFuIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gYmUgaGFuZGxlZC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZXJyb3Igd2FzIGhhbmRsZWQuXG4gICAqL1xuICBFdmVudEJ1cy5wcm90b3R5cGUuaGFuZGxlRXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xuICAgIHJldHVybiB0aGlzLmZpcmUoJ2Vycm9yJywgeyBlcnJvcjogZXJyb3IgfSkgPT09IGZhbHNlO1xuICB9O1xuXG5cbiAgRXZlbnRCdXMucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAgICogQHBhcmFtIHtFdmVudEJ1c0xpc3RlbmVyfSBsaXN0ZW5lclxuICAgKlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICBFdmVudEJ1cy5wcm90b3R5cGUuX2ludm9rZUxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50LCBhcmdzLCBsaXN0ZW5lcikge1xuXG4gICAgdmFyIHJldHVyblZhbHVlO1xuXG4gICAgd2hpbGUgKGxpc3RlbmVyKSB7XG5cbiAgICAgIC8vIGhhbmRsZSBzdG9wcGVkIHByb3BhZ2F0aW9uXG4gICAgICBpZiAoZXZlbnQuY2FuY2VsQnViYmxlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm5WYWx1ZSA9IHRoaXMuX2ludm9rZUxpc3RlbmVyKGV2ZW50LCBhcmdzLCBsaXN0ZW5lcik7XG5cbiAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAgICogQHBhcmFtIHtFdmVudEJ1c0xpc3RlbmVyfSBsaXN0ZW5lclxuICAgKlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICBFdmVudEJ1cy5wcm90b3R5cGUuX2ludm9rZUxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGFyZ3MsIGxpc3RlbmVyKSB7XG5cbiAgICB2YXIgcmV0dXJuVmFsdWU7XG5cbiAgICBpZiAobGlzdGVuZXIuY2FsbGJhY2suX19pc1RvbWIpIHtcbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuXG4gICAgICAvLyByZXR1cm5pbmcgZmFsc2UgcHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uXG4gICAgICByZXR1cm5WYWx1ZSA9IGludm9rZUZ1bmN0aW9uKGxpc3RlbmVyLmNhbGxiYWNrLCBhcmdzKTtcblxuICAgICAgLy8gc3RvcCBwcm9wYWdhdGlvbiBvbiByZXR1cm4gdmFsdWVcbiAgICAgIGlmIChyZXR1cm5WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gcmV0dXJuVmFsdWU7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICAvLyBwcmV2ZW50IGRlZmF1bHQgb24gcmV0dXJuIGZhbHNlXG4gICAgICBpZiAocmV0dXJuVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghdGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcigndW5oYW5kbGVkIGVycm9yIGluIGV2ZW50IGxpc3RlbmVyJywgZXJyb3IpO1xuXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIG5ldyBsaXN0ZW5lciB3aXRoIGEgY2VydGFpbiBwcmlvcml0eSB0byB0aGUgbGlzdFxuICAgKiBvZiBsaXN0ZW5lcnMgKGZvciB0aGUgZ2l2ZW4gZXZlbnQpLlxuICAgKlxuICAgKiBUaGUgc2VtYW50aWNzIG9mIGxpc3RlbmVyIHJlZ2lzdHJhdGlvbiAvIGxpc3RlbmVyIGV4ZWN1dGlvbiBhcmVcbiAgICogZmlyc3QgcmVnaXN0ZXIsIGZpcnN0IHNlcnZlOiBOZXcgbGlzdGVuZXJzIHdpbGwgYWx3YXlzIGJlIGluc2VydGVkXG4gICAqIGFmdGVyIGV4aXN0aW5nIGxpc3RlbmVycyB3aXRoIHRoZSBzYW1lIHByaW9yaXR5LlxuICAgKlxuICAgKiBFeGFtcGxlOiBJbnNlcnRpbmcgdHdvIGxpc3RlbmVycyB3aXRoIHByaW9yaXR5IDEwMDAgYW5kIDEzMDBcbiAgICpcbiAgICogICAgKiBiZWZvcmU6IFsgMTUwMCwgMTUwMCwgMTAwMCwgMTAwMCBdXG4gICAqICAgICogYWZ0ZXI6IFsgMTUwMCwgMTUwMCwgKG5ldz0xMzAwKSwgMTAwMCwgMTAwMCwgKG5ldz0xMDAwKSBdXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0V2ZW50QnVzTGlzdGVuZXJ9IG5ld0xpc3RlbmVyXG4gICAqL1xuICBFdmVudEJ1cy5wcm90b3R5cGUuX2FkZExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIG5ld0xpc3RlbmVyKSB7XG5cbiAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLl9nZXRMaXN0ZW5lcnMoZXZlbnQpLFxuICAgICAgICBwcmV2aW91c0xpc3RlbmVyO1xuXG4gICAgLy8gbm8gcHJpb3IgbGlzdGVuZXJzXG4gICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgdGhpcy5fc2V0TGlzdGVuZXJzKGV2ZW50LCBuZXdMaXN0ZW5lcik7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgd2Ugb3JkZXIgbGlzdGVuZXJzIGJ5IHByaW9yaXR5IGZyb21cbiAgICAvLyAwIChoaWdoKSB0byBuID4gMCAobG93KVxuICAgIHdoaWxlIChsaXN0ZW5lcikge1xuXG4gICAgICBpZiAobGlzdGVuZXIucHJpb3JpdHkgPCBuZXdMaXN0ZW5lci5wcmlvcml0eSkge1xuXG4gICAgICAgIG5ld0xpc3RlbmVyLm5leHQgPSBsaXN0ZW5lcjtcblxuICAgICAgICBpZiAocHJldmlvdXNMaXN0ZW5lcikge1xuICAgICAgICAgIHByZXZpb3VzTGlzdGVuZXIubmV4dCA9IG5ld0xpc3RlbmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NldExpc3RlbmVycyhldmVudCwgbmV3TGlzdGVuZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwcmV2aW91c0xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XG4gICAgfVxuXG4gICAgLy8gYWRkIG5ldyBsaXN0ZW5lciB0byBiYWNrXG4gICAgcHJldmlvdXNMaXN0ZW5lci5uZXh0ID0gbmV3TGlzdGVuZXI7XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICpcbiAgICogQHJldHVybiB7RXZlbnRCdXNMaXN0ZW5lcn1cbiAgICovXG4gIEV2ZW50QnVzLnByb3RvdHlwZS5fZ2V0TGlzdGVuZXJzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcnNbbmFtZV07XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RXZlbnRCdXNMaXN0ZW5lcn0gbGlzdGVuZXJcbiAgICovXG4gIEV2ZW50QnVzLnByb3RvdHlwZS5fc2V0TGlzdGVuZXJzID0gZnVuY3Rpb24obmFtZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV0gPSBsaXN0ZW5lcjtcbiAgfTtcblxuICBFdmVudEJ1cy5wcm90b3R5cGUuX3JlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKSB7XG5cbiAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLl9nZXRMaXN0ZW5lcnMoZXZlbnQpLFxuICAgICAgICBuZXh0TGlzdGVuZXIsXG4gICAgICAgIHByZXZpb3VzTGlzdGVuZXIsXG4gICAgICAgIGxpc3RlbmVyQ2FsbGJhY2s7XG5cbiAgICBpZiAoIWNhbGxiYWNrKSB7XG5cbiAgICAgIC8vIGNsZWFyIGxpc3RlbmVyc1xuICAgICAgdGhpcy5fc2V0TGlzdGVuZXJzKGV2ZW50LCBudWxsKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdoaWxlIChsaXN0ZW5lcikge1xuXG4gICAgICBuZXh0TGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuXG4gICAgICBsaXN0ZW5lckNhbGxiYWNrID0gbGlzdGVuZXIuY2FsbGJhY2s7XG5cbiAgICAgIGlmIChsaXN0ZW5lckNhbGxiYWNrID09PSBjYWxsYmFjayB8fCBsaXN0ZW5lckNhbGxiYWNrW0ZOX1JFRl0gPT09IGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChwcmV2aW91c0xpc3RlbmVyKSB7XG4gICAgICAgICAgcHJldmlvdXNMaXN0ZW5lci5uZXh0ID0gbmV4dExpc3RlbmVyO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gbmV3IGZpcnN0IGxpc3RlbmVyXG4gICAgICAgICAgdGhpcy5fc2V0TGlzdGVuZXJzKGV2ZW50LCBuZXh0TGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzTGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgIGxpc3RlbmVyID0gbmV4dExpc3RlbmVyO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQSBldmVudCB0aGF0IGlzIGVtaXR0ZWQgdmlhIHRoZSBldmVudCBidXMuXG4gICAqL1xuICBmdW5jdGlvbiBJbnRlcm5hbEV2ZW50KCkgeyB9XG5cbiAgSW50ZXJuYWxFdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICB9O1xuXG4gIEludGVybmFsRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgfTtcblxuICBJbnRlcm5hbEV2ZW50LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGFzc2lnbiQxKHRoaXMsIGRhdGEgfHwge30pO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEludm9rZSBmdW5jdGlvbi4gQmUgZmFzdC4uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gICAqXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmN0aW9uKGZuLCBhcmdzKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNWR3MgZm9yIGVsZW1lbnRzIGFyZSBnZW5lcmF0ZWQgYnkgdGhlIHtAbGluayBHcmFwaGljc0ZhY3Rvcnl9LlxuICAgKlxuICAgKiBUaGlzIHV0aWxpdHkgZ2l2ZXMgcXVpY2sgYWNjZXNzIHRvIHRoZSBpbXBvcnRhbnQgc2VtYW50aWNcbiAgICogcGFydHMgb2YgYW4gZWxlbWVudC5cbiAgICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZpc3VhbCBwYXJ0IG9mIGEgZGlhZ3JhbSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGdmeFxuICAgKlxuICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VmlzdWFsKGdmeCkge1xuICAgIHJldHVybiBnZnguY2hpbGROb2Rlc1swXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjaGlsZHJlbiBmb3IgYSBnaXZlbiBkaWFncmFtIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZ2Z4XG4gICAqIEByZXR1cm4ge1NWR0VsZW1lbnR9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRDaGlsZHJlbihnZngpIHtcbiAgICByZXR1cm4gZ2Z4LnBhcmVudE5vZGUuY2hpbGROb2Rlc1sxXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuL1R5cGVzJykuQ29ubmVjdGlvbkxpa2V9IENvbm5lY3Rpb25MaWtlXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vVHlwZXMnKS5FbGVtZW50TGlrZX0gRWxlbWVudExpa2VcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi9UeXBlcycpLlNoYXBlTGlrZX0gU2hhcGVMaWtlXG4gICAqXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vRWxlbWVudFJlZ2lzdHJ5JykuZGVmYXVsdH0gRWxlbWVudFJlZ2lzdHJ5XG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vRXZlbnRCdXMnKS5kZWZhdWx0fSBFdmVudEJ1c1xuICAgKi9cblxuICAvKipcbiAgICogQSBmYWN0b3J5IHRoYXQgY3JlYXRlcyBncmFwaGljYWwgZWxlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gICAqIEBwYXJhbSB7RWxlbWVudFJlZ2lzdHJ5fSBlbGVtZW50UmVnaXN0cnlcbiAgICovXG4gIGZ1bmN0aW9uIEdyYXBoaWNzRmFjdG9yeShldmVudEJ1cywgZWxlbWVudFJlZ2lzdHJ5KSB7XG4gICAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgICB0aGlzLl9lbGVtZW50UmVnaXN0cnkgPSBlbGVtZW50UmVnaXN0cnk7XG4gIH1cblxuICBHcmFwaGljc0ZhY3RvcnkuJGluamVjdCA9IFsgJ2V2ZW50QnVzJyAsICdlbGVtZW50UmVnaXN0cnknIF07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IHsgcGFyZW50PzogYW55IH0gfSBlbGVtZW50XG4gICAqIEByZXR1cm4ge1NWR0VsZW1lbnR9XG4gICAqL1xuICBHcmFwaGljc0ZhY3RvcnkucHJvdG90eXBlLl9nZXRDaGlsZHJlbkNvbnRhaW5lciA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAgIHZhciBnZnggPSB0aGlzLl9lbGVtZW50UmVnaXN0cnkuZ2V0R3JhcGhpY3MoZWxlbWVudCk7XG5cbiAgICB2YXIgY2hpbGRyZW5HZng7XG5cbiAgICAvLyByb290IGVsZW1lbnRcbiAgICBpZiAoIWVsZW1lbnQucGFyZW50KSB7XG4gICAgICBjaGlsZHJlbkdmeCA9IGdmeDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGRyZW5HZnggPSBnZXRDaGlsZHJlbihnZngpO1xuICAgICAgaWYgKCFjaGlsZHJlbkdmeCkge1xuICAgICAgICBjaGlsZHJlbkdmeCA9IGNyZWF0ZSQxKCdnJyk7XG4gICAgICAgIGNsYXNzZXMkMShjaGlsZHJlbkdmeCkuYWRkKCdkanMtY2hpbGRyZW4nKTtcblxuICAgICAgICBhcHBlbmQoZ2Z4LnBhcmVudE5vZGUsIGNoaWxkcmVuR2Z4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGRyZW5HZng7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgZ3JhcGhpY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlbGVtZW50IGFuZCByZXR1cm5zIHRoZVxuICAgKiBjbGVhcmVkIHZpc3VhbCAodGhlIDxnIGNsYXNzPVwiZGpzLXZpc3VhbFwiIC8+IGVsZW1lbnQpLlxuICAgKi9cbiAgR3JhcGhpY3NGYWN0b3J5LnByb3RvdHlwZS5fY2xlYXIgPSBmdW5jdGlvbihnZngpIHtcbiAgICB2YXIgdmlzdWFsID0gZ2V0VmlzdWFsKGdmeCk7XG5cbiAgICBjbGVhcih2aXN1YWwpO1xuXG4gICAgcmV0dXJuIHZpc3VhbDtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGdmeCBjb250YWluZXIgZm9yIHNoYXBlcyBhbmQgY29ubmVjdGlvbnNcbiAgICpcbiAgICogVGhlIGxheW91dCBpcyBhcyBmb2xsb3dzOlxuICAgKlxuICAgKiA8ZyBjbGFzcz1cImRqcy1ncm91cFwiPlxuICAgKlxuICAgKiAgIDwhLS0gdGhlIGdmeCAtLT5cbiAgICogICA8ZyBjbGFzcz1cImRqcy1lbGVtZW50IGRqcy0oc2hhcGV8Y29ubmVjdGlvbnxmcmFtZSlcIj5cbiAgICogICAgIDxnIGNsYXNzPVwiZGpzLXZpc3VhbFwiPlxuICAgKiAgICAgICA8IS0tIHRoZSByZW5kZXJlciBkcmF3cyBpbiBoZXJlIC0tPlxuICAgKiAgICAgPC9nPlxuICAgKlxuICAgKiAgICAgPCEtLSBleHRlbnNpb25zIChvdmVybGF5cywgY2xpY2sgYm94LCAuLi4pIGdvZXMgaGVyZVxuICAgKiAgIDwvZz5cbiAgICpcbiAgICogICA8IS0tIHRoZSBnZnggY2hpbGQgbm9kZXMgLS0+XG4gICAqICAgPGcgY2xhc3M9XCJkanMtY2hpbGRyZW5cIj48L2c+XG4gICAqIDwvZz5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIGVsZW1lbnQsIGkuZS4gc2hhcGUgfCBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gY2hpbGRyZW5HZnhcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJlbnRJbmRleF0gcG9zaXRpb24gdG8gY3JlYXRlIGNvbnRhaW5lciBpbiBwYXJlbnRcbiAgICogQHBhcmFtIHtib29sZWFufSBbaXNGcmFtZV0gaXMgZnJhbWUgZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fVxuICAgKi9cbiAgR3JhcGhpY3NGYWN0b3J5LnByb3RvdHlwZS5fY3JlYXRlQ29udGFpbmVyID0gZnVuY3Rpb24oXG4gICAgICB0eXBlLCBjaGlsZHJlbkdmeCwgcGFyZW50SW5kZXgsIGlzRnJhbWVcbiAgKSB7XG4gICAgdmFyIG91dGVyR2Z4ID0gY3JlYXRlJDEoJ2cnKTtcbiAgICBjbGFzc2VzJDEob3V0ZXJHZngpLmFkZCgnZGpzLWdyb3VwJyk7XG5cbiAgICAvLyBpbnNlcnQgbm9kZSBhdCBwb3NpdGlvblxuICAgIGlmICh0eXBlb2YgcGFyZW50SW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwcmVwZW5kVG8ob3V0ZXJHZngsIGNoaWxkcmVuR2Z4LCBjaGlsZHJlbkdmeC5jaGlsZE5vZGVzW3BhcmVudEluZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGVuZChjaGlsZHJlbkdmeCwgb3V0ZXJHZngpO1xuICAgIH1cblxuICAgIHZhciBnZnggPSBjcmVhdGUkMSgnZycpO1xuICAgIGNsYXNzZXMkMShnZngpLmFkZCgnZGpzLWVsZW1lbnQnKTtcbiAgICBjbGFzc2VzJDEoZ2Z4KS5hZGQoJ2Rqcy0nICsgdHlwZSk7XG5cbiAgICBpZiAoaXNGcmFtZSkge1xuICAgICAgY2xhc3NlcyQxKGdmeCkuYWRkKCdkanMtZnJhbWUnKTtcbiAgICB9XG5cbiAgICBhcHBlbmQob3V0ZXJHZngsIGdmeCk7XG5cbiAgICAvLyBjcmVhdGUgdmlzdWFsXG4gICAgdmFyIHZpc3VhbCA9IGNyZWF0ZSQxKCdnJyk7XG4gICAgY2xhc3NlcyQxKHZpc3VhbCkuYWRkKCdkanMtdmlzdWFsJyk7XG5cbiAgICBhcHBlbmQoZ2Z4LCB2aXN1YWwpO1xuXG4gICAgcmV0dXJuIGdmeDtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgZ3JhcGhpY2FsIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7ICdzaGFwZScgfCAnY29ubmVjdGlvbicgfCAnbGFiZWwnIHwgJ3Jvb3QnIH0gdHlwZSBUaGUgdHlwZSBvZiB0aGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50TGlrZX0gZWxlbWVudCBUaGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJlbnRJbmRleF0gVGhlIGluZGV4IGF0IHdoaWNoIHRvIGFkZCB0aGUgZ3JhcGhpY2FsIGVsZW1lbnQgdG8gaXRzIHBhcmVudCdzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fSBUaGUgZ3JhcGhpY2FsIGVsZW1lbnQuXG4gICAqL1xuICBHcmFwaGljc0ZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKHR5cGUsIGVsZW1lbnQsIHBhcmVudEluZGV4KSB7XG4gICAgdmFyIGNoaWxkcmVuR2Z4ID0gdGhpcy5fZ2V0Q2hpbGRyZW5Db250YWluZXIoZWxlbWVudC5wYXJlbnQpO1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVDb250YWluZXIodHlwZSwgY2hpbGRyZW5HZngsIHBhcmVudEluZGV4LCBpc0ZyYW1lRWxlbWVudChlbGVtZW50KSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY29udGFpbm1lbnRzIG9mIHRoZSBnaXZlbiBlbGVtZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50TGlrZVtdfSBlbGVtZW50cyBUaGUgZWxlbWVudHMuXG4gICAqL1xuICBHcmFwaGljc0ZhY3RvcnkucHJvdG90eXBlLnVwZGF0ZUNvbnRhaW5tZW50cyA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGVsZW1lbnRSZWdpc3RyeSA9IHRoaXMuX2VsZW1lbnRSZWdpc3RyeSxcbiAgICAgICAgcGFyZW50cztcblxuICAgIHBhcmVudHMgPSByZWR1Y2UoZWxlbWVudHMsIGZ1bmN0aW9uKG1hcCwgZSkge1xuXG4gICAgICBpZiAoZS5wYXJlbnQpIHtcbiAgICAgICAgbWFwW2UucGFyZW50LmlkXSA9IGUucGFyZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0sIHt9KTtcblxuICAgIC8vIHVwZGF0ZSBhbGwgcGFyZW50cyBvZiBjaGFuZ2VkIGFuZCByZW9yZ2FuaXplZCB0aGVpciBjaGlsZHJlblxuICAgIC8vIGluIHRoZSBjb3JyZWN0IG9yZGVyIChhcyBpbmRpY2F0ZWQgaW4gb3VyIG1vZGVsKVxuICAgIGZvckVhY2gkMShwYXJlbnRzLCBmdW5jdGlvbihwYXJlbnQpIHtcblxuICAgICAgdmFyIGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuO1xuXG4gICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkcmVuR2Z4ID0gc2VsZi5fZ2V0Q2hpbGRyZW5Db250YWluZXIocGFyZW50KTtcblxuICAgICAgZm9yRWFjaCQxKGNoaWxkcmVuLnNsaWNlKCkucmV2ZXJzZSgpLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICB2YXIgY2hpbGRHZnggPSBlbGVtZW50UmVnaXN0cnkuZ2V0R3JhcGhpY3MoY2hpbGQpO1xuXG4gICAgICAgIHByZXBlbmRUbyhjaGlsZEdmeC5wYXJlbnROb2RlLCBjaGlsZHJlbkdmeCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogRHJhdyBhIHNoYXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IHZpc3VhbCBUaGUgZ3JhcGhpY2FsIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7U2hhcGVMaWtlfSBlbGVtZW50IFRoZSBzaGFwZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIE9wdGlvbmFsIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge1NWR0VsZW1lbnR9XG4gICAqL1xuICBHcmFwaGljc0ZhY3RvcnkucHJvdG90eXBlLmRyYXdTaGFwZSA9IGZ1bmN0aW9uKHZpc3VhbCwgZWxlbWVudCwgYXR0cnMgPSB7fSkge1xuICAgIHZhciBldmVudEJ1cyA9IHRoaXMuX2V2ZW50QnVzO1xuXG4gICAgcmV0dXJuIGV2ZW50QnVzLmZpcmUoJ3JlbmRlci5zaGFwZScsIHsgZ2Z4OiB2aXN1YWwsIGVsZW1lbnQsIGF0dHJzIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBhdGggb2YgYSBzaGFwZS5cbiAgICpcbiAgICogQHBhcmFtIHtTaGFwZUxpa2V9IGVsZW1lbnQgVGhlIHNoYXBlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwYXRoIG9mIHRoZSBzaGFwZS5cbiAgICovXG4gIEdyYXBoaWNzRmFjdG9yeS5wcm90b3R5cGUuZ2V0U2hhcGVQYXRoID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHZhciBldmVudEJ1cyA9IHRoaXMuX2V2ZW50QnVzO1xuXG4gICAgcmV0dXJuIGV2ZW50QnVzLmZpcmUoJ3JlbmRlci5nZXRTaGFwZVBhdGgnLCBlbGVtZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogRHJhdyBhIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gdmlzdWFsIFRoZSBncmFwaGljYWwgZWxlbWVudC5cbiAgICogQHBhcmFtIHtDb25uZWN0aW9uTGlrZX0gZWxlbWVudCBUaGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIE9wdGlvbmFsIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge1NWR0VsZW1lbnR9XG4gICAqL1xuICBHcmFwaGljc0ZhY3RvcnkucHJvdG90eXBlLmRyYXdDb25uZWN0aW9uID0gZnVuY3Rpb24odmlzdWFsLCBlbGVtZW50LCBhdHRycyA9IHt9KSB7XG4gICAgdmFyIGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXM7XG5cbiAgICByZXR1cm4gZXZlbnRCdXMuZmlyZSgncmVuZGVyLmNvbm5lY3Rpb24nLCB7IGdmeDogdmlzdWFsLCBlbGVtZW50LCBhdHRycyB9KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwYXRoIG9mIGEgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtDb25uZWN0aW9uTGlrZX0gY29ubmVjdGlvbiBUaGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgcGF0aCBvZiB0aGUgY29ubmVjdGlvbi5cbiAgICovXG4gIEdyYXBoaWNzRmFjdG9yeS5wcm90b3R5cGUuZ2V0Q29ubmVjdGlvblBhdGggPSBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgdmFyIGV2ZW50QnVzID0gdGhpcy5fZXZlbnRCdXM7XG5cbiAgICByZXR1cm4gZXZlbnRCdXMuZmlyZSgncmVuZGVyLmdldENvbm5lY3Rpb25QYXRoJywgY29ubmVjdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhbiBlbGVtZW50cyBncmFwaGljYWwgcmVwcmVzZW50YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7J3NoYXBlJ3wnY29ubmVjdGlvbid9IHR5cGVcbiAgICogQHBhcmFtIHtFbGVtZW50TGlrZX0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGdmeFxuICAgKi9cbiAgR3JhcGhpY3NGYWN0b3J5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbih0eXBlLCBlbGVtZW50LCBnZngpIHtcblxuICAgIC8vIGRvIE5PVCB1cGRhdGUgcm9vdCBlbGVtZW50XG4gICAgaWYgKCFlbGVtZW50LnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB2aXN1YWwgPSB0aGlzLl9jbGVhcihnZngpO1xuXG4gICAgLy8gcmVkcmF3XG4gICAgaWYgKHR5cGUgPT09ICdzaGFwZScpIHtcbiAgICAgIHRoaXMuZHJhd1NoYXBlKHZpc3VhbCwgZWxlbWVudCk7XG5cbiAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbmluZ1xuICAgICAgdHJhbnNsYXRlJDEoZ2Z4LCBlbGVtZW50LngsIGVsZW1lbnQueSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY29ubmVjdGlvbicpIHtcbiAgICAgIHRoaXMuZHJhd0Nvbm5lY3Rpb24odmlzdWFsLCBlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5oaWRkZW4pIHtcbiAgICAgIGF0dHIkMShnZngsICdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0ciQxKGdmeCwgJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGdyYXBoaWNhbCBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnRMaWtlfSBlbGVtZW50IFRoZSBlbGVtZW50LlxuICAgKi9cbiAgR3JhcGhpY3NGYWN0b3J5LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIGdmeCA9IHRoaXMuX2VsZW1lbnRSZWdpc3RyeS5nZXRHcmFwaGljcyhlbGVtZW50KTtcblxuICAgIC8vIHJlbW92ZVxuICAgIHJlbW92ZSQyKGdmeC5wYXJlbnROb2RlKTtcbiAgfTtcblxuXG4gIC8vIGhlbHBlcnMgLy8vLy8vLy8vL1xuXG4gIGZ1bmN0aW9uIHByZXBlbmRUbyhuZXdOb2RlLCBwYXJlbnROb2RlLCBzaWJsaW5nTm9kZSkge1xuICAgIHZhciBub2RlID0gc2libGluZ05vZGUgfHwgcGFyZW50Tm9kZS5maXJzdENoaWxkO1xuXG4gICAgLy8gZG8gbm90IHByZXBlbmQgbm9kZSB0byBpdHNlbGYgdG8gcHJldmVudCBJRSBmcm9tIGNyYXNoaW5nXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JwbW4taW8vYnBtbi1qcy9pc3N1ZXMvNzQ2XG4gICAgaWYgKG5ld05vZGUgPT09IG5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCBub2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7IGltcG9ydCgnZGlkaScpLk1vZHVsZURlY2xhcmF0aW9uIH1cbiAgICovXG4gIHZhciBDb3JlTW9kdWxlID0ge1xuICAgIF9fZGVwZW5kc19fOiBbIERyYXdNb2R1bGUgXSxcbiAgICBfX2luaXRfXzogWyAnY2FudmFzJyBdLFxuICAgIGNhbnZhczogWyAndHlwZScsIENhbnZhcyBdLFxuICAgIGVsZW1lbnRSZWdpc3RyeTogWyAndHlwZScsIEVsZW1lbnRSZWdpc3RyeSBdLFxuICAgIGVsZW1lbnRGYWN0b3J5OiBbICd0eXBlJywgRWxlbWVudEZhY3RvcnkgXSxcbiAgICBldmVudEJ1czogWyAndHlwZScsIEV2ZW50QnVzIF0sXG4gICAgZ3JhcGhpY3NGYWN0b3J5OiBbICd0eXBlJywgR3JhcGhpY3NGYWN0b3J5IF1cbiAgfTtcblxuICAvKipcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnZGlkaScpLkluamVjdGlvbkNvbnRleHR9IEluamVjdGlvbkNvbnRleHRcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnZGlkaScpLkxvY2Fsc01hcH0gTG9jYWxzTWFwXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJ2RpZGknKS5Nb2R1bGVEZWNsYXJhdGlvbn0gTW9kdWxlRGVjbGFyYXRpb25cbiAgICpcbiAgICogQHR5cGVkZWYgeyB7XG4gICAqICAgbW9kdWxlcz86IE1vZHVsZURlY2xhcmF0aW9uW107XG4gICAqIH0gJiBSZWNvcmQ8c3RyaW5nLCBhbnk+IH0gRGlhZ3JhbU9wdGlvbnNcbiAgICovXG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJ2RpZGknKS5GYWN0b3J5RnVuY3Rpb248VD59IEZhY3RvcnlGdW5jdGlvblxuICAgKi9cblxuICAvKipcbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnZGlkaScpLkFycmF5RnVuYzxUPn0gQXJyYXlGdW5jXG4gICAqL1xuXG4gIC8qKlxuICAgKiBCb290c3RyYXAgYW4gaW5qZWN0b3IgZnJvbSBhIGxpc3Qgb2YgbW9kdWxlcywgaW5zdGFudGlhdGluZyBhIG51bWJlciBvZiBkZWZhdWx0IGNvbXBvbmVudHNcbiAgICpcbiAgICogQHBhcmFtIHtNb2R1bGVEZWNsYXJhdGlvbltdfSBtb2R1bGVzXG4gICAqXG4gICAqIEByZXR1cm4ge0luamVjdG9yfSBhIGluamVjdG9yIHRvIHVzZSB0byBhY2Nlc3MgdGhlIGNvbXBvbmVudHNcbiAgICovXG4gIGZ1bmN0aW9uIGJvb3RzdHJhcChtb2R1bGVzKSB7XG4gICAgdmFyIGluamVjdG9yID0gbmV3IEluamVjdG9yKG1vZHVsZXMpO1xuXG4gICAgaW5qZWN0b3IuaW5pdCgpO1xuXG4gICAgcmV0dXJuIGluamVjdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5qZWN0b3IgZnJvbSBwYXNzZWQgb3B0aW9ucy5cbiAgICpcbiAgICogQHRlbXBsYXRlIFNlcnZpY2VNYXBcbiAgICogQHBhcmFtIHtEaWFncmFtT3B0aW9uc30gW29wdGlvbnNdXG4gICAqXG4gICAqIEByZXR1cm4ge0luamVjdG9yPFNlcnZpY2VNYXA+fVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlSW5qZWN0b3Iob3B0aW9ucykge1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IE1vZHVsZURlY2xhcmF0aW9uIH1cbiAgICAgKi9cbiAgICB2YXIgY29uZmlnTW9kdWxlID0ge1xuICAgICAgJ2NvbmZpZyc6IFsgJ3ZhbHVlJywgb3B0aW9ucyBdXG4gICAgfTtcblxuICAgIHZhciBtb2R1bGVzID0gWyBjb25maWdNb2R1bGUsIENvcmVNb2R1bGUgXS5jb25jYXQob3B0aW9ucy5tb2R1bGVzIHx8IFtdKTtcblxuICAgIHJldHVybiBib290c3RyYXAobW9kdWxlcyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBUaGUgbWFpbiBkaWFncmFtLWpzIGVudHJ5IHBvaW50IHRoYXQgYm9vdHN0cmFwcyB0aGUgZGlhZ3JhbSB3aXRoIHRoZSBnaXZlblxuICAgKiBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBUbyByZWdpc3RlciBleHRlbnNpb25zIHdpdGggdGhlIGRpYWdyYW0sIHBhc3MgdGhlbSBhcyBBcnJheTxNb2R1bGU+IHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAdGVtcGxhdGUgW1NlcnZpY2VNYXA9bnVsbF1cbiAgICpcbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBwbHVnLWluIHRoYXQgbG9ncyB3aGVuZXZlciBhIHNoYXBlIGlzIGFkZGVkIHRvIHRoZSBjYW52YXMuXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogLy8gcGx1Zy1pbiBpbXBsZW1lbnRhdGlvblxuICAgKiBmdW5jdGlvbiBNeUxvZ2dpbmdQbHVnaW4oZXZlbnRCdXMpIHtcbiAgICogICBldmVudEJ1cy5vbignc2hhcGUuYWRkZWQnLCBmdW5jdGlvbihldmVudCkge1xuICAgKiAgICAgY29uc29sZS5sb2coJ3NoYXBlICcsIGV2ZW50LnNoYXBlLCAnIHdhcyBhZGRlZCB0byB0aGUgZGlhZ3JhbScpO1xuICAgKiAgIH0pO1xuICAgKiB9XG4gICAqXG4gICAqIC8vIGV4cG9ydCBhcyBtb2R1bGVcbiAgICogZXhwb3J0IGRlZmF1bHQge1xuICAgKiAgIF9faW5pdF9fOiBbICdteUxvZ2dpbmdQbHVnaW4nIF0sXG4gICAqICAgICBteUxvZ2dpbmdQbHVnaW46IFsgJ3R5cGUnLCBNeUxvZ2dpbmdQbHVnaW4gXVxuICAgKiB9O1xuICAgKiBgYGBcbiAgICpcbiAgICogVXNlIHRoZSBwbHVnLWluIGluIGEgRGlhZ3JhbSBpbnN0YW5jZTpcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBpbXBvcnQgTXlMb2dnaW5nTW9kdWxlIGZyb20gJ3BhdGgtdG8tbXktbG9nZ2luZy1wbHVnaW4nO1xuICAgKlxuICAgKiB2YXIgZGlhZ3JhbSA9IG5ldyBEaWFncmFtKHtcbiAgICogICBtb2R1bGVzOiBbXG4gICAqICAgICBNeUxvZ2dpbmdNb2R1bGVcbiAgICogICBdXG4gICAqIH0pO1xuICAgKlxuICAgKiBkaWFncmFtLmludm9rZShbICdjYW52YXMnLCBmdW5jdGlvbihjYW52YXMpIHtcbiAgICogICAvLyBhZGQgc2hhcGUgdG8gZHJhd2luZyBjYW52YXNcbiAgICogICBjYW52YXMuYWRkU2hhcGUoeyB4OiAxMCwgeTogMTAgfSk7XG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyAnc2hhcGUgLi4uIHdhcyBhZGRlZCB0byB0aGUgZGlhZ3JhbScgbG9nZ2VkIHRvIGNvbnNvbGVcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7RGlhZ3JhbU9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge0luamVjdG9yPFNlcnZpY2VNYXA+fSBbaW5qZWN0b3JdIEFuIChvcHRpb25hbCkgaW5qZWN0b3IgdG8gYm9vdHN0cmFwIHRoZSBkaWFncmFtIHdpdGguXG4gICAqL1xuICBmdW5jdGlvbiBEaWFncmFtKG9wdGlvbnMsIGluamVjdG9yKSB7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SW5qZWN0b3I8U2VydmljZU1hcD59XG4gICAgICovXG4gICAgdGhpcy5faW5qZWN0b3IgPSBpbmplY3RvciB8fCBjcmVhdGVJbmplY3RvcihvcHRpb25zKTtcblxuICAgIC8vIGluaXRcblxuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCBhbGwgcGx1Zy1pbnMgYXJlIGxvYWRlZC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGV2ZW50IHRvIGZpcmUgb3RoZXIgZXZlbnRzIHRvIGludGVyZXN0ZWQgcGx1Zy1pbnNcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBEaWFncmFtXG4gICAgICpcbiAgICAgKiBAZXZlbnQgZGlhZ3JhbS5pbml0XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIGV2ZW50QnVzLm9uKCdkaWFncmFtLmluaXQnLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgIGV2ZW50QnVzLmZpcmUoJ215LWN1c3RvbS1ldmVudCcsIHsgZm9vOiAnQkFSJyB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5nZXQoJ2V2ZW50QnVzJykuZmlyZSgnZGlhZ3JhbS5pbml0Jyk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJsb3JkXG4gICAqXG4gICAqIFJlc29sdmVzIGEgZGlhZ3JhbSBzZXJ2aWNlLlxuICAgKlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc2VydmljZSB0byBnZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge1R9XG4gICAqL1xuICAvKipcbiAgICogQG92ZXJsb3JkXG4gICAqXG4gICAqIFJlc29sdmVzIGEgZGlhZ3JhbSBzZXJ2aWNlLlxuICAgKlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc2VydmljZSB0byBnZXQuXG4gICAqIEBwYXJhbSB7dHJ1ZX0gc3RyaWN0IElmIGZhbHNlLCByZXNvbHZlIG1pc3Npbmcgc2VydmljZXMgdG8gbnVsbC5cbiAgICpcbiAgICogQHJldHVybiB7VH1cbiAgICovXG4gIC8qKlxuICAgKiBAb3ZlcmxvcmRcbiAgICpcbiAgICogUmVzb2x2ZXMgYSBkaWFncmFtIHNlcnZpY2UuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzZXJ2aWNlIHRvIGdldC5cbiAgICogQHBhcmFtIHtib29sZWFufSBzdHJpY3QgSWYgZmFsc2UsIHJlc29sdmUgbWlzc2luZyBzZXJ2aWNlcyB0byBudWxsLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUfG51bGx9XG4gICAqL1xuICAvKipcbiAgICogUmVzb2x2ZXMgYSBkaWFncmFtIHNlcnZpY2UuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgU2VydmljZU1hcH0gTmFtZVxuICAgKlxuICAgKiBAcGFyYW0ge05hbWV9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHNlcnZpY2UgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtTZXJ2aWNlTWFwW05hbWVdfVxuICAgKi9cbiAgRGlhZ3JhbS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSwgc3RyaWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2luamVjdG9yLmdldChuYW1lLCBzdHJpY3QpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcmxvcmRcbiAgICpcbiAgICogSW52b2tlIHRoZSBnaXZlbiBmdW5jdGlvbiwgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy4gUmV0dXJuIHRoZSByZXN1bHQuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqXG4gICAqIEBwYXJhbSB7RmFjdG9yeUZ1bmN0aW9uPFQ+fSBmdW5jXG4gICAqIEBwYXJhbSB7SW5qZWN0aW9uQ29udGV4dH0gW2NvbnRleHRdXG4gICAqIEBwYXJhbSB7TG9jYWxzTWFwfSBbbG9jYWxzXVxuICAgKlxuICAgKiBAcmV0dXJuIHtUfVxuICAgKi9cbiAgLyoqXG4gICAqIEludm9rZSB0aGUgZ2l2ZW4gZnVuY3Rpb24sIGluamVjdGluZyBkZXBlbmRlbmNpZXMgcHJvdmlkZWQgaW5cbiAgICogYXJyYXkgbm90YXRpb24uIFJldHVybiB0aGUgcmVzdWx0LlxuICAgKlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5RnVuYzxUPn0gZnVuYyBmdW5jdGlvbiB0byBiZSBpbnZva2VkXG4gICAqIEBwYXJhbSB7SW5qZWN0aW9uQ29udGV4dH0gW2NvbnRleHRdIGNvbnRleHQgb2YgdGhlIGludm9jYXRpb25cbiAgICogQHBhcmFtIHtMb2NhbHNNYXB9IFtsb2NhbHNdIGxvY2FscyBwcm92aWRlZFxuICAgKlxuICAgKiBAcmV0dXJuIHtUfVxuICAgKi9cbiAgRGlhZ3JhbS5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCwgbG9jYWxzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luamVjdG9yLmludm9rZShmdW5jLCBjb250ZXh0LCBsb2NhbHMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgZGlhZ3JhbVxuICAgKi9cbiAgRGlhZ3JhbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZ2V0KCdldmVudEJ1cycpLmZpcmUoJ2RpYWdyYW0uZGVzdHJveScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgZGlhZ3JhbSwgcmVtb3ZpbmcgYWxsIGNvbnRlbnRzLlxuICAgKi9cbiAgRGlhZ3JhbS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmdldCgnZXZlbnRCdXMnKS5maXJlKCdkaWFncmFtLmNsZWFyJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vZGRsZSBiYXNlIGVsZW1lbnQuXG4gICAqL1xuICBmdW5jdGlvbiBCYXNlKCkgeyB9XG5cbiAgQmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLiRtb2RlbC5wcm9wZXJ0aWVzLmdldCh0aGlzLCBuYW1lKTtcbiAgfTtcblxuICBCYXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuJG1vZGVsLnByb3BlcnRpZXMuc2V0KHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogQSBtb2RlbCBlbGVtZW50IGZhY3RvcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZGxlfSBtb2RlbFxuICAgKiBAcGFyYW0ge1Byb3BlcnRpZXN9IHByb3BlcnRpZXNcbiAgICovXG4gIGZ1bmN0aW9uIEZhY3RvcnkobW9kZWwsIHByb3BlcnRpZXMpIHtcbiAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgfVxuXG5cbiAgRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlVHlwZSA9IGZ1bmN0aW9uKGRlc2NyaXB0b3IpIHtcblxuICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BlcnRpZXMsXG4gICAgICAgIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBkZWZhdWx0IHZhbHVlc1xuICAgIGZvckVhY2gkMShkZXNjcmlwdG9yLnByb3BlcnRpZXMsIGZ1bmN0aW9uKHApIHtcbiAgICAgIGlmICghcC5pc01hbnkgJiYgcC5kZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvdG90eXBlW3AubmFtZV0gPSBwLmRlZmF1bHQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBwcm9wcy5kZWZpbmVNb2RlbChwcm90b3R5cGUsIG1vZGVsKTtcbiAgICBwcm9wcy5kZWZpbmVEZXNjcmlwdG9yKHByb3RvdHlwZSwgZGVzY3JpcHRvcik7XG5cbiAgICB2YXIgbmFtZSA9IGRlc2NyaXB0b3IubnMubmFtZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuZXcgdHlwZSBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1vZGRsZUVsZW1lbnQoYXR0cnMpIHtcbiAgICAgIHByb3BzLmRlZmluZSh0aGlzLCAnJHR5cGUnLCB7IHZhbHVlOiBuYW1lLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgICAgcHJvcHMuZGVmaW5lKHRoaXMsICckYXR0cnMnLCB7IHZhbHVlOiB7fSB9KTtcbiAgICAgIHByb3BzLmRlZmluZSh0aGlzLCAnJHBhcmVudCcsIHsgd3JpdGFibGU6IHRydWUgfSk7XG5cbiAgICAgIGZvckVhY2gkMShhdHRycywgYmluZCQyKGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICAgIHRoaXMuc2V0KGtleSwgdmFsKTtcbiAgICAgIH0sIHRoaXMpKTtcbiAgICB9XG5cbiAgICBNb2RkbGVFbGVtZW50LnByb3RvdHlwZSA9IHByb3RvdHlwZTtcblxuICAgIE1vZGRsZUVsZW1lbnQuaGFzVHlwZSA9IHByb3RvdHlwZS4kaW5zdGFuY2VPZiA9IHRoaXMubW9kZWwuaGFzVHlwZTtcblxuICAgIC8vIHN0YXRpYyBsaW5rc1xuICAgIHByb3BzLmRlZmluZU1vZGVsKE1vZGRsZUVsZW1lbnQsIG1vZGVsKTtcbiAgICBwcm9wcy5kZWZpbmVEZXNjcmlwdG9yKE1vZGRsZUVsZW1lbnQsIGRlc2NyaXB0b3IpO1xuXG4gICAgcmV0dXJuIE1vZGRsZUVsZW1lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWx0LWluIG1vZGRsZSB0eXBlc1xuICAgKi9cbiAgdmFyIEJVSUxUSU5TID0ge1xuICAgIFN0cmluZzogdHJ1ZSxcbiAgICBCb29sZWFuOiB0cnVlLFxuICAgIEludGVnZXI6IHRydWUsXG4gICAgUmVhbDogdHJ1ZSxcbiAgICBFbGVtZW50OiB0cnVlXG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnRlcnMgZm9yIGJ1aWx0IGluIHR5cGVzIGZyb20gc3RyaW5nIHJlcHJlc2VudGF0aW9uc1xuICAgKi9cbiAgdmFyIFRZUEVfQ09OVkVSVEVSUyA9IHtcbiAgICBTdHJpbmc6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHM7IH0sXG4gICAgQm9vbGVhbjogZnVuY3Rpb24ocykgeyByZXR1cm4gcyA9PT0gJ3RydWUnOyB9LFxuICAgIEludGVnZXI6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHBhcnNlSW50KHMsIDEwKTsgfSxcbiAgICBSZWFsOiBmdW5jdGlvbihzKSB7IHJldHVybiBwYXJzZUZsb2F0KHMpOyB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSB0eXBlIHRvIGl0cyByZWFsIHJlcHJlc2VudGF0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBjb2VyY2VUeXBlKHR5cGUsIHZhbHVlKSB7XG5cbiAgICB2YXIgY29udmVydGVyID0gVFlQRV9DT05WRVJURVJTW3R5cGVdO1xuXG4gICAgaWYgKGNvbnZlcnRlcikge1xuICAgICAgcmV0dXJuIGNvbnZlcnRlcih2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhlIGdpdmVuIHR5cGUgaXMgYnVpbHQtaW5cbiAgICovXG4gIGZ1bmN0aW9uIGlzQnVpbHRJbih0eXBlKSB7XG4gICAgcmV0dXJuICEhQlVJTFRJTlNbdHlwZV07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhlIGdpdmVuIHR5cGUgaXMgc2ltcGxlXG4gICAqL1xuICBmdW5jdGlvbiBpc1NpbXBsZSh0eXBlKSB7XG4gICAgcmV0dXJuICEhVFlQRV9DT05WRVJURVJTW3R5cGVdO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIG5hbWVzcGFjZWQgYXR0cmlidXRlIG5hbWUgb2YgdGhlIGZvcm0gKG5zOilsb2NhbE5hbWUgdG8gYW4gb2JqZWN0LFxuICAgKiBnaXZlbiBhIGRlZmF1bHQgcHJlZml4IHRvIGFzc3VtZSBpbiBjYXNlIG5vIGV4cGxpY2l0IG5hbWVzcGFjZSBpcyBnaXZlbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtkZWZhdWx0UHJlZml4XSB0aGUgZGVmYXVsdCBwcmVmaXggdG8gdGFrZSwgaWYgbm9uZSBpcyBwcmVzZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBwYXJzZWQgbmFtZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VOYW1lKG5hbWUsIGRlZmF1bHRQcmVmaXgpIHtcbiAgICB2YXIgcGFydHMgPSBuYW1lLnNwbGl0KC86LyksXG4gICAgICAgIGxvY2FsTmFtZSwgcHJlZml4O1xuXG4gICAgLy8gbm8gcHJlZml4IChpLmUuIG9ubHkgbG9jYWwgbmFtZSlcbiAgICBpZiAocGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBsb2NhbE5hbWUgPSBuYW1lO1xuICAgICAgcHJlZml4ID0gZGVmYXVsdFByZWZpeDtcbiAgICB9XG5cbiAgICAvLyBwcmVmaXggKyBsb2NhbCBuYW1lXG4gICAgZWxzZSBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBsb2NhbE5hbWUgPSBwYXJ0c1sxXTtcbiAgICAgIHByZWZpeCA9IHBhcnRzWzBdO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCA8cHJlZml4OmxvY2FsTmFtZT4gb3IgPGxvY2FsTmFtZT4sIGdvdCAnICsgbmFtZSk7XG4gICAgfVxuXG4gICAgbmFtZSA9IChwcmVmaXggPyBwcmVmaXggKyAnOicgOiAnJykgKyBsb2NhbE5hbWU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgbG9jYWxOYW1lOiBsb2NhbE5hbWVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdXRpbGl0eSB0byBidWlsZCBlbGVtZW50IGRlc2NyaXB0b3JzLlxuICAgKi9cbiAgZnVuY3Rpb24gRGVzY3JpcHRvckJ1aWxkZXIobmFtZU5zKSB7XG4gICAgdGhpcy5ucyA9IG5hbWVOcztcbiAgICB0aGlzLm5hbWUgPSBuYW1lTnMubmFtZTtcbiAgICB0aGlzLmFsbFR5cGVzID0gW107XG4gICAgdGhpcy5hbGxUeXBlc0J5TmFtZSA9IHt9O1xuICAgIHRoaXMucHJvcGVydGllcyA9IFtdO1xuICAgIHRoaXMucHJvcGVydGllc0J5TmFtZSA9IHt9O1xuICB9XG5cblxuICBEZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcGljayh0aGlzLCBbXG4gICAgICAnbnMnLFxuICAgICAgJ25hbWUnLFxuICAgICAgJ2FsbFR5cGVzJyxcbiAgICAgICdhbGxUeXBlc0J5TmFtZScsXG4gICAgICAncHJvcGVydGllcycsXG4gICAgICAncHJvcGVydGllc0J5TmFtZScsXG4gICAgICAnYm9keVByb3BlcnR5JyxcbiAgICAgICdpZFByb3BlcnR5J1xuICAgIF0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgcHJvcGVydHkgYXQgZ2l2ZW4gaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaWR4XVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt2YWxpZGF0ZT10cnVlXVxuICAgKi9cbiAgRGVzY3JpcHRvckJ1aWxkZXIucHJvdG90eXBlLmFkZFByb3BlcnR5ID0gZnVuY3Rpb24ocCwgaWR4LCB2YWxpZGF0ZSkge1xuXG4gICAgaWYgKHR5cGVvZiBpZHggPT09ICdib29sZWFuJykge1xuICAgICAgdmFsaWRhdGUgPSBpZHg7XG4gICAgICBpZHggPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGhpcy5hZGROYW1lZFByb3BlcnR5KHAsIHZhbGlkYXRlICE9PSBmYWxzZSk7XG5cbiAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcztcblxuICAgIGlmIChpZHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJvcGVydGllcy5zcGxpY2UoaWR4LCAwLCBwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcGVydGllcy5wdXNoKHApO1xuICAgIH1cbiAgfTtcblxuXG4gIERlc2NyaXB0b3JCdWlsZGVyLnByb3RvdHlwZS5yZXBsYWNlUHJvcGVydHkgPSBmdW5jdGlvbihvbGRQcm9wZXJ0eSwgbmV3UHJvcGVydHksIHJlcGxhY2UpIHtcbiAgICB2YXIgb2xkTmFtZU5zID0gb2xkUHJvcGVydHkubnM7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BlcnRpZXMsXG4gICAgICAgIHByb3BlcnRpZXNCeU5hbWUgPSB0aGlzLnByb3BlcnRpZXNCeU5hbWUsXG4gICAgICAgIHJlbmFtZSA9IG9sZFByb3BlcnR5Lm5hbWUgIT09IG5ld1Byb3BlcnR5Lm5hbWU7XG5cbiAgICBpZiAob2xkUHJvcGVydHkuaXNJZCkge1xuICAgICAgaWYgKCFuZXdQcm9wZXJ0eS5pc0lkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAncHJvcGVydHkgPCcgKyBuZXdQcm9wZXJ0eS5ucy5uYW1lICsgJz4gbXVzdCBiZSBpZCBwcm9wZXJ0eSAnICtcbiAgICAgICAgICAndG8gcmVmaW5lIDwnICsgb2xkUHJvcGVydHkubnMubmFtZSArICc+Jyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0SWRQcm9wZXJ0eShuZXdQcm9wZXJ0eSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChvbGRQcm9wZXJ0eS5pc0JvZHkpIHtcblxuICAgICAgaWYgKCFuZXdQcm9wZXJ0eS5pc0JvZHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdwcm9wZXJ0eSA8JyArIG5ld1Byb3BlcnR5Lm5zLm5hbWUgKyAnPiBtdXN0IGJlIGJvZHkgcHJvcGVydHkgJyArXG4gICAgICAgICAgJ3RvIHJlZmluZSA8JyArIG9sZFByb3BlcnR5Lm5zLm5hbWUgKyAnPicpO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBDaGVjayBjb21wYXRpYmlsaXR5XG4gICAgICB0aGlzLnNldEJvZHlQcm9wZXJ0eShuZXdQcm9wZXJ0eSwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIGV4aXN0ZW5jZSBhbmQgZ2V0IGxvY2F0aW9uIG9mIG9sZCBwcm9wZXJ0eVxuICAgIHZhciBpZHggPSBwcm9wcy5pbmRleE9mKG9sZFByb3BlcnR5KTtcbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9wZXJ0eSA8JyArIG9sZE5hbWVOcy5uYW1lICsgJz4gbm90IGZvdW5kIGluIHByb3BlcnR5IGxpc3QnKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgb2xkIHByb3BlcnR5XG4gICAgcHJvcHMuc3BsaWNlKGlkeCwgMSk7XG5cbiAgICAvLyByZXBsYWNpbmcgdGhlIG5hbWVkIHByb3BlcnR5IGlzIGludGVudGlvbmFsXG4gICAgLy9cbiAgICAvLyAgKiB2YWxpZGF0ZSBvbmx5IGlmIHRoaXMgaXMgYSBcInJlbmFtZVwiIG9wZXJhdGlvblxuICAgIC8vICAqIGFkZCBhdCBzcGVjaWZpYyBpbmRleCB1bmxlc3Mgd2UgXCJyZXBsYWNlXCJcbiAgICAvL1xuICAgIHRoaXMuYWRkUHJvcGVydHkobmV3UHJvcGVydHksIHJlcGxhY2UgPyB1bmRlZmluZWQgOiBpZHgsIHJlbmFtZSk7XG5cbiAgICAvLyBtYWtlIG5ldyBwcm9wZXJ0eSBhdmFpbGFibGUgdW5kZXIgb2xkIG5hbWVcbiAgICBwcm9wZXJ0aWVzQnlOYW1lW29sZE5hbWVOcy5uYW1lXSA9IHByb3BlcnRpZXNCeU5hbWVbb2xkTmFtZU5zLmxvY2FsTmFtZV0gPSBuZXdQcm9wZXJ0eTtcbiAgfTtcblxuXG4gIERlc2NyaXB0b3JCdWlsZGVyLnByb3RvdHlwZS5yZWRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24ocCwgdGFyZ2V0UHJvcGVydHlOYW1lLCByZXBsYWNlKSB7XG5cbiAgICB2YXIgbnNQcmVmaXggPSBwLm5zLnByZWZpeDtcbiAgICB2YXIgcGFydHMgPSB0YXJnZXRQcm9wZXJ0eU5hbWUuc3BsaXQoJyMnKTtcblxuICAgIHZhciBuYW1lID0gcGFyc2VOYW1lKHBhcnRzWzBdLCBuc1ByZWZpeCk7XG4gICAgdmFyIGF0dHJOYW1lID0gcGFyc2VOYW1lKHBhcnRzWzFdLCBuYW1lLnByZWZpeCkubmFtZTtcblxuICAgIHZhciByZWRlZmluZWRQcm9wZXJ0eSA9IHRoaXMucHJvcGVydGllc0J5TmFtZVthdHRyTmFtZV07XG4gICAgaWYgKCFyZWRlZmluZWRQcm9wZXJ0eSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWZpbmVkIHByb3BlcnR5IDwnICsgYXR0ck5hbWUgKyAnPiBub3QgZm91bmQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXBsYWNlUHJvcGVydHkocmVkZWZpbmVkUHJvcGVydHksIHAsIHJlcGxhY2UpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBwLnJlZGVmaW5lcztcbiAgfTtcblxuICBEZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuYWRkTmFtZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uKHAsIHZhbGlkYXRlKSB7XG4gICAgdmFyIG5zID0gcC5ucyxcbiAgICAgICAgcHJvcHNCeU5hbWUgPSB0aGlzLnByb3BlcnRpZXNCeU5hbWU7XG5cbiAgICBpZiAodmFsaWRhdGUpIHtcbiAgICAgIHRoaXMuYXNzZXJ0Tm90RGVmaW5lZChwLCBucy5uYW1lKTtcbiAgICAgIHRoaXMuYXNzZXJ0Tm90RGVmaW5lZChwLCBucy5sb2NhbE5hbWUpO1xuICAgIH1cblxuICAgIHByb3BzQnlOYW1lW25zLm5hbWVdID0gcHJvcHNCeU5hbWVbbnMubG9jYWxOYW1lXSA9IHA7XG4gIH07XG5cbiAgRGVzY3JpcHRvckJ1aWxkZXIucHJvdG90eXBlLnJlbW92ZU5hbWVkUHJvcGVydHkgPSBmdW5jdGlvbihwKSB7XG4gICAgdmFyIG5zID0gcC5ucyxcbiAgICAgICAgcHJvcHNCeU5hbWUgPSB0aGlzLnByb3BlcnRpZXNCeU5hbWU7XG5cbiAgICBkZWxldGUgcHJvcHNCeU5hbWVbbnMubmFtZV07XG4gICAgZGVsZXRlIHByb3BzQnlOYW1lW25zLmxvY2FsTmFtZV07XG4gIH07XG5cbiAgRGVzY3JpcHRvckJ1aWxkZXIucHJvdG90eXBlLnNldEJvZHlQcm9wZXJ0eSA9IGZ1bmN0aW9uKHAsIHZhbGlkYXRlKSB7XG5cbiAgICBpZiAodmFsaWRhdGUgJiYgdGhpcy5ib2R5UHJvcGVydHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2JvZHkgcHJvcGVydHkgZGVmaW5lZCBtdWx0aXBsZSB0aW1lcyAnICtcbiAgICAgICAgJyg8JyArIHRoaXMuYm9keVByb3BlcnR5Lm5zLm5hbWUgKyAnPiwgPCcgKyBwLm5zLm5hbWUgKyAnPiknKTtcbiAgICB9XG5cbiAgICB0aGlzLmJvZHlQcm9wZXJ0eSA9IHA7XG4gIH07XG5cbiAgRGVzY3JpcHRvckJ1aWxkZXIucHJvdG90eXBlLnNldElkUHJvcGVydHkgPSBmdW5jdGlvbihwLCB2YWxpZGF0ZSkge1xuXG4gICAgaWYgKHZhbGlkYXRlICYmIHRoaXMuaWRQcm9wZXJ0eSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnaWQgcHJvcGVydHkgZGVmaW5lZCBtdWx0aXBsZSB0aW1lcyAnICtcbiAgICAgICAgJyg8JyArIHRoaXMuaWRQcm9wZXJ0eS5ucy5uYW1lICsgJz4sIDwnICsgcC5ucy5uYW1lICsgJz4pJyk7XG4gICAgfVxuXG4gICAgdGhpcy5pZFByb3BlcnR5ID0gcDtcbiAgfTtcblxuICBEZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuYXNzZXJ0Tm90VHJhaXQgPSBmdW5jdGlvbih0eXBlRGVzY3JpcHRvcikge1xuXG4gICAgY29uc3QgX2V4dGVuZHMgPSB0eXBlRGVzY3JpcHRvci5leHRlbmRzIHx8IFtdO1xuXG4gICAgaWYgKF9leHRlbmRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgY2Fubm90IGNyZWF0ZSA8JHsgdHlwZURlc2NyaXB0b3IubmFtZSB9PiBleHRlbmRpbmcgPCR7IHR5cGVEZXNjcmlwdG9yLmV4dGVuZHMgfT5gXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBEZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuYXNzZXJ0Tm90RGVmaW5lZCA9IGZ1bmN0aW9uKHAsIG5hbWUpIHtcbiAgICB2YXIgcHJvcGVydHlOYW1lID0gcC5uYW1lLFxuICAgICAgICBkZWZpbmVkUHJvcGVydHkgPSB0aGlzLnByb3BlcnRpZXNCeU5hbWVbcHJvcGVydHlOYW1lXTtcblxuICAgIGlmIChkZWZpbmVkUHJvcGVydHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3Byb3BlcnR5IDwnICsgcHJvcGVydHlOYW1lICsgJz4gYWxyZWFkeSBkZWZpbmVkOyAnICtcbiAgICAgICAgJ292ZXJyaWRlIG9mIDwnICsgZGVmaW5lZFByb3BlcnR5LmRlZmluZWRCeS5ucy5uYW1lICsgJyMnICsgZGVmaW5lZFByb3BlcnR5Lm5zLm5hbWUgKyAnPiBieSAnICtcbiAgICAgICAgJzwnICsgcC5kZWZpbmVkQnkubnMubmFtZSArICcjJyArIHAubnMubmFtZSArICc+IG5vdCBhbGxvd2VkIHdpdGhvdXQgcmVkZWZpbmVzJyk7XG4gICAgfVxuICB9O1xuXG4gIERlc2NyaXB0b3JCdWlsZGVyLnByb3RvdHlwZS5oYXNQcm9wZXJ0eSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzQnlOYW1lW25hbWVdO1xuICB9O1xuXG4gIERlc2NyaXB0b3JCdWlsZGVyLnByb3RvdHlwZS5hZGRUcmFpdCA9IGZ1bmN0aW9uKHQsIGluaGVyaXRlZCkge1xuXG4gICAgaWYgKGluaGVyaXRlZCkge1xuICAgICAgdGhpcy5hc3NlcnROb3RUcmFpdCh0KTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZXNCeU5hbWUgPSB0aGlzLmFsbFR5cGVzQnlOYW1lLFxuICAgICAgICB0eXBlcyA9IHRoaXMuYWxsVHlwZXM7XG5cbiAgICB2YXIgdHlwZU5hbWUgPSB0Lm5hbWU7XG5cbiAgICBpZiAodHlwZU5hbWUgaW4gdHlwZXNCeU5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3JFYWNoJDEodC5wcm9wZXJ0aWVzLCBiaW5kJDIoZnVuY3Rpb24ocCkge1xuXG4gICAgICAvLyBjbG9uZSBwcm9wZXJ0eSB0byBhbGxvdyBleHRlbnNpb25zXG4gICAgICBwID0gYXNzaWduJDEoe30sIHAsIHtcbiAgICAgICAgbmFtZTogcC5ucy5sb2NhbE5hbWUsXG4gICAgICAgIGluaGVyaXRlZDogaW5oZXJpdGVkXG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHAsICdkZWZpbmVkQnknLCB7XG4gICAgICAgIHZhbHVlOiB0XG4gICAgICB9KTtcblxuICAgICAgdmFyIHJlcGxhY2VzID0gcC5yZXBsYWNlcyxcbiAgICAgICAgICByZWRlZmluZXMgPSBwLnJlZGVmaW5lcztcblxuICAgICAgLy8gYWRkIHJlcGxhY2UvcmVkZWZpbmUgc3VwcG9ydFxuICAgICAgaWYgKHJlcGxhY2VzIHx8IHJlZGVmaW5lcykge1xuICAgICAgICB0aGlzLnJlZGVmaW5lUHJvcGVydHkocCwgcmVwbGFjZXMgfHwgcmVkZWZpbmVzLCByZXBsYWNlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocC5pc0JvZHkpIHtcbiAgICAgICAgICB0aGlzLnNldEJvZHlQcm9wZXJ0eShwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocC5pc0lkKSB7XG4gICAgICAgICAgdGhpcy5zZXRJZFByb3BlcnR5KHApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkocCk7XG4gICAgICB9XG4gICAgfSwgdGhpcykpO1xuXG4gICAgdHlwZXMucHVzaCh0KTtcbiAgICB0eXBlc0J5TmFtZVt0eXBlTmFtZV0gPSB0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIHJlZ2lzdHJ5IG9mIE1vZGRsZSBwYWNrYWdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxQYWNrYWdlPn0gcGFja2FnZXNcbiAgICogQHBhcmFtIHtQcm9wZXJ0aWVzfSBwcm9wZXJ0aWVzXG4gICAqL1xuICBmdW5jdGlvbiBSZWdpc3RyeShwYWNrYWdlcywgcHJvcGVydGllcykge1xuICAgIHRoaXMucGFja2FnZU1hcCA9IHt9O1xuICAgIHRoaXMudHlwZU1hcCA9IHt9O1xuXG4gICAgdGhpcy5wYWNrYWdlcyA9IFtdO1xuXG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcblxuICAgIGZvckVhY2gkMShwYWNrYWdlcywgYmluZCQyKHRoaXMucmVnaXN0ZXJQYWNrYWdlLCB0aGlzKSk7XG4gIH1cblxuXG4gIFJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRQYWNrYWdlID0gZnVuY3Rpb24odXJpT3JQcmVmaXgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWNrYWdlTWFwW3VyaU9yUHJlZml4XTtcbiAgfTtcblxuICBSZWdpc3RyeS5wcm90b3R5cGUuZ2V0UGFja2FnZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYWNrYWdlcztcbiAgfTtcblxuXG4gIFJlZ2lzdHJ5LnByb3RvdHlwZS5yZWdpc3RlclBhY2thZ2UgPSBmdW5jdGlvbihwa2cpIHtcblxuICAgIC8vIGNvcHkgcGFja2FnZVxuICAgIHBrZyA9IGFzc2lnbiQxKHt9LCBwa2cpO1xuXG4gICAgdmFyIHBrZ01hcCA9IHRoaXMucGFja2FnZU1hcDtcblxuICAgIGVuc3VyZUF2YWlsYWJsZShwa2dNYXAsIHBrZywgJ3ByZWZpeCcpO1xuICAgIGVuc3VyZUF2YWlsYWJsZShwa2dNYXAsIHBrZywgJ3VyaScpO1xuXG4gICAgLy8gcmVnaXN0ZXIgdHlwZXNcbiAgICBmb3JFYWNoJDEocGtnLnR5cGVzLCBiaW5kJDIoZnVuY3Rpb24oZGVzY3JpcHRvcikge1xuICAgICAgdGhpcy5yZWdpc3RlclR5cGUoZGVzY3JpcHRvciwgcGtnKTtcbiAgICB9LCB0aGlzKSk7XG5cbiAgICBwa2dNYXBbcGtnLnVyaV0gPSBwa2dNYXBbcGtnLnByZWZpeF0gPSBwa2c7XG4gICAgdGhpcy5wYWNrYWdlcy5wdXNoKHBrZyk7XG4gIH07XG5cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSB0eXBlIGZyb20gYSBzcGVjaWZpYyBwYWNrYWdlIHdpdGggdXNcbiAgICovXG4gIFJlZ2lzdHJ5LnByb3RvdHlwZS5yZWdpc3RlclR5cGUgPSBmdW5jdGlvbih0eXBlLCBwa2cpIHtcblxuICAgIHR5cGUgPSBhc3NpZ24kMSh7fSwgdHlwZSwge1xuICAgICAgc3VwZXJDbGFzczogKHR5cGUuc3VwZXJDbGFzcyB8fCBbXSkuc2xpY2UoKSxcbiAgICAgIGV4dGVuZHM6ICh0eXBlLmV4dGVuZHMgfHwgW10pLnNsaWNlKCksXG4gICAgICBwcm9wZXJ0aWVzOiAodHlwZS5wcm9wZXJ0aWVzIHx8IFtdKS5zbGljZSgpLFxuICAgICAgbWV0YTogYXNzaWduJDEoKHR5cGUubWV0YSB8fCB7fSkpXG4gICAgfSk7XG5cbiAgICB2YXIgbnMgPSBwYXJzZU5hbWUodHlwZS5uYW1lLCBwa2cucHJlZml4KSxcbiAgICAgICAgbmFtZSA9IG5zLm5hbWUsXG4gICAgICAgIHByb3BlcnRpZXNCeU5hbWUgPSB7fTtcblxuICAgIC8vIHBhcnNlIHByb3BlcnRpZXNcbiAgICBmb3JFYWNoJDEodHlwZS5wcm9wZXJ0aWVzLCBiaW5kJDIoZnVuY3Rpb24ocCkge1xuXG4gICAgICAvLyBuYW1lc3BhY2UgcHJvcGVydHkgbmFtZXNcbiAgICAgIHZhciBwcm9wZXJ0eU5zID0gcGFyc2VOYW1lKHAubmFtZSwgbnMucHJlZml4KSxcbiAgICAgICAgICBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5zLm5hbWU7XG5cbiAgICAgIC8vIG5hbWVzcGFjZSBwcm9wZXJ0eSB0eXBlc1xuICAgICAgaWYgKCFpc0J1aWx0SW4ocC50eXBlKSkge1xuICAgICAgICBwLnR5cGUgPSBwYXJzZU5hbWUocC50eXBlLCBwcm9wZXJ0eU5zLnByZWZpeCkubmFtZTtcbiAgICAgIH1cblxuICAgICAgYXNzaWduJDEocCwge1xuICAgICAgICBuczogcHJvcGVydHlOcyxcbiAgICAgICAgbmFtZTogcHJvcGVydHlOYW1lXG4gICAgICB9KTtcblxuICAgICAgcHJvcGVydGllc0J5TmFtZVtwcm9wZXJ0eU5hbWVdID0gcDtcbiAgICB9LCB0aGlzKSk7XG5cbiAgICAvLyB1cGRhdGUgbnMgKyBuYW1lXG4gICAgYXNzaWduJDEodHlwZSwge1xuICAgICAgbnM6IG5zLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHByb3BlcnRpZXNCeU5hbWU6IHByb3BlcnRpZXNCeU5hbWVcbiAgICB9KTtcblxuICAgIGZvckVhY2gkMSh0eXBlLmV4dGVuZHMsIGJpbmQkMihmdW5jdGlvbihleHRlbmRzTmFtZSkge1xuICAgICAgdmFyIGV4dGVuZHNOYW1lTnMgPSBwYXJzZU5hbWUoZXh0ZW5kc05hbWUsIG5zLnByZWZpeCk7XG5cbiAgICAgIHZhciBleHRlbmRlZCA9IHRoaXMudHlwZU1hcFtleHRlbmRzTmFtZU5zLm5hbWVdO1xuXG4gICAgICBleHRlbmRlZC50cmFpdHMgPSBleHRlbmRlZC50cmFpdHMgfHwgW107XG4gICAgICBleHRlbmRlZC50cmFpdHMucHVzaChuYW1lKTtcbiAgICB9LCB0aGlzKSk7XG5cbiAgICAvLyBsaW5rIHRvIHBhY2thZ2VcbiAgICB0aGlzLmRlZmluZVBhY2thZ2UodHlwZSwgcGtnKTtcblxuICAgIC8vIHJlZ2lzdGVyXG4gICAgdGhpcy50eXBlTWFwW25hbWVdID0gdHlwZTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZSB0aGUgdHlwZSBoaWVyYXJjaHkgZnJvbSBib3R0b20gdG8gdG9wLFxuICAgKiBjYWxsaW5nIGl0ZXJhdG9yIHdpdGggKHR5cGUsIGluaGVyaXRlZCkgZm9yIGFsbCBlbGVtZW50cyBpblxuICAgKiB0aGUgaW5oZXJpdGFuY2UgY2hhaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuc05hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAgICogQHBhcmFtIHtCb29sZWFufSBbdHJhaXQ9ZmFsc2VdXG4gICAqL1xuICBSZWdpc3RyeS5wcm90b3R5cGUubWFwVHlwZXMgPSBmdW5jdGlvbihuc05hbWUsIGl0ZXJhdG9yLCB0cmFpdCkge1xuXG4gICAgdmFyIHR5cGUgPSBpc0J1aWx0SW4obnNOYW1lLm5hbWUpID8geyBuYW1lOiBuc05hbWUubmFtZSB9IDogdGhpcy50eXBlTWFwW25zTmFtZS5uYW1lXTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlIHRoZSBzZWxlY3RlZCBzdXBlciB0eXBlIG9yIHRyYWl0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbdHJhaXQ9ZmFsc2VdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhdmVyc2UoY2xzLCB0cmFpdCkge1xuICAgICAgdmFyIHBhcmVudE5zID0gcGFyc2VOYW1lKGNscywgaXNCdWlsdEluKGNscykgPyAnJyA6IG5zTmFtZS5wcmVmaXgpO1xuICAgICAgc2VsZi5tYXBUeXBlcyhwYXJlbnROcywgaXRlcmF0b3IsIHRyYWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZSB0aGUgc2VsZWN0ZWQgdHJhaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhdmVyc2VUcmFpdChjbHMpIHtcbiAgICAgIHJldHVybiB0cmF2ZXJzZShjbHMsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlIHRoZSBzZWxlY3RlZCBzdXBlciB0eXBlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhdmVyc2VTdXBlcihjbHMpIHtcbiAgICAgIHJldHVybiB0cmF2ZXJzZShjbHMsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biB0eXBlIDwnICsgbnNOYW1lLm5hbWUgKyAnPicpO1xuICAgIH1cblxuICAgIGZvckVhY2gkMSh0eXBlLnN1cGVyQ2xhc3MsIHRyYWl0ID8gdHJhdmVyc2VUcmFpdCA6IHRyYXZlcnNlU3VwZXIpO1xuXG4gICAgLy8gY2FsbCBpdGVyYXRvciB3aXRoICh0eXBlLCBpbmhlcml0ZWQ9IXRyYWl0KVxuICAgIGl0ZXJhdG9yKHR5cGUsICF0cmFpdCk7XG5cbiAgICBmb3JFYWNoJDEodHlwZS50cmFpdHMsIHRyYXZlcnNlVHJhaXQpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSBkZXNjcmlwdG9yIGZvciBhIHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZSB0aGUgbmFtZXNwYWNlZCBuYW1lIChuczpsb2NhbE5hbWUpIG9mIHRoZSB0eXBlXG4gICAqXG4gICAqIEByZXR1cm4ge0Rlc2NyaXB0b3J9IHRoZSByZXN1bHRpbmcgZWZmZWN0aXZlIGRlc2NyaXB0b3JcbiAgICovXG4gIFJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRFZmZlY3RpdmVEZXNjcmlwdG9yID0gZnVuY3Rpb24obmFtZSkge1xuXG4gICAgdmFyIG5zTmFtZSA9IHBhcnNlTmFtZShuYW1lKTtcblxuICAgIHZhciBidWlsZGVyID0gbmV3IERlc2NyaXB0b3JCdWlsZGVyKG5zTmFtZSk7XG5cbiAgICB0aGlzLm1hcFR5cGVzKG5zTmFtZSwgZnVuY3Rpb24odHlwZSwgaW5oZXJpdGVkKSB7XG4gICAgICBidWlsZGVyLmFkZFRyYWl0KHR5cGUsIGluaGVyaXRlZCk7XG4gICAgfSk7XG5cbiAgICB2YXIgZGVzY3JpcHRvciA9IGJ1aWxkZXIuYnVpbGQoKTtcblxuICAgIC8vIGRlZmluZSBwYWNrYWdlIGxpbmtcbiAgICB0aGlzLmRlZmluZVBhY2thZ2UoZGVzY3JpcHRvciwgZGVzY3JpcHRvci5hbGxUeXBlc1tkZXNjcmlwdG9yLmFsbFR5cGVzLmxlbmd0aCAtIDFdLiRwa2cpO1xuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gIH07XG5cblxuICBSZWdpc3RyeS5wcm90b3R5cGUuZGVmaW5lUGFja2FnZSA9IGZ1bmN0aW9uKHRhcmdldCwgcGtnKSB7XG4gICAgdGhpcy5wcm9wZXJ0aWVzLmRlZmluZSh0YXJnZXQsICckcGtnJywgeyB2YWx1ZTogcGtnIH0pO1xuICB9O1xuXG5cblxuICAvLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICBmdW5jdGlvbiBlbnN1cmVBdmFpbGFibGUocGFja2FnZU1hcCwgcGtnLCBpZGVudGlmaWVyS2V5KSB7XG5cbiAgICB2YXIgdmFsdWUgPSBwa2dbaWRlbnRpZmllcktleV07XG5cbiAgICBpZiAodmFsdWUgaW4gcGFja2FnZU1hcCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWNrYWdlIHdpdGggJyArIGlkZW50aWZpZXJLZXkgKyAnIDwnICsgdmFsdWUgKyAnPiBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSB1dGlsaXR5IHRoYXQgZ2V0cyBhbmQgc2V0cyBwcm9wZXJ0aWVzIG9mIG1vZGVsIGVsZW1lbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsfSBtb2RlbFxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcGVydGllcyhtb2RlbCkge1xuICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNldHMgYSBuYW1lZCBwcm9wZXJ0eSBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAqIElmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIHRoZSBwcm9wZXJ0eSBnZXRzIGRlbGV0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAqL1xuICBQcm9wZXJ0aWVzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG5cbiAgICBpZiAoIWlzU3RyaW5nKG5hbWUpIHx8ICFuYW1lLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvcGVydHkgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMuZ2V0UHJvcGVydHkodGFyZ2V0LCBuYW1lKTtcblxuICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5uYW1lO1xuXG4gICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuXG4gICAgICAvLyB1bnNldCB0aGUgcHJvcGVydHksIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgdW5kZWZpbmVkO1xuICAgICAgLy8gZGVsZXRlIGZyb20gJGF0dHJzIChmb3IgZXh0ZW5zaW9ucykgb3IgdGhlIHRhcmdldCBpdHNlbGZcbiAgICAgIGlmIChwcm9wZXJ0eSkge1xuICAgICAgICBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5TmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGFyZ2V0LiRhdHRyc1tzdHJpcEdsb2JhbChuYW1lKV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gc2V0IHRoZSBwcm9wZXJ0eSwgZGVmaW5pbmcgd2VsbCBkZWZpbmVkIHByb3BlcnRpZXMgb24gdGhlIGZseVxuICAgICAgLy8gb3Igc2ltcGx5IHVwZGF0aW5nIHRoZW0gaW4gdGFyZ2V0LiRhdHRycyAoZm9yIGV4dGVuc2lvbnMpXG4gICAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICB0YXJnZXRbcHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0LiRhdHRyc1tzdHJpcEdsb2JhbChuYW1lKV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5hbWVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBQcm9wZXJ0aWVzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbih0YXJnZXQsIG5hbWUpIHtcblxuICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMuZ2V0UHJvcGVydHkodGFyZ2V0LCBuYW1lKTtcblxuICAgIGlmICghcHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0YXJnZXQuJGF0dHJzW3N0cmlwR2xvYmFsKG5hbWUpXTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHlOYW1lID0gcHJvcGVydHkubmFtZTtcblxuICAgIC8vIGNoZWNrIGlmIGFjY2VzcyB0byBjb2xsZWN0aW9uIHByb3BlcnR5IGFuZCBsYXppbHkgaW5pdGlhbGl6ZSBpdFxuICAgIGlmICghdGFyZ2V0W3Byb3BlcnR5TmFtZV0gJiYgcHJvcGVydHkuaXNNYW55KSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBbXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eU5hbWVdO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIERlZmluZSBhIHByb3BlcnR5IG9uIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBQcm9wZXJ0aWVzLnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbih0YXJnZXQsIG5hbWUsIG9wdGlvbnMpIHtcblxuICAgIGlmICghb3B0aW9ucy53cml0YWJsZSkge1xuXG4gICAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuXG4gICAgICAvLyB1c2UgZ2V0dGVycyBmb3IgcmVhZC1vbmx5IHZhcmlhYmxlcyB0byBzdXBwb3J0IEVTNiBwcm94aWVzXG4gICAgICAvLyBjZi4gaHR0cHM6Ly9naXRodWIuY29tL2JwbW4taW8vaW50ZXJuYWwtZG9jcy9pc3N1ZXMvMzg2XG4gICAgICBvcHRpb25zID0gYXNzaWduJDEoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHZhbHVlOyB9XG4gICAgICB9KTtcblxuICAgICAgZGVsZXRlIG9wdGlvbnMudmFsdWU7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwgb3B0aW9ucyk7XG4gIH07XG5cblxuICAvKipcbiAgICogRGVmaW5lIHRoZSBkZXNjcmlwdG9yIGZvciBhbiBlbGVtZW50XG4gICAqL1xuICBQcm9wZXJ0aWVzLnByb3RvdHlwZS5kZWZpbmVEZXNjcmlwdG9yID0gZnVuY3Rpb24odGFyZ2V0LCBkZXNjcmlwdG9yKSB7XG4gICAgdGhpcy5kZWZpbmUodGFyZ2V0LCAnJGRlc2NyaXB0b3InLCB7IHZhbHVlOiBkZXNjcmlwdG9yIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWZpbmUgdGhlIG1vZGVsIGZvciBhbiBlbGVtZW50XG4gICAqL1xuICBQcm9wZXJ0aWVzLnByb3RvdHlwZS5kZWZpbmVNb2RlbCA9IGZ1bmN0aW9uKHRhcmdldCwgbW9kZWwpIHtcbiAgICB0aGlzLmRlZmluZSh0YXJnZXQsICckbW9kZWwnLCB7IHZhbHVlOiBtb2RlbCB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIG5hbWUgb24gdGhlIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSB0YXJnZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0IHwgbnVsbH0gcHJvcGVydHlcbiAgICovXG4gIFByb3BlcnRpZXMucHJvdG90eXBlLmdldFByb3BlcnR5ID0gZnVuY3Rpb24odGFyZ2V0LCBuYW1lKSB7XG5cbiAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuXG4gICAgdmFyIHByb3BlcnR5ID0gbW9kZWwuZ2V0UHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgbmFtZSk7XG5cbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICB9XG5cbiAgICBpZiAobmFtZS5pbmNsdWRlcygnOicpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBzdHJpY3QgPSBtb2RlbC5jb25maWcuc3RyaWN0O1xuXG4gICAgaWYgKHR5cGVvZiBzdHJpY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBUeXBlRXJyb3IoYHVua25vd24gcHJvcGVydHkgPCR7IG5hbWUgfT4gb24gPCR7IHRhcmdldC4kdHlwZSB9PmApO1xuXG4gICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eS5uYW1lLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhcHJvcGVydHkuaXNSZWZlcmVuY2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaXBHbG9iYWwobmFtZSkge1xuICAgIHJldHVybiBuYW1lLnJlcGxhY2UoL146LywgJycpO1xuICB9XG5cbiAgLy8gTW9kZGxlIGltcGxlbWVudGF0aW9uIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogQGNsYXNzIE1vZGRsZVxuICAgKlxuICAgKiBBIG1vZGVsIHRoYXQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGVsZW1lbnRzIG9mIGEgc3BlY2lmaWMgdHlwZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIE1vZGRsZSA9IHJlcXVpcmUoJ21vZGRsZScpO1xuICAgKlxuICAgKiB2YXIgcGtnID0ge1xuICAgKiAgIG5hbWU6ICdteXBhY2thZ2UnLFxuICAgKiAgIHByZWZpeDogJ215JyxcbiAgICogICB0eXBlczogW1xuICAgKiAgICAgeyBuYW1lOiAnUm9vdCcgfVxuICAgKiAgIF1cbiAgICogfTtcbiAgICpcbiAgICogdmFyIG1vZGRsZSA9IG5ldyBNb2RkbGUoW3BrZ10pO1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFBhY2thZ2U+fSBwYWNrYWdlcyB0aGUgcGFja2FnZXMgdG8gY29udGFpblxuICAgKlxuICAgKiBAcGFyYW0geyB7IHN0cmljdD86IGJvb2xlYW4gfSB9IFtjb25maWddIG1vZGRsZSBjb25maWd1cmF0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBNb2RkbGUocGFja2FnZXMsIGNvbmZpZyA9IHt9KSB7XG5cbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgUHJvcGVydGllcyh0aGlzKTtcblxuICAgIHRoaXMuZmFjdG9yeSA9IG5ldyBGYWN0b3J5KHRoaXMsIHRoaXMucHJvcGVydGllcyk7XG4gICAgdGhpcy5yZWdpc3RyeSA9IG5ldyBSZWdpc3RyeShwYWNrYWdlcywgdGhpcy5wcm9wZXJ0aWVzKTtcblxuICAgIHRoaXMudHlwZUNhY2hlID0ge307XG5cbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuXG4gICAqXG4gICAqIEBtZXRob2QgTW9kZGxlI2NyZWF0ZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgZm9vID0gbW9kZGxlLmNyZWF0ZSgnbXk6Rm9vJyk7XG4gICAqIHZhciBiYXIgPSBtb2RkbGUuY3JlYXRlKCdteTpCYXInLCB7IGlkOiAnQkFSXzEnIH0pO1xuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fSBkZXNjcmlwdG9yIHRoZSB0eXBlIGRlc2NyaXB0b3Igb3IgbmFtZSBrbm93IHRvIHRoZSBtb2RlbFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGF0dHJzICAgYSBudW1iZXIgb2YgYXR0cmlidXRlcyB0byBpbml0aWFsaXplIHRoZSBtb2RlbCBpbnN0YW5jZSB3aXRoXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBtb2RlbCBpbnN0YW5jZVxuICAgKi9cbiAgTW9kZGxlLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihkZXNjcmlwdG9yLCBhdHRycykge1xuICAgIHZhciBUeXBlID0gdGhpcy5nZXRUeXBlKGRlc2NyaXB0b3IpO1xuXG4gICAgaWYgKCFUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gdHlwZSA8JyArIGRlc2NyaXB0b3IgKyAnPicpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVHlwZShhdHRycyk7XG4gIH07XG5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdHlwZSByZXByZXNlbnRpbmcgYSBnaXZlbiBkZXNjcmlwdG9yXG4gICAqXG4gICAqIEBtZXRob2QgTW9kZGxlI2dldFR5cGVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIEZvbyA9IG1vZGRsZS5nZXRUeXBlKCdteTpGb28nKTtcbiAgICogdmFyIGZvbyA9IG5ldyBGb28oeyAnaWQnIDogJ0ZPT18xJyB9KTtcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfE9iamVjdH0gZGVzY3JpcHRvciB0aGUgdHlwZSBkZXNjcmlwdG9yIG9yIG5hbWUga25vdyB0byB0aGUgbW9kZWxcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIHRoZSB0eXBlIHJlcHJlc2VudGluZyB0aGUgZGVzY3JpcHRvclxuICAgKi9cbiAgTW9kZGxlLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24oZGVzY3JpcHRvcikge1xuXG4gICAgdmFyIGNhY2hlID0gdGhpcy50eXBlQ2FjaGU7XG5cbiAgICB2YXIgbmFtZSA9IGlzU3RyaW5nKGRlc2NyaXB0b3IpID8gZGVzY3JpcHRvciA6IGRlc2NyaXB0b3IubnMubmFtZTtcblxuICAgIHZhciB0eXBlID0gY2FjaGVbbmFtZV07XG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSB0aGlzLnJlZ2lzdHJ5LmdldEVmZmVjdGl2ZURlc2NyaXB0b3IobmFtZSk7XG4gICAgICB0eXBlID0gY2FjaGVbbmFtZV0gPSB0aGlzLmZhY3RvcnkuY3JlYXRlVHlwZShkZXNjcmlwdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFueS1lbGVtZW50IHR5cGUgdG8gYmUgdXNlZCB3aXRoaW4gbW9kZWwgaW5zdGFuY2VzLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBjdXN0b20gZWxlbWVudHMgdGhhdCBsaWUgb3V0c2lkZSB0aGUgbWV0YS1tb2RlbC5cbiAgICogVGhlIGNyZWF0ZWQgZWxlbWVudCBjb250YWlucyBhbGwgdGhlIG1ldGEtZGF0YSByZXF1aXJlZCB0byBzZXJpYWxpemUgaXRcbiAgICogYXMgcGFydCBvZiBtZXRhLW1vZGVsIGVsZW1lbnRzLlxuICAgKlxuICAgKiBAbWV0aG9kIE1vZGRsZSNjcmVhdGVBbnlcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIGZvbyA9IG1vZGRsZS5jcmVhdGVBbnkoJ3ZlbmRvcjpGb28nLCAnaHR0cDovL3ZlbmRvcicsIHtcbiAgICogICB2YWx1ZTogJ2JhcidcbiAgICogfSk7XG4gICAqXG4gICAqIHZhciBjb250YWluZXIgPSBtb2RkbGUuY3JlYXRlKCdteTpDb250YWluZXInLCAnaHR0cDovL215Jywge1xuICAgKiAgIGFueTogWyBmb28gXVxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gZ28gYWhlYWQgYW5kIHNlcmlhbGl6ZSB0aGUgc3R1ZmZcbiAgICpcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lICB0aGUgbmFtZSBvZiB0aGUgZWxlbWVudFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5zVXJpIHRoZSBuYW1lc3BhY2UgdXJpIG9mIHRoZSBlbGVtZW50XG4gICAqIEBwYXJhbSAge09iamVjdH0gW3Byb3BlcnRpZXNdIGEgbWFwIG9mIHByb3BlcnRpZXMgdG8gaW5pdGlhbGl6ZSB0aGUgaW5zdGFuY2Ugd2l0aFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBhbnkgdHlwZSBpbnN0YW5jZVxuICAgKi9cbiAgTW9kZGxlLnByb3RvdHlwZS5jcmVhdGVBbnkgPSBmdW5jdGlvbihuYW1lLCBuc1VyaSwgcHJvcGVydGllcykge1xuXG4gICAgdmFyIG5hbWVOcyA9IHBhcnNlTmFtZShuYW1lKTtcblxuICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgJHR5cGU6IG5hbWUsXG4gICAgICAkaW5zdGFuY2VPZjogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gdGhpcy4kdHlwZTtcbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpc1trZXldO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBzZXQkMSh0aGlzLCBbIGtleSBdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGlzR2VuZXJpYzogdHJ1ZSxcbiAgICAgIG5zOiB7XG4gICAgICAgIHByZWZpeDogbmFtZU5zLnByZWZpeCxcbiAgICAgICAgbG9jYWxOYW1lOiBuYW1lTnMubG9jYWxOYW1lLFxuICAgICAgICB1cmk6IG5zVXJpXG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucHJvcGVydGllcy5kZWZpbmVEZXNjcmlwdG9yKGVsZW1lbnQsIGRlc2NyaXB0b3IpO1xuICAgIHRoaXMucHJvcGVydGllcy5kZWZpbmVNb2RlbChlbGVtZW50LCB0aGlzKTtcbiAgICB0aGlzLnByb3BlcnRpZXMuZGVmaW5lKGVsZW1lbnQsICdnZXQnLCB7IGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICB0aGlzLnByb3BlcnRpZXMuZGVmaW5lKGVsZW1lbnQsICdzZXQnLCB7IGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICB0aGlzLnByb3BlcnRpZXMuZGVmaW5lKGVsZW1lbnQsICckcGFyZW50JywgeyBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgdGhpcy5wcm9wZXJ0aWVzLmRlZmluZShlbGVtZW50LCAnJGluc3RhbmNlT2YnLCB7IGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9KTtcblxuICAgIGZvckVhY2gkMShwcm9wZXJ0aWVzLCBmdW5jdGlvbihhLCBrZXkpIHtcbiAgICAgIGlmIChpc09iamVjdChhKSAmJiBhLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWxlbWVudFthLm5hbWVdID0gYS52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnRba2V5XSA9IGE7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHJlZ2lzdGVyZWQgcGFja2FnZSBieSB1cmkgb3IgcHJlZml4XG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gdGhlIHBhY2thZ2VcbiAgICovXG4gIE1vZGRsZS5wcm90b3R5cGUuZ2V0UGFja2FnZSA9IGZ1bmN0aW9uKHVyaU9yUHJlZml4KSB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0cnkuZ2V0UGFja2FnZSh1cmlPclByZWZpeCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzbmFwc2hvdCBvZiBhbGwga25vd24gcGFja2FnZXNcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgcGFja2FnZVxuICAgKi9cbiAgTW9kZGxlLnByb3RvdHlwZS5nZXRQYWNrYWdlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LmdldFBhY2thZ2VzKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlc2NyaXB0b3IgZm9yIGFuIGVsZW1lbnRcbiAgICovXG4gIE1vZGRsZS5wcm90b3R5cGUuZ2V0RWxlbWVudERlc2NyaXB0b3IgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuJGRlc2NyaXB0b3I7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZGVzY3JpcHRvciBvciBpbnN0YW5jZVxuICAgKiByZXByZXNlbnRzIHRoZSBnaXZlbiB0eXBlLlxuICAgKlxuICAgKiBNYXkgYmUgYXBwbGllZCB0byB0aGlzLCBpZiBlbGVtZW50IGlzIG9taXR0ZWQuXG4gICAqL1xuICBNb2RkbGUucHJvdG90eXBlLmhhc1R5cGUgPSBmdW5jdGlvbihlbGVtZW50LCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdHlwZSA9IGVsZW1lbnQ7XG4gICAgICBlbGVtZW50ID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnQuJG1vZGVsLmdldEVsZW1lbnREZXNjcmlwdG9yKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuICh0eXBlIGluIGRlc2NyaXB0b3IuYWxsVHlwZXNCeU5hbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXNjcmlwdG9yIG9mIGFuIGVsZW1lbnRzIG5hbWVkIHByb3BlcnR5XG4gICAqL1xuICBNb2RkbGUucHJvdG90eXBlLmdldFByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudERlc2NyaXB0b3IoZWxlbWVudCkucHJvcGVydGllc0J5TmFtZVtwcm9wZXJ0eV07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBtYXBwZWQgdHlwZSdzIGRlc2NyaXB0b3JcbiAgICovXG4gIE1vZGRsZS5wcm90b3R5cGUuZ2V0VHlwZURlc2NyaXB0b3IgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0cnkudHlwZU1hcFt0eXBlXTtcbiAgfTtcblxuICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIHZhciBFTlRJVFlfUEFUVEVSTiA9IC8mIyhcXGQrKTt8JiN4KFswLTlhLWZdKyk7fCYoXFx3Kyk7L2lnO1xuXG4gIHZhciBFTlRJVFlfTUFQUElORyA9IHtcbiAgICAnYW1wJzogJyYnLFxuICAgICdhcG9zJzogJ1xcJycsXG4gICAgJ2d0JzogJz4nLFxuICAgICdsdCc6ICc8JyxcbiAgICAncXVvdCc6ICdcIidcbiAgfTtcblxuICAvLyBtYXAgVVBQRVJDQVNFIHZhcmlhbnRzIG9mIHN1cHBvcnRlZCBzcGVjaWFsIGNoYXJzXG4gIE9iamVjdC5rZXlzKEVOVElUWV9NQVBQSU5HKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBFTlRJVFlfTUFQUElOR1trLnRvVXBwZXJDYXNlKCldID0gRU5USVRZX01BUFBJTkdba107XG4gIH0pO1xuXG5cbiAgZnVuY3Rpb24gcmVwbGFjZUVudGl0aWVzKF8sIGQsIHgsIHopIHtcblxuICAgIC8vIHJlc2VydmVkIG5hbWVzLCBpLmUuICZuYnNwO1xuICAgIGlmICh6KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChFTlRJVFlfTUFQUElORywgeikpIHtcbiAgICAgICAgcmV0dXJuIEVOVElUWV9NQVBQSU5HW3pdO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBmYWxsIGJhY2sgdG8gb3JpZ2luYWwgdmFsdWVcbiAgICAgICAgcmV0dXJuICcmJyArIHogKyAnOyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGVjaW1hbCBlbmNvZGVkIGNoYXJcbiAgICBpZiAoZCkge1xuICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShkKTtcbiAgICB9XG5cbiAgICAvLyBoZXggZW5jb2RlZCBjaGFyXG4gICAgcmV0dXJuIGZyb21DaGFyQ29kZShwYXJzZUludCh4LCAxNikpO1xuICB9XG5cblxuICAvKipcbiAgICogQSBiYXNpYyBlbnRpdHkgZGVjb2RlciB0aGF0IGNhbiBkZWNvZGUgYSBtaW5pbWFsXG4gICAqIHN1Yi1zZXQgb2YgcmVzZXJ2ZWQgbmFtZXMgKCZhbXA7KSBhcyB3ZWxsIGFzXG4gICAqIGhleCAoJiN4YWFmOykgYW5kIGRlY2ltYWwgKCYjMTIzMTspIGVuY29kZWQgY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBkZWNvZGVkIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gZGVjb2RlRW50aXRpZXMocykge1xuICAgIGlmIChzLmxlbmd0aCA+IDMgJiYgcy5pbmRleE9mKCcmJykgIT09IC0xKSB7XG4gICAgICByZXR1cm4gcy5yZXBsYWNlKEVOVElUWV9QQVRURVJOLCByZXBsYWNlRW50aXRpZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBzO1xuICB9XG5cbiAgdmFyIE5PTl9XSElURVNQQUNFX09VVFNJREVfUk9PVF9OT0RFID0gJ25vbi13aGl0ZXNwYWNlIG91dHNpZGUgb2Ygcm9vdCBub2RlJztcblxuICBmdW5jdGlvbiBlcnJvciQxKG1zZykge1xuICAgIHJldHVybiBuZXcgRXJyb3IobXNnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1pc3NpbmdOYW1lc3BhY2VGb3JQcmVmaXgocHJlZml4KSB7XG4gICAgcmV0dXJuICdtaXNzaW5nIG5hbWVzcGFjZSBmb3IgcHJlZml4IDwnICsgcHJlZml4ICsgJz4nO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0dGVyKGdldEZuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdnZXQnOiBnZXRGbixcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZU5zTWF0cml4KG5zTWF0cml4KSB7XG4gICAgdmFyIGNsb25lID0ge30sIGtleTtcbiAgICBmb3IgKGtleSBpbiBuc01hdHJpeCkge1xuICAgICAgY2xvbmVba2V5XSA9IG5zTWF0cml4W2tleV07XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVyaVByZWZpeChwcmVmaXgpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJyR1cmknO1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGROc01hdHJpeChuc1VyaVRvUHJlZml4KSB7XG4gICAgdmFyIG5zTWF0cml4ID0ge30sXG4gICAgICAgIHVyaSxcbiAgICAgICAgcHJlZml4O1xuXG4gICAgZm9yICh1cmkgaW4gbnNVcmlUb1ByZWZpeCkge1xuICAgICAgcHJlZml4ID0gbnNVcmlUb1ByZWZpeFt1cmldO1xuICAgICAgbnNNYXRyaXhbcHJlZml4XSA9IHByZWZpeDtcbiAgICAgIG5zTWF0cml4W3VyaVByZWZpeChwcmVmaXgpXSA9IHVyaTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnNNYXRyaXg7XG4gIH1cblxuICBmdW5jdGlvbiBub29wR2V0Q29udGV4dCgpIHtcbiAgICByZXR1cm4geyBsaW5lOiAwLCBjb2x1bW46IDAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRocm93RnVuYyhlcnIpIHtcbiAgICB0aHJvdyBlcnI7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwYXJzZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSAgeyFPYmplY3Q8c3RyaW5nLCA/Pj19IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIFBhcnNlcihvcHRpb25zKSB7XG5cbiAgICBpZiAoIXRoaXMpIHtcbiAgICAgIHJldHVybiBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBwcm94eSA9IG9wdGlvbnMgJiYgb3B0aW9uc1sncHJveHknXTtcblxuICAgIHZhciBvblRleHQsXG4gICAgICAgIG9uT3BlblRhZyxcbiAgICAgICAgb25DbG9zZVRhZyxcbiAgICAgICAgb25DREFUQSxcbiAgICAgICAgb25FcnJvciA9IHRocm93RnVuYyxcbiAgICAgICAgb25XYXJuaW5nLFxuICAgICAgICBvbkNvbW1lbnQsXG4gICAgICAgIG9uUXVlc3Rpb24sXG4gICAgICAgIG9uQXR0ZW50aW9uO1xuXG4gICAgdmFyIGdldENvbnRleHQgPSBub29wR2V0Q29udGV4dDtcblxuICAgIC8qKlxuICAgICAqIERvIHdlIG5lZWQgdG8gcGFyc2UgdGhlIGN1cnJlbnQgZWxlbWVudHMgYXR0cmlidXRlcyBmb3IgbmFtZXNwYWNlcz9cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHZhciBtYXliZU5TID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBEbyB3ZSBwcm9jZXNzIG5hbWVzcGFjZXMgYXQgYWxsP1xuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdmFyIGlzTmFtZXNwYWNlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2F1Z2h0IGVycm9yIHJldHVybmVkIG9uIHBhcnNlIGVuZFxuICAgICAqXG4gICAgICogQHR5cGUge0Vycm9yfVxuICAgICAqL1xuICAgIHZhciByZXR1cm5FcnJvciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTaG91bGQgd2Ugc3RvcCBwYXJzaW5nP1xuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdmFyIHBhcnNlU3RvcCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQSBtYXAgb2YgeyB1cmk6IHByZWZpeCB9IHVzZWQgYnkgdGhlIHBhcnNlci5cbiAgICAgKlxuICAgICAqIFRoaXMgbWFwIHdpbGwgZW5zdXJlIHdlIGNhbiBub3JtYWxpemUgcHJlZml4ZXMgZHVyaW5nIHByb2Nlc3Npbmc7XG4gICAgICogZm9yIGVhY2ggdXJpLCBvbmx5IG9uZSBwcmVmaXggd2lsbCBiZSBleHBvc2VkIHRvIHRoZSBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn19XG4gICAgICovXG4gICAgdmFyIG5zVXJpVG9QcmVmaXg7XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcGFyc2UgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd8RXJyb3J9IGVyclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycikge1xuICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgIGVyciA9IGVycm9yJDEoZXJyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuRXJyb3IgPSBlcnI7XG5cbiAgICAgIG9uRXJyb3IoZXJyLCBnZXRDb250ZXh0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcGFyc2UgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd8RXJyb3J9IGVyclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhbmRsZVdhcm5pbmcoZXJyKSB7XG5cbiAgICAgIGlmICghb25XYXJuaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgIGVyciA9IGVycm9yJDEoZXJyKTtcbiAgICAgIH1cblxuICAgICAgb25XYXJuaW5nKGVyciwgZ2V0Q29udGV4dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgcGFyc2UgbGlzdGVuZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgbmFtZVxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAqXG4gICAgICogQHJldHVybiB7UGFyc2VyfVxuICAgICAqL1xuICAgIHRoaXNbJ29uJ10gPSBmdW5jdGlvbihuYW1lLCBjYikge1xuXG4gICAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IGVycm9yJDEoJ3JlcXVpcmVkIGFyZ3MgPG5hbWUsIGNiPicpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ29wZW5UYWcnOiBvbk9wZW5UYWcgPSBjYjsgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0Jzogb25UZXh0ID0gY2I7IGJyZWFrO1xuICAgICAgY2FzZSAnY2xvc2VUYWcnOiBvbkNsb3NlVGFnID0gY2I7IGJyZWFrO1xuICAgICAgY2FzZSAnZXJyb3InOiBvbkVycm9yID0gY2I7IGJyZWFrO1xuICAgICAgY2FzZSAnd2Fybic6IG9uV2FybmluZyA9IGNiOyBicmVhaztcbiAgICAgIGNhc2UgJ2NkYXRhJzogb25DREFUQSA9IGNiOyBicmVhaztcbiAgICAgIGNhc2UgJ2F0dGVudGlvbic6IG9uQXR0ZW50aW9uID0gY2I7IGJyZWFrOyAvLyA8IVhYWFhYIHp6eno9XCJlZWVlXCI+XG4gICAgICBjYXNlICdxdWVzdGlvbic6IG9uUXVlc3Rpb24gPSBjYjsgYnJlYWs7IC8vIDw/IC4uLi4gID8+XG4gICAgICBjYXNlICdjb21tZW50Jzogb25Db21tZW50ID0gY2I7IGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgZXJyb3IkMSgndW5zdXBwb3J0ZWQgZXZlbnQ6ICcgKyBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbmFtZXNwYWNlIHRvIHByZWZpeCBtYXBwaW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHBhcnNlci5ucyh7XG4gICAgICogICAnaHR0cDovL2Zvbyc6ICdmb28nLFxuICAgICAqICAgJ2h0dHA6Ly9iYXInOiAnYmFyJ1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtICB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz59IG5zTWFwXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQYXJzZXJ9XG4gICAgICovXG4gICAgdGhpc1snbnMnXSA9IGZ1bmN0aW9uKG5zTWFwKSB7XG5cbiAgICAgIGlmICh0eXBlb2YgbnNNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG5zTWFwID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbnNNYXAgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IGVycm9yJDEoJ3JlcXVpcmVkIGFyZ3MgPG5zTWFwPXt9PicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX25zVXJpVG9QcmVmaXggPSB7fSwgaztcblxuICAgICAgZm9yIChrIGluIG5zTWFwKSB7XG4gICAgICAgIF9uc1VyaVRvUHJlZml4W2tdID0gbnNNYXBba107XG4gICAgICB9XG5cbiAgICAgIGlzTmFtZXNwYWNlID0gdHJ1ZTtcbiAgICAgIG5zVXJpVG9QcmVmaXggPSBfbnNVcmlUb1ByZWZpeDtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHhtbCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHhtbFxuICAgICAqXG4gICAgICogQHJldHVybiB7RXJyb3J9IHJldHVybkVycm9yLCBpZiBub3QgdGhyb3duXG4gICAgICovXG4gICAgdGhpc1sncGFyc2UnXSA9IGZ1bmN0aW9uKHhtbCkge1xuICAgICAgaWYgKHR5cGVvZiB4bWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IGVycm9yJDEoJ3JlcXVpcmVkIGFyZ3MgPHhtbD1zdHJpbmc+Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybkVycm9yID0gbnVsbDtcblxuICAgICAgcGFyc2UoeG1sKTtcblxuICAgICAgZ2V0Q29udGV4dCA9IG5vb3BHZXRDb250ZXh0O1xuICAgICAgcGFyc2VTdG9wID0gZmFsc2U7XG5cbiAgICAgIHJldHVybiByZXR1cm5FcnJvcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RvcCBwYXJzaW5nLlxuICAgICAqL1xuICAgIHRoaXNbJ3N0b3AnXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcGFyc2VTdG9wID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2Ugc3RyaW5nLCBpbnZva2luZyBjb25maWd1cmVkIGxpc3RlbmVycyBvbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB4bWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZSh4bWwpIHtcbiAgICAgIHZhciBuc01hdHJpeFN0YWNrID0gaXNOYW1lc3BhY2UgPyBbXSA6IG51bGwsXG4gICAgICAgICAgbnNNYXRyaXggPSBpc05hbWVzcGFjZSA/IGJ1aWxkTnNNYXRyaXgobnNVcmlUb1ByZWZpeCkgOiBudWxsLFxuICAgICAgICAgIF9uc01hdHJpeCxcbiAgICAgICAgICBub2RlU3RhY2sgPSBbXSxcbiAgICAgICAgICBhbm9ueW1vdXNOc0NvdW50ID0gMCxcbiAgICAgICAgICB0YWdTdGFydCA9IGZhbHNlLFxuICAgICAgICAgIHRhZ0VuZCA9IGZhbHNlLFxuICAgICAgICAgIGkgPSAwLCBqID0gMCxcbiAgICAgICAgICB4LCB5LCBxLCB3LCB2LFxuICAgICAgICAgIHhtbG5zLFxuICAgICAgICAgIGVsZW1lbnROYW1lLFxuICAgICAgICAgIF9lbGVtZW50TmFtZSxcbiAgICAgICAgICBlbGVtZW50UHJveHlcbiAgICAgICAgICA7XG5cbiAgICAgIHZhciBhdHRyc1N0cmluZyA9ICcnLFxuICAgICAgICAgIGF0dHJzU3RhcnQgPSAwLFxuICAgICAgICAgIGNhY2hlZEF0dHJzIC8vIGZhbHNlID0gcGFyc2VkIHdpdGggZXJyb3JzLCBudWxsID0gbmVlZHMgcGFyc2luZ1xuICAgICAgICAgIDtcblxuICAgICAgLyoqXG4gICAgICAgKiBQYXJzZSBhdHRyaWJ1dGVzIG9uIGRlbWFuZCBhbmQgcmV0dXJucyB0aGUgcGFyc2VkIGF0dHJpYnV0ZXMuXG4gICAgICAgKlxuICAgICAgICogUmV0dXJuIHNlbWFudGljczogKDEpIGBmYWxzZWAgb24gYXR0cmlidXRlIHBhcnNlIGVycm9yLFxuICAgICAgICogKDIpIG9iamVjdCBoYXNoIG9uIGV4dHJhY3RlZCBhdHRycy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufE9iamVjdH1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZ2V0QXR0cnMoKSB7XG4gICAgICAgIGlmIChjYWNoZWRBdHRycyAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBjYWNoZWRBdHRycztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuc1VyaSxcbiAgICAgICAgICAgIG5zVXJpUHJlZml4LFxuICAgICAgICAgICAgbnNOYW1lLFxuICAgICAgICAgICAgZGVmYXVsdEFsaWFzID0gaXNOYW1lc3BhY2UgJiYgbnNNYXRyaXhbJ3htbG5zJ10sXG4gICAgICAgICAgICBhdHRyTGlzdCA9IGlzTmFtZXNwYWNlICYmIG1heWJlTlMgPyBbXSA6IG51bGwsXG4gICAgICAgICAgICBpID0gYXR0cnNTdGFydCxcbiAgICAgICAgICAgIHMgPSBhdHRyc1N0cmluZyxcbiAgICAgICAgICAgIGwgPSBzLmxlbmd0aCxcbiAgICAgICAgICAgIGhhc05ld01hdHJpeCxcbiAgICAgICAgICAgIG5ld2FsaWFzLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBhbGlhcyxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhdHRycyA9IHt9LFxuICAgICAgICAgICAgc2VlbkF0dHJzID0ge30sXG4gICAgICAgICAgICBza2lwQXR0cixcbiAgICAgICAgICAgIHcsXG4gICAgICAgICAgICBqO1xuXG4gICAgICAgIHBhcnNlQXR0cjpcbiAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBza2lwQXR0ciA9IGZhbHNlO1xuICAgICAgICAgIHcgPSBzLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgICBpZiAodyA9PT0gMzIgfHwgKHcgPCAxNCAmJiB3ID4gOCkpIHsgLy8gV0hJVEVTUEFDRT17IFxcZlxcblxcclxcdFxcdn1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHdhaXQgZm9yIG5vbiB3aGl0ZXNwYWNlIGNoYXJhY3RlclxuICAgICAgICAgIGlmICh3IDwgNjUgfHwgdyA+IDEyMiB8fCAodyA+IDkwICYmIHcgPCA5NykpIHtcbiAgICAgICAgICAgIGlmICh3ICE9PSA5NSAmJiB3ICE9PSA1OCkgeyAvLyBjaGFyIDk1XCJfXCIgNThcIjpcIlxuICAgICAgICAgICAgICBoYW5kbGVXYXJuaW5nKCdpbGxlZ2FsIGZpcnN0IGNoYXIgYXR0cmlidXRlIG5hbWUnKTtcbiAgICAgICAgICAgICAgc2tpcEF0dHIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHBhcnNlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICAgIHcgPSBzLmNoYXJDb2RlQXQoaik7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdyA+IDk2ICYmIHcgPCAxMjMgfHxcbiAgICAgICAgICAgICAgdyA+IDY0ICYmIHcgPCA5MSB8fFxuICAgICAgICAgICAgICB3ID4gNDcgJiYgdyA8IDU5IHx8XG4gICAgICAgICAgICAgIHcgPT09IDQ2IHx8IC8vICcuJ1xuICAgICAgICAgICAgICB3ID09PSA0NSB8fCAvLyAnLSdcbiAgICAgICAgICAgICAgdyA9PT0gOTUgLy8gJ18nXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgd2hpdGVzcGFjZVxuICAgICAgICAgICAgaWYgKHcgPT09IDMyIHx8ICh3IDwgMTQgJiYgdyA+IDgpKSB7IC8vIFdISVRFU1BBQ0VcbiAgICAgICAgICAgICAgaGFuZGxlV2FybmluZygnbWlzc2luZyBhdHRyaWJ1dGUgdmFsdWUnKTtcbiAgICAgICAgICAgICAgaSA9IGo7XG5cbiAgICAgICAgICAgICAgY29udGludWUgcGFyc2VBdHRyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBleHBlY3RlZCBcIj1cIlxuICAgICAgICAgICAgaWYgKHcgPT09IDYxKSB7IC8vIFwiPVwiID09IDYxXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYW5kbGVXYXJuaW5nKCdpbGxlZ2FsIGF0dHJpYnV0ZSBuYW1lIGNoYXInKTtcbiAgICAgICAgICAgIHNraXBBdHRyID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuYW1lID0gcy5zdWJzdHJpbmcoaSwgaik7XG5cbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3htbG5zOnhtbG5zJykge1xuICAgICAgICAgICAgaGFuZGxlV2FybmluZygnaWxsZWdhbCBkZWNsYXJhdGlvbiBvZiB4bWxucycpO1xuICAgICAgICAgICAgc2tpcEF0dHIgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHcgPSBzLmNoYXJDb2RlQXQoaiArIDEpO1xuXG4gICAgICAgICAgaWYgKHcgPT09IDM0KSB7IC8vICdcIidcbiAgICAgICAgICAgIGogPSBzLmluZGV4T2YoJ1wiJywgaSA9IGogKyAyKTtcblxuICAgICAgICAgICAgaWYgKGogPT09IC0xKSB7XG4gICAgICAgICAgICAgIGogPSBzLmluZGV4T2YoJ1xcJycsIGkpO1xuXG4gICAgICAgICAgICAgIGlmIChqICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ2F0dHJpYnV0ZSB2YWx1ZSBxdW90ZSBtaXNzbWF0Y2gnKTtcbiAgICAgICAgICAgICAgICBza2lwQXR0ciA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAodyA9PT0gMzkpIHsgLy8gXCInXCJcbiAgICAgICAgICAgIGogPSBzLmluZGV4T2YoJ1xcJycsIGkgPSBqICsgMik7XG5cbiAgICAgICAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICAgICAgICBqID0gcy5pbmRleE9mKCdcIicsIGkpO1xuXG4gICAgICAgICAgICAgIGlmIChqICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ2F0dHJpYnV0ZSB2YWx1ZSBxdW90ZSBtaXNzbWF0Y2gnKTtcbiAgICAgICAgICAgICAgICBza2lwQXR0ciA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVXYXJuaW5nKCdtaXNzaW5nIGF0dHJpYnV0ZSB2YWx1ZSBxdW90ZXMnKTtcbiAgICAgICAgICAgIHNraXBBdHRyID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gc2tpcCB0byBuZXh0IHNwYWNlXG4gICAgICAgICAgICBmb3IgKGogPSBqICsgMTsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgICB3ID0gcy5jaGFyQ29kZUF0KGogKyAxKTtcblxuICAgICAgICAgICAgICBpZiAodyA9PT0gMzIgfHwgKHcgPCAxNCAmJiB3ID4gOCkpIHsgLy8gV0hJVEVTUEFDRVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ21pc3NpbmcgY2xvc2luZyBxdW90ZXMnKTtcblxuICAgICAgICAgICAgaiA9IGw7XG4gICAgICAgICAgICBza2lwQXR0ciA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFza2lwQXR0cikge1xuICAgICAgICAgICAgdmFsdWUgPSBzLnN1YnN0cmluZyhpLCBqKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpID0gajtcblxuICAgICAgICAgIC8vIGVuc3VyZSBTUEFDRSBmb2xsb3dzIGF0dHJpYnV0ZVxuICAgICAgICAgIC8vIHNraXAgaWxsZWdhbCBjb250ZW50IG90aGVyd2lzZVxuICAgICAgICAgIC8vIGV4YW1wbGUgYT1cImJcImNcbiAgICAgICAgICBmb3IgKDsgaiArIDEgPCBsOyBqKyspIHtcbiAgICAgICAgICAgIHcgPSBzLmNoYXJDb2RlQXQoaiArIDEpO1xuXG4gICAgICAgICAgICBpZiAodyA9PT0gMzIgfHwgKHcgPCAxNCAmJiB3ID4gOCkpIHsgLy8gV0hJVEVTUEFDRVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRklSU1QgSUxMRUdBTCBDSEFSXG4gICAgICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgICAgICBoYW5kbGVXYXJuaW5nKCdpbGxlZ2FsIGNoYXJhY3RlciBhZnRlciBhdHRyaWJ1dGUgZW5kJyk7XG4gICAgICAgICAgICAgIHNraXBBdHRyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBhZHZhbmNlIGN1cnNvciB0byBuZXh0IGF0dHJpYnV0ZVxuICAgICAgICAgIGkgPSBqICsgMTtcblxuICAgICAgICAgIGlmIChza2lwQXR0cikge1xuICAgICAgICAgICAgY29udGludWUgcGFyc2VBdHRyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNoZWNrIGF0dHJpYnV0ZSByZS1kZWNsYXJhdGlvblxuICAgICAgICAgIGlmIChuYW1lIGluIHNlZW5BdHRycykge1xuICAgICAgICAgICAgaGFuZGxlV2FybmluZygnYXR0cmlidXRlIDwnICsgbmFtZSArICc+IGFscmVhZHkgZGVmaW5lZCcpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VlbkF0dHJzW25hbWVdID0gdHJ1ZTtcblxuICAgICAgICAgIGlmICghaXNOYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0cnkgdG8gZXh0cmFjdCBuYW1lc3BhY2UgaW5mb3JtYXRpb25cbiAgICAgICAgICBpZiAobWF5YmVOUykge1xuICAgICAgICAgICAgbmV3YWxpYXMgPSAoXG4gICAgICAgICAgICAgIG5hbWUgPT09ICd4bWxucydcbiAgICAgICAgICAgICAgICA/ICd4bWxucydcbiAgICAgICAgICAgICAgICA6IChuYW1lLmNoYXJDb2RlQXQoMCkgPT09IDEyMCAmJiBuYW1lLnN1YnN0cigwLCA2KSA9PT0gJ3htbG5zOicpXG4gICAgICAgICAgICAgICAgICA/IG5hbWUuc3Vic3RyKDYpXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIGhhbmRsZSB4bWxucyg6YWxpYXMpIGFzc2lnbm1lbnRcbiAgICAgICAgICAgIGlmIChuZXdhbGlhcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBuc1VyaSA9IGRlY29kZUVudGl0aWVzKHZhbHVlKTtcbiAgICAgICAgICAgICAgbnNVcmlQcmVmaXggPSB1cmlQcmVmaXgobmV3YWxpYXMpO1xuXG4gICAgICAgICAgICAgIGFsaWFzID0gbnNVcmlUb1ByZWZpeFtuc1VyaV07XG5cbiAgICAgICAgICAgICAgaWYgKCFhbGlhcykge1xuXG4gICAgICAgICAgICAgICAgLy8gbm8gcHJlZml4IGRlZmluZWQgb3IgcHJlZml4IGNvbGxpc2lvblxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIChuZXdhbGlhcyA9PT0gJ3htbG5zJykgfHxcbiAgICAgICAgICAgICAgICAgIChuc1VyaVByZWZpeCBpbiBuc01hdHJpeCAmJiBuc01hdHJpeFtuc1VyaVByZWZpeF0gIT09IG5zVXJpKVxuICAgICAgICAgICAgICAgICkge1xuXG4gICAgICAgICAgICAgICAgICAvLyBhbG9jYXRlIGZyZWUgbnMgcHJlZml4XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGFsaWFzID0gJ25zJyArIChhbm9ueW1vdXNOc0NvdW50KyspO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAodHlwZW9mIG5zTWF0cml4W2FsaWFzXSAhPT0gJ3VuZGVmaW5lZCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhbGlhcyA9IG5ld2FsaWFzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5zVXJpVG9QcmVmaXhbbnNVcmldID0gYWxpYXM7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobnNNYXRyaXhbbmV3YWxpYXNdICE9PSBhbGlhcykge1xuICAgICAgICAgICAgICAgIGlmICghaGFzTmV3TWF0cml4KSB7XG4gICAgICAgICAgICAgICAgICBuc01hdHJpeCA9IGNsb25lTnNNYXRyaXgobnNNYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgaGFzTmV3TWF0cml4ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuc01hdHJpeFtuZXdhbGlhc10gPSBhbGlhcztcbiAgICAgICAgICAgICAgICBpZiAobmV3YWxpYXMgPT09ICd4bWxucycpIHtcbiAgICAgICAgICAgICAgICAgIG5zTWF0cml4W3VyaVByZWZpeChhbGlhcyldID0gbnNVcmk7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0QWxpYXMgPSBhbGlhcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuc01hdHJpeFtuc1VyaVByZWZpeF0gPSBuc1VyaTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGV4cG9zZSB4bWxucyg6YXNkKT1cIi4uLlwiIGluIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgYXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNvbGxlY3QgYXR0cmlidXRlcyB1bnRpbCBhbGwgbmFtZXNwYWNlXG4gICAgICAgICAgICAvLyBkZWNsYXJhdGlvbnMgYXJlIHByb2Nlc3NlZFxuICAgICAgICAgICAgYXR0ckxpc3QucHVzaChuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgIH0gLyoqIGVuZCBpZiAobWF5YmVOcykgKi9cblxuICAgICAgICAgIC8vIGhhbmRsZSBhdHRyaWJ1dGVzIG9uIGVsZW1lbnQgd2l0aG91dFxuICAgICAgICAgIC8vIG5hbWVzcGFjZSBkZWNsYXJhdGlvbnNcbiAgICAgICAgICB3ID0gbmFtZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgaWYgKHcgPT09IC0xKSB7XG4gICAgICAgICAgICBhdHRyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbm9ybWFsaXplIG5zIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgICAgaWYgKCEobnNOYW1lID0gbnNNYXRyaXhbbmFtZS5zdWJzdHJpbmcoMCwgdyldKSkge1xuICAgICAgICAgICAgaGFuZGxlV2FybmluZyhtaXNzaW5nTmFtZXNwYWNlRm9yUHJlZml4KG5hbWUuc3Vic3RyaW5nKDAsIHcpKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuYW1lID0gZGVmYXVsdEFsaWFzID09PSBuc05hbWVcbiAgICAgICAgICAgID8gbmFtZS5zdWJzdHIodyArIDEpXG4gICAgICAgICAgICA6IG5zTmFtZSArIG5hbWUuc3Vic3RyKHcpO1xuXG4gICAgICAgICAgLy8gZW5kOiBub3JtYWxpemUgbnMgYXR0cmlidXRlIG5hbWVcblxuICAgICAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIGhhbmRsZSBkZWZlcnJlZCwgcG9zc2libHkgbmFtZXNwYWNlZCBhdHRyaWJ1dGVzXG4gICAgICAgIGlmIChtYXliZU5TKSB7XG5cbiAgICAgICAgICAvLyBub3JtYWxpemUgY2FwdHVyZWQgYXR0cmlidXRlc1xuICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBhdHRyTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblxuICAgICAgICAgICAgbmFtZSA9IGF0dHJMaXN0W2krK107XG4gICAgICAgICAgICB2YWx1ZSA9IGF0dHJMaXN0W2ldO1xuXG4gICAgICAgICAgICB3ID0gbmFtZS5pbmRleE9mKCc6Jyk7XG5cbiAgICAgICAgICAgIGlmICh3ICE9PSAtMSkge1xuXG4gICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBucyBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICAgICAgICBpZiAoIShuc05hbWUgPSBuc01hdHJpeFtuYW1lLnN1YnN0cmluZygwLCB3KV0pKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlV2FybmluZyhtaXNzaW5nTmFtZXNwYWNlRm9yUHJlZml4KG5hbWUuc3Vic3RyaW5nKDAsIHcpKSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBuYW1lID0gZGVmYXVsdEFsaWFzID09PSBuc05hbWVcbiAgICAgICAgICAgICAgICA/IG5hbWUuc3Vic3RyKHcgKyAxKVxuICAgICAgICAgICAgICAgIDogbnNOYW1lICsgbmFtZS5zdWJzdHIodyk7XG5cbiAgICAgICAgICAgICAgLy8gZW5kOiBub3JtYWxpemUgbnMgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBlbmQ6IG5vcm1hbGl6ZSBjYXB0dXJlZCBhdHRyaWJ1dGVzXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FjaGVkQXR0cnMgPSBhdHRycztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFeHRyYWN0IHRoZSBwYXJzZSBjb250ZXh0IHsgbGluZSwgY29sdW1uLCBwYXJ0IH1cbiAgICAgICAqIGZyb20gdGhlIGN1cnJlbnQgcGFyc2VyIHBvc2l0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gcGFyc2UgY29udGV4dFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBnZXRQYXJzZUNvbnRleHQoKSB7XG4gICAgICAgIHZhciBzcGxpdHNSZSA9IC8oXFxyXFxufFxccnxcXG4pL2c7XG5cbiAgICAgICAgdmFyIGxpbmUgPSAwO1xuICAgICAgICB2YXIgY29sdW1uID0gMDtcbiAgICAgICAgdmFyIHN0YXJ0T2ZMaW5lID0gMDtcbiAgICAgICAgdmFyIGVuZE9mTGluZSA9IGo7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgdmFyIGRhdGE7XG5cbiAgICAgICAgd2hpbGUgKGkgPj0gc3RhcnRPZkxpbmUpIHtcblxuICAgICAgICAgIG1hdGNoID0gc3BsaXRzUmUuZXhlYyh4bWwpO1xuXG4gICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZW5kIG9mIGxpbmUgPSAoYnJlYWsgaWR4ICsgYnJlYWsgY2hhcnMpXG4gICAgICAgICAgZW5kT2ZMaW5lID0gbWF0Y2hbMF0ubGVuZ3RoICsgbWF0Y2guaW5kZXg7XG5cbiAgICAgICAgICBpZiAoZW5kT2ZMaW5lID4gaSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWR2YW5jZSB0byBuZXh0IGxpbmVcbiAgICAgICAgICBsaW5lICs9IDE7XG5cbiAgICAgICAgICBzdGFydE9mTGluZSA9IGVuZE9mTGluZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVPRiBlcnJvcnNcbiAgICAgICAgaWYgKGkgPT0gLTEpIHtcbiAgICAgICAgICBjb2x1bW4gPSBlbmRPZkxpbmU7XG4gICAgICAgICAgZGF0YSA9IHhtbC5zdWJzdHJpbmcoaik7XG4gICAgICAgIH0gZWxzZVxuXG4gICAgICAgIC8vIHN0YXJ0IGVycm9yc1xuICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgIGRhdGEgPSB4bWwuc3Vic3RyaW5nKGosIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXIgZXJyb3JzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbHVtbiA9IGkgLSBzdGFydE9mTGluZTtcbiAgICAgICAgICBkYXRhID0gKGogPT0gLTEgPyB4bWwuc3Vic3RyaW5nKGkpIDogeG1sLnN1YnN0cmluZyhpLCBqICsgMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAnZGF0YSc6IGRhdGEsXG4gICAgICAgICAgJ2xpbmUnOiBsaW5lLFxuICAgICAgICAgICdjb2x1bW4nOiBjb2x1bW5cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZ2V0Q29udGV4dCA9IGdldFBhcnNlQ29udGV4dDtcblxuXG4gICAgICBpZiAocHJveHkpIHtcbiAgICAgICAgZWxlbWVudFByb3h5ID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAgICduYW1lJzogZ2V0dGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnROYW1lO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgICdvcmlnaW5hbE5hbWUnOiBnZXR0ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gX2VsZW1lbnROYW1lO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgICdhdHRycyc6IGdldHRlcihnZXRBdHRycyksXG4gICAgICAgICAgJ25zJzogZ2V0dGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5zTWF0cml4O1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBhY3R1YWwgcGFyc2UgbG9naWNcbiAgICAgIHdoaWxlIChqICE9PSAtMSkge1xuXG4gICAgICAgIGlmICh4bWwuY2hhckNvZGVBdChqKSA9PT0gNjApIHsgLy8gXCI8XCJcbiAgICAgICAgICBpID0gajtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpID0geG1sLmluZGV4T2YoJzwnLCBqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhcnNlIGVuZFxuICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICBpZiAobm9kZVN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCd1bmV4cGVjdGVkIGVuZCBvZiBmaWxlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcignbWlzc2luZyBzdGFydCB0YWcnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaiA8IHhtbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh4bWwuc3Vic3RyaW5nKGopLnRyaW0oKSkge1xuICAgICAgICAgICAgICBoYW5kbGVXYXJuaW5nKE5PTl9XSElURVNQQUNFX09VVFNJREVfUk9PVF9OT0RFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYXJzZSB0ZXh0XG4gICAgICAgIGlmIChqICE9PSBpKSB7XG5cbiAgICAgICAgICBpZiAobm9kZVN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG9uVGV4dCkge1xuICAgICAgICAgICAgICBvblRleHQoeG1sLnN1YnN0cmluZyhqLCBpKSwgZGVjb2RlRW50aXRpZXMsIGdldENvbnRleHQpO1xuXG4gICAgICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHhtbC5zdWJzdHJpbmcoaiwgaSkudHJpbSgpKSB7XG4gICAgICAgICAgICAgIGhhbmRsZVdhcm5pbmcoTk9OX1dISVRFU1BBQ0VfT1VUU0lERV9ST09UX05PREUpO1xuXG4gICAgICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3ID0geG1sLmNoYXJDb2RlQXQoaSArIDEpO1xuXG4gICAgICAgIC8vIHBhcnNlIGNvbW1lbnRzICsgQ0RBVEFcbiAgICAgICAgaWYgKHcgPT09IDMzKSB7IC8vIFwiIVwiXG4gICAgICAgICAgcSA9IHhtbC5jaGFyQ29kZUF0KGkgKyAyKTtcblxuICAgICAgICAgIC8vIENEQVRBIHNlY3Rpb25cbiAgICAgICAgICBpZiAocSA9PT0gOTEgJiYgeG1sLnN1YnN0cihpICsgMywgNikgPT09ICdDREFUQVsnKSB7IC8vIDkxID09IFwiW1wiXG4gICAgICAgICAgICBqID0geG1sLmluZGV4T2YoJ11dPicsIGkpO1xuICAgICAgICAgICAgaWYgKGogPT09IC0xKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcigndW5jbG9zZWQgY2RhdGEnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9uQ0RBVEEpIHtcbiAgICAgICAgICAgICAgb25DREFUQSh4bWwuc3Vic3RyaW5nKGkgKyA5LCBqKSwgZ2V0Q29udGV4dCk7XG4gICAgICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaiArPSAzO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY29tbWVudFxuICAgICAgICAgIGlmIChxID09PSA0NSAmJiB4bWwuY2hhckNvZGVBdChpICsgMykgPT09IDQ1KSB7IC8vIDQ1ID09IFwiLVwiXG4gICAgICAgICAgICBqID0geG1sLmluZGV4T2YoJy0tPicsIGkpO1xuICAgICAgICAgICAgaWYgKGogPT09IC0xKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcigndW5jbG9zZWQgY29tbWVudCcpO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGlmIChvbkNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgb25Db21tZW50KHhtbC5zdWJzdHJpbmcoaSArIDQsIGopLCBkZWNvZGVFbnRpdGllcywgZ2V0Q29udGV4dCk7XG4gICAgICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaiArPSAzO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFyc2UgcXVlc3Rpb24gPD8gLi4uID8+XG4gICAgICAgIGlmICh3ID09PSA2MykgeyAvLyBcIj9cIlxuICAgICAgICAgIGogPSB4bWwuaW5kZXhPZignPz4nLCBpKTtcbiAgICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcigndW5jbG9zZWQgcXVlc3Rpb24nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob25RdWVzdGlvbikge1xuICAgICAgICAgICAgb25RdWVzdGlvbih4bWwuc3Vic3RyaW5nKGksIGogKyAyKSwgZ2V0Q29udGV4dCk7XG4gICAgICAgICAgICBpZiAocGFyc2VTdG9wKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBqICs9IDI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIG1hdGNoaW5nIGNsb3NpbmcgdGFnIGZvciBhdHRlbnRpb24gb3Igc3RhbmRhcmQgdGFnc1xuICAgICAgICAvLyBmb3IgdGhhdCB3ZSBtdXN0IHNraXAgdGhyb3VnaCBhdHRyaWJ1dGUgdmFsdWVzXG4gICAgICAgIC8vIChlbmNsb3NlZCBpbiBzaW5nbGUgb3IgZG91YmxlIHF1b3RlcylcbiAgICAgICAgZm9yICh4ID0gaSArIDE7IDsgeCsrKSB7XG4gICAgICAgICAgdiA9IHhtbC5jaGFyQ29kZUF0KHgpO1xuICAgICAgICAgIGlmIChpc05hTih2KSkge1xuICAgICAgICAgICAgaiA9IC0xO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCd1bmNsb3NlZCB0YWcnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBbMTBdIEF0dFZhbHVlIDo6PSAnXCInIChbXjwmXCJdIHwgUmVmZXJlbmNlKSogJ1wiJyB8IFwiJ1wiIChbXjwmJ10gfCBSZWZlcmVuY2UpKiBcIidcIlxuICAgICAgICAgIC8vIHNraXBzIHRoZSBxdW90ZWQgc3RyaW5nXG4gICAgICAgICAgLy8gKGRvdWJsZSBxdW90ZXMpIGRvZXMgbm90IGFwcGVhciBpbiBhIGxpdGVyYWwgZW5jbG9zZWQgYnkgKGRvdWJsZSBxdW90ZXMpXG4gICAgICAgICAgLy8gKHNpbmdsZSBxdW90ZSkgZG9lcyBub3QgYXBwZWFyIGluIGEgbGl0ZXJhbCBlbmNsb3NlZCBieSAoc2luZ2xlIHF1b3RlKVxuICAgICAgICAgIGlmICh2ID09PSAzNCkgeyAvLyAgJ1wiJ1xuICAgICAgICAgICAgcSA9IHhtbC5pbmRleE9mKCdcIicsIHggKyAxKTtcbiAgICAgICAgICAgIHggPSBxICE9PSAtMSA/IHEgOiB4O1xuICAgICAgICAgIH0gZWxzZSBpZiAodiA9PT0gMzkpIHsgLy8gXCInXCJcbiAgICAgICAgICAgIHEgPSB4bWwuaW5kZXhPZihcIidcIiwgeCArIDEpO1xuICAgICAgICAgICAgeCA9IHEgIT09IC0xID8gcSA6IHg7XG4gICAgICAgICAgfSBlbHNlIGlmICh2ID09PSA2MikgeyAvLyAnPidcbiAgICAgICAgICAgIGogPSB4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvLyBwYXJzZSBhdHRlbnRpb24gPCEgLi4uPlxuICAgICAgICAvLyBwcmV2aW91c2x5IGNvbW1lbnQgYW5kIENEQVRBIGhhdmUgYWxyZWFkeSBiZWVuIHBhcnNlZFxuICAgICAgICBpZiAodyA9PT0gMzMpIHsgLy8gXCIhXCJcblxuICAgICAgICAgIGlmIChvbkF0dGVudGlvbikge1xuICAgICAgICAgICAgb25BdHRlbnRpb24oeG1sLnN1YnN0cmluZyhpLCBqICsgMSksIGRlY29kZUVudGl0aWVzLCBnZXRDb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvbid0IHByb2Nlc3MgYXR0cmlidXRlcztcbiAgICAgICAgLy8gdGhlcmUgYXJlIG5vbmVcbiAgICAgICAgY2FjaGVkQXR0cnMgPSB7fTtcblxuICAgICAgICAvLyBpZiAoeG1sLmNoYXJDb2RlQXQoaSsxKSA9PT0gNDcpIHsgLy8gPC8uLi5cbiAgICAgICAgaWYgKHcgPT09IDQ3KSB7IC8vIDwvLi4uXG4gICAgICAgICAgdGFnU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICB0YWdFbmQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKCFub2RlU3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoJ21pc3Npbmcgb3BlbiB0YWcnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB2ZXJpZnkgb3BlbiA8LT4gY2xvc2UgdGFnIG1hdGNoXG4gICAgICAgICAgeCA9IGVsZW1lbnROYW1lID0gbm9kZVN0YWNrLnBvcCgpO1xuICAgICAgICAgIHEgPSBpICsgMiArIHgubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKHhtbC5zdWJzdHJpbmcoaSArIDIsIHEpICE9PSB4KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoJ2Nsb3NpbmcgdGFnIG1pc21hdGNoJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdmVyaWZ5IGNoYXJzIGluIGNsb3NlIHRhZ1xuICAgICAgICAgIGZvciAoOyBxIDwgajsgcSsrKSB7XG4gICAgICAgICAgICB3ID0geG1sLmNoYXJDb2RlQXQocSk7XG5cbiAgICAgICAgICAgIGlmICh3ID09PSAzMiB8fCAodyA+IDggJiYgdyA8IDE0KSkgeyAvLyBcXGZcXG5cXHJcXHRcXHYgc3BhY2VcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcignY2xvc2UgdGFnJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHhtbC5jaGFyQ29kZUF0KGogLSAxKSA9PT0gNDcpIHsgLy8gLi4uLz5cbiAgICAgICAgICAgIHggPSBlbGVtZW50TmFtZSA9IHhtbC5zdWJzdHJpbmcoaSArIDEsIGogLSAxKTtcblxuICAgICAgICAgICAgdGFnU3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgdGFnRW5kID0gdHJ1ZTtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4ID0gZWxlbWVudE5hbWUgPSB4bWwuc3Vic3RyaW5nKGkgKyAxLCBqKTtcblxuICAgICAgICAgICAgdGFnU3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgdGFnRW5kID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCEodyA+IDk2ICYmIHcgPCAxMjMgfHwgdyA+IDY0ICYmIHcgPCA5MSB8fCB3ID09PSA5NSB8fCB3ID09PSA1OCkpIHsgLy8gY2hhciA5NVwiX1wiIDU4XCI6XCJcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcignaWxsZWdhbCBmaXJzdCBjaGFyIG5vZGVOYW1lJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChxID0gMSwgeSA9IHgubGVuZ3RoOyBxIDwgeTsgcSsrKSB7XG4gICAgICAgICAgICB3ID0geC5jaGFyQ29kZUF0KHEpO1xuXG4gICAgICAgICAgICBpZiAodyA+IDk2ICYmIHcgPCAxMjMgfHwgdyA+IDY0ICYmIHcgPCA5MSB8fCB3ID4gNDcgJiYgdyA8IDU5IHx8IHcgPT09IDQ1IHx8IHcgPT09IDk1IHx8IHcgPT0gNDYpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh3ID09PSAzMiB8fCAodyA8IDE0ICYmIHcgPiA4KSkgeyAvLyBcXGZcXG5cXHJcXHRcXHYgc3BhY2VcbiAgICAgICAgICAgICAgZWxlbWVudE5hbWUgPSB4LnN1YnN0cmluZygwLCBxKTtcblxuICAgICAgICAgICAgICAvLyBtYXliZSB0aGVyZSBhcmUgYXR0cmlidXRlc1xuICAgICAgICAgICAgICBjYWNoZWRBdHRycyA9IG51bGw7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoJ2ludmFsaWQgbm9kZU5hbWUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRhZ0VuZCkge1xuICAgICAgICAgICAgbm9kZVN0YWNrLnB1c2goZWxlbWVudE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc05hbWVzcGFjZSkge1xuXG4gICAgICAgICAgX25zTWF0cml4ID0gbnNNYXRyaXg7XG5cbiAgICAgICAgICBpZiAodGFnU3RhcnQpIHtcblxuICAgICAgICAgICAgLy8gcmVtZW1iZXIgb2xkIG5hbWVzcGFjZVxuICAgICAgICAgICAgLy8gdW5sZXNzIHdlJ3JlIHNlbGYtY2xvc2luZ1xuICAgICAgICAgICAgaWYgKCF0YWdFbmQpIHtcbiAgICAgICAgICAgICAgbnNNYXRyaXhTdGFjay5wdXNoKF9uc01hdHJpeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjYWNoZWRBdHRycyA9PT0gbnVsbCkge1xuXG4gICAgICAgICAgICAgIC8vIHF1aWNrIGNoZWNrLCB3aGV0aGVyIHRoZXJlIG1heSBiZSBuYW1lc3BhY2VcbiAgICAgICAgICAgICAgLy8gZGVjbGFyYXRpb25zIG9uIHRoZSBub2RlOyBpZiB0aGF0IGlzIHRoZSBjYXNlXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZWFnZXJseSBwYXJzZSB0aGUgbm9kZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgIGlmICgobWF5YmVOUyA9IHguaW5kZXhPZigneG1sbnMnLCBxKSAhPT0gLTEpKSB7XG4gICAgICAgICAgICAgICAgYXR0cnNTdGFydCA9IHE7XG4gICAgICAgICAgICAgICAgYXR0cnNTdHJpbmcgPSB4O1xuXG4gICAgICAgICAgICAgICAgZ2V0QXR0cnMoKTtcblxuICAgICAgICAgICAgICAgIG1heWJlTlMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIF9lbGVtZW50TmFtZSA9IGVsZW1lbnROYW1lO1xuXG4gICAgICAgICAgdyA9IGVsZW1lbnROYW1lLmluZGV4T2YoJzonKTtcbiAgICAgICAgICBpZiAodyAhPT0gLTEpIHtcbiAgICAgICAgICAgIHhtbG5zID0gbnNNYXRyaXhbZWxlbWVudE5hbWUuc3Vic3RyaW5nKDAsIHcpXTtcblxuICAgICAgICAgICAgLy8gcHJlZml4IGdpdmVuOyBuYW1lc3BhY2UgbXVzdCBleGlzdFxuICAgICAgICAgICAgaWYgKCF4bWxucykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoJ21pc3NpbmcgbmFtZXNwYWNlIG9uIDwnICsgX2VsZW1lbnROYW1lICsgJz4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbWVudE5hbWUgPSBlbGVtZW50TmFtZS5zdWJzdHIodyArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4bWxucyA9IG5zTWF0cml4Wyd4bWxucyddO1xuXG4gICAgICAgICAgICAvLyBpZiBubyBkZWZhdWx0IG5hbWVzcGFjZSBpcyBkZWZpbmVkLFxuICAgICAgICAgICAgLy8gd2UnbGwgaW1wb3J0IHRoZSBlbGVtZW50IGFzIGFub255bW91cy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBpdCBpcyB1cCB0byB1c2VycyB0byBjb3JyZWN0IHRoYXQgdG8gdGhlIGRvY3VtZW50IGRlZmluZWRcbiAgICAgICAgICAgIC8vIHRhcmdldE5hbWVzcGFjZSwgb3Igd2hhdGV2ZXIgdGhlaXIgdW5kZXJzYW5kaW5nIG9mIHRoZVxuICAgICAgICAgICAgLy8gWE1MIHNwZWMgbWFuZGF0ZXMuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWRqdXN0IG5hbWVzcGFjZSBwcmVmaXhzIGFzIGNvbmZpZ3VyZWRcbiAgICAgICAgICBpZiAoeG1sbnMpIHtcbiAgICAgICAgICAgIGVsZW1lbnROYW1lID0geG1sbnMgKyAnOicgKyBlbGVtZW50TmFtZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YWdTdGFydCkge1xuICAgICAgICAgIGF0dHJzU3RhcnQgPSBxO1xuICAgICAgICAgIGF0dHJzU3RyaW5nID0geDtcblxuICAgICAgICAgIGlmIChvbk9wZW5UYWcpIHtcbiAgICAgICAgICAgIGlmIChwcm94eSkge1xuICAgICAgICAgICAgICBvbk9wZW5UYWcoZWxlbWVudFByb3h5LCBkZWNvZGVFbnRpdGllcywgdGFnRW5kLCBnZXRDb250ZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9uT3BlblRhZyhlbGVtZW50TmFtZSwgZ2V0QXR0cnMsIGRlY29kZUVudGl0aWVzLCB0YWdFbmQsIGdldENvbnRleHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyc2VTdG9wKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YWdFbmQpIHtcblxuICAgICAgICAgIGlmIChvbkNsb3NlVGFnKSB7XG4gICAgICAgICAgICBvbkNsb3NlVGFnKHByb3h5ID8gZWxlbWVudFByb3h5IDogZWxlbWVudE5hbWUsIGRlY29kZUVudGl0aWVzLCB0YWdTdGFydCwgZ2V0Q29udGV4dCk7XG5cbiAgICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJlc3RvcmUgb2xkIG5hbWVzcGFjZVxuICAgICAgICAgIGlmIChpc05hbWVzcGFjZSkge1xuICAgICAgICAgICAgaWYgKCF0YWdTdGFydCkge1xuICAgICAgICAgICAgICBuc01hdHJpeCA9IG5zTWF0cml4U3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuc01hdHJpeCA9IF9uc01hdHJpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBqICs9IDE7XG4gICAgICB9XG4gICAgfSAvKiogZW5kIHBhcnNlICovXG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0xvd2VyQ2FzZUFsaWFzKHBrZykge1xuICAgIHJldHVybiBwa2cueG1sICYmIHBrZy54bWwudGFnQWxpYXMgPT09ICdsb3dlckNhc2UnO1xuICB9XG5cbiAgdmFyIERFRkFVTFRfTlNfTUFQID0ge1xuICAgICd4c2knOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEtaW5zdGFuY2UnLFxuICAgICd4bWwnOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xuICB9O1xuXG4gIHZhciBTRVJJQUxJWkVfUFJPUEVSVFkgPSAncHJvcGVydHknO1xuXG4gIGZ1bmN0aW9uIGdldFNlcmlhbGl6YXRpb24oZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LnhtbCAmJiBlbGVtZW50LnhtbC5zZXJpYWxpemU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTZXJpYWxpemF0aW9uVHlwZShlbGVtZW50KSB7XG4gICAgY29uc3QgdHlwZSA9IGdldFNlcmlhbGl6YXRpb24oZWxlbWVudCk7XG5cbiAgICByZXR1cm4gdHlwZSAhPT0gU0VSSUFMSVpFX1BST1BFUlRZICYmICh0eXBlIHx8IG51bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWxpYXNUb05hbWUoYWxpYXNOcywgcGtnKSB7XG5cbiAgICBpZiAoIWhhc0xvd2VyQ2FzZUFsaWFzKHBrZykpIHtcbiAgICAgIHJldHVybiBhbGlhc05zLm5hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsaWFzTnMucHJlZml4ICsgJzonICsgY2FwaXRhbGl6ZShhbGlhc05zLmxvY2FsTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogVW4tcHJlZml4IGEgcG90ZW50aWFsbHkgcHJlZml4ZWQgdHlwZSBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge05zTmFtZX0gbmFtZU5zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGtnXVxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBwcmVmaXhlZFRvTmFtZShuYW1lTnMsIHBrZykge1xuXG4gICAgdmFyIG5hbWUgPSBuYW1lTnMubmFtZSxcbiAgICAgICAgbG9jYWxOYW1lID0gbmFtZU5zLmxvY2FsTmFtZTtcblxuICAgIHZhciB0eXBlUHJlZml4ID0gcGtnICYmIHBrZy54bWwgJiYgcGtnLnhtbC50eXBlUHJlZml4O1xuXG4gICAgaWYgKHR5cGVQcmVmaXggJiYgbG9jYWxOYW1lLmluZGV4T2YodHlwZVByZWZpeCkgPT09IDApIHtcbiAgICAgIHJldHVybiBuYW1lTnMucHJlZml4ICsgJzonICsgbG9jYWxOYW1lLnNsaWNlKHR5cGVQcmVmaXgubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVHlwZU5hbWUobmFtZSwgbnNNYXAsIG1vZGVsKSB7XG5cbiAgICAvLyBub3JtYWxpemUgYWdhaW5zdCBhY3R1YWwgTlNcbiAgICBjb25zdCBuYW1lTnMgPSBwYXJzZU5hbWUobmFtZSwgbnNNYXAueG1sbnMpO1xuXG4gICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSBgJHsgbnNNYXBbbmFtZU5zLnByZWZpeF0gfHwgbmFtZU5zLnByZWZpeCB9OiR7IG5hbWVOcy5sb2NhbE5hbWUgfWA7XG5cbiAgICBjb25zdCBub3JtYWxpemVkTmFtZU5zID0gcGFyc2VOYW1lKG5vcm1hbGl6ZWROYW1lKTtcblxuICAgIC8vIGRldGVybWluZSBhY3R1YWwgdHlwZSBuYW1lLCBiYXNlZCBvbiBwYWNrYWdlLWRlZmluZWQgcHJlZml4XG4gICAgdmFyIHBrZyA9IG1vZGVsLmdldFBhY2thZ2Uobm9ybWFsaXplZE5hbWVOcy5wcmVmaXgpO1xuXG4gICAgcmV0dXJuIHByZWZpeGVkVG9OYW1lKG5vcm1hbGl6ZWROYW1lTnMsIHBrZyk7XG4gIH1cblxuICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vZGRsZSBkZXNjcmlwdG9yIGZvciBhIGdpdmVuIGluc3RhbmNlIG9yIHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSAge01vZGRsZUVsZW1lbnR8RnVuY3Rpb259IGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgbW9kZGxlIGRlc2NyaXB0b3JcbiAgICovXG4gIGZ1bmN0aW9uIGdldE1vZGRsZURlc2NyaXB0b3IoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LiRkZXNjcmlwdG9yO1xuICB9XG5cblxuICAvKipcbiAgICogQSBwYXJzZSBjb250ZXh0LlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtFbGVtZW50SGFuZGxlcn0gb3B0aW9ucy5yb290SGFuZGxlciB0aGUgcm9vdCBoYW5kbGVyIGZvciBwYXJzaW5nIGEgZG9jdW1lbnRcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sYXg9ZmFsc2VdIHdoZXRoZXIgb3Igbm90IHRvIGlnbm9yZSBpbnZhbGlkIGVsZW1lbnRzXG4gICAqL1xuICBmdW5jdGlvbiBDb250ZXh0KG9wdGlvbnMpIHtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7RWxlbWVudEhhbmRsZXJ9IHJvb3RIYW5kbGVyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGxheFxuICAgICAqL1xuXG4gICAgYXNzaWduJDEodGhpcywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmVsZW1lbnRzQnlJZCA9IHt9O1xuICAgIHRoaXMucmVmZXJlbmNlcyA9IFtdO1xuICAgIHRoaXMud2FybmluZ3MgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiB1bnJlc29sdmVkIHJlZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VcbiAgICAgKi9cbiAgICB0aGlzLmFkZFJlZmVyZW5jZSA9IGZ1bmN0aW9uKHJlZmVyZW5jZSkge1xuICAgICAgdGhpcy5yZWZlcmVuY2VzLnB1c2gocmVmZXJlbmNlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIGEgcHJvY2Vzc2VkIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKi9cbiAgICB0aGlzLmFkZEVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICB0aHJvdyBlcnJvcignZXhwZWN0ZWQgZWxlbWVudCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudHNCeUlkID0gdGhpcy5lbGVtZW50c0J5SWQ7XG5cbiAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50KTtcblxuICAgICAgdmFyIGlkUHJvcGVydHkgPSBkZXNjcmlwdG9yLmlkUHJvcGVydHksXG4gICAgICAgICAgaWQ7XG5cbiAgICAgIGlmIChpZFByb3BlcnR5KSB7XG4gICAgICAgIGlkID0gZWxlbWVudC5nZXQoaWRQcm9wZXJ0eS5uYW1lKTtcblxuICAgICAgICBpZiAoaWQpIHtcblxuICAgICAgICAgIC8vIGZvciBRTmFtZSB2YWxpZGF0aW9uIGFzIHBlciBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lQ2hhclxuICAgICAgICAgIGlmICghL14oW2Etel1bXFx3LS5dKjopP1thLXpfXVtcXHctLl0qJC9pLnRlc3QoaWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lsbGVnYWwgSUQgPCcgKyBpZCArICc+Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGVsZW1lbnRzQnlJZFtpZF0pIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yKCdkdXBsaWNhdGUgSUQgPCcgKyBpZCArICc+Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudHNCeUlkW2lkXSA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGltcG9ydCB3YXJuaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHdhcm5pbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gd2FybmluZy5tZXNzYWdlXG4gICAgICogQHBhcmFtIHtFcnJvcn0gW3dhcm5pbmcuZXJyb3JdXG4gICAgICovXG4gICAgdGhpcy5hZGRXYXJuaW5nID0gZnVuY3Rpb24od2FybmluZykge1xuICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKHdhcm5pbmcpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBCYXNlSGFuZGxlcigpIHt9XG5cbiAgQmFzZUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUVuZCA9IGZ1bmN0aW9uKCkge307XG4gIEJhc2VIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVUZXh0ID0gZnVuY3Rpb24oKSB7fTtcbiAgQmFzZUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZU5vZGUgPSBmdW5jdGlvbigpIHt9O1xuXG5cbiAgLyoqXG4gICAqIEEgc2ltcGxlIHBhc3MgdGhyb3VnaCBoYW5kbGVyIHRoYXQgZG9lcyBub3RoaW5nIGV4Y2VwdCBmb3JcbiAgICogaWdub3JpbmcgYWxsIGlucHV0IGl0IHJlY2VpdmVzLlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gaWdub3JlIHVua25vd24gZWxlbWVudHMgYW5kXG4gICAqIGF0dHJpYnV0ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBOb29wSGFuZGxlcigpIHsgfVxuXG4gIE5vb3BIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUhhbmRsZXIucHJvdG90eXBlKTtcblxuICBOb29wSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlTm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEJvZHlIYW5kbGVyKCkge31cblxuICBCb2R5SGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VIYW5kbGVyLnByb3RvdHlwZSk7XG5cbiAgQm9keUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZVRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdGhpcy5ib2R5ID0gKHRoaXMuYm9keSB8fCAnJykgKyB0ZXh0O1xuICB9O1xuXG4gIGZ1bmN0aW9uIFJlZmVyZW5jZUhhbmRsZXIocHJvcGVydHksIGNvbnRleHQpIHtcbiAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgfVxuXG4gIFJlZmVyZW5jZUhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCb2R5SGFuZGxlci5wcm90b3R5cGUpO1xuXG4gIFJlZmVyZW5jZUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICB0aHJvdyBlcnJvcignZXhwZWN0ZWQgbm8gc3ViIG5vZGVzJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWxlbWVudCA9IHRoaXMuY3JlYXRlUmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFJlZmVyZW5jZUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZWxlbWVudC5pZCA9IHRoaXMuYm9keTtcbiAgfTtcblxuICBSZWZlcmVuY2VIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVSZWZlcmVuY2UgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3BlcnR5OiB0aGlzLnByb3BlcnR5Lm5zLm5hbWUsXG4gICAgICBpZDogJydcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIFZhbHVlSGFuZGxlcihwcm9wZXJ0eURlc2MsIGVsZW1lbnQpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMucHJvcGVydHlEZXNjID0gcHJvcGVydHlEZXNjO1xuICB9XG5cbiAgVmFsdWVIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQm9keUhhbmRsZXIucHJvdG90eXBlKTtcblxuICBWYWx1ZUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUVuZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHZhbHVlID0gdGhpcy5ib2R5IHx8ICcnLFxuICAgICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICBwcm9wZXJ0eURlc2MgPSB0aGlzLnByb3BlcnR5RGVzYztcblxuICAgIHZhbHVlID0gY29lcmNlVHlwZShwcm9wZXJ0eURlc2MudHlwZSwgdmFsdWUpO1xuXG4gICAgaWYgKHByb3BlcnR5RGVzYy5pc01hbnkpIHtcbiAgICAgIGVsZW1lbnQuZ2V0KHByb3BlcnR5RGVzYy5uYW1lKS5wdXNoKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zZXQocHJvcGVydHlEZXNjLm5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cblxuICBmdW5jdGlvbiBCYXNlRWxlbWVudEhhbmRsZXIoKSB7fVxuXG4gIEJhc2VFbGVtZW50SGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJvZHlIYW5kbGVyLnByb3RvdHlwZSk7XG5cbiAgQmFzZUVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVOb2RlID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBwYXJzZXIgPSB0aGlzLFxuICAgICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50ID0gdGhpcy5jcmVhdGVFbGVtZW50KG5vZGUpO1xuXG4gICAgICB0aGlzLmNvbnRleHQuYWRkRWxlbWVudChlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VyID0gdGhpcy5oYW5kbGVDaGlsZChub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUmVhZGVyLkVsZW1lbnRIYW5kbGVyXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBFbGVtZW50SGFuZGxlcihtb2RlbCwgdHlwZU5hbWUsIGNvbnRleHQpIHtcbiAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgdGhpcy50eXBlID0gbW9kZWwuZ2V0VHlwZSh0eXBlTmFtZSk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgfVxuXG4gIEVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZSk7XG5cbiAgRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmFkZFJlZmVyZW5jZSA9IGZ1bmN0aW9uKHJlZmVyZW5jZSkge1xuICAgIHRoaXMuY29udGV4dC5hZGRSZWZlcmVuY2UocmVmZXJlbmNlKTtcbiAgfTtcblxuICBFbGVtZW50SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlVGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcblxuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICBkZXNjcmlwdG9yID0gZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50KSxcbiAgICAgICAgYm9keVByb3BlcnR5ID0gZGVzY3JpcHRvci5ib2R5UHJvcGVydHk7XG5cbiAgICBpZiAoIWJvZHlQcm9wZXJ0eSkge1xuICAgICAgdGhyb3cgZXJyb3IoJ3VuZXhwZWN0ZWQgYm9keSB0ZXh0IDwnICsgdGV4dCArICc+Jyk7XG4gICAgfVxuXG4gICAgQm9keUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZVRleHQuY2FsbCh0aGlzLCB0ZXh0KTtcbiAgfTtcblxuICBFbGVtZW50SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlRW5kID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgdmFsdWUgPSB0aGlzLmJvZHksXG4gICAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgIGRlc2NyaXB0b3IgPSBnZXRNb2RkbGVEZXNjcmlwdG9yKGVsZW1lbnQpLFxuICAgICAgICBib2R5UHJvcGVydHkgPSBkZXNjcmlwdG9yLmJvZHlQcm9wZXJ0eTtcblxuICAgIGlmIChib2R5UHJvcGVydHkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSBjb2VyY2VUeXBlKGJvZHlQcm9wZXJ0eS50eXBlLCB2YWx1ZSk7XG4gICAgICBlbGVtZW50LnNldChib2R5UHJvcGVydHkubmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBtb2RlbCBmcm9tIHRoZSBnaXZlbiBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtFbGVtZW50fSBub2RlIHRoZSB4bWwgbm9kZVxuICAgKi9cbiAgRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXMsXG4gICAgICAgIFR5cGUgPSB0aGlzLnR5cGUsXG4gICAgICAgIGRlc2NyaXB0b3IgPSBnZXRNb2RkbGVEZXNjcmlwdG9yKFR5cGUpLFxuICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuICAgICAgICBpbnN0YW5jZSA9IG5ldyBUeXBlKHt9KSxcbiAgICAgICAgbW9kZWwgPSB0aGlzLm1vZGVsLFxuICAgICAgICBwcm9wTmFtZU5zO1xuXG4gICAgZm9yRWFjaCQxKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG5cbiAgICAgIHZhciBwcm9wID0gZGVzY3JpcHRvci5wcm9wZXJ0aWVzQnlOYW1lW25hbWVdLFxuICAgICAgICAgIHZhbHVlcztcblxuICAgICAgaWYgKHByb3AgJiYgcHJvcC5pc1JlZmVyZW5jZSkge1xuXG4gICAgICAgIGlmICghcHJvcC5pc01hbnkpIHtcbiAgICAgICAgICBjb250ZXh0LmFkZFJlZmVyZW5jZSh7XG4gICAgICAgICAgICBlbGVtZW50OiBpbnN0YW5jZSxcbiAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLm5zLm5hbWUsXG4gICAgICAgICAgICBpZDogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIC8vIElEUkVGUzogcGFyc2UgcmVmZXJlbmNlcyBhcyB3aGl0ZXNwYWNlLXNlcGFyYXRlZCBsaXN0XG4gICAgICAgICAgdmFsdWVzID0gdmFsdWUuc3BsaXQoJyAnKTtcblxuICAgICAgICAgIGZvckVhY2gkMSh2YWx1ZXMsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIGNvbnRleHQuYWRkUmVmZXJlbmNlKHtcbiAgICAgICAgICAgICAgZWxlbWVudDogaW5zdGFuY2UsXG4gICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLm5zLm5hbWUsXG4gICAgICAgICAgICAgIGlkOiB2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgIHZhbHVlID0gY29lcmNlVHlwZShwcm9wLnR5cGUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAneG1sbnMnKSB7XG4gICAgICAgICAgbmFtZSA9ICc6JyArIG5hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcE5hbWVOcyA9IHBhcnNlTmFtZShuYW1lLCBkZXNjcmlwdG9yLm5zLnByZWZpeCk7XG5cbiAgICAgICAgICAvLyBjaGVjayB3aGV0aGVyIGF0dHJpYnV0ZSBpcyBkZWZpbmVkIGluIGEgd2VsbC1rbm93biBuYW1lc3BhY2VcbiAgICAgICAgICAvLyBpZiB0aGF0IGlzIHRoZSBjYXNlIHdlIGVtaXQgYSB3YXJuaW5nIHRvIGluZGljYXRlIHBvdGVudGlhbCBtaXN1c2VcbiAgICAgICAgICBpZiAobW9kZWwuZ2V0UGFja2FnZShwcm9wTmFtZU5zLnByZWZpeCkpIHtcblxuICAgICAgICAgICAgY29udGV4dC5hZGRXYXJuaW5nKHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ3Vua25vd24gYXR0cmlidXRlIDwnICsgbmFtZSArICc+JyxcbiAgICAgICAgICAgICAgZWxlbWVudDogaW5zdGFuY2UsXG4gICAgICAgICAgICAgIHByb3BlcnR5OiBuYW1lLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGluc3RhbmNlLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmdldFByb3BlcnR5Rm9yTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICAgIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuICAgIHZhciBuYW1lTnMgPSBwYXJzZU5hbWUobmFtZSk7XG5cbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZSxcbiAgICAgICAgbW9kZWwgPSB0aGlzLm1vZGVsLFxuICAgICAgICBkZXNjcmlwdG9yID0gZ2V0TW9kZGxlRGVzY3JpcHRvcih0eXBlKTtcblxuICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBuYW1lTnMubmFtZSxcbiAgICAgICAgcHJvcGVydHkgPSBkZXNjcmlwdG9yLnByb3BlcnRpZXNCeU5hbWVbcHJvcGVydHlOYW1lXTtcblxuICAgIC8vIHNlYXJjaCBmb3IgcHJvcGVydGllcyBieSBuYW1lIGZpcnN0XG5cbiAgICBpZiAocHJvcGVydHkgJiYgIXByb3BlcnR5LmlzQXR0cikge1xuXG4gICAgICBjb25zdCBzZXJpYWxpemF0aW9uVHlwZSA9IGdldFNlcmlhbGl6YXRpb25UeXBlKHByb3BlcnR5KTtcblxuICAgICAgaWYgKHNlcmlhbGl6YXRpb25UeXBlKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRUeXBlTmFtZSA9IG5vZGUuYXR0cmlidXRlc1tzZXJpYWxpemF0aW9uVHlwZV07XG5cbiAgICAgICAgLy8gdHlwZSBpcyBvcHRpb25hbCwgaWYgaXQgZG9lcyBub3QgZXhpc3RzIHRoZVxuICAgICAgICAvLyBkZWZhdWx0IHR5cGUgaXMgYXNzdW1lZFxuICAgICAgICBpZiAoZWxlbWVudFR5cGVOYW1lKSB7XG5cbiAgICAgICAgICAvLyBjb252ZXJ0IHRoZSBwcmVmaXggdXNlZCB0byB0aGUgbWFwcGVkIGZvcm0sIGJ1dCBhbHNvXG4gICAgICAgICAgLy8gdGFrZSBwb3NzaWJsZSB0eXBlIHByZWZpeGVzIGZyb20gWE1MXG4gICAgICAgICAgLy8gaW50byBhY2NvdW50LCBpLmUuOiB4c2k6dHlwZT1cInR7QWN0dWFsVHlwZX1cIixcbiAgICAgICAgICBjb25zdCBub3JtYWxpemVkVHlwZU5hbWUgPSBub3JtYWxpemVUeXBlTmFtZShlbGVtZW50VHlwZU5hbWUsIG5vZGUubnMsIG1vZGVsKTtcblxuICAgICAgICAgIGNvbnN0IGVsZW1lbnRUeXBlID0gbW9kZWwuZ2V0VHlwZShub3JtYWxpemVkVHlwZU5hbWUpO1xuXG4gICAgICAgICAgcmV0dXJuIGFzc2lnbiQxKHt9LCBwcm9wZXJ0eSwge1xuICAgICAgICAgICAgZWZmZWN0aXZlVHlwZTogZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50VHlwZSkubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHNlYXJjaCBmb3IgcHJvcGVydGllcyBieSBuYW1lIGZpcnN0XG4gICAgICByZXR1cm4gcHJvcGVydHk7XG4gICAgfVxuXG4gICAgdmFyIHBrZyA9IG1vZGVsLmdldFBhY2thZ2UobmFtZU5zLnByZWZpeCk7XG5cbiAgICBpZiAocGtnKSB7XG4gICAgICBjb25zdCBlbGVtZW50VHlwZU5hbWUgPSBhbGlhc1RvTmFtZShuYW1lTnMsIHBrZyk7XG4gICAgICBjb25zdCBlbGVtZW50VHlwZSA9IG1vZGVsLmdldFR5cGUoZWxlbWVudFR5cGVOYW1lKTtcblxuICAgICAgLy8gc2VhcmNoIGZvciBjb2xsZWN0aW9uIG1lbWJlcnMgbGF0ZXJcbiAgICAgIHByb3BlcnR5ID0gZmluZChkZXNjcmlwdG9yLnByb3BlcnRpZXMsIGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuICFwLmlzVmlydHVhbCAmJiAhcC5pc1JlZmVyZW5jZSAmJiAhcC5pc0F0dHJpYnV0ZSAmJiBlbGVtZW50VHlwZS5oYXNUeXBlKHAudHlwZSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBhc3NpZ24kMSh7fSwgcHJvcGVydHksIHtcbiAgICAgICAgICBlZmZlY3RpdmVUeXBlOiBnZXRNb2RkbGVEZXNjcmlwdG9yKGVsZW1lbnRUeXBlKS5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIHBhcnNlIHVua25vd24gZWxlbWVudCAobWF5YmUgZXh0ZW5zaW9uKVxuICAgICAgcHJvcGVydHkgPSBmaW5kKGRlc2NyaXB0b3IucHJvcGVydGllcywgZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gIXAuaXNSZWZlcmVuY2UgJiYgIXAuaXNBdHRyaWJ1dGUgJiYgcC50eXBlID09PSAnRWxlbWVudCc7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBlcnJvcigndW5yZWNvZ25pemVkIGVsZW1lbnQgPCcgKyBuYW1lTnMubmFtZSArICc+Jyk7XG4gIH07XG5cbiAgRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICdFbGVtZW50RGVzY3JpcHRvclsnICsgZ2V0TW9kZGxlRGVzY3JpcHRvcih0aGlzLnR5cGUpLm5hbWUgKyAnXSc7XG4gIH07XG5cbiAgRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnZhbHVlSGFuZGxlciA9IGZ1bmN0aW9uKHByb3BlcnR5RGVzYywgZWxlbWVudCkge1xuICAgIHJldHVybiBuZXcgVmFsdWVIYW5kbGVyKHByb3BlcnR5RGVzYywgZWxlbWVudCk7XG4gIH07XG5cbiAgRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnJlZmVyZW5jZUhhbmRsZXIgPSBmdW5jdGlvbihwcm9wZXJ0eURlc2MpIHtcbiAgICByZXR1cm4gbmV3IFJlZmVyZW5jZUhhbmRsZXIocHJvcGVydHlEZXNjLCB0aGlzLmNvbnRleHQpO1xuICB9O1xuXG4gIEVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVyID0gZnVuY3Rpb24odHlwZSkge1xuICAgIGlmICh0eXBlID09PSAnRWxlbWVudCcpIHtcbiAgICAgIHJldHVybiBuZXcgR2VuZXJpY0VsZW1lbnRIYW5kbGVyKHRoaXMubW9kZWwsIHR5cGUsIHRoaXMuY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRWxlbWVudEhhbmRsZXIodGhpcy5tb2RlbCwgdHlwZSwgdGhpcy5jb250ZXh0KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0aGUgY2hpbGQgZWxlbWVudCBwYXJzaW5nXG4gICAqXG4gICAqIEBwYXJhbSAge0VsZW1lbnR9IG5vZGUgdGhlIHhtbCBub2RlXG4gICAqL1xuICBFbGVtZW50SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlQ2hpbGQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIHByb3BlcnR5RGVzYywgdHlwZSwgZWxlbWVudCwgY2hpbGRIYW5kbGVyO1xuXG4gICAgcHJvcGVydHlEZXNjID0gdGhpcy5nZXRQcm9wZXJ0eUZvck5vZGUobm9kZSk7XG4gICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICAgIHR5cGUgPSBwcm9wZXJ0eURlc2MuZWZmZWN0aXZlVHlwZSB8fCBwcm9wZXJ0eURlc2MudHlwZTtcblxuICAgIGlmIChpc1NpbXBsZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVIYW5kbGVyKHByb3BlcnR5RGVzYywgZWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5RGVzYy5pc1JlZmVyZW5jZSkge1xuICAgICAgY2hpbGRIYW5kbGVyID0gdGhpcy5yZWZlcmVuY2VIYW5kbGVyKHByb3BlcnR5RGVzYykuaGFuZGxlTm9kZShub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGRIYW5kbGVyID0gdGhpcy5oYW5kbGVyKHR5cGUpLmhhbmRsZU5vZGUobm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIG5ld0VsZW1lbnQgPSBjaGlsZEhhbmRsZXIuZWxlbWVudDtcblxuICAgIC8vIGNoaWxkIGhhbmRsZXMgbWF5IGRlY2lkZSB0byBza2lwIGVsZW1lbnRzXG4gICAgLy8gYnkgbm90IHJldHVybmluZyBhbnl0aGluZ1xuICAgIGlmIChuZXdFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgaWYgKHByb3BlcnR5RGVzYy5pc01hbnkpIHtcbiAgICAgICAgZWxlbWVudC5nZXQocHJvcGVydHlEZXNjLm5hbWUpLnB1c2gobmV3RWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldChwcm9wZXJ0eURlc2MubmFtZSwgbmV3RWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wZXJ0eURlc2MuaXNSZWZlcmVuY2UpIHtcbiAgICAgICAgYXNzaWduJDEobmV3RWxlbWVudCwge1xuICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jb250ZXh0LmFkZFJlZmVyZW5jZShuZXdFbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gZXN0YWJsaXNoIGNoaWxkIC0+IHBhcmVudCByZWxhdGlvbnNoaXBcbiAgICAgICAgbmV3RWxlbWVudC4kcGFyZW50ID0gZWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGRIYW5kbGVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBbiBlbGVtZW50IGhhbmRsZXIgdGhhdCBwZXJmb3JtcyBzcGVjaWFsIHZhbGlkYXRpb25cbiAgICogdG8gZW5zdXJlIHRoZSBub2RlIGl0IGdldHMgaW5pdGlhbGl6ZWQgd2l0aCBtYXRjaGVzXG4gICAqIHRoZSBoYW5kbGVycyB0eXBlIChuYW1lc3BhY2Ugd2lzZSkuXG4gICAqXG4gICAqIEBwYXJhbSB7TW9kZGxlfSBtb2RlbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZU5hbWVcbiAgICogQHBhcmFtIHtDb250ZXh0fSBjb250ZXh0XG4gICAqL1xuICBmdW5jdGlvbiBSb290RWxlbWVudEhhbmRsZXIobW9kZWwsIHR5cGVOYW1lLCBjb250ZXh0KSB7XG4gICAgRWxlbWVudEhhbmRsZXIuY2FsbCh0aGlzLCBtb2RlbCwgdHlwZU5hbWUsIGNvbnRleHQpO1xuICB9XG5cbiAgUm9vdEVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRWxlbWVudEhhbmRsZXIucHJvdG90eXBlKTtcblxuICBSb290RWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgICB2YXIgbmFtZSA9IG5vZGUubmFtZSxcbiAgICAgICAgbmFtZU5zID0gcGFyc2VOYW1lKG5hbWUpLFxuICAgICAgICBtb2RlbCA9IHRoaXMubW9kZWwsXG4gICAgICAgIHR5cGUgPSB0aGlzLnR5cGUsXG4gICAgICAgIHBrZyA9IG1vZGVsLmdldFBhY2thZ2UobmFtZU5zLnByZWZpeCksXG4gICAgICAgIHR5cGVOYW1lID0gcGtnICYmIGFsaWFzVG9OYW1lKG5hbWVOcywgcGtnKSB8fCBuYW1lO1xuXG4gICAgLy8gdmVyaWZ5IHRoZSBjb3JyZWN0IG5hbWVzcGFjZSBpZiB3ZSBwYXJzZVxuICAgIC8vIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBoYW5kbGVyIHRyZWVcbiAgICAvL1xuICAgIC8vIHRoaXMgZW5zdXJlcyB3ZSBkb24ndCBtaXN0YWtlbmx5IGltcG9ydCB3cm9uZyBuYW1lc3BhY2UgZWxlbWVudHNcbiAgICBpZiAoIXR5cGUuaGFzVHlwZSh0eXBlTmFtZSkpIHtcbiAgICAgIHRocm93IGVycm9yKCd1bmV4cGVjdGVkIGVsZW1lbnQgPCcgKyBub2RlLm9yaWdpbmFsTmFtZSArICc+Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50LmNhbGwodGhpcywgbm9kZSk7XG4gIH07XG5cblxuICBmdW5jdGlvbiBHZW5lcmljRWxlbWVudEhhbmRsZXIobW9kZWwsIHR5cGVOYW1lLCBjb250ZXh0KSB7XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIH1cblxuICBHZW5lcmljRWxlbWVudEhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlRWxlbWVudEhhbmRsZXIucHJvdG90eXBlKTtcblxuICBHZW5lcmljRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgICB2YXIgbmFtZSA9IG5vZGUubmFtZSxcbiAgICAgICAgbnMgPSBwYXJzZU5hbWUobmFtZSksXG4gICAgICAgIHByZWZpeCA9IG5zLnByZWZpeCxcbiAgICAgICAgdXJpID0gbm9kZS5uc1twcmVmaXggKyAnJHVyaSddLFxuICAgICAgICBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuXG4gICAgcmV0dXJuIHRoaXMubW9kZWwuY3JlYXRlQW55KG5hbWUsIHVyaSwgYXR0cmlidXRlcyk7XG4gIH07XG5cbiAgR2VuZXJpY0VsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVDaGlsZCA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICAgIHZhciBoYW5kbGVyID0gbmV3IEdlbmVyaWNFbGVtZW50SGFuZGxlcih0aGlzLm1vZGVsLCAnRWxlbWVudCcsIHRoaXMuY29udGV4dCkuaGFuZGxlTm9kZShub2RlKSxcbiAgICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICAgIHZhciBuZXdFbGVtZW50ID0gaGFuZGxlci5lbGVtZW50LFxuICAgICAgICBjaGlsZHJlbjtcblxuICAgIGlmIChuZXdFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNoaWxkcmVuID0gZWxlbWVudC4kY2hpbGRyZW4gPSBlbGVtZW50LiRjaGlsZHJlbiB8fCBbXTtcbiAgICAgIGNoaWxkcmVuLnB1c2gobmV3RWxlbWVudCk7XG5cbiAgICAgIC8vIGVzdGFibGlzaCBjaGlsZCAtPiBwYXJlbnQgcmVsYXRpb25zaGlwXG4gICAgICBuZXdFbGVtZW50LiRwYXJlbnQgPSBlbGVtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBoYW5kbGVyO1xuICB9O1xuXG4gIEdlbmVyaWNFbGVtZW50SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYm9keSkge1xuICAgICAgdGhpcy5lbGVtZW50LiRib2R5ID0gdGhpcy5ib2R5O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQSByZWFkZXIgZm9yIGEgbWV0YS1tb2RlbFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge01vZGVsfSBvcHRpb25zLm1vZGVsIHVzZWQgdG8gcmVhZCB4bWwgZmlsZXNcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmxheCB3aGV0aGVyIHRvIG1ha2UgcGFyc2UgZXJyb3JzIHdhcm5pbmdzXG4gICAqL1xuICBmdW5jdGlvbiBSZWFkZXIob3B0aW9ucykge1xuXG4gICAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBNb2RkbGUpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIG1vZGVsOiBvcHRpb25zXG4gICAgICB9O1xuICAgIH1cblxuICAgIGFzc2lnbiQxKHRoaXMsIHsgbGF4OiBmYWxzZSB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZnJvbVhNTCByZXN1bHQuXG4gICAqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFBhcnNlUmVzdWx0XG4gICAqXG4gICAqIEBwcm9wZXJ0eSB7TW9kZGxlRWxlbWVudH0gcm9vdEVsZW1lbnRcbiAgICogQHByb3BlcnR5IHtBcnJheTxPYmplY3Q+fSByZWZlcmVuY2VzXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8RXJyb3I+fSB3YXJuaW5nc1xuICAgKiBAcHJvcGVydHkge09iamVjdH0gZWxlbWVudHNCeUlkIC0gYSBtYXBwaW5nIGNvbnRhaW5pbmcgZWFjaCBJRCAtPiBNb2RkbGVFbGVtZW50XG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgZnJvbVhNTCByZXN1bHQuXG4gICAqXG4gICAqIEB0eXBlZGVmIHtFcnJvcn0gUGFyc2VFcnJvclxuICAgKlxuICAgKiBAcHJvcGVydHkge0FycmF5PEVycm9yPn0gd2FybmluZ3NcbiAgICovXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBnaXZlbiBYTUwgaW50byBhIG1vZGRsZSBkb2N1bWVudCB0cmVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30geG1sXG4gICAqIEBwYXJhbSB7RWxlbWVudEhhbmRsZXJ8T2JqZWN0fSBvcHRpb25zIG9yIHJvb3RIYW5kbGVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFBhcnNlUmVzdWx0LCBQYXJzZUVycm9yPn1cbiAgICovXG4gIFJlYWRlci5wcm90b3R5cGUuZnJvbVhNTCA9IGZ1bmN0aW9uKHhtbCwgb3B0aW9ucywgZG9uZSkge1xuXG4gICAgdmFyIHJvb3RIYW5kbGVyID0gb3B0aW9ucy5yb290SGFuZGxlcjtcblxuICAgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgRWxlbWVudEhhbmRsZXIpIHtcblxuICAgICAgLy8gcm9vdCBoYW5kbGVyIHBhc3NlZCB2aWEgKHhtbCwgeyByb290SGFuZGxlcjogRWxlbWVudEhhbmRsZXIgfSwgLi4uKVxuICAgICAgcm9vdEhhbmRsZXIgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgLy8gcm9vdEhhbmRsZXIgcGFzc2VkIHZpYSAoeG1sLCAnc29tZVN0cmluZycsIC4uLilcbiAgICAgICAgcm9vdEhhbmRsZXIgPSB0aGlzLmhhbmRsZXIob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJvb3RIYW5kbGVyID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgIC8vIHJvb3RIYW5kbGVyIHBhc3NlZCB2aWEgKHhtbCwgeyByb290SGFuZGxlcjogJ3NvbWVTdHJpbmcnIH0sIC4uLilcbiAgICAgICAgcm9vdEhhbmRsZXIgPSB0aGlzLmhhbmRsZXIocm9vdEhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWwsXG4gICAgICAgIGxheCA9IHRoaXMubGF4O1xuXG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dChhc3NpZ24kMSh7fSwgb3B0aW9ucywgeyByb290SGFuZGxlcjogcm9vdEhhbmRsZXIgfSkpLFxuICAgICAgICBwYXJzZXIgPSBuZXcgUGFyc2VyKHsgcHJveHk6IHRydWUgfSksXG4gICAgICAgIHN0YWNrID0gY3JlYXRlU3RhY2soKTtcblxuICAgIHJvb3RIYW5kbGVyLmNvbnRleHQgPSBjb250ZXh0O1xuXG4gICAgLy8gcHVzaCByb290IGhhbmRsZXJcbiAgICBzdGFjay5wdXNoKHJvb3RIYW5kbGVyKTtcblxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7RXJyb3J9IGVyclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBnZXRDb250ZXh0XG4gICAgICogQHBhcmFtICB7Ym9vbGVhbn0gbGF4XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGhhbmRsZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIsIGdldENvbnRleHQsIGxheCkge1xuXG4gICAgICB2YXIgY3R4ID0gZ2V0Q29udGV4dCgpO1xuXG4gICAgICB2YXIgbGluZSA9IGN0eC5saW5lLFxuICAgICAgICAgIGNvbHVtbiA9IGN0eC5jb2x1bW4sXG4gICAgICAgICAgZGF0YSA9IGN0eC5kYXRhO1xuXG4gICAgICAvLyB3ZSByZWNlaXZlIHRoZSBmdWxsIGNvbnRleHQgZGF0YSBoZXJlLFxuICAgICAgLy8gZm9yIGVsZW1lbnRzIHRyaW0gZG93biB0aGUgaW5mb3JtYXRpb25cbiAgICAgIC8vIHRvIHRoZSB0YWcgbmFtZSwgb25seVxuICAgICAgaWYgKGRhdGEuY2hhckF0KDApID09PSAnPCcgJiYgZGF0YS5pbmRleE9mKCcgJykgIT09IC0xKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKDAsIGRhdGEuaW5kZXhPZignICcpKSArICc+JztcbiAgICAgIH1cblxuICAgICAgdmFyIG1lc3NhZ2UgPVxuICAgICAgICAndW5wYXJzYWJsZSBjb250ZW50ICcgKyAoZGF0YSA/IGRhdGEgKyAnICcgOiAnJykgKyAnZGV0ZWN0ZWRcXG5cXHQnICtcbiAgICAgICAgICAnbGluZTogJyArIGxpbmUgKyAnXFxuXFx0JyArXG4gICAgICAgICAgJ2NvbHVtbjogJyArIGNvbHVtbiArICdcXG5cXHQnICtcbiAgICAgICAgICAnbmVzdGVkIGVycm9yOiAnICsgZXJyLm1lc3NhZ2U7XG5cbiAgICAgIGlmIChsYXgpIHtcbiAgICAgICAgY29udGV4dC5hZGRXYXJuaW5nKHtcbiAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVXYXJuaW5nKGVyciwgZ2V0Q29udGV4dCkge1xuXG4gICAgICAvLyBqdXN0IGxpa2UgaGFuZGxpbmcgZXJyb3JzIGluIDxsYXg9dHJ1ZT4gbW9kZVxuICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKGVyciwgZ2V0Q29udGV4dCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSBjb2xsZWN0ZWQgcmVmZXJlbmNlcyBvbiBwYXJzZSBlbmQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVJlZmVyZW5jZXMoKSB7XG5cbiAgICAgIHZhciBlbGVtZW50c0J5SWQgPSBjb250ZXh0LmVsZW1lbnRzQnlJZDtcbiAgICAgIHZhciByZWZlcmVuY2VzID0gY29udGV4dC5yZWZlcmVuY2VzO1xuXG4gICAgICB2YXIgaSwgcjtcblxuICAgICAgZm9yIChpID0gMDsgKHIgPSByZWZlcmVuY2VzW2ldKTsgaSsrKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gci5lbGVtZW50O1xuICAgICAgICB2YXIgcmVmZXJlbmNlID0gZWxlbWVudHNCeUlkW3IuaWRdO1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBnZXRNb2RkbGVEZXNjcmlwdG9yKGVsZW1lbnQpLnByb3BlcnRpZXNCeU5hbWVbci5wcm9wZXJ0eV07XG5cbiAgICAgICAgaWYgKCFyZWZlcmVuY2UpIHtcbiAgICAgICAgICBjb250ZXh0LmFkZFdhcm5pbmcoe1xuICAgICAgICAgICAgbWVzc2FnZTogJ3VucmVzb2x2ZWQgcmVmZXJlbmNlIDwnICsgci5pZCArICc+JyxcbiAgICAgICAgICAgIGVsZW1lbnQ6IHIuZWxlbWVudCxcbiAgICAgICAgICAgIHByb3BlcnR5OiByLnByb3BlcnR5LFxuICAgICAgICAgICAgdmFsdWU6IHIuaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wZXJ0eS5pc01hbnkpIHtcbiAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9IGVsZW1lbnQuZ2V0KHByb3BlcnR5Lm5hbWUpLFxuICAgICAgICAgICAgICBpZHggPSBjb2xsZWN0aW9uLmluZGV4T2Yocik7XG5cbiAgICAgICAgICAvLyB3ZSByZXBsYWNlIGFuIGV4aXN0aW5nIHBsYWNlIGhvbGRlciAoaWR4ICE9IC0xKSBvclxuICAgICAgICAgIC8vIGFwcGVuZCB0byB0aGUgY29sbGVjdGlvbiBpbnN0ZWFkXG4gICAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlkeCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghcmVmZXJlbmNlKSB7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB1bnJlc29sdmFibGUgcmVmZXJlbmNlXG4gICAgICAgICAgICBjb2xsZWN0aW9uLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIGFkZCBvciB1cGRhdGUgcmVmZXJlbmNlIGluIGNvbGxlY3Rpb25cbiAgICAgICAgICAgIGNvbGxlY3Rpb25baWR4XSA9IHJlZmVyZW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbWVudC5zZXQocHJvcGVydHkubmFtZSwgcmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUNsb3NlKCkge1xuICAgICAgc3RhY2sucG9wKCkuaGFuZGxlRW5kKCk7XG4gICAgfVxuXG4gICAgdmFyIFBSRUFNQkxFX1NUQVJUX1BBVFRFUk4gPSAvXjxcXD94bWwgL2k7XG5cbiAgICB2YXIgRU5DT0RJTkdfUEFUVEVSTiA9IC8gZW5jb2Rpbmc9XCIoW15cIl0rKVwiL2k7XG5cbiAgICB2YXIgVVRGXzhfUEFUVEVSTiA9IC9edXRmLTgkL2k7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVRdWVzdGlvbihxdWVzdGlvbikge1xuXG4gICAgICBpZiAoIVBSRUFNQkxFX1NUQVJUX1BBVFRFUk4udGVzdChxdWVzdGlvbikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2ggPSBFTkNPRElOR19QQVRURVJOLmV4ZWMocXVlc3Rpb24pO1xuICAgICAgdmFyIGVuY29kaW5nID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG5cbiAgICAgIGlmICghZW5jb2RpbmcgfHwgVVRGXzhfUEFUVEVSTi50ZXN0KGVuY29kaW5nKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuYWRkV2FybmluZyh7XG4gICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgJ3Vuc3VwcG9ydGVkIGRvY3VtZW50IGVuY29kaW5nIDwnICsgZW5jb2RpbmcgKyAnPiwgJyArXG4gICAgICAgICAgJ2ZhbGxpbmcgYmFjayB0byBVVEYtOCdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZU9wZW4obm9kZSwgZ2V0Q29udGV4dCkge1xuICAgICAgdmFyIGhhbmRsZXIgPSBzdGFjay5wZWVrKCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YWNrLnB1c2goaGFuZGxlci5oYW5kbGVOb2RlKG5vZGUpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuXG4gICAgICAgIGlmIChoYW5kbGVFcnJvcihlcnIsIGdldENvbnRleHQsIGxheCkpIHtcbiAgICAgICAgICBzdGFjay5wdXNoKG5ldyBOb29wSGFuZGxlcigpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUNEYXRhKHRleHQsIGdldENvbnRleHQpIHtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhY2sucGVlaygpLmhhbmRsZVRleHQodGV4dCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaGFuZGxlV2FybmluZyhlcnIsIGdldENvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVRleHQodGV4dCwgZ2V0Q29udGV4dCkge1xuXG4gICAgICAvLyBzdHJpcCB3aGl0ZXNwYWNlIG9ubHkgbm9kZXMsIGkuZS4gYmVmb3JlXG4gICAgICAvLyA8IUNEQVRBWyAuLi4gXT4gc2VjdGlvbnMgYW5kIGluIGJldHdlZW4gdGFnc1xuXG4gICAgICBpZiAoIXRleHQudHJpbSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaGFuZGxlQ0RhdGEodGV4dCwgZ2V0Q29udGV4dCk7XG4gICAgfVxuXG4gICAgdmFyIHVyaU1hcCA9IG1vZGVsLmdldFBhY2thZ2VzKCkucmVkdWNlKGZ1bmN0aW9uKHVyaU1hcCwgcCkge1xuICAgICAgdXJpTWFwW3AudXJpXSA9IHAucHJlZml4O1xuXG4gICAgICByZXR1cm4gdXJpTWFwO1xuICAgIH0sIE9iamVjdC5lbnRyaWVzKERFRkFVTFRfTlNfTUFQKS5yZWR1Y2UoZnVuY3Rpb24obWFwLCBbIHByZWZpeCwgdXJsIF0pIHtcbiAgICAgIG1hcFt1cmxdID0gcHJlZml4O1xuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0sIG1vZGVsLmNvbmZpZyAmJiBtb2RlbC5jb25maWcubnNNYXAgfHwge30pKTtcblxuICAgIHBhcnNlclxuICAgICAgLm5zKHVyaU1hcClcbiAgICAgIC5vbignb3BlblRhZycsIGZ1bmN0aW9uKG9iaiwgZGVjb2RlU3RyLCBzZWxmQ2xvc2luZywgZ2V0Q29udGV4dCkge1xuXG4gICAgICAgIC8vIGdyYWNlZnVsbHkgaGFuZGxlIHVucGFyc2FibGUgYXR0cmlidXRlcyAoYXR0cnM9ZmFsc2UpXG4gICAgICAgIHZhciBhdHRycyA9IG9iai5hdHRycyB8fCB7fTtcblxuICAgICAgICB2YXIgZGVjb2RlZEF0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpLnJlZHVjZShmdW5jdGlvbihkLCBrZXkpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBkZWNvZGVTdHIoYXR0cnNba2V5XSk7XG5cbiAgICAgICAgICBkW2tleV0gPSB2YWx1ZTtcblxuICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9LCB7fSk7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB7XG4gICAgICAgICAgbmFtZTogb2JqLm5hbWUsXG4gICAgICAgICAgb3JpZ2luYWxOYW1lOiBvYmoub3JpZ2luYWxOYW1lLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IGRlY29kZWRBdHRycyxcbiAgICAgICAgICBuczogb2JqLm5zXG4gICAgICAgIH07XG5cbiAgICAgICAgaGFuZGxlT3Blbihub2RlLCBnZXRDb250ZXh0KTtcbiAgICAgIH0pXG4gICAgICAub24oJ3F1ZXN0aW9uJywgaGFuZGxlUXVlc3Rpb24pXG4gICAgICAub24oJ2Nsb3NlVGFnJywgaGFuZGxlQ2xvc2UpXG4gICAgICAub24oJ2NkYXRhJywgaGFuZGxlQ0RhdGEpXG4gICAgICAub24oJ3RleHQnLCBmdW5jdGlvbih0ZXh0LCBkZWNvZGVFbnRpdGllcywgZ2V0Q29udGV4dCkge1xuICAgICAgICBoYW5kbGVUZXh0KGRlY29kZUVudGl0aWVzKHRleHQpLCBnZXRDb250ZXh0KTtcbiAgICAgIH0pXG4gICAgICAub24oJ2Vycm9yJywgaGFuZGxlRXJyb3IpXG4gICAgICAub24oJ3dhcm4nLCBoYW5kbGVXYXJuaW5nKTtcblxuICAgIC8vIGFzeW5jIFhNTCBwYXJzaW5nIHRvIG1ha2Ugc3VyZSB0aGUgZXhlY3V0aW9uIGVudmlyb25tZW50XG4gICAgLy8gKG5vZGUgb3IgYnJvd2VyKSBpcyBrZXB0IHJlc3BvbnNpdmUgYW5kIHRoYXQgY2VydGFpbiBvcHRpbWl6YXRpb25cbiAgICAvLyBzdHJhdGVnaWVzIGNhbiBraWNrIGluLlxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgdmFyIGVycjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VyLnBhcnNlKHhtbCk7XG5cbiAgICAgICAgcmVzb2x2ZVJlZmVyZW5jZXMoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyID0gZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gcm9vdEhhbmRsZXIuZWxlbWVudDtcblxuICAgICAgaWYgKCFlcnIgJiYgIXJvb3RFbGVtZW50KSB7XG4gICAgICAgIGVyciA9IGVycm9yKCdmYWlsZWQgdG8gcGFyc2UgZG9jdW1lbnQgYXMgPCcgKyByb290SGFuZGxlci50eXBlLiRkZXNjcmlwdG9yLm5hbWUgKyAnPicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgd2FybmluZ3MgPSBjb250ZXh0Lndhcm5pbmdzO1xuICAgICAgdmFyIHJlZmVyZW5jZXMgPSBjb250ZXh0LnJlZmVyZW5jZXM7XG4gICAgICB2YXIgZWxlbWVudHNCeUlkID0gY29udGV4dC5lbGVtZW50c0J5SWQ7XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZXJyLndhcm5pbmdzID0gd2FybmluZ3M7XG5cbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoe1xuICAgICAgICAgIHJvb3RFbGVtZW50OiByb290RWxlbWVudCxcbiAgICAgICAgICBlbGVtZW50c0J5SWQ6IGVsZW1lbnRzQnlJZCxcbiAgICAgICAgICByZWZlcmVuY2VzOiByZWZlcmVuY2VzLFxuICAgICAgICAgIHdhcm5pbmdzOiB3YXJuaW5nc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBSZWFkZXIucHJvdG90eXBlLmhhbmRsZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBSb290RWxlbWVudEhhbmRsZXIodGhpcy5tb2RlbCwgbmFtZSk7XG4gIH07XG5cblxuICAvLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RhY2soKSB7XG4gICAgdmFyIHN0YWNrID0gW107XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RhY2ssICdwZWVrJywge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1t0aGlzLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9XG5cbiAgdmFyIFhNTF9QUkVBTUJMRSA9ICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiPz5cXG4nO1xuXG4gIHZhciBFU0NBUEVfQVRUUl9DSEFSUyA9IC88fD58J3xcInwmfFxcblxccnxcXG4vZztcbiAgdmFyIEVTQ0FQRV9DSEFSUyA9IC88fD58Ji9nO1xuXG5cbiAgZnVuY3Rpb24gTmFtZXNwYWNlcyhwYXJlbnQpIHtcblxuICAgIHRoaXMucHJlZml4TWFwID0ge307XG4gICAgdGhpcy51cmlNYXAgPSB7fTtcbiAgICB0aGlzLnVzZWQgPSB7fTtcblxuICAgIHRoaXMud2VsbGtub3duID0gW107XG4gICAgdGhpcy5jdXN0b20gPSBbXTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuICAgIHRoaXMuZGVmYXVsdFByZWZpeE1hcCA9IHBhcmVudCAmJiBwYXJlbnQuZGVmYXVsdFByZWZpeE1hcCB8fCB7fTtcbiAgfVxuXG4gIE5hbWVzcGFjZXMucHJvdG90eXBlLm1hcERlZmF1bHRQcmVmaXhlcyA9IGZ1bmN0aW9uKGRlZmF1bHRQcmVmaXhNYXApIHtcbiAgICB0aGlzLmRlZmF1bHRQcmVmaXhNYXAgPSBkZWZhdWx0UHJlZml4TWFwO1xuICB9O1xuXG4gIE5hbWVzcGFjZXMucHJvdG90eXBlLmRlZmF1bHRVcmlCeVByZWZpeCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRQcmVmaXhNYXBbcHJlZml4XTtcbiAgfTtcblxuICBOYW1lc3BhY2VzLnByb3RvdHlwZS5ieVVyaSA9IGZ1bmN0aW9uKHVyaSkge1xuICAgIHJldHVybiB0aGlzLnVyaU1hcFt1cmldIHx8IChcbiAgICAgIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmJ5VXJpKHVyaSlcbiAgICApO1xuICB9O1xuXG4gIE5hbWVzcGFjZXMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG5zLCBpc1dlbGxrbm93bikge1xuXG4gICAgdGhpcy51cmlNYXBbbnMudXJpXSA9IG5zO1xuXG4gICAgaWYgKGlzV2VsbGtub3duKSB7XG4gICAgICB0aGlzLndlbGxrbm93bi5wdXNoKG5zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdXN0b20ucHVzaChucyk7XG4gICAgfVxuXG4gICAgdGhpcy5tYXBQcmVmaXgobnMucHJlZml4LCBucy51cmkpO1xuICB9O1xuXG4gIE5hbWVzcGFjZXMucHJvdG90eXBlLnVyaUJ5UHJlZml4ID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZml4TWFwW3ByZWZpeCB8fCAneG1sbnMnXSB8fCAoXG4gICAgICB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC51cmlCeVByZWZpeChwcmVmaXgpXG4gICAgKTtcbiAgfTtcblxuICBOYW1lc3BhY2VzLnByb3RvdHlwZS5tYXBQcmVmaXggPSBmdW5jdGlvbihwcmVmaXgsIHVyaSkge1xuICAgIHRoaXMucHJlZml4TWFwW3ByZWZpeCB8fCAneG1sbnMnXSA9IHVyaTtcbiAgfTtcblxuICBOYW1lc3BhY2VzLnByb3RvdHlwZS5nZXROU0tleSA9IGZ1bmN0aW9uKG5zKSB7XG4gICAgcmV0dXJuIChucy5wcmVmaXggIT09IHVuZGVmaW5lZCkgPyAobnMudXJpICsgJ3wnICsgbnMucHJlZml4KSA6IG5zLnVyaTtcbiAgfTtcblxuICBOYW1lc3BhY2VzLnByb3RvdHlwZS5sb2dVc2VkID0gZnVuY3Rpb24obnMpIHtcblxuICAgIHZhciB1cmkgPSBucy51cmk7XG4gICAgdmFyIG5zS2V5ID0gdGhpcy5nZXROU0tleShucyk7XG5cbiAgICB0aGlzLnVzZWRbbnNLZXldID0gdGhpcy5ieVVyaSh1cmkpO1xuXG4gICAgLy8gSW5mb3JtIHBhcmVudCByZWN1cnNpdmVseSBhYm91dCB0aGUgdXNhZ2Ugb2YgdGhpcyBOU1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQubG9nVXNlZChucyk7XG4gICAgfVxuICB9O1xuXG4gIE5hbWVzcGFjZXMucHJvdG90eXBlLmdldFVzZWQgPSBmdW5jdGlvbihucykge1xuXG4gICAgdmFyIGFsbE5zID0gW10uY29uY2F0KHRoaXMud2VsbGtub3duLCB0aGlzLmN1c3RvbSk7XG5cbiAgICByZXR1cm4gYWxsTnMuZmlsdGVyKG5zID0+IHtcbiAgICAgIHZhciBuc0tleSA9IHRoaXMuZ2V0TlNLZXkobnMpO1xuXG4gICAgICByZXR1cm4gdGhpcy51c2VkW25zS2V5XTtcbiAgICB9KTtcbiAgfTtcblxuXG4gIGZ1bmN0aW9uIGxvd2VyKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG4gIH1cblxuICBmdW5jdGlvbiBuYW1lVG9BbGlhcyhuYW1lLCBwa2cpIHtcbiAgICBpZiAoaGFzTG93ZXJDYXNlQWxpYXMocGtnKSkge1xuICAgICAgcmV0dXJuIGxvd2VyKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBuc05hbWUobnMpIHtcbiAgICBpZiAoaXNTdHJpbmcobnMpKSB7XG4gICAgICByZXR1cm4gbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAobnMucHJlZml4ID8gbnMucHJlZml4ICsgJzonIDogJycpICsgbnMubG9jYWxOYW1lO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5zQXR0cnMobmFtZXNwYWNlcykge1xuXG4gICAgcmV0dXJuIG5hbWVzcGFjZXMuZ2V0VXNlZCgpLmZpbHRlcihmdW5jdGlvbihucykge1xuXG4gICAgICAvLyBkbyBub3Qgc2VyaWFsaXplIGJ1aWx0IGluIDx4bWw+IG5hbWVzcGFjZVxuICAgICAgcmV0dXJuIG5zLnByZWZpeCAhPT0gJ3htbCc7XG4gICAgfSkubWFwKGZ1bmN0aW9uKG5zKSB7XG4gICAgICB2YXIgbmFtZSA9ICd4bWxucycgKyAobnMucHJlZml4ID8gJzonICsgbnMucHJlZml4IDogJycpO1xuICAgICAgcmV0dXJuIHsgbmFtZTogbmFtZSwgdmFsdWU6IG5zLnVyaSB9O1xuICAgIH0pO1xuXG4gIH1cblxuICBmdW5jdGlvbiBnZXRFbGVtZW50TnMobnMsIGRlc2NyaXB0b3IpIHtcbiAgICBpZiAoZGVzY3JpcHRvci5pc0dlbmVyaWMpIHtcbiAgICAgIHJldHVybiBhc3NpZ24kMSh7IGxvY2FsTmFtZTogZGVzY3JpcHRvci5ucy5sb2NhbE5hbWUgfSwgbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXNzaWduJDEoeyBsb2NhbE5hbWU6IG5hbWVUb0FsaWFzKGRlc2NyaXB0b3IubnMubG9jYWxOYW1lLCBkZXNjcmlwdG9yLiRwa2cpIH0sIG5zKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQcm9wZXJ0eU5zKG5zLCBkZXNjcmlwdG9yKSB7XG4gICAgcmV0dXJuIGFzc2lnbiQxKHsgbG9jYWxOYW1lOiBkZXNjcmlwdG9yLm5zLmxvY2FsTmFtZSB9LCBucyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTZXJpYWxpemFibGVQcm9wZXJ0aWVzKGVsZW1lbnQpIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnQuJGRlc2NyaXB0b3I7XG5cbiAgICByZXR1cm4gZmlsdGVyKGRlc2NyaXB0b3IucHJvcGVydGllcywgZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIG5hbWUgPSBwLm5hbWU7XG5cbiAgICAgIGlmIChwLmlzVmlydHVhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvIG5vdCBzZXJpYWxpemUgZGVmYXVsdHNcbiAgICAgIGlmICghaGFzJDEoZWxlbWVudCwgbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBlbGVtZW50W25hbWVdO1xuXG4gICAgICAvLyBkbyBub3Qgc2VyaWFsaXplIGRlZmF1bHQgZXF1YWxzXG4gICAgICBpZiAodmFsdWUgPT09IHAuZGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvIG5vdCBzZXJpYWxpemUgbnVsbCBwcm9wZXJ0aWVzXG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcC5pc01hbnkgPyB2YWx1ZS5sZW5ndGggOiB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIEVTQ0FQRV9BVFRSX01BUCA9IHtcbiAgICAnXFxuJzogJyMxMCcsXG4gICAgJ1xcblxccic6ICcjMTAnLFxuICAgICdcIic6ICcjMzQnLFxuICAgICdcXCcnOiAnIzM5JyxcbiAgICAnPCc6ICcjNjAnLFxuICAgICc+JzogJyM2MicsXG4gICAgJyYnOiAnIzM4J1xuICB9O1xuXG4gIHZhciBFU0NBUEVfTUFQID0ge1xuICAgICc8JzogJ2x0JyxcbiAgICAnPic6ICdndCcsXG4gICAgJyYnOiAnYW1wJ1xuICB9O1xuXG4gIGZ1bmN0aW9uIGVzY2FwZShzdHIsIGNoYXJQYXR0ZXJuLCByZXBsYWNlTWFwKSB7XG5cbiAgICAvLyBlbnN1cmUgd2UgYXJlIGhhbmRsaW5nIHN0cmluZ3MgaGVyZVxuICAgIHN0ciA9IGlzU3RyaW5nKHN0cikgPyBzdHIgOiAnJyArIHN0cjtcblxuICAgIHJldHVybiBzdHIucmVwbGFjZShjaGFyUGF0dGVybiwgZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuICcmJyArIHJlcGxhY2VNYXBbc10gKyAnOyc7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXNjYXBlIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBub3QgY29udGFpbiBhbnkgYmFkIHZhbHVlcyAobGluZSBicmVha3MsICdcIicsIC4uLilcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIGVzY2FwZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBlc2NhcGVkIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlQXR0cihzdHIpIHtcbiAgICByZXR1cm4gZXNjYXBlKHN0ciwgRVNDQVBFX0FUVFJfQ0hBUlMsIEVTQ0FQRV9BVFRSX01BUCk7XG4gIH1cblxuICBmdW5jdGlvbiBlc2NhcGVCb2R5KHN0cikge1xuICAgIHJldHVybiBlc2NhcGUoc3RyLCBFU0NBUEVfQ0hBUlMsIEVTQ0FQRV9NQVApO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsdGVyQXR0cmlidXRlcyhwcm9wcykge1xuICAgIHJldHVybiBmaWx0ZXIocHJvcHMsIGZ1bmN0aW9uKHApIHsgcmV0dXJuIHAuaXNBdHRyOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbHRlckNvbnRhaW5lZChwcm9wcykge1xuICAgIHJldHVybiBmaWx0ZXIocHJvcHMsIGZ1bmN0aW9uKHApIHsgcmV0dXJuICFwLmlzQXR0cjsgfSk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIFJlZmVyZW5jZVNlcmlhbGl6ZXIodGFnTmFtZSkge1xuICAgIHRoaXMudGFnTmFtZSA9IHRhZ05hbWU7XG4gIH1cblxuICBSZWZlcmVuY2VTZXJpYWxpemVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFJlZmVyZW5jZVNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZVRvID0gZnVuY3Rpb24od3JpdGVyKSB7XG4gICAgd3JpdGVyXG4gICAgICAuYXBwZW5kSW5kZW50KClcbiAgICAgIC5hcHBlbmQoJzwnICsgdGhpcy50YWdOYW1lICsgJz4nICsgdGhpcy5lbGVtZW50LmlkICsgJzwvJyArIHRoaXMudGFnTmFtZSArICc+JylcbiAgICAgIC5hcHBlbmROZXdMaW5lKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQm9keVNlcmlhbGl6ZXIoKSB7fVxuXG4gIEJvZHlTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVWYWx1ZSA9XG4gIEJvZHlTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVUbyA9IGZ1bmN0aW9uKHdyaXRlcikge1xuICAgIHdyaXRlci5hcHBlbmQoXG4gICAgICB0aGlzLmVzY2FwZVxuICAgICAgICA/IGVzY2FwZUJvZHkodGhpcy52YWx1ZSlcbiAgICAgICAgOiB0aGlzLnZhbHVlXG4gICAgKTtcbiAgfTtcblxuICBCb2R5U2VyaWFsaXplci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChwcm9wLnR5cGUgPT09ICdTdHJpbmcnICYmIHZhbHVlLnNlYXJjaChFU0NBUEVfQ0hBUlMpICE9PSAtMSkge1xuICAgICAgdGhpcy5lc2NhcGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFZhbHVlU2VyaWFsaXplcih0YWdOYW1lKSB7XG4gICAgdGhpcy50YWdOYW1lID0gdGFnTmFtZTtcbiAgfVxuXG4gIGluaGVyaXRzKFZhbHVlU2VyaWFsaXplciwgQm9keVNlcmlhbGl6ZXIpO1xuXG4gIFZhbHVlU2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplVG8gPSBmdW5jdGlvbih3cml0ZXIpIHtcblxuICAgIHdyaXRlclxuICAgICAgLmFwcGVuZEluZGVudCgpXG4gICAgICAuYXBwZW5kKCc8JyArIHRoaXMudGFnTmFtZSArICc+Jyk7XG5cbiAgICB0aGlzLnNlcmlhbGl6ZVZhbHVlKHdyaXRlcik7XG5cbiAgICB3cml0ZXJcbiAgICAgIC5hcHBlbmQoJzwvJyArIHRoaXMudGFnTmFtZSArICc+JylcbiAgICAgIC5hcHBlbmROZXdMaW5lKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gRWxlbWVudFNlcmlhbGl6ZXIocGFyZW50LCBwcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgICB0aGlzLmJvZHkgPSBbXTtcbiAgICB0aGlzLmF0dHJzID0gW107XG5cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnByb3BlcnR5RGVzY3JpcHRvciA9IHByb3BlcnR5RGVzY3JpcHRvcjtcbiAgfVxuXG4gIEVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgdmFyIGVsZW1lbnREZXNjcmlwdG9yID0gZWxlbWVudC4kZGVzY3JpcHRvcixcbiAgICAgICAgcHJvcGVydHlEZXNjcmlwdG9yID0gdGhpcy5wcm9wZXJ0eURlc2NyaXB0b3I7XG5cbiAgICB2YXIgb3RoZXJBdHRycyxcbiAgICAgICAgcHJvcGVydGllcztcblxuICAgIHZhciBpc0dlbmVyaWMgPSBlbGVtZW50RGVzY3JpcHRvci5pc0dlbmVyaWM7XG5cbiAgICBpZiAoaXNHZW5lcmljKSB7XG4gICAgICBvdGhlckF0dHJzID0gdGhpcy5wYXJzZUdlbmVyaWNOc0F0dHJpYnV0ZXMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG90aGVyQXR0cnMgPSB0aGlzLnBhcnNlTnNBdHRyaWJ1dGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgICAgIHRoaXMubnMgPSB0aGlzLm5zUHJvcGVydHlUYWdOYW1lKHByb3BlcnR5RGVzY3JpcHRvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubnMgPSB0aGlzLm5zVGFnTmFtZShlbGVtZW50RGVzY3JpcHRvcik7XG4gICAgfVxuXG4gICAgLy8gY29tcHV0ZSB0YWcgbmFtZVxuICAgIHRoaXMudGFnTmFtZSA9IHRoaXMuYWRkVGFnTmFtZSh0aGlzLm5zKTtcblxuICAgIGlmIChpc0dlbmVyaWMpIHtcbiAgICAgIHRoaXMucGFyc2VHZW5lcmljQ29udGFpbm1lbnRzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wZXJ0aWVzID0gZ2V0U2VyaWFsaXphYmxlUHJvcGVydGllcyhlbGVtZW50KTtcblxuICAgICAgdGhpcy5wYXJzZUF0dHJpYnV0ZXMoZmlsdGVyQXR0cmlidXRlcyhwcm9wZXJ0aWVzKSk7XG4gICAgICB0aGlzLnBhcnNlQ29udGFpbm1lbnRzKGZpbHRlckNvbnRhaW5lZChwcm9wZXJ0aWVzKSk7XG4gICAgfVxuXG4gICAgdGhpcy5wYXJzZUdlbmVyaWNBdHRyaWJ1dGVzKGVsZW1lbnQsIG90aGVyQXR0cnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLm5zVGFnTmFtZSA9IGZ1bmN0aW9uKGRlc2NyaXB0b3IpIHtcbiAgICB2YXIgZWZmZWN0aXZlTnMgPSB0aGlzLmxvZ05hbWVzcGFjZVVzZWQoZGVzY3JpcHRvci5ucyk7XG4gICAgcmV0dXJuIGdldEVsZW1lbnROcyhlZmZlY3RpdmVOcywgZGVzY3JpcHRvcik7XG4gIH07XG5cbiAgRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLm5zUHJvcGVydHlUYWdOYW1lID0gZnVuY3Rpb24oZGVzY3JpcHRvcikge1xuICAgIHZhciBlZmZlY3RpdmVOcyA9IHRoaXMubG9nTmFtZXNwYWNlVXNlZChkZXNjcmlwdG9yLm5zKTtcbiAgICByZXR1cm4gZ2V0UHJvcGVydHlOcyhlZmZlY3RpdmVOcywgZGVzY3JpcHRvcik7XG4gIH07XG5cbiAgRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLmlzTG9jYWxOcyA9IGZ1bmN0aW9uKG5zKSB7XG4gICAgcmV0dXJuIG5zLnVyaSA9PT0gdGhpcy5ucy51cmk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYWN0dWFsIG5zIGF0dHJpYnV0ZSBuYW1lIGZvciB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZWxlbWVudC5pbmhlcml0ZWQ9ZmFsc2VdXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gbnNOYW1lXG4gICAqL1xuICBFbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUubnNBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gICAgdmFyIG5zO1xuXG4gICAgaWYgKGlzU3RyaW5nKGVsZW1lbnQpKSB7XG4gICAgICBucyA9IHBhcnNlTmFtZShlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnMgPSBlbGVtZW50Lm5zO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBqdXN0IGxvY2FsIG5hbWUgZm9yIGluaGVyaXRlZCBhdHRyaWJ1dGVzXG4gICAgaWYgKGVsZW1lbnQuaW5oZXJpdGVkKSB7XG4gICAgICByZXR1cm4geyBsb2NhbE5hbWU6IG5zLmxvY2FsTmFtZSB9O1xuICAgIH1cblxuICAgIC8vIHBhcnNlICsgbG9nIGVmZmVjdGl2ZSBuc1xuICAgIHZhciBlZmZlY3RpdmVOcyA9IHRoaXMubG9nTmFtZXNwYWNlVXNlZChucyk7XG5cbiAgICAvLyBMT0cgQUNUVUFMIG5hbWVzcGFjZSB1c2VcbiAgICB0aGlzLmdldE5hbWVzcGFjZXMoKS5sb2dVc2VkKGVmZmVjdGl2ZU5zKTtcblxuICAgIC8vIHN0cmlwIHByZWZpeCBpZiBzYW1lIG5hbWVzcGFjZSBsaWtlIHBhcmVudFxuICAgIGlmICh0aGlzLmlzTG9jYWxOcyhlZmZlY3RpdmVOcykpIHtcbiAgICAgIHJldHVybiB7IGxvY2FsTmFtZTogbnMubG9jYWxOYW1lIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhc3NpZ24kMSh7IGxvY2FsTmFtZTogbnMubG9jYWxOYW1lIH0sIGVmZmVjdGl2ZU5zKTtcbiAgICB9XG4gIH07XG5cbiAgRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLnBhcnNlR2VuZXJpY05zQXR0cmlidXRlcyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhlbGVtZW50KS5maWx0ZXIoXG4gICAgICAoWyBrZXksIHZhbHVlIF0pID0+ICFrZXkuc3RhcnRzV2l0aCgnJCcpICYmIHRoaXMucGFyc2VOc0F0dHJpYnV0ZShlbGVtZW50LCBrZXksIHZhbHVlKVxuICAgICkubWFwKFxuICAgICAgKFsga2V5LCB2YWx1ZSBdKSA9PiAoeyBuYW1lOiBrZXksIHZhbHVlOiB2YWx1ZSB9KVxuICAgICk7XG4gIH07XG5cbiAgRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLnBhcnNlR2VuZXJpY0NvbnRhaW5tZW50cyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB2YXIgYm9keSA9IGVsZW1lbnQuJGJvZHk7XG5cbiAgICBpZiAoYm9keSkge1xuICAgICAgdGhpcy5ib2R5LnB1c2gobmV3IEJvZHlTZXJpYWxpemVyKCkuYnVpbGQoeyB0eXBlOiAnU3RyaW5nJyB9LCBib2R5KSk7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gZWxlbWVudC4kY2hpbGRyZW47XG5cbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGZvckVhY2gkMShjaGlsZHJlbiwgY2hpbGQgPT4ge1xuICAgICAgICB0aGlzLmJvZHkucHVzaChuZXcgRWxlbWVudFNlcmlhbGl6ZXIodGhpcykuYnVpbGQoY2hpbGQpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBFbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VOc0F0dHJpYnV0ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIG1vZGVsID0gZWxlbWVudC4kbW9kZWw7XG5cbiAgICB2YXIgbmFtZU5zID0gcGFyc2VOYW1lKG5hbWUpO1xuXG4gICAgdmFyIG5zO1xuXG4gICAgLy8gcGFyc2UgeG1sbnM6Zm9vPVwiaHR0cDovL2Zvby5iYXJcIlxuICAgIGlmIChuYW1lTnMucHJlZml4ID09PSAneG1sbnMnKSB7XG4gICAgICBucyA9IHsgcHJlZml4OiBuYW1lTnMubG9jYWxOYW1lLCB1cmk6IHZhbHVlIH07XG4gICAgfVxuXG4gICAgLy8gcGFyc2UgeG1sbnM9XCJodHRwOi8vZm9vLmJhclwiXG4gICAgaWYgKCFuYW1lTnMucHJlZml4ICYmIG5hbWVOcy5sb2NhbE5hbWUgPT09ICd4bWxucycpIHtcbiAgICAgIG5zID0geyB1cmk6IHZhbHVlIH07XG4gICAgfVxuXG4gICAgaWYgKCFucykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChtb2RlbCAmJiBtb2RlbC5nZXRQYWNrYWdlKHZhbHVlKSkge1xuXG4gICAgICAvLyByZWdpc3RlciB3ZWxsIGtub3duIG5hbWVzcGFjZVxuICAgICAgdGhpcy5sb2dOYW1lc3BhY2UobnMsIHRydWUsIHRydWUpO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIGxvZyBjdXN0b20gbmFtZXNwYWNlIGRpcmVjdGx5IGFzIHVzZWRcbiAgICAgIHZhciBhY3R1YWxOcyA9IHRoaXMubG9nTmFtZXNwYWNlVXNlZChucywgdHJ1ZSk7XG5cbiAgICAgIHRoaXMuZ2V0TmFtZXNwYWNlcygpLmxvZ1VzZWQoYWN0dWFsTnMpO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBQYXJzZSBuYW1lc3BhY2VzIGFuZCByZXR1cm4gYSBsaXN0IG9mIGxlZnQgb3ZlciBnZW5lcmljIGF0dHJpYnV0ZXNcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBlbGVtZW50XG4gICAqIEByZXR1cm4ge0FycmF5PE9iamVjdD59XG4gICAqL1xuICBFbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VOc0F0dHJpYnV0ZXMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIGdlbmVyaWNBdHRycyA9IGVsZW1lbnQuJGF0dHJzO1xuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBbXTtcblxuICAgIC8vIHBhcnNlIG5hbWVzcGFjZSBhdHRyaWJ1dGVzIGZpcnN0XG4gICAgLy8gYW5kIGxvZyB0aGVtLiBwdXNoIG5vbiBuYW1lc3BhY2UgYXR0cmlidXRlcyB0byBhIGxpc3RcbiAgICAvLyBhbmQgcHJvY2VzcyB0aGVtIGxhdGVyXG4gICAgZm9yRWFjaCQxKGdlbmVyaWNBdHRycywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblxuICAgICAgdmFyIG5vbk5zQXR0ciA9IHNlbGYucGFyc2VOc0F0dHJpYnV0ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG5cbiAgICAgIGlmIChub25Oc0F0dHIpIHtcbiAgICAgICAgYXR0cmlidXRlcy5wdXNoKG5vbk5zQXR0cik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfTtcblxuICBFbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VHZW5lcmljQXR0cmlidXRlcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZvckVhY2gkMShhdHRyaWJ1dGVzLCBmdW5jdGlvbihhdHRyKSB7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYuYWRkQXR0cmlidXRlKHNlbGYubnNBdHRyaWJ1dGVOYW1lKGF0dHIubmFtZSksIGF0dHIudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBtaXNzaW5nIG5hbWVzcGFjZSBpbmZvcm1hdGlvbiBmb3IgPCR7XG4gICAgICAgICAgYXR0ci5uYW1lXG4gICAgICAgIH09JHsgYXR0ci52YWx1ZSB9PiBvbmAsIGVsZW1lbnQsIGVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBFbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VDb250YWlubWVudHMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGJvZHkgPSB0aGlzLmJvZHksXG4gICAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cbiAgICBmb3JFYWNoJDEocHJvcGVydGllcywgZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIHZhbHVlID0gZWxlbWVudC5nZXQocC5uYW1lKSxcbiAgICAgICAgICBpc1JlZmVyZW5jZSA9IHAuaXNSZWZlcmVuY2UsXG4gICAgICAgICAgaXNNYW55ID0gcC5pc01hbnk7XG5cbiAgICAgIGlmICghaXNNYW55KSB7XG4gICAgICAgIHZhbHVlID0gWyB2YWx1ZSBdO1xuICAgICAgfVxuXG4gICAgICBpZiAocC5pc0JvZHkpIHtcbiAgICAgICAgYm9keS5wdXNoKG5ldyBCb2R5U2VyaWFsaXplcigpLmJ1aWxkKHAsIHZhbHVlWzBdKSk7XG4gICAgICB9IGVsc2UgaWYgKGlzU2ltcGxlKHAudHlwZSkpIHtcbiAgICAgICAgZm9yRWFjaCQxKHZhbHVlLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgYm9keS5wdXNoKG5ldyBWYWx1ZVNlcmlhbGl6ZXIoc2VsZi5hZGRUYWdOYW1lKHNlbGYubnNQcm9wZXJ0eVRhZ05hbWUocCkpKS5idWlsZChwLCB2KSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc1JlZmVyZW5jZSkge1xuICAgICAgICBmb3JFYWNoJDEodmFsdWUsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICBib2R5LnB1c2gobmV3IFJlZmVyZW5jZVNlcmlhbGl6ZXIoc2VsZi5hZGRUYWdOYW1lKHNlbGYubnNQcm9wZXJ0eVRhZ05hbWUocCkpKS5idWlsZCh2KSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBhbGxvdyBzZXJpYWxpemF0aW9uIHZpYSB0eXBlXG4gICAgICAgIC8vIHJhdGhlciB0aGFuIGVsZW1lbnQgbmFtZVxuICAgICAgICB2YXIgc2VyaWFsaXphdGlvbiA9IGdldFNlcmlhbGl6YXRpb24ocCk7XG5cbiAgICAgICAgZm9yRWFjaCQxKHZhbHVlLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdmFyIHNlcmlhbGl6ZXI7XG5cbiAgICAgICAgICBpZiAoc2VyaWFsaXphdGlvbikge1xuICAgICAgICAgICAgaWYgKHNlcmlhbGl6YXRpb24gPT09IFNFUklBTElaRV9QUk9QRVJUWSkge1xuICAgICAgICAgICAgICBzZXJpYWxpemVyID0gbmV3IEVsZW1lbnRTZXJpYWxpemVyKHNlbGYsIHApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VyaWFsaXplciA9IG5ldyBUeXBlU2VyaWFsaXplcihzZWxmLCBwLCBzZXJpYWxpemF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VyaWFsaXplciA9IG5ldyBFbGVtZW50U2VyaWFsaXplcihzZWxmKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBib2R5LnB1c2goc2VyaWFsaXplci5idWlsZCh2KSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIEVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5nZXROYW1lc3BhY2VzID0gZnVuY3Rpb24obG9jYWwpIHtcblxuICAgIHZhciBuYW1lc3BhY2VzID0gdGhpcy5uYW1lc3BhY2VzLFxuICAgICAgICBwYXJlbnQgPSB0aGlzLnBhcmVudCxcbiAgICAgICAgcGFyZW50TmFtZXNwYWNlcztcblxuICAgIGlmICghbmFtZXNwYWNlcykge1xuICAgICAgcGFyZW50TmFtZXNwYWNlcyA9IHBhcmVudCAmJiBwYXJlbnQuZ2V0TmFtZXNwYWNlcygpO1xuXG4gICAgICBpZiAobG9jYWwgfHwgIXBhcmVudE5hbWVzcGFjZXMpIHtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcyA9IG5ldyBOYW1lc3BhY2VzKHBhcmVudE5hbWVzcGFjZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZXNwYWNlcyA9IHBhcmVudE5hbWVzcGFjZXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWVzcGFjZXM7XG4gIH07XG5cbiAgRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLmxvZ05hbWVzcGFjZSA9IGZ1bmN0aW9uKG5zLCB3ZWxsa25vd24sIGxvY2FsKSB7XG4gICAgdmFyIG5hbWVzcGFjZXMgPSB0aGlzLmdldE5hbWVzcGFjZXMobG9jYWwpO1xuXG4gICAgdmFyIG5zVXJpID0gbnMudXJpLFxuICAgICAgICBuc1ByZWZpeCA9IG5zLnByZWZpeDtcblxuICAgIHZhciBleGlzdGluZyA9IG5hbWVzcGFjZXMuYnlVcmkobnNVcmkpO1xuXG4gICAgaWYgKCFleGlzdGluZyB8fCBsb2NhbCkge1xuICAgICAgbmFtZXNwYWNlcy5hZGQobnMsIHdlbGxrbm93bik7XG4gICAgfVxuXG4gICAgbmFtZXNwYWNlcy5tYXBQcmVmaXgobnNQcmVmaXgsIG5zVXJpKTtcblxuICAgIHJldHVybiBucztcbiAgfTtcblxuICBFbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUubG9nTmFtZXNwYWNlVXNlZCA9IGZ1bmN0aW9uKG5zLCBsb2NhbCkge1xuICAgIHZhciBuYW1lc3BhY2VzID0gdGhpcy5nZXROYW1lc3BhY2VzKGxvY2FsKTtcblxuICAgIC8vIG5zIG1heSBiZVxuICAgIC8vXG4gICAgLy8gICAqIHByZWZpeCBvbmx5XG4gICAgLy8gICAqIHByZWZpeDp1cmlcbiAgICAvLyAgICogbG9jYWxOYW1lIG9ubHlcblxuICAgIHZhciBwcmVmaXggPSBucy5wcmVmaXgsXG4gICAgICAgIHVyaSA9IG5zLnVyaSxcbiAgICAgICAgbmV3UHJlZml4LCBpZHgsXG4gICAgICAgIHdlbGxrbm93blVyaTtcblxuICAgIC8vIGhhbmRsZSBhbm9ueW1vdXMgbmFtZXNwYWNlcyAoZWxlbWVudEZvcm09dW5xdWFsaWZpZWQpLCBjZi4gIzIzXG4gICAgaWYgKCFwcmVmaXggJiYgIXVyaSkge1xuICAgICAgcmV0dXJuIHsgbG9jYWxOYW1lOiBucy5sb2NhbE5hbWUgfTtcbiAgICB9XG5cbiAgICB3ZWxsa25vd25VcmkgPSBuYW1lc3BhY2VzLmRlZmF1bHRVcmlCeVByZWZpeChwcmVmaXgpO1xuXG4gICAgdXJpID0gdXJpIHx8IHdlbGxrbm93blVyaSB8fCBuYW1lc3BhY2VzLnVyaUJ5UHJlZml4KHByZWZpeCk7XG5cbiAgICBpZiAoIXVyaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBuYW1lc3BhY2UgdXJpIGdpdmVuIGZvciBwcmVmaXggPCcgKyBwcmVmaXggKyAnPicpO1xuICAgIH1cblxuICAgIG5zID0gbmFtZXNwYWNlcy5ieVVyaSh1cmkpO1xuXG4gICAgLy8gcmVnaXN0ZXIgbmV3IGRlZmF1bHQgcHJlZml4IDx4bWxucz4gaW4gbG9jYWwgc2NvcGVcbiAgICBpZiAoIW5zICYmICFwcmVmaXgpIHtcbiAgICAgIG5zID0gdGhpcy5sb2dOYW1lc3BhY2UoeyB1cmkgfSwgd2VsbGtub3duVXJpID09PSB1cmksIHRydWUpO1xuICAgIH1cblxuICAgIGlmICghbnMpIHtcbiAgICAgIG5ld1ByZWZpeCA9IHByZWZpeDtcbiAgICAgIGlkeCA9IDE7XG5cbiAgICAgIC8vIGZpbmQgYSBwcmVmaXggdGhhdCBpcyBub3QgbWFwcGVkIHlldFxuICAgICAgd2hpbGUgKG5hbWVzcGFjZXMudXJpQnlQcmVmaXgobmV3UHJlZml4KSkge1xuICAgICAgICBuZXdQcmVmaXggPSBwcmVmaXggKyAnXycgKyBpZHgrKztcbiAgICAgIH1cblxuICAgICAgbnMgPSB0aGlzLmxvZ05hbWVzcGFjZSh7IHByZWZpeDogbmV3UHJlZml4LCB1cmk6IHVyaSB9LCB3ZWxsa25vd25VcmkgPT09IHVyaSk7XG4gICAgfVxuXG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgbmFtZXNwYWNlcy5tYXBQcmVmaXgocHJlZml4LCB1cmkpO1xuICAgIH1cblxuICAgIHJldHVybiBucztcbiAgfTtcblxuICBFbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICAgIGZvckVhY2gkMShwcm9wZXJ0aWVzLCBmdW5jdGlvbihwKSB7XG5cbiAgICAgIHZhciB2YWx1ZSA9IGVsZW1lbnQuZ2V0KHAubmFtZSk7XG5cbiAgICAgIGlmIChwLmlzUmVmZXJlbmNlKSB7XG5cbiAgICAgICAgaWYgKCFwLmlzTWFueSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUuaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICAgIGZvckVhY2gkMSh2YWx1ZSwgZnVuY3Rpb24odikge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godi5pZCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBJRFJFRlMgaXMgYSB3aGl0ZXNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIHJlZmVyZW5jZXMuXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuam9pbignICcpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgc2VsZi5hZGRBdHRyaWJ1dGUoc2VsZi5uc0F0dHJpYnV0ZU5hbWUocCksIHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICBFbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuYWRkVGFnTmFtZSA9IGZ1bmN0aW9uKG5zVGFnTmFtZSkge1xuICAgIHZhciBhY3R1YWxOcyA9IHRoaXMubG9nTmFtZXNwYWNlVXNlZChuc1RhZ05hbWUpO1xuXG4gICAgdGhpcy5nZXROYW1lc3BhY2VzKCkubG9nVXNlZChhY3R1YWxOcyk7XG5cbiAgICByZXR1cm4gbnNOYW1lKG5zVGFnTmFtZSk7XG4gIH07XG5cbiAgRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5hdHRycztcblxuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gZXNjYXBlQXR0cih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gZGUtZHVwbGljYXRlIGF0dHJpYnV0ZXNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYnBtbi1pby9tb2RkbGUteG1sL2lzc3Vlcy82NlxuICAgIHZhciBpZHggPSBmaW5kSW5kZXgoYXR0cnMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGVsZW1lbnQubmFtZS5sb2NhbE5hbWUgPT09IG5hbWUubG9jYWxOYW1lICYmXG4gICAgICAgIGVsZW1lbnQubmFtZS51cmkgPT09IG5hbWUudXJpICYmXG4gICAgICAgIGVsZW1lbnQubmFtZS5wcmVmaXggPT09IG5hbWUucHJlZml4XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdmFyIGF0dHIgPSB7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9O1xuXG4gICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgIGF0dHJzLnNwbGljZShpZHgsIDEsIGF0dHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRycy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfTtcblxuICBFbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplQXR0cmlidXRlcyA9IGZ1bmN0aW9uKHdyaXRlcikge1xuICAgIHZhciBhdHRycyA9IHRoaXMuYXR0cnMsXG4gICAgICAgIG5hbWVzcGFjZXMgPSB0aGlzLm5hbWVzcGFjZXM7XG5cbiAgICBpZiAobmFtZXNwYWNlcykge1xuICAgICAgYXR0cnMgPSBnZXROc0F0dHJzKG5hbWVzcGFjZXMpLmNvbmNhdChhdHRycyk7XG4gICAgfVxuXG4gICAgZm9yRWFjaCQxKGF0dHJzLCBmdW5jdGlvbihhKSB7XG4gICAgICB3cml0ZXJcbiAgICAgICAgLmFwcGVuZCgnICcpXG4gICAgICAgIC5hcHBlbmQobnNOYW1lKGEubmFtZSkpLmFwcGVuZCgnPVwiJykuYXBwZW5kKGEudmFsdWUpLmFwcGVuZCgnXCInKTtcbiAgICB9KTtcbiAgfTtcblxuICBFbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplVG8gPSBmdW5jdGlvbih3cml0ZXIpIHtcbiAgICB2YXIgZmlyc3RCb2R5ID0gdGhpcy5ib2R5WzBdLFxuICAgICAgICBpbmRlbnQgPSBmaXJzdEJvZHkgJiYgZmlyc3RCb2R5LmNvbnN0cnVjdG9yICE9PSBCb2R5U2VyaWFsaXplcjtcblxuICAgIHdyaXRlclxuICAgICAgLmFwcGVuZEluZGVudCgpXG4gICAgICAuYXBwZW5kKCc8JyArIHRoaXMudGFnTmFtZSk7XG5cbiAgICB0aGlzLnNlcmlhbGl6ZUF0dHJpYnV0ZXMod3JpdGVyKTtcblxuICAgIHdyaXRlci5hcHBlbmQoZmlyc3RCb2R5ID8gJz4nIDogJyAvPicpO1xuXG4gICAgaWYgKGZpcnN0Qm9keSkge1xuXG4gICAgICBpZiAoaW5kZW50KSB7XG4gICAgICAgIHdyaXRlclxuICAgICAgICAgIC5hcHBlbmROZXdMaW5lKClcbiAgICAgICAgICAuaW5kZW50KCk7XG4gICAgICB9XG5cbiAgICAgIGZvckVhY2gkMSh0aGlzLmJvZHksIGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgYi5zZXJpYWxpemVUbyh3cml0ZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbmRlbnQpIHtcbiAgICAgICAgd3JpdGVyXG4gICAgICAgICAgLnVuaW5kZW50KClcbiAgICAgICAgICAuYXBwZW5kSW5kZW50KCk7XG4gICAgICB9XG5cbiAgICAgIHdyaXRlci5hcHBlbmQoJzwvJyArIHRoaXMudGFnTmFtZSArICc+Jyk7XG4gICAgfVxuXG4gICAgd3JpdGVyLmFwcGVuZE5ld0xpbmUoKTtcbiAgfTtcblxuICAvKipcbiAgICogQSBzZXJpYWxpemVyIGZvciB0eXBlcyB0aGF0IGhhbmRsZXMgc2VyaWFsaXphdGlvbiBvZiBkYXRhIHR5cGVzXG4gICAqL1xuICBmdW5jdGlvbiBUeXBlU2VyaWFsaXplcihwYXJlbnQsIHByb3BlcnR5RGVzY3JpcHRvciwgc2VyaWFsaXphdGlvbikge1xuICAgIEVsZW1lbnRTZXJpYWxpemVyLmNhbGwodGhpcywgcGFyZW50LCBwcm9wZXJ0eURlc2NyaXB0b3IpO1xuXG4gICAgdGhpcy5zZXJpYWxpemF0aW9uID0gc2VyaWFsaXphdGlvbjtcbiAgfVxuXG4gIGluaGVyaXRzKFR5cGVTZXJpYWxpemVyLCBFbGVtZW50U2VyaWFsaXplcik7XG5cbiAgVHlwZVNlcmlhbGl6ZXIucHJvdG90eXBlLnBhcnNlTnNBdHRyaWJ1dGVzID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gICAgLy8gZXh0cmFjdGVkIGF0dHJpYnV0ZXMgd2l0aCBzZXJpYWxpemF0aW9uIGF0dHJpYnV0ZVxuICAgIC8vIDx0eXBlPXR5cGVOYW1lPiBzdHJpcHBlZDsgaXQgbWF5IGJlIGxhdGVyXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBFbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VOc0F0dHJpYnV0ZXMuY2FsbCh0aGlzLCBlbGVtZW50KS5maWx0ZXIoXG4gICAgICBhdHRyID0+IGF0dHIubmFtZSAhPT0gdGhpcy5zZXJpYWxpemF0aW9uXG4gICAgKTtcblxuICAgIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC4kZGVzY3JpcHRvcjtcblxuICAgIC8vIG9ubHkgc2VyaWFsaXplIDx0eXBlPXR5cGVOYW1lPiBpZiBuZWNlc3NhcnlcbiAgICBpZiAoZGVzY3JpcHRvci5uYW1lID09PSB0aGlzLnByb3BlcnR5RGVzY3JpcHRvci50eXBlKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9XG5cbiAgICB2YXIgdHlwZU5zID0gdGhpcy50eXBlTnMgPSB0aGlzLm5zVGFnTmFtZShkZXNjcmlwdG9yKTtcbiAgICB0aGlzLmdldE5hbWVzcGFjZXMoKS5sb2dVc2VkKHRoaXMudHlwZU5zKTtcblxuICAgIC8vIGFkZCB4c2k6dHlwZSBhdHRyaWJ1dGUgdG8gcmVwcmVzZW50IHRoZSBlbGVtZW50c1xuICAgIC8vIGFjdHVhbCB0eXBlXG5cbiAgICB2YXIgcGtnID0gZWxlbWVudC4kbW9kZWwuZ2V0UGFja2FnZSh0eXBlTnMudXJpKSxcbiAgICAgICAgdHlwZVByZWZpeCA9IChwa2cueG1sICYmIHBrZy54bWwudHlwZVByZWZpeCkgfHwgJyc7XG5cbiAgICB0aGlzLmFkZEF0dHJpYnV0ZShcbiAgICAgIHRoaXMubnNBdHRyaWJ1dGVOYW1lKHRoaXMuc2VyaWFsaXphdGlvbiksXG4gICAgICAodHlwZU5zLnByZWZpeCA/IHR5cGVOcy5wcmVmaXggKyAnOicgOiAnJykgKyB0eXBlUHJlZml4ICsgZGVzY3JpcHRvci5ucy5sb2NhbE5hbWVcbiAgICApO1xuXG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH07XG5cbiAgVHlwZVNlcmlhbGl6ZXIucHJvdG90eXBlLmlzTG9jYWxOcyA9IGZ1bmN0aW9uKG5zKSB7XG4gICAgcmV0dXJuIG5zLnVyaSA9PT0gKHRoaXMudHlwZU5zIHx8IHRoaXMubnMpLnVyaTtcbiAgfTtcblxuICBmdW5jdGlvbiBTYXZpbmdXcml0ZXIoKSB7XG4gICAgdGhpcy52YWx1ZSA9ICcnO1xuXG4gICAgdGhpcy53cml0ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgdGhpcy52YWx1ZSArPSBzdHI7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEZvcm1hdGluZ1dyaXRlcihvdXQsIGZvcm1hdCkge1xuXG4gICAgdmFyIGluZGVudCA9IFsgJycgXTtcblxuICAgIHRoaXMuYXBwZW5kID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICBvdXQud3JpdGUoc3RyKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuYXBwZW5kTmV3TGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGZvcm1hdCkge1xuICAgICAgICBvdXQud3JpdGUoJ1xcbicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5hcHBlbmRJbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgb3V0LndyaXRlKGluZGVudC5qb2luKCcgICcpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpbmRlbnQucHVzaCgnJyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy51bmluZGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaW5kZW50LnBvcCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHdyaXRlciBmb3IgbWV0YS1tb2RlbCBiYWNrZWQgZG9jdW1lbnQgdHJlZXNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3V0cHV0IG9wdGlvbnMgdG8gcGFzcyBpbnRvIHRoZSB3cml0ZXJcbiAgICovXG4gIGZ1bmN0aW9uIFdyaXRlcihvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gYXNzaWduJDEoeyBmb3JtYXQ6IGZhbHNlLCBwcmVhbWJsZTogdHJ1ZSB9LCBvcHRpb25zIHx8IHt9KTtcblxuICAgIGZ1bmN0aW9uIHRvWE1MKHRyZWUsIHdyaXRlcikge1xuICAgICAgdmFyIGludGVybmFsV3JpdGVyID0gd3JpdGVyIHx8IG5ldyBTYXZpbmdXcml0ZXIoKTtcbiAgICAgIHZhciBmb3JtYXRpbmdXcml0ZXIgPSBuZXcgRm9ybWF0aW5nV3JpdGVyKGludGVybmFsV3JpdGVyLCBvcHRpb25zLmZvcm1hdCk7XG5cbiAgICAgIGlmIChvcHRpb25zLnByZWFtYmxlKSB7XG4gICAgICAgIGZvcm1hdGluZ1dyaXRlci5hcHBlbmQoWE1MX1BSRUFNQkxFKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlcmlhbGl6ZXIgPSBuZXcgRWxlbWVudFNlcmlhbGl6ZXIoKTtcblxuICAgICAgdmFyIG1vZGVsID0gdHJlZS4kbW9kZWw7XG5cbiAgICAgIHNlcmlhbGl6ZXIuZ2V0TmFtZXNwYWNlcygpLm1hcERlZmF1bHRQcmVmaXhlcyhnZXREZWZhdWx0UHJlZml4TWFwcGluZ3MobW9kZWwpKTtcblxuICAgICAgc2VyaWFsaXplci5idWlsZCh0cmVlKS5zZXJpYWxpemVUbyhmb3JtYXRpbmdXcml0ZXIpO1xuXG4gICAgICBpZiAoIXdyaXRlcikge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxXcml0ZXIudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvWE1MOiB0b1hNTFxuICAgIH07XG4gIH1cblxuXG4gIC8vIGhlbHBlcnMgLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogQHBhcmFtIHtNb2RkbGV9IG1vZGVsXG4gICAqXG4gICAqIEByZXR1cm4geyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IH0gbWFwIGZyb20gcHJlZml4IHRvIFVSSVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0RGVmYXVsdFByZWZpeE1hcHBpbmdzKG1vZGVsKSB7XG5cbiAgICBjb25zdCBuc01hcCA9IG1vZGVsLmNvbmZpZyAmJiBtb2RlbC5jb25maWcubnNNYXAgfHwge307XG5cbiAgICBjb25zdCBwcmVmaXhNYXAgPSB7fTtcblxuICAgIC8vIHsgcHJlZml4IC0+IHVyaSB9XG4gICAgZm9yIChjb25zdCBwcmVmaXggaW4gREVGQVVMVF9OU19NQVApIHtcbiAgICAgIHByZWZpeE1hcFtwcmVmaXhdID0gREVGQVVMVF9OU19NQVBbcHJlZml4XTtcbiAgICB9XG5cbiAgICAvLyB7IHVyaSAtPiBwcmVmaXggfVxuICAgIGZvciAoY29uc3QgdXJpIGluIG5zTWFwKSB7XG4gICAgICBjb25zdCBwcmVmaXggPSBuc01hcFt1cmldO1xuXG4gICAgICBwcmVmaXhNYXBbcHJlZml4XSA9IHVyaTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHBrZyBvZiBtb2RlbC5nZXRQYWNrYWdlcygpKSB7XG4gICAgICBwcmVmaXhNYXBbcGtnLnByZWZpeF0gPSBwa2cudXJpO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVmaXhNYXA7XG4gIH1cblxuICAvKipcclxuICAgKiBBIHN1YiBjbGFzcyBvZiB7QGxpbmsgTW9kZGxlfSB3aXRoIHN1cHBvcnQgZm9yIGltcG9ydCBhbmQgZXhwb3J0IG9mIEJQTU4gMi4wIHhtbCBmaWxlcy5cclxuICAgKlxyXG4gICAqIEBjbGFzcyBCcG1uTW9kZGxlXHJcbiAgICogQGV4dGVuZHMgTW9kZGxlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gcGFja2FnZXMgdG8gdXNlIGZvciBpbnN0YW50aWF0aW5nIHRoZSBtb2RlbFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gYWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3Mgb3ZlclxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIEJwbW5Nb2RkbGUocGFja2FnZXMsIG9wdGlvbnMpIHtcclxuICAgIE1vZGRsZS5jYWxsKHRoaXMsIHBhY2thZ2VzLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIEJwbW5Nb2RkbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNb2RkbGUucHJvdG90eXBlKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGZyb21YTUwgcmVzdWx0LlxyXG4gICAqXHJcbiAgICogQHR5cGVkZWYge09iamVjdH0gUGFyc2VSZXN1bHRcclxuICAgKlxyXG4gICAqIEBwcm9wZXJ0eSB7TW9kZGxlRWxlbWVudH0gcm9vdEVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkge0FycmF5PE9iamVjdD59IHJlZmVyZW5jZXNcclxuICAgKiBAcHJvcGVydHkge0FycmF5PEVycm9yPn0gd2FybmluZ3NcclxuICAgKiBAcHJvcGVydHkge09iamVjdH0gZWxlbWVudHNCeUlkIC0gYSBtYXBwaW5nIGNvbnRhaW5pbmcgZWFjaCBJRCAtPiBNb2RkbGVFbGVtZW50XHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBmcm9tWE1MIGVycm9yLlxyXG4gICAqXHJcbiAgICogQHR5cGVkZWYge0Vycm9yfSBQYXJzZUVycm9yXHJcbiAgICpcclxuICAgKiBAcHJvcGVydHkge0FycmF5PEVycm9yPn0gd2FybmluZ3NcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogSW5zdGFudGlhdGVzIGEgQlBNTiBtb2RlbCB0cmVlIGZyb20gYSBnaXZlbiB4bWwgc3RyaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9ICAgeG1sU3RyXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9ICAgW3R5cGVOYW1lPSdicG1uOkRlZmluaXRpb25zJ10gbmFtZSBvZiB0aGUgcm9vdCBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtPYmplY3R9ICAgW29wdGlvbnNdICBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHVuZGVybHlpbmcgcmVhZGVyXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQYXJzZVJlc3VsdCwgUGFyc2VFcnJvcj59XHJcbiAgICovXHJcbiAgQnBtbk1vZGRsZS5wcm90b3R5cGUuZnJvbVhNTCA9IGZ1bmN0aW9uKHhtbFN0ciwgdHlwZU5hbWUsIG9wdGlvbnMpIHtcclxuXHJcbiAgICBpZiAoIWlzU3RyaW5nKHR5cGVOYW1lKSkge1xyXG4gICAgICBvcHRpb25zID0gdHlwZU5hbWU7XHJcbiAgICAgIHR5cGVOYW1lID0gJ2JwbW46RGVmaW5pdGlvbnMnO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZWFkZXIgPSBuZXcgUmVhZGVyKGFzc2lnbiQxKHsgbW9kZWw6IHRoaXMsIGxheDogdHJ1ZSB9LCBvcHRpb25zKSk7XHJcbiAgICB2YXIgcm9vdEhhbmRsZXIgPSByZWFkZXIuaGFuZGxlcih0eXBlTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIHJlYWRlci5mcm9tWE1MKHhtbFN0ciwgcm9vdEhhbmRsZXIpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKipcclxuICAgKiBUaGUgdG9YTUwgcmVzdWx0LlxyXG4gICAqXHJcbiAgICogQHR5cGVkZWYge09iamVjdH0gU2VyaWFsaXphdGlvblJlc3VsdFxyXG4gICAqXHJcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHhtbFxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBTZXJpYWxpemVzIGEgQlBNTiAyLjAgb2JqZWN0IHRyZWUgdG8gWE1MLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9ICAgZWxlbWVudCAgICB0aGUgcm9vdCBlbGVtZW50LCB0eXBpY2FsbHkgYW4gaW5zdGFuY2Ugb2YgYGJwbW46RGVmaW5pdGlvbnNgXHJcbiAgICogQHBhcmFtIHtPYmplY3R9ICAgW29wdGlvbnNdICB0byBwYXNzIHRvIHRoZSB1bmRlcmx5aW5nIHdyaXRlclxyXG4gICAqXHJcbiAgICogQHJldHVybnMge1Byb21pc2U8U2VyaWFsaXphdGlvblJlc3VsdCwgRXJyb3I+fVxyXG4gICAqL1xyXG4gIEJwbW5Nb2RkbGUucHJvdG90eXBlLnRvWE1MID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xyXG5cclxuICAgIHZhciB3cml0ZXIgPSBuZXcgV3JpdGVyKG9wdGlvbnMpO1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gd3JpdGVyLnRvWE1MKGVsZW1lbnQpO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzb2x2ZSh7XHJcbiAgICAgICAgICB4bWw6IHJlc3VsdFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XG5cbiAgdmFyIG5hbWUkNSA9IFwiQlBNTjIwXCI7XG4gIHZhciB1cmkkNSA9IFwiaHR0cDovL3d3dy5vbWcub3JnL3NwZWMvQlBNTi8yMDEwMDUyNC9NT0RFTFwiO1xuICB2YXIgcHJlZml4JDUgPSBcImJwbW5cIjtcbiAgdmFyIGFzc29jaWF0aW9ucyQ1ID0gW1xuICBdO1xuICB2YXIgdHlwZXMkNSA9IFtcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkludGVyZmFjZVwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIlJvb3RFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJvcGVyYXRpb25zXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJPcGVyYXRpb25cIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaW1wbGVtZW50YXRpb25SZWZcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIk9wZXJhdGlvblwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkJhc2VFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpbk1lc3NhZ2VSZWZcIixcbiAgXHRcdFx0XHR0eXBlOiBcIk1lc3NhZ2VcIixcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJvdXRNZXNzYWdlUmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJNZXNzYWdlXCIsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZXJyb3JSZWZcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkVycm9yXCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImltcGxlbWVudGF0aW9uUmVmXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJFbmRQb2ludFwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIlJvb3RFbGVtZW50XCJcbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiQXVkaXRpbmdcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJCYXNlRWxlbWVudFwiXG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkdsb2JhbFRhc2tcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJDYWxsYWJsZUVsZW1lbnRcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwicmVzb3VyY2VzXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJSZXNvdXJjZVJvbGVcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJNb25pdG9yaW5nXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJQZXJmb3JtZXJcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJSZXNvdXJjZVJvbGVcIlxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJQcm9jZXNzXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiRmxvd0VsZW1lbnRzQ29udGFpbmVyXCIsXG4gIFx0XHRcdFwiQ2FsbGFibGVFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInByb2Nlc3NUeXBlXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJQcm9jZXNzVHlwZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpc0Nsb3NlZFwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJhdWRpdGluZ1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiQXVkaXRpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJtb25pdG9yaW5nXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJNb25pdG9yaW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwicHJvcGVydGllc1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiUHJvcGVydHlcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibGFuZVNldHNcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0cmVwbGFjZXM6IFwiRmxvd0VsZW1lbnRzQ29udGFpbmVyI2xhbmVTZXRzXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJMYW5lU2V0XCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZmxvd0VsZW1lbnRzXCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlLFxuICBcdFx0XHRcdHJlcGxhY2VzOiBcIkZsb3dFbGVtZW50c0NvbnRhaW5lciNmbG93RWxlbWVudHNcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkZsb3dFbGVtZW50XCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiYXJ0aWZhY3RzXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJBcnRpZmFjdFwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJyZXNvdXJjZXNcIixcbiAgXHRcdFx0XHR0eXBlOiBcIlJlc291cmNlUm9sZVwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJjb3JyZWxhdGlvblN1YnNjcmlwdGlvbnNcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkNvcnJlbGF0aW9uU3Vic2NyaXB0aW9uXCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInN1cHBvcnRzXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJQcm9jZXNzXCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImRlZmluaXRpb25hbENvbGxhYm9yYXRpb25SZWZcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkNvbGxhYm9yYXRpb25cIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaXNFeGVjdXRhYmxlXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiTGFuZVNldFwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkJhc2VFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImxhbmVzXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJMYW5lXCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkxhbmVcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJCYXNlRWxlbWVudFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwicGFydGl0aW9uRWxlbWVudFJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiQmFzZUVsZW1lbnRcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwicGFydGl0aW9uRWxlbWVudFwiLFxuICBcdFx0XHRcdHR5cGU6IFwiQmFzZUVsZW1lbnRcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJmbG93Tm9kZVJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRmxvd05vZGVcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiY2hpbGRMYW5lU2V0XCIsXG4gIFx0XHRcdFx0dHlwZTogXCJMYW5lU2V0XCIsXG4gIFx0XHRcdFx0eG1sOiB7XG4gIFx0XHRcdFx0XHRzZXJpYWxpemU6IFwieHNpOnR5cGVcIlxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJHbG9iYWxNYW51YWxUYXNrXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiR2xvYmFsVGFza1wiXG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIk1hbnVhbFRhc2tcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJUYXNrXCJcbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiVXNlclRhc2tcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJUYXNrXCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInJlbmRlcmluZ3NcIixcbiAgXHRcdFx0XHR0eXBlOiBcIlJlbmRlcmluZ1wiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpbXBsZW1lbnRhdGlvblwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiUmVuZGVyaW5nXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJIdW1hblBlcmZvcm1lclwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIlBlcmZvcm1lclwiXG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIlBvdGVudGlhbE93bmVyXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiSHVtYW5QZXJmb3JtZXJcIlxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJHbG9iYWxVc2VyVGFza1wiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkdsb2JhbFRhc2tcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaW1wbGVtZW50YXRpb25cIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJyZW5kZXJpbmdzXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJSZW5kZXJpbmdcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJHYXRld2F5XCIsXG4gIFx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkZsb3dOb2RlXCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImdhdGV3YXlEaXJlY3Rpb25cIixcbiAgXHRcdFx0XHR0eXBlOiBcIkdhdGV3YXlEaXJlY3Rpb25cIixcbiAgXHRcdFx0XHRcImRlZmF1bHRcIjogXCJVbnNwZWNpZmllZFwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkV2ZW50QmFzZWRHYXRld2F5XCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiR2F0ZXdheVwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpbnN0YW50aWF0ZVwiLFxuICBcdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZXZlbnRHYXRld2F5VHlwZVwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRXZlbnRCYXNlZEdhdGV3YXlUeXBlXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdFwiZGVmYXVsdFwiOiBcIkV4Y2x1c2l2ZVwiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiQ29tcGxleEdhdGV3YXlcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJHYXRld2F5XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImFjdGl2YXRpb25Db25kaXRpb25cIixcbiAgXHRcdFx0XHR0eXBlOiBcIkV4cHJlc3Npb25cIixcbiAgXHRcdFx0XHR4bWw6IHtcbiAgXHRcdFx0XHRcdHNlcmlhbGl6ZTogXCJ4c2k6dHlwZVwiXG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJkZWZhdWx0XCIsXG4gIFx0XHRcdFx0dHlwZTogXCJTZXF1ZW5jZUZsb3dcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJFeGNsdXNpdmVHYXRld2F5XCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiR2F0ZXdheVwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJkZWZhdWx0XCIsXG4gIFx0XHRcdFx0dHlwZTogXCJTZXF1ZW5jZUZsb3dcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJJbmNsdXNpdmVHYXRld2F5XCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiR2F0ZXdheVwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJkZWZhdWx0XCIsXG4gIFx0XHRcdFx0dHlwZTogXCJTZXF1ZW5jZUZsb3dcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJQYXJhbGxlbEdhdGV3YXlcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJHYXRld2F5XCJcbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiUm9vdEVsZW1lbnRcIixcbiAgXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJSZWxhdGlvbnNoaXBcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJCYXNlRWxlbWVudFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJ0eXBlXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZGlyZWN0aW9uXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJSZWxhdGlvbnNoaXBEaXJlY3Rpb25cIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwic291cmNlXCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiRWxlbWVudFwiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInRhcmdldFwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIkVsZW1lbnRcIlxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkJhc2VFbGVtZW50XCIsXG4gIFx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpZFwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiLFxuICBcdFx0XHRcdGlzSWQ6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZG9jdW1lbnRhdGlvblwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRhdGlvblwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJleHRlbnNpb25EZWZpbml0aW9uc1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiRXh0ZW5zaW9uRGVmaW5pdGlvblwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJleHRlbnNpb25FbGVtZW50c1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiRXh0ZW5zaW9uRWxlbWVudHNcIlxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkV4dGVuc2lvblwiLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJtdXN0VW5kZXJzdGFuZFwiLFxuICBcdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZGVmaW5pdGlvblwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRXh0ZW5zaW9uRGVmaW5pdGlvblwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkV4dGVuc2lvbkRlZmluaXRpb25cIixcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImV4dGVuc2lvbkF0dHJpYnV0ZURlZmluaXRpb25zXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJFeHRlbnNpb25BdHRyaWJ1dGVEZWZpbml0aW9uXCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiRXh0ZW5zaW9uQXR0cmlidXRlRGVmaW5pdGlvblwiLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwidHlwZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImlzUmVmZXJlbmNlXCIsXG4gIFx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJleHRlbnNpb25EZWZpbml0aW9uXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJFeHRlbnNpb25EZWZpbml0aW9uXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiRXh0ZW5zaW9uRWxlbWVudHNcIixcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwidmFsdWVSZWZcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJFbGVtZW50XCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwidmFsdWVzXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJFbGVtZW50XCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImV4dGVuc2lvbkF0dHJpYnV0ZURlZmluaXRpb25cIixcbiAgXHRcdFx0XHR0eXBlOiBcIkV4dGVuc2lvbkF0dHJpYnV0ZURlZmluaXRpb25cIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJEb2N1bWVudGF0aW9uXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwidGV4dFwiLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCIsXG4gIFx0XHRcdFx0aXNCb2R5OiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInRleHRGb3JtYXRcIixcbiAgXHRcdFx0XHRcImRlZmF1bHRcIjogXCJ0ZXh0L3BsYWluXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJFdmVudFwiLFxuICBcdFx0aXNBYnN0cmFjdDogdHJ1ZSxcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJGbG93Tm9kZVwiLFxuICBcdFx0XHRcIkludGVyYWN0aW9uTm9kZVwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJwcm9wZXJ0aWVzXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJQcm9wZXJ0eVwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkludGVybWVkaWF0ZUNhdGNoRXZlbnRcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJDYXRjaEV2ZW50XCJcbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiSW50ZXJtZWRpYXRlVGhyb3dFdmVudFwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIlRocm93RXZlbnRcIlxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJFbmRFdmVudFwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIlRocm93RXZlbnRcIlxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJTdGFydEV2ZW50XCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiQ2F0Y2hFdmVudFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpc0ludGVycnVwdGluZ1wiLFxuICBcdFx0XHRcdFwiZGVmYXVsdFwiOiB0cnVlLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIlRocm93RXZlbnRcIixcbiAgXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiRXZlbnRcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZGF0YUlucHV0c1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiRGF0YUlucHV0XCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImRhdGFJbnB1dEFzc29jaWF0aW9uc1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiRGF0YUlucHV0QXNzb2NpYXRpb25cIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaW5wdXRTZXRcIixcbiAgXHRcdFx0XHR0eXBlOiBcIklucHV0U2V0XCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZXZlbnREZWZpbml0aW9uc1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiRXZlbnREZWZpbml0aW9uXCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImV2ZW50RGVmaW5pdGlvblJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRXZlbnREZWZpbml0aW9uXCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiQ2F0Y2hFdmVudFwiLFxuICBcdFx0aXNBYnN0cmFjdDogdHJ1ZSxcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJFdmVudFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJwYXJhbGxlbE11bHRpcGxlXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiLFxuICBcdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJkYXRhT3V0cHV0c1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiRGF0YU91dHB1dFwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJkYXRhT3V0cHV0QXNzb2NpYXRpb25zXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJEYXRhT3V0cHV0QXNzb2NpYXRpb25cIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwib3V0cHV0U2V0XCIsXG4gIFx0XHRcdFx0dHlwZTogXCJPdXRwdXRTZXRcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJldmVudERlZmluaXRpb25zXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJFdmVudERlZmluaXRpb25cIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZXZlbnREZWZpbml0aW9uUmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJFdmVudERlZmluaXRpb25cIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJCb3VuZGFyeUV2ZW50XCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiQ2F0Y2hFdmVudFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJjYW5jZWxBY3Rpdml0eVwiLFxuICBcdFx0XHRcdFwiZGVmYXVsdFwiOiB0cnVlLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJhdHRhY2hlZFRvUmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJBY3Rpdml0eVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkV2ZW50RGVmaW5pdGlvblwiLFxuICBcdFx0aXNBYnN0cmFjdDogdHJ1ZSxcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJSb290RWxlbWVudFwiXG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkNhbmNlbEV2ZW50RGVmaW5pdGlvblwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkV2ZW50RGVmaW5pdGlvblwiXG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkVycm9yRXZlbnREZWZpbml0aW9uXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiRXZlbnREZWZpbml0aW9uXCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImVycm9yUmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJFcnJvclwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIlRlcm1pbmF0ZUV2ZW50RGVmaW5pdGlvblwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkV2ZW50RGVmaW5pdGlvblwiXG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkVzY2FsYXRpb25FdmVudERlZmluaXRpb25cIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJFdmVudERlZmluaXRpb25cIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZXNjYWxhdGlvblJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRXNjYWxhdGlvblwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkVzY2FsYXRpb25cIixcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwic3RydWN0dXJlUmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJJdGVtRGVmaW5pdGlvblwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZXNjYWxhdGlvbkNvZGVcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9XG4gIFx0XHRdLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIlJvb3RFbGVtZW50XCJcbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiQ29tcGVuc2F0ZUV2ZW50RGVmaW5pdGlvblwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkV2ZW50RGVmaW5pdGlvblwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJ3YWl0Rm9yQ29tcGxldGlvblwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIixcbiAgXHRcdFx0XHRcImRlZmF1bHRcIjogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJhY3Rpdml0eVJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiQWN0aXZpdHlcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJUaW1lckV2ZW50RGVmaW5pdGlvblwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkV2ZW50RGVmaW5pdGlvblwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJ0aW1lRGF0ZVwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRXhwcmVzc2lvblwiLFxuICBcdFx0XHRcdHhtbDoge1xuICBcdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInRpbWVDeWNsZVwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRXhwcmVzc2lvblwiLFxuICBcdFx0XHRcdHhtbDoge1xuICBcdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInRpbWVEdXJhdGlvblwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRXhwcmVzc2lvblwiLFxuICBcdFx0XHRcdHhtbDoge1xuICBcdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiTGlua0V2ZW50RGVmaW5pdGlvblwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkV2ZW50RGVmaW5pdGlvblwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwidGFyZ2V0XCIsXG4gIFx0XHRcdFx0dHlwZTogXCJMaW5rRXZlbnREZWZpbml0aW9uXCIsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwic291cmNlXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJMaW5rRXZlbnREZWZpbml0aW9uXCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiTWVzc2FnZUV2ZW50RGVmaW5pdGlvblwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkV2ZW50RGVmaW5pdGlvblwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJtZXNzYWdlUmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJNZXNzYWdlXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm9wZXJhdGlvblJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiT3BlcmF0aW9uXCIsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJDb25kaXRpb25hbEV2ZW50RGVmaW5pdGlvblwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkV2ZW50RGVmaW5pdGlvblwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJjb25kaXRpb25cIixcbiAgXHRcdFx0XHR0eXBlOiBcIkV4cHJlc3Npb25cIixcbiAgXHRcdFx0XHR4bWw6IHtcbiAgXHRcdFx0XHRcdHNlcmlhbGl6ZTogXCJ4c2k6dHlwZVwiXG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIlNpZ25hbEV2ZW50RGVmaW5pdGlvblwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkV2ZW50RGVmaW5pdGlvblwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJzaWduYWxSZWZcIixcbiAgXHRcdFx0XHR0eXBlOiBcIlNpZ25hbFwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIlNpZ25hbFwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIlJvb3RFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInN0cnVjdHVyZVJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiSXRlbURlZmluaXRpb25cIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiSW1wbGljaXRUaHJvd0V2ZW50XCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiVGhyb3dFdmVudFwiXG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkRhdGFTdGF0ZVwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkJhc2VFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkl0ZW1Bd2FyZUVsZW1lbnRcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJCYXNlRWxlbWVudFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpdGVtU3ViamVjdFJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiSXRlbURlZmluaXRpb25cIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZGF0YVN0YXRlXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJEYXRhU3RhdGVcIlxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkRhdGFBc3NvY2lhdGlvblwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkJhc2VFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInNvdXJjZVJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiSXRlbUF3YXJlRWxlbWVudFwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJ0YXJnZXRSZWZcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkl0ZW1Bd2FyZUVsZW1lbnRcIixcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRm9ybWFsRXhwcmVzc2lvblwiLFxuICBcdFx0XHRcdHhtbDoge1xuICBcdFx0XHRcdFx0c2VyaWFsaXplOiBcInByb3BlcnR5XCJcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImFzc2lnbm1lbnRcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkFzc2lnbm1lbnRcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJEYXRhSW5wdXRcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJJdGVtQXdhcmVFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpc0NvbGxlY3Rpb25cIixcbiAgXHRcdFx0XHRcImRlZmF1bHRcIjogZmFsc2UsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImlucHV0U2V0UmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJJbnB1dFNldFwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZSxcbiAgXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaW5wdXRTZXRXaXRoT3B0aW9uYWxcIixcbiAgXHRcdFx0XHR0eXBlOiBcIklucHV0U2V0XCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlLFxuICBcdFx0XHRcdGlzVmlydHVhbDogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpbnB1dFNldFdpdGhXaGlsZUV4ZWN1dGluZ1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiSW5wdXRTZXRcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0aXNWaXJ0dWFsOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiRGF0YU91dHB1dFwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkl0ZW1Bd2FyZUVsZW1lbnRcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImlzQ29sbGVjdGlvblwiLFxuICBcdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwib3V0cHV0U2V0UmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJPdXRwdXRTZXRcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0aXNWaXJ0dWFsOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm91dHB1dFNldFdpdGhPcHRpb25hbFwiLFxuICBcdFx0XHRcdHR5cGU6IFwiT3V0cHV0U2V0XCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlLFxuICBcdFx0XHRcdGlzVmlydHVhbDogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJvdXRwdXRTZXRXaXRoV2hpbGVFeGVjdXRpbmdcIixcbiAgXHRcdFx0XHR0eXBlOiBcIk91dHB1dFNldFwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZSxcbiAgXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJJbnB1dFNldFwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkJhc2VFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJkYXRhSW5wdXRSZWZzXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJEYXRhSW5wdXRcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwib3B0aW9uYWxJbnB1dFJlZnNcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkRhdGFJbnB1dFwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJ3aGlsZUV4ZWN1dGluZ0lucHV0UmVmc1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiRGF0YUlucHV0XCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm91dHB1dFNldFJlZnNcIixcbiAgXHRcdFx0XHR0eXBlOiBcIk91dHB1dFNldFwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIk91dHB1dFNldFwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkJhc2VFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImRhdGFPdXRwdXRSZWZzXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJEYXRhT3V0cHV0XCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpbnB1dFNldFJlZnNcIixcbiAgXHRcdFx0XHR0eXBlOiBcIklucHV0U2V0XCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm9wdGlvbmFsT3V0cHV0UmVmc1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiRGF0YU91dHB1dFwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJ3aGlsZUV4ZWN1dGluZ091dHB1dFJlZnNcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkRhdGFPdXRwdXRcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJQcm9wZXJ0eVwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkl0ZW1Bd2FyZUVsZW1lbnRcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiRGF0YUlucHV0QXNzb2NpYXRpb25cIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJEYXRhQXNzb2NpYXRpb25cIlxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJEYXRhT3V0cHV0QXNzb2NpYXRpb25cIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJEYXRhQXNzb2NpYXRpb25cIlxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJJbnB1dE91dHB1dFNwZWNpZmljYXRpb25cIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJCYXNlRWxlbWVudFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJkYXRhSW5wdXRzXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJEYXRhSW5wdXRcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZGF0YU91dHB1dHNcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkRhdGFPdXRwdXRcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaW5wdXRTZXRzXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJJbnB1dFNldFwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJvdXRwdXRTZXRzXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJPdXRwdXRTZXRcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJEYXRhT2JqZWN0XCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiRmxvd0VsZW1lbnRcIixcbiAgXHRcdFx0XCJJdGVtQXdhcmVFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImlzQ29sbGVjdGlvblwiLFxuICBcdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCJcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJJbnB1dE91dHB1dEJpbmRpbmdcIixcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaW5wdXREYXRhUmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJJbnB1dFNldFwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJvdXRwdXREYXRhUmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJPdXRwdXRTZXRcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwib3BlcmF0aW9uUmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJPcGVyYXRpb25cIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJBc3NpZ25tZW50XCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZnJvbVwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRXhwcmVzc2lvblwiLFxuICBcdFx0XHRcdHhtbDoge1xuICBcdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInRvXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJFeHByZXNzaW9uXCIsXG4gIFx0XHRcdFx0eG1sOiB7XG4gIFx0XHRcdFx0XHRzZXJpYWxpemU6IFwieHNpOnR5cGVcIlxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJEYXRhU3RvcmVcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJSb290RWxlbWVudFwiLFxuICBcdFx0XHRcIkl0ZW1Bd2FyZUVsZW1lbnRcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImNhcGFjaXR5XCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiSW50ZWdlclwiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImlzVW5saW1pdGVkXCIsXG4gIFx0XHRcdFx0XCJkZWZhdWx0XCI6IHRydWUsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiRGF0YVN0b3JlUmVmZXJlbmNlXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiSXRlbUF3YXJlRWxlbWVudFwiLFxuICBcdFx0XHRcIkZsb3dFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImRhdGFTdG9yZVJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRGF0YVN0b3JlXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiRGF0YU9iamVjdFJlZmVyZW5jZVwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkl0ZW1Bd2FyZUVsZW1lbnRcIixcbiAgXHRcdFx0XCJGbG93RWxlbWVudFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJkYXRhT2JqZWN0UmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJEYXRhT2JqZWN0XCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiQ29udmVyc2F0aW9uTGlua1wiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkJhc2VFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInNvdXJjZVJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiSW50ZXJhY3Rpb25Ob2RlXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInRhcmdldFJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiSW50ZXJhY3Rpb25Ob2RlXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkNvbnZlcnNhdGlvbkFzc29jaWF0aW9uXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaW5uZXJDb252ZXJzYXRpb25Ob2RlUmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJDb252ZXJzYXRpb25Ob2RlXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm91dGVyQ29udmVyc2F0aW9uTm9kZVJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiQ29udmVyc2F0aW9uTm9kZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkNhbGxDb252ZXJzYXRpb25cIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJDb252ZXJzYXRpb25Ob2RlXCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImNhbGxlZENvbGxhYm9yYXRpb25SZWZcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkNvbGxhYm9yYXRpb25cIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwicGFydGljaXBhbnRBc3NvY2lhdGlvbnNcIixcbiAgXHRcdFx0XHR0eXBlOiBcIlBhcnRpY2lwYW50QXNzb2NpYXRpb25cIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJDb252ZXJzYXRpb25cIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJDb252ZXJzYXRpb25Ob2RlXCJcbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiU3ViQ29udmVyc2F0aW9uXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiQ29udmVyc2F0aW9uTm9kZVwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJjb252ZXJzYXRpb25Ob2Rlc1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiQ29udmVyc2F0aW9uTm9kZVwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkNvbnZlcnNhdGlvbk5vZGVcIixcbiAgXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiSW50ZXJhY3Rpb25Ob2RlXCIsXG4gIFx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInBhcnRpY2lwYW50UmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJQYXJ0aWNpcGFudFwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJtZXNzYWdlRmxvd1JlZnNcIixcbiAgXHRcdFx0XHR0eXBlOiBcIk1lc3NhZ2VGbG93XCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImNvcnJlbGF0aW9uS2V5c1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiQ29ycmVsYXRpb25LZXlcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJHbG9iYWxDb252ZXJzYXRpb25cIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJDb2xsYWJvcmF0aW9uXCJcbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiUGFydG5lckVudGl0eVwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIlJvb3RFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJwYXJ0aWNpcGFudFJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiUGFydGljaXBhbnRcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJQYXJ0bmVyUm9sZVwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIlJvb3RFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJwYXJ0aWNpcGFudFJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiUGFydGljaXBhbnRcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJDb3JyZWxhdGlvblByb3BlcnR5XCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiUm9vdEVsZW1lbnRcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiY29ycmVsYXRpb25Qcm9wZXJ0eVJldHJpZXZhbEV4cHJlc3Npb25cIixcbiAgXHRcdFx0XHR0eXBlOiBcIkNvcnJlbGF0aW9uUHJvcGVydHlSZXRyaWV2YWxFeHByZXNzaW9uXCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJ0eXBlXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJJdGVtRGVmaW5pdGlvblwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkVycm9yXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiUm9vdEVsZW1lbnRcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwic3RydWN0dXJlUmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJJdGVtRGVmaW5pdGlvblwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZXJyb3JDb2RlXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJDb3JyZWxhdGlvbktleVwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkJhc2VFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImNvcnJlbGF0aW9uUHJvcGVydHlSZWZcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkNvcnJlbGF0aW9uUHJvcGVydHlcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiRXhwcmVzc2lvblwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkJhc2VFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRpc0Fic3RyYWN0OiBmYWxzZSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiYm9keVwiLFxuICBcdFx0XHRcdGlzQm9keTogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiRm9ybWFsRXhwcmVzc2lvblwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkV4cHJlc3Npb25cIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibGFuZ3VhZ2VcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJldmFsdWF0ZXNUb1R5cGVSZWZcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkl0ZW1EZWZpbml0aW9uXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiTWVzc2FnZVwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIlJvb3RFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpdGVtUmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJJdGVtRGVmaW5pdGlvblwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkl0ZW1EZWZpbml0aW9uXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiUm9vdEVsZW1lbnRcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaXRlbUtpbmRcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkl0ZW1LaW5kXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInN0cnVjdHVyZVJlZlwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImlzQ29sbGVjdGlvblwiLFxuICBcdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaW1wb3J0XCIsXG4gIFx0XHRcdFx0dHlwZTogXCJJbXBvcnRcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJGbG93RWxlbWVudFwiLFxuICBcdFx0aXNBYnN0cmFjdDogdHJ1ZSxcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJCYXNlRWxlbWVudFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiYXVkaXRpbmdcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkF1ZGl0aW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibW9uaXRvcmluZ1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiTW9uaXRvcmluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImNhdGVnb3J5VmFsdWVSZWZcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkNhdGVnb3J5VmFsdWVcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJTZXF1ZW5jZUZsb3dcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJGbG93RWxlbWVudFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpc0ltbWVkaWF0ZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJjb25kaXRpb25FeHByZXNzaW9uXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJFeHByZXNzaW9uXCIsXG4gIFx0XHRcdFx0eG1sOiB7XG4gIFx0XHRcdFx0XHRzZXJpYWxpemU6IFwieHNpOnR5cGVcIlxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwic291cmNlUmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJGbG93Tm9kZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJ0YXJnZXRSZWZcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkZsb3dOb2RlXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiRmxvd0VsZW1lbnRzQ29udGFpbmVyXCIsXG4gIFx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkJhc2VFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImxhbmVTZXRzXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJMYW5lU2V0XCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImZsb3dFbGVtZW50c1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiRmxvd0VsZW1lbnRcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJDYWxsYWJsZUVsZW1lbnRcIixcbiAgXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiUm9vdEVsZW1lbnRcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImlvU3BlY2lmaWNhdGlvblwiLFxuICBcdFx0XHRcdHR5cGU6IFwiSW5wdXRPdXRwdXRTcGVjaWZpY2F0aW9uXCIsXG4gIFx0XHRcdFx0eG1sOiB7XG4gIFx0XHRcdFx0XHRzZXJpYWxpemU6IFwicHJvcGVydHlcIlxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwic3VwcG9ydGVkSW50ZXJmYWNlUmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJJbnRlcmZhY2VcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaW9CaW5kaW5nXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJJbnB1dE91dHB1dEJpbmRpbmdcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0eG1sOiB7XG4gIFx0XHRcdFx0XHRzZXJpYWxpemU6IFwicHJvcGVydHlcIlxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJGbG93Tm9kZVwiLFxuICBcdFx0aXNBYnN0cmFjdDogdHJ1ZSxcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJGbG93RWxlbWVudFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpbmNvbWluZ1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiU2VxdWVuY2VGbG93XCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm91dGdvaW5nXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJTZXF1ZW5jZUZsb3dcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibGFuZXNcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkxhbmVcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0aXNWaXJ0dWFsOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiQ29ycmVsYXRpb25Qcm9wZXJ0eVJldHJpZXZhbEV4cHJlc3Npb25cIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJCYXNlRWxlbWVudFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJtZXNzYWdlUGF0aFwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRm9ybWFsRXhwcmVzc2lvblwiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm1lc3NhZ2VSZWZcIixcbiAgXHRcdFx0XHR0eXBlOiBcIk1lc3NhZ2VcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJDb3JyZWxhdGlvblByb3BlcnR5QmluZGluZ1wiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkJhc2VFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImRhdGFQYXRoXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJGb3JtYWxFeHByZXNzaW9uXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiY29ycmVsYXRpb25Qcm9wZXJ0eVJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiQ29ycmVsYXRpb25Qcm9wZXJ0eVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIlJlc291cmNlXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiUm9vdEVsZW1lbnRcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInJlc291cmNlUGFyYW1ldGVyc1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiUmVzb3VyY2VQYXJhbWV0ZXJcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJSZXNvdXJjZVBhcmFtZXRlclwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkJhc2VFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpc1JlcXVpcmVkXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInR5cGVcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkl0ZW1EZWZpbml0aW9uXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiQ29ycmVsYXRpb25TdWJzY3JpcHRpb25cIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJCYXNlRWxlbWVudFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJjb3JyZWxhdGlvbktleVJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiQ29ycmVsYXRpb25LZXlcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiY29ycmVsYXRpb25Qcm9wZXJ0eUJpbmRpbmdcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkNvcnJlbGF0aW9uUHJvcGVydHlCaW5kaW5nXCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiTWVzc2FnZUZsb3dcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJCYXNlRWxlbWVudFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwic291cmNlUmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJJbnRlcmFjdGlvbk5vZGVcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwidGFyZ2V0UmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJJbnRlcmFjdGlvbk5vZGVcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibWVzc2FnZVJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiTWVzc2FnZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIk1lc3NhZ2VGbG93QXNzb2NpYXRpb25cIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJCYXNlRWxlbWVudFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpbm5lck1lc3NhZ2VGbG93UmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJNZXNzYWdlRmxvd1wiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJvdXRlck1lc3NhZ2VGbG93UmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJNZXNzYWdlRmxvd1wiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkludGVyYWN0aW9uTm9kZVwiLFxuICBcdFx0aXNBYnN0cmFjdDogdHJ1ZSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaW5jb21pbmdDb252ZXJzYXRpb25MaW5rc1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiQ29udmVyc2F0aW9uTGlua1wiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZSxcbiAgXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwib3V0Z29pbmdDb252ZXJzYXRpb25MaW5rc1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiQ29udmVyc2F0aW9uTGlua1wiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZSxcbiAgXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJQYXJ0aWNpcGFudFwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkludGVyYWN0aW9uTm9kZVwiLFxuICBcdFx0XHRcIkJhc2VFbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpbnRlcmZhY2VSZWZcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkludGVyZmFjZVwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJwYXJ0aWNpcGFudE11bHRpcGxpY2l0eVwiLFxuICBcdFx0XHRcdHR5cGU6IFwiUGFydGljaXBhbnRNdWx0aXBsaWNpdHlcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJlbmRQb2ludFJlZnNcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkVuZFBvaW50XCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInByb2Nlc3NSZWZcIixcbiAgXHRcdFx0XHR0eXBlOiBcIlByb2Nlc3NcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJQYXJ0aWNpcGFudEFzc29jaWF0aW9uXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaW5uZXJQYXJ0aWNpcGFudFJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiUGFydGljaXBhbnRcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwib3V0ZXJQYXJ0aWNpcGFudFJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiUGFydGljaXBhbnRcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJQYXJ0aWNpcGFudE11bHRpcGxpY2l0eVwiLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJtaW5pbXVtXCIsXG4gIFx0XHRcdFx0XCJkZWZhdWx0XCI6IDAsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiSW50ZWdlclwiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm1heGltdW1cIixcbiAgXHRcdFx0XHRcImRlZmF1bHRcIjogMSxcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJJbnRlZ2VyXCJcbiAgXHRcdFx0fVxuICBcdFx0XSxcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJCYXNlRWxlbWVudFwiXG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkNvbGxhYm9yYXRpb25cIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJSb290RWxlbWVudFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaXNDbG9zZWRcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwicGFydGljaXBhbnRzXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJQYXJ0aWNpcGFudFwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJtZXNzYWdlRmxvd3NcIixcbiAgXHRcdFx0XHR0eXBlOiBcIk1lc3NhZ2VGbG93XCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImFydGlmYWN0c1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiQXJ0aWZhY3RcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiY29udmVyc2F0aW9uc1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiQ29udmVyc2F0aW9uTm9kZVwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJjb252ZXJzYXRpb25Bc3NvY2lhdGlvbnNcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkNvbnZlcnNhdGlvbkFzc29jaWF0aW9uXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwicGFydGljaXBhbnRBc3NvY2lhdGlvbnNcIixcbiAgXHRcdFx0XHR0eXBlOiBcIlBhcnRpY2lwYW50QXNzb2NpYXRpb25cIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibWVzc2FnZUZsb3dBc3NvY2lhdGlvbnNcIixcbiAgXHRcdFx0XHR0eXBlOiBcIk1lc3NhZ2VGbG93QXNzb2NpYXRpb25cIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiY29ycmVsYXRpb25LZXlzXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJDb3JyZWxhdGlvbktleVwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJjaG9yZW9ncmFwaHlSZWZcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkNob3Jlb2dyYXBoeVwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJjb252ZXJzYXRpb25MaW5rc1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiQ29udmVyc2F0aW9uTGlua1wiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkNob3Jlb2dyYXBoeUFjdGl2aXR5XCIsXG4gIFx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkZsb3dOb2RlXCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInBhcnRpY2lwYW50UmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJQYXJ0aWNpcGFudFwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpbml0aWF0aW5nUGFydGljaXBhbnRSZWZcIixcbiAgXHRcdFx0XHR0eXBlOiBcIlBhcnRpY2lwYW50XCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImNvcnJlbGF0aW9uS2V5c1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiQ29ycmVsYXRpb25LZXlcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibG9vcFR5cGVcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkNob3Jlb2dyYXBoeUxvb3BUeXBlXCIsXG4gIFx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiTm9uZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkNhbGxDaG9yZW9ncmFwaHlcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJDaG9yZW9ncmFwaHlBY3Rpdml0eVwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJjYWxsZWRDaG9yZW9ncmFwaHlSZWZcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkNob3Jlb2dyYXBoeVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJwYXJ0aWNpcGFudEFzc29jaWF0aW9uc1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiUGFydGljaXBhbnRBc3NvY2lhdGlvblwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIlN1YkNob3Jlb2dyYXBoeVwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkNob3Jlb2dyYXBoeUFjdGl2aXR5XCIsXG4gIFx0XHRcdFwiRmxvd0VsZW1lbnRzQ29udGFpbmVyXCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImFydGlmYWN0c1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiQXJ0aWZhY3RcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJDaG9yZW9ncmFwaHlUYXNrXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiQ2hvcmVvZ3JhcGh5QWN0aXZpdHlcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibWVzc2FnZUZsb3dSZWZcIixcbiAgXHRcdFx0XHR0eXBlOiBcIk1lc3NhZ2VGbG93XCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiQ2hvcmVvZ3JhcGh5XCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiQ29sbGFib3JhdGlvblwiLFxuICBcdFx0XHRcIkZsb3dFbGVtZW50c0NvbnRhaW5lclwiXG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkdsb2JhbENob3Jlb2dyYXBoeVRhc2tcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJDaG9yZW9ncmFwaHlcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaW5pdGlhdGluZ1BhcnRpY2lwYW50UmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJQYXJ0aWNpcGFudFwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIlRleHRBbm5vdGF0aW9uXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiQXJ0aWZhY3RcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwidGV4dFwiLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwidGV4dEZvcm1hdFwiLFxuICBcdFx0XHRcdFwiZGVmYXVsdFwiOiBcInRleHQvcGxhaW5cIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkdyb3VwXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiQXJ0aWZhY3RcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiY2F0ZWdvcnlWYWx1ZVJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiQ2F0ZWdvcnlWYWx1ZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkFzc29jaWF0aW9uXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiQXJ0aWZhY3RcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiYXNzb2NpYXRpb25EaXJlY3Rpb25cIixcbiAgXHRcdFx0XHR0eXBlOiBcIkFzc29jaWF0aW9uRGlyZWN0aW9uXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInNvdXJjZVJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiQmFzZUVsZW1lbnRcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwidGFyZ2V0UmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJCYXNlRWxlbWVudFwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkNhdGVnb3J5XCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiUm9vdEVsZW1lbnRcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiY2F0ZWdvcnlWYWx1ZVwiLFxuICBcdFx0XHRcdHR5cGU6IFwiQ2F0ZWdvcnlWYWx1ZVwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJBcnRpZmFjdFwiLFxuICBcdFx0aXNBYnN0cmFjdDogdHJ1ZSxcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJCYXNlRWxlbWVudFwiXG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkNhdGVnb3J5VmFsdWVcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJCYXNlRWxlbWVudFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJjYXRlZ29yaXplZEZsb3dFbGVtZW50c1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiRmxvd0VsZW1lbnRcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0aXNWaXJ0dWFsOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInZhbHVlXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJBY3Rpdml0eVwiLFxuICBcdFx0aXNBYnN0cmFjdDogdHJ1ZSxcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJGbG93Tm9kZVwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpc0ZvckNvbXBlbnNhdGlvblwiLFxuICBcdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZGVmYXVsdFwiLFxuICBcdFx0XHRcdHR5cGU6IFwiU2VxdWVuY2VGbG93XCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImlvU3BlY2lmaWNhdGlvblwiLFxuICBcdFx0XHRcdHR5cGU6IFwiSW5wdXRPdXRwdXRTcGVjaWZpY2F0aW9uXCIsXG4gIFx0XHRcdFx0eG1sOiB7XG4gIFx0XHRcdFx0XHRzZXJpYWxpemU6IFwicHJvcGVydHlcIlxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiYm91bmRhcnlFdmVudFJlZnNcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkJvdW5kYXJ5RXZlbnRcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwicHJvcGVydGllc1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiUHJvcGVydHlcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZGF0YUlucHV0QXNzb2NpYXRpb25zXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJEYXRhSW5wdXRBc3NvY2lhdGlvblwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJkYXRhT3V0cHV0QXNzb2NpYXRpb25zXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJEYXRhT3V0cHV0QXNzb2NpYXRpb25cIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwic3RhcnRRdWFudGl0eVwiLFxuICBcdFx0XHRcdFwiZGVmYXVsdFwiOiAxLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIkludGVnZXJcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJyZXNvdXJjZXNcIixcbiAgXHRcdFx0XHR0eXBlOiBcIlJlc291cmNlUm9sZVwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJjb21wbGV0aW9uUXVhbnRpdHlcIixcbiAgXHRcdFx0XHRcImRlZmF1bHRcIjogMSxcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJJbnRlZ2VyXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibG9vcENoYXJhY3RlcmlzdGljc1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiTG9vcENoYXJhY3RlcmlzdGljc1wiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiU2VydmljZVRhc2tcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJUYXNrXCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImltcGxlbWVudGF0aW9uXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwib3BlcmF0aW9uUmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJPcGVyYXRpb25cIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJTdWJQcm9jZXNzXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiQWN0aXZpdHlcIixcbiAgXHRcdFx0XCJGbG93RWxlbWVudHNDb250YWluZXJcIixcbiAgXHRcdFx0XCJJbnRlcmFjdGlvbk5vZGVcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwidHJpZ2dlcmVkQnlFdmVudFwiLFxuICBcdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiYXJ0aWZhY3RzXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJBcnRpZmFjdFwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkxvb3BDaGFyYWN0ZXJpc3RpY3NcIixcbiAgXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJNdWx0aUluc3RhbmNlTG9vcENoYXJhY3RlcmlzdGljc1wiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkxvb3BDaGFyYWN0ZXJpc3RpY3NcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaXNTZXF1ZW50aWFsXCIsXG4gIFx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJiZWhhdmlvclwiLFxuICBcdFx0XHRcdHR5cGU6IFwiTXVsdGlJbnN0YW5jZUJlaGF2aW9yXCIsXG4gIFx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiQWxsXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImxvb3BDYXJkaW5hbGl0eVwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRXhwcmVzc2lvblwiLFxuICBcdFx0XHRcdHhtbDoge1xuICBcdFx0XHRcdFx0c2VyaWFsaXplOiBcInhzaTp0eXBlXCJcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImxvb3BEYXRhSW5wdXRSZWZcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkl0ZW1Bd2FyZUVsZW1lbnRcIixcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJsb29wRGF0YU91dHB1dFJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiSXRlbUF3YXJlRWxlbWVudFwiLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImlucHV0RGF0YUl0ZW1cIixcbiAgXHRcdFx0XHR0eXBlOiBcIkRhdGFJbnB1dFwiLFxuICBcdFx0XHRcdHhtbDoge1xuICBcdFx0XHRcdFx0c2VyaWFsaXplOiBcInByb3BlcnR5XCJcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm91dHB1dERhdGFJdGVtXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJEYXRhT3V0cHV0XCIsXG4gIFx0XHRcdFx0eG1sOiB7XG4gIFx0XHRcdFx0XHRzZXJpYWxpemU6IFwicHJvcGVydHlcIlxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiY29tcGxleEJlaGF2aW9yRGVmaW5pdGlvblwiLFxuICBcdFx0XHRcdHR5cGU6IFwiQ29tcGxleEJlaGF2aW9yRGVmaW5pdGlvblwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJjb21wbGV0aW9uQ29uZGl0aW9uXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJFeHByZXNzaW9uXCIsXG4gIFx0XHRcdFx0eG1sOiB7XG4gIFx0XHRcdFx0XHRzZXJpYWxpemU6IFwieHNpOnR5cGVcIlxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwib25lQmVoYXZpb3JFdmVudFJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRXZlbnREZWZpbml0aW9uXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm5vbmVCZWhhdmlvckV2ZW50UmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJFdmVudERlZmluaXRpb25cIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJTdGFuZGFyZExvb3BDaGFyYWN0ZXJpc3RpY3NcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJMb29wQ2hhcmFjdGVyaXN0aWNzXCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInRlc3RCZWZvcmVcIixcbiAgXHRcdFx0XHRcImRlZmF1bHRcIjogZmFsc2UsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImxvb3BDb25kaXRpb25cIixcbiAgXHRcdFx0XHR0eXBlOiBcIkV4cHJlc3Npb25cIixcbiAgXHRcdFx0XHR4bWw6IHtcbiAgXHRcdFx0XHRcdHNlcmlhbGl6ZTogXCJ4c2k6dHlwZVwiXG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJsb29wTWF4aW11bVwiLFxuICBcdFx0XHRcdHR5cGU6IFwiSW50ZWdlclwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkNhbGxBY3Rpdml0eVwiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkFjdGl2aXR5XCIsXG4gIFx0XHRcdFwiSW50ZXJhY3Rpb25Ob2RlXCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImNhbGxlZEVsZW1lbnRcIixcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIlRhc2tcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJBY3Rpdml0eVwiLFxuICBcdFx0XHRcIkludGVyYWN0aW9uTm9kZVwiXG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIlNlbmRUYXNrXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiVGFza1wiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpbXBsZW1lbnRhdGlvblwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm9wZXJhdGlvblJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiT3BlcmF0aW9uXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm1lc3NhZ2VSZWZcIixcbiAgXHRcdFx0XHR0eXBlOiBcIk1lc3NhZ2VcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJSZWNlaXZlVGFza1wiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIlRhc2tcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaW1wbGVtZW50YXRpb25cIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpbnN0YW50aWF0ZVwiLFxuICBcdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwib3BlcmF0aW9uUmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJPcGVyYXRpb25cIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibWVzc2FnZVJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiTWVzc2FnZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIlNjcmlwdFRhc2tcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJUYXNrXCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInNjcmlwdEZvcm1hdFwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInNjcmlwdFwiLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJCdXNpbmVzc1J1bGVUYXNrXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiVGFza1wiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpbXBsZW1lbnRhdGlvblwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiQWRIb2NTdWJQcm9jZXNzXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiU3ViUHJvY2Vzc1wiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJjb21wbGV0aW9uQ29uZGl0aW9uXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJFeHByZXNzaW9uXCIsXG4gIFx0XHRcdFx0eG1sOiB7XG4gIFx0XHRcdFx0XHRzZXJpYWxpemU6IFwieHNpOnR5cGVcIlxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwib3JkZXJpbmdcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkFkSG9jT3JkZXJpbmdcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiY2FuY2VsUmVtYWluaW5nSW5zdGFuY2VzXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiVHJhbnNhY3Rpb25cIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJTdWJQcm9jZXNzXCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInByb3RvY29sXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibWV0aG9kXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJHbG9iYWxTY3JpcHRUYXNrXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiR2xvYmFsVGFza1wiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJzY3JpcHRMYW5ndWFnZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInNjcmlwdFwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiR2xvYmFsQnVzaW5lc3NSdWxlVGFza1wiLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkdsb2JhbFRhc2tcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaW1wbGVtZW50YXRpb25cIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkNvbXBsZXhCZWhhdmlvckRlZmluaXRpb25cIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJCYXNlRWxlbWVudFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJjb25kaXRpb25cIixcbiAgXHRcdFx0XHR0eXBlOiBcIkZvcm1hbEV4cHJlc3Npb25cIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJldmVudFwiLFxuICBcdFx0XHRcdHR5cGU6IFwiSW1wbGljaXRUaHJvd0V2ZW50XCJcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJSZXNvdXJjZVJvbGVcIixcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJCYXNlRWxlbWVudFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJyZXNvdXJjZVJlZlwiLFxuICBcdFx0XHRcdHR5cGU6IFwiUmVzb3VyY2VcIixcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJyZXNvdXJjZVBhcmFtZXRlckJpbmRpbmdzXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJSZXNvdXJjZVBhcmFtZXRlckJpbmRpbmdcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwicmVzb3VyY2VBc3NpZ25tZW50RXhwcmVzc2lvblwiLFxuICBcdFx0XHRcdHR5cGU6IFwiUmVzb3VyY2VBc3NpZ25tZW50RXhwcmVzc2lvblwiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIlJlc291cmNlUGFyYW1ldGVyQmluZGluZ1wiLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJleHByZXNzaW9uXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJFeHByZXNzaW9uXCIsXG4gIFx0XHRcdFx0eG1sOiB7XG4gIFx0XHRcdFx0XHRzZXJpYWxpemU6IFwieHNpOnR5cGVcIlxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwicGFyYW1ldGVyUmVmXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJSZXNvdXJjZVBhcmFtZXRlclwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkJhc2VFbGVtZW50XCJcbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiUmVzb3VyY2VBc3NpZ25tZW50RXhwcmVzc2lvblwiLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJleHByZXNzaW9uXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJFeHByZXNzaW9uXCIsXG4gIFx0XHRcdFx0eG1sOiB7XG4gIFx0XHRcdFx0XHRzZXJpYWxpemU6IFwieHNpOnR5cGVcIlxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0XSxcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJCYXNlRWxlbWVudFwiXG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkltcG9ydFwiLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpbXBvcnRUeXBlXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibG9jYXRpb25cIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJuYW1lc3BhY2VcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkRlZmluaXRpb25zXCIsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiQmFzZUVsZW1lbnRcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInRhcmdldE5hbWVzcGFjZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImV4cHJlc3Npb25MYW5ndWFnZVwiLFxuICBcdFx0XHRcdFwiZGVmYXVsdFwiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkvWFBhdGhcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJ0eXBlTGFuZ3VhZ2VcIixcbiAgXHRcdFx0XHRcImRlZmF1bHRcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImltcG9ydHNcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkltcG9ydFwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJleHRlbnNpb25zXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJFeHRlbnNpb25cIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwicm9vdEVsZW1lbnRzXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJSb290RWxlbWVudFwiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJkaWFncmFtc1wiLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcImJwbW5kaTpCUE1ORGlhZ3JhbVwiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImV4cG9ydGVyXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwicmVsYXRpb25zaGlwc1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiUmVsYXRpb25zaGlwXCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImV4cG9ydGVyVmVyc2lvblwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9XG4gIF07XG4gIHZhciBlbnVtZXJhdGlvbnMkMyA9IFtcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIlByb2Nlc3NUeXBlXCIsXG4gIFx0XHRsaXRlcmFsVmFsdWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIk5vbmVcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJQdWJsaWNcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJQcml2YXRlXCJcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJHYXRld2F5RGlyZWN0aW9uXCIsXG4gIFx0XHRsaXRlcmFsVmFsdWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIlVuc3BlY2lmaWVkXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiQ29udmVyZ2luZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIkRpdmVyZ2luZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIk1peGVkXCJcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJFdmVudEJhc2VkR2F0ZXdheVR5cGVcIixcbiAgXHRcdGxpdGVyYWxWYWx1ZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiUGFyYWxsZWxcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJFeGNsdXNpdmVcIlxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIlJlbGF0aW9uc2hpcERpcmVjdGlvblwiLFxuICBcdFx0bGl0ZXJhbFZhbHVlczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJOb25lXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiRm9yd2FyZFwiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIkJhY2t3YXJkXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiQm90aFwiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiSXRlbUtpbmRcIixcbiAgXHRcdGxpdGVyYWxWYWx1ZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiUGh5c2ljYWxcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJJbmZvcm1hdGlvblwiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiQ2hvcmVvZ3JhcGh5TG9vcFR5cGVcIixcbiAgXHRcdGxpdGVyYWxWYWx1ZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiTm9uZVwiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIlN0YW5kYXJkXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiTXVsdGlJbnN0YW5jZVNlcXVlbnRpYWxcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJNdWx0aUluc3RhbmNlUGFyYWxsZWxcIlxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkFzc29jaWF0aW9uRGlyZWN0aW9uXCIsXG4gIFx0XHRsaXRlcmFsVmFsdWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIk5vbmVcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJPbmVcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJCb3RoXCJcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJNdWx0aUluc3RhbmNlQmVoYXZpb3JcIixcbiAgXHRcdGxpdGVyYWxWYWx1ZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiTm9uZVwiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIk9uZVwiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIkFsbFwiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIkNvbXBsZXhcIlxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkFkSG9jT3JkZXJpbmdcIixcbiAgXHRcdGxpdGVyYWxWYWx1ZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiUGFyYWxsZWxcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJTZXF1ZW50aWFsXCJcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH1cbiAgXTtcbiAgdmFyIHhtbCQxID0ge1xuICBcdHRhZ0FsaWFzOiBcImxvd2VyQ2FzZVwiLFxuICBcdHR5cGVQcmVmaXg6IFwidFwiXG4gIH07XG4gIHZhciBCcG1uUGFja2FnZSA9IHtcbiAgXHRuYW1lOiBuYW1lJDUsXG4gIFx0dXJpOiB1cmkkNSxcbiAgXHRwcmVmaXg6IHByZWZpeCQ1LFxuICBcdGFzc29jaWF0aW9uczogYXNzb2NpYXRpb25zJDUsXG4gIFx0dHlwZXM6IHR5cGVzJDUsXG4gIFx0ZW51bWVyYXRpb25zOiBlbnVtZXJhdGlvbnMkMyxcbiAgXHR4bWw6IHhtbCQxXG4gIH07XG5cbiAgdmFyIG5hbWUkNCA9IFwiQlBNTkRJXCI7XG4gIHZhciB1cmkkNCA9IFwiaHR0cDovL3d3dy5vbWcub3JnL3NwZWMvQlBNTi8yMDEwMDUyNC9ESVwiO1xuICB2YXIgcHJlZml4JDQgPSBcImJwbW5kaVwiO1xuICB2YXIgdHlwZXMkNCA9IFtcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkJQTU5EaWFncmFtXCIsXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInBsYW5lXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJCUE1OUGxhbmVcIixcbiAgXHRcdFx0XHRyZWRlZmluZXM6IFwiZGk6RGlhZ3JhbSNyb290RWxlbWVudFwiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImxhYmVsU3R5bGVcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkJQTU5MYWJlbFN0eWxlXCIsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlXG4gIFx0XHRcdH1cbiAgXHRcdF0sXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiZGk6RGlhZ3JhbVwiXG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkJQTU5QbGFuZVwiLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJicG1uRWxlbWVudFwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcImJwbW46QmFzZUVsZW1lbnRcIixcbiAgXHRcdFx0XHRyZWRlZmluZXM6IFwiZGk6RGlhZ3JhbUVsZW1lbnQjbW9kZWxFbGVtZW50XCJcbiAgXHRcdFx0fVxuICBcdFx0XSxcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJkaTpQbGFuZVwiXG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkJQTU5TaGFwZVwiLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJicG1uRWxlbWVudFwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcImJwbW46QmFzZUVsZW1lbnRcIixcbiAgXHRcdFx0XHRyZWRlZmluZXM6IFwiZGk6RGlhZ3JhbUVsZW1lbnQjbW9kZWxFbGVtZW50XCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaXNIb3Jpem9udGFsXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImlzRXhwYW5kZWRcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaXNNYXJrZXJWaXNpYmxlXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImxhYmVsXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJCUE1OTGFiZWxcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpc01lc3NhZ2VWaXNpYmxlXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiQm9vbGVhblwiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInBhcnRpY2lwYW50QmFuZEtpbmRcIixcbiAgXHRcdFx0XHR0eXBlOiBcIlBhcnRpY2lwYW50QmFuZEtpbmRcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiY2hvcmVvZ3JhcGh5QWN0aXZpdHlTaGFwZVwiLFxuICBcdFx0XHRcdHR5cGU6IFwiQlBNTlNoYXBlXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH1cbiAgXHRcdF0sXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiZGk6TGFiZWxlZFNoYXBlXCJcbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiQlBNTkVkZ2VcIixcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibGFiZWxcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkJQTU5MYWJlbFwiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImJwbW5FbGVtZW50XCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiYnBtbjpCYXNlRWxlbWVudFwiLFxuICBcdFx0XHRcdHJlZGVmaW5lczogXCJkaTpEaWFncmFtRWxlbWVudCNtb2RlbEVsZW1lbnRcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJzb3VyY2VFbGVtZW50XCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiZGk6RGlhZ3JhbUVsZW1lbnRcIixcbiAgXHRcdFx0XHRyZWRlZmluZXM6IFwiZGk6RWRnZSNzb3VyY2VcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJ0YXJnZXRFbGVtZW50XCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiZGk6RGlhZ3JhbUVsZW1lbnRcIixcbiAgXHRcdFx0XHRyZWRlZmluZXM6IFwiZGk6RWRnZSN0YXJnZXRcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJtZXNzYWdlVmlzaWJsZUtpbmRcIixcbiAgXHRcdFx0XHR0eXBlOiBcIk1lc3NhZ2VWaXNpYmxlS2luZFwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRcImRlZmF1bHRcIjogXCJpbml0aWF0aW5nXCJcbiAgXHRcdFx0fVxuICBcdFx0XSxcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJkaTpMYWJlbGVkRWRnZVwiXG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkJQTU5MYWJlbFwiLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJsYWJlbFN0eWxlXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJCUE1OTGFiZWxTdHlsZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZSxcbiAgXHRcdFx0XHRyZWRlZmluZXM6IFwiZGk6RGlhZ3JhbUVsZW1lbnQjc3R5bGVcIlxuICBcdFx0XHR9XG4gIFx0XHRdLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcImRpOkxhYmVsXCJcbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiQlBNTkxhYmVsU3R5bGVcIixcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZm9udFwiLFxuICBcdFx0XHRcdHR5cGU6IFwiZGM6Rm9udFwiXG4gIFx0XHRcdH1cbiAgXHRcdF0sXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiZGk6U3R5bGVcIlxuICBcdFx0XVxuICBcdH1cbiAgXTtcbiAgdmFyIGVudW1lcmF0aW9ucyQyID0gW1xuICBcdHtcbiAgXHRcdG5hbWU6IFwiUGFydGljaXBhbnRCYW5kS2luZFwiLFxuICBcdFx0bGl0ZXJhbFZhbHVlczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJ0b3BfaW5pdGlhdGluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm1pZGRsZV9pbml0aWF0aW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiYm90dG9tX2luaXRpYXRpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJ0b3Bfbm9uX2luaXRpYXRpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJtaWRkbGVfbm9uX2luaXRpYXRpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJib3R0b21fbm9uX2luaXRpYXRpbmdcIlxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIk1lc3NhZ2VWaXNpYmxlS2luZFwiLFxuICBcdFx0bGl0ZXJhbFZhbHVlczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpbml0aWF0aW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibm9uX2luaXRpYXRpbmdcIlxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fVxuICBdO1xuICB2YXIgYXNzb2NpYXRpb25zJDQgPSBbXG4gIF07XG4gIHZhciBCcG1uRGlQYWNrYWdlID0ge1xuICBcdG5hbWU6IG5hbWUkNCxcbiAgXHR1cmk6IHVyaSQ0LFxuICBcdHByZWZpeDogcHJlZml4JDQsXG4gIFx0dHlwZXM6IHR5cGVzJDQsXG4gIFx0ZW51bWVyYXRpb25zOiBlbnVtZXJhdGlvbnMkMixcbiAgXHRhc3NvY2lhdGlvbnM6IGFzc29jaWF0aW9ucyQ0XG4gIH07XG5cbiAgdmFyIG5hbWUkMyA9IFwiRENcIjtcbiAgdmFyIHVyaSQzID0gXCJodHRwOi8vd3d3Lm9tZy5vcmcvc3BlYy9ERC8yMDEwMDUyNC9EQ1wiO1xuICB2YXIgcHJlZml4JDMgPSBcImRjXCI7XG4gIHZhciB0eXBlcyQzID0gW1xuICBcdHtcbiAgXHRcdG5hbWU6IFwiQm9vbGVhblwiXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkludGVnZXJcIlxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJSZWFsXCJcbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiU3RyaW5nXCJcbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiRm9udFwiLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwic2l6ZVwiLFxuICBcdFx0XHRcdHR5cGU6IFwiUmVhbFwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJpc0JvbGRcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaXNJdGFsaWNcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaXNVbmRlcmxpbmVcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkJvb2xlYW5cIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaXNTdHJpa2VUaHJvdWdoXCIsXG4gIFx0XHRcdFx0dHlwZTogXCJCb29sZWFuXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiUG9pbnRcIixcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwieFwiLFxuICBcdFx0XHRcdHR5cGU6IFwiUmVhbFwiLFxuICBcdFx0XHRcdFwiZGVmYXVsdFwiOiBcIjBcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwieVwiLFxuICBcdFx0XHRcdHR5cGU6IFwiUmVhbFwiLFxuICBcdFx0XHRcdFwiZGVmYXVsdFwiOiBcIjBcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJCb3VuZHNcIixcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwieFwiLFxuICBcdFx0XHRcdHR5cGU6IFwiUmVhbFwiLFxuICBcdFx0XHRcdFwiZGVmYXVsdFwiOiBcIjBcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwieVwiLFxuICBcdFx0XHRcdHR5cGU6IFwiUmVhbFwiLFxuICBcdFx0XHRcdFwiZGVmYXVsdFwiOiBcIjBcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwid2lkdGhcIixcbiAgXHRcdFx0XHR0eXBlOiBcIlJlYWxcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaGVpZ2h0XCIsXG4gIFx0XHRcdFx0dHlwZTogXCJSZWFsXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9XG4gIF07XG4gIHZhciBhc3NvY2lhdGlvbnMkMyA9IFtcbiAgXTtcbiAgdmFyIERjUGFja2FnZSA9IHtcbiAgXHRuYW1lOiBuYW1lJDMsXG4gIFx0dXJpOiB1cmkkMyxcbiAgXHRwcmVmaXg6IHByZWZpeCQzLFxuICBcdHR5cGVzOiB0eXBlcyQzLFxuICBcdGFzc29jaWF0aW9uczogYXNzb2NpYXRpb25zJDNcbiAgfTtcblxuICB2YXIgbmFtZSQyID0gXCJESVwiO1xuICB2YXIgdXJpJDIgPSBcImh0dHA6Ly93d3cub21nLm9yZy9zcGVjL0RELzIwMTAwNTI0L0RJXCI7XG4gIHZhciBwcmVmaXgkMiA9IFwiZGlcIjtcbiAgdmFyIHR5cGVzJDIgPSBbXG4gIFx0e1xuICBcdFx0bmFtZTogXCJEaWFncmFtRWxlbWVudFwiLFxuICBcdFx0aXNBYnN0cmFjdDogdHJ1ZSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiaWRcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0aXNJZDogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImV4dGVuc2lvblwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRXh0ZW5zaW9uXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwib3duaW5nRGlhZ3JhbVwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRGlhZ3JhbVwiLFxuICBcdFx0XHRcdGlzUmVhZE9ubHk6IHRydWUsXG4gIFx0XHRcdFx0aXNWaXJ0dWFsOiB0cnVlLFxuICBcdFx0XHRcdGlzUmVmZXJlbmNlOiB0cnVlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm93bmluZ0VsZW1lbnRcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkRpYWdyYW1FbGVtZW50XCIsXG4gIFx0XHRcdFx0aXNSZWFkT25seTogdHJ1ZSxcbiAgXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwibW9kZWxFbGVtZW50XCIsXG4gIFx0XHRcdFx0aXNSZWFkT25seTogdHJ1ZSxcbiAgXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJFbGVtZW50XCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwic3R5bGVcIixcbiAgXHRcdFx0XHR0eXBlOiBcIlN0eWxlXCIsXG4gIFx0XHRcdFx0aXNSZWFkT25seTogdHJ1ZSxcbiAgXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwib3duZWRFbGVtZW50XCIsXG4gIFx0XHRcdFx0dHlwZTogXCJEaWFncmFtRWxlbWVudFwiLFxuICBcdFx0XHRcdGlzUmVhZE9ubHk6IHRydWUsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlLFxuICBcdFx0XHRcdGlzVmlydHVhbDogdHJ1ZVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIk5vZGVcIixcbiAgXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiRGlhZ3JhbUVsZW1lbnRcIlxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJFZGdlXCIsXG4gIFx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIkRpYWdyYW1FbGVtZW50XCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInNvdXJjZVwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRGlhZ3JhbUVsZW1lbnRcIixcbiAgXHRcdFx0XHRpc1JlYWRPbmx5OiB0cnVlLFxuICBcdFx0XHRcdGlzVmlydHVhbDogdHJ1ZSxcbiAgXHRcdFx0XHRpc1JlZmVyZW5jZTogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJ0YXJnZXRcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkRpYWdyYW1FbGVtZW50XCIsXG4gIFx0XHRcdFx0aXNSZWFkT25seTogdHJ1ZSxcbiAgXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWUsXG4gIFx0XHRcdFx0aXNSZWZlcmVuY2U6IHRydWVcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwid2F5cG9pbnRcIixcbiAgXHRcdFx0XHRpc1VuaXF1ZTogZmFsc2UsXG4gIFx0XHRcdFx0aXNNYW55OiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiZGM6UG9pbnRcIixcbiAgXHRcdFx0XHR4bWw6IHtcbiAgXHRcdFx0XHRcdHNlcmlhbGl6ZTogXCJ4c2k6dHlwZVwiXG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkRpYWdyYW1cIixcbiAgXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImlkXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzSWQ6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJyb290RWxlbWVudFwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRGlhZ3JhbUVsZW1lbnRcIixcbiAgXHRcdFx0XHRpc1JlYWRPbmx5OiB0cnVlLFxuICBcdFx0XHRcdGlzVmlydHVhbDogdHJ1ZVxuICBcdFx0XHR9LFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJuYW1lXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZG9jdW1lbnRhdGlvblwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInJlc29sdXRpb25cIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJSZWFsXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwib3duZWRTdHlsZVwiLFxuICBcdFx0XHRcdHR5cGU6IFwiU3R5bGVcIixcbiAgXHRcdFx0XHRpc1JlYWRPbmx5OiB0cnVlLFxuICBcdFx0XHRcdGlzTWFueTogdHJ1ZSxcbiAgXHRcdFx0XHRpc1ZpcnR1YWw6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJTaGFwZVwiLFxuICBcdFx0aXNBYnN0cmFjdDogdHJ1ZSxcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJOb2RlXCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImJvdW5kc1wiLFxuICBcdFx0XHRcdHR5cGU6IFwiZGM6Qm91bmRzXCJcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJQbGFuZVwiLFxuICBcdFx0aXNBYnN0cmFjdDogdHJ1ZSxcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJOb2RlXCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInBsYW5lRWxlbWVudFwiLFxuICBcdFx0XHRcdHR5cGU6IFwiRGlhZ3JhbUVsZW1lbnRcIixcbiAgXHRcdFx0XHRzdWJzZXR0ZWRQcm9wZXJ0eTogXCJEaWFncmFtRWxlbWVudC1vd25lZEVsZW1lbnRcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWVcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH0sXG4gIFx0e1xuICBcdFx0bmFtZTogXCJMYWJlbGVkRWRnZVwiLFxuICBcdFx0aXNBYnN0cmFjdDogdHJ1ZSxcbiAgXHRcdHN1cGVyQ2xhc3M6IFtcbiAgXHRcdFx0XCJFZGdlXCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm93bmVkTGFiZWxcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkxhYmVsXCIsXG4gIFx0XHRcdFx0aXNSZWFkT25seTogdHJ1ZSxcbiAgXHRcdFx0XHRzdWJzZXR0ZWRQcm9wZXJ0eTogXCJEaWFncmFtRWxlbWVudC1vd25lZEVsZW1lbnRcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0aXNWaXJ0dWFsOiB0cnVlXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiTGFiZWxlZFNoYXBlXCIsXG4gIFx0XHRpc0Fic3RyYWN0OiB0cnVlLFxuICBcdFx0c3VwZXJDbGFzczogW1xuICBcdFx0XHRcIlNoYXBlXCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcIm93bmVkTGFiZWxcIixcbiAgXHRcdFx0XHR0eXBlOiBcIkxhYmVsXCIsXG4gIFx0XHRcdFx0aXNSZWFkT25seTogdHJ1ZSxcbiAgXHRcdFx0XHRzdWJzZXR0ZWRQcm9wZXJ0eTogXCJEaWFncmFtRWxlbWVudC1vd25lZEVsZW1lbnRcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0aXNWaXJ0dWFsOiB0cnVlXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiTGFiZWxcIixcbiAgXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG4gIFx0XHRzdXBlckNsYXNzOiBbXG4gIFx0XHRcdFwiTm9kZVwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJib3VuZHNcIixcbiAgXHRcdFx0XHR0eXBlOiBcImRjOkJvdW5kc1wiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiU3R5bGVcIixcbiAgXHRcdGlzQWJzdHJhY3Q6IHRydWUsXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImlkXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdGlzSWQ6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRuYW1lOiBcIkV4dGVuc2lvblwiLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJ2YWx1ZXNcIixcbiAgXHRcdFx0XHRpc01hbnk6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJFbGVtZW50XCJcbiAgXHRcdFx0fVxuICBcdFx0XVxuICBcdH1cbiAgXTtcbiAgdmFyIGFzc29jaWF0aW9ucyQyID0gW1xuICBdO1xuICB2YXIgeG1sID0ge1xuICBcdHRhZ0FsaWFzOiBcImxvd2VyQ2FzZVwiXG4gIH07XG4gIHZhciBEaVBhY2thZ2UgPSB7XG4gIFx0bmFtZTogbmFtZSQyLFxuICBcdHVyaTogdXJpJDIsXG4gIFx0cHJlZml4OiBwcmVmaXgkMixcbiAgXHR0eXBlczogdHlwZXMkMixcbiAgXHRhc3NvY2lhdGlvbnM6IGFzc29jaWF0aW9ucyQyLFxuICBcdHhtbDogeG1sXG4gIH07XG5cbiAgdmFyIG5hbWUkMSA9IFwiYnBtbi5pbyBjb2xvcnMgZm9yIEJQTU5cIjtcbiAgdmFyIHVyaSQxID0gXCJodHRwOi8vYnBtbi5pby9zY2hlbWEvYnBtbi9iaW9jb2xvci8xLjBcIjtcbiAgdmFyIHByZWZpeCQxID0gXCJiaW9jXCI7XG4gIHZhciB0eXBlcyQxID0gW1xuICBcdHtcbiAgXHRcdG5hbWU6IFwiQ29sb3JlZFNoYXBlXCIsXG4gIFx0XHRcImV4dGVuZHNcIjogW1xuICBcdFx0XHRcImJwbW5kaTpCUE1OU2hhcGVcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwic3Ryb2tlXCIsXG4gIFx0XHRcdFx0aXNBdHRyOiB0cnVlLFxuICBcdFx0XHRcdHR5cGU6IFwiU3RyaW5nXCJcbiAgXHRcdFx0fSxcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiZmlsbFwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiQ29sb3JlZEVkZ2VcIixcbiAgXHRcdFwiZXh0ZW5kc1wiOiBbXG4gIFx0XHRcdFwiYnBtbmRpOkJQTU5FZGdlXCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcInN0cm9rZVwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImZpbGxcIixcbiAgXHRcdFx0XHRpc0F0dHI6IHRydWUsXG4gIFx0XHRcdFx0dHlwZTogXCJTdHJpbmdcIlxuICBcdFx0XHR9XG4gIFx0XHRdXG4gIFx0fVxuICBdO1xuICB2YXIgZW51bWVyYXRpb25zJDEgPSBbXG4gIF07XG4gIHZhciBhc3NvY2lhdGlvbnMkMSA9IFtcbiAgXTtcbiAgdmFyIEJpb2NQYWNrYWdlID0ge1xuICBcdG5hbWU6IG5hbWUkMSxcbiAgXHR1cmk6IHVyaSQxLFxuICBcdHByZWZpeDogcHJlZml4JDEsXG4gIFx0dHlwZXM6IHR5cGVzJDEsXG4gIFx0ZW51bWVyYXRpb25zOiBlbnVtZXJhdGlvbnMkMSxcbiAgXHRhc3NvY2lhdGlvbnM6IGFzc29jaWF0aW9ucyQxXG4gIH07XG5cbiAgdmFyIG5hbWUgPSBcIkJQTU4gaW4gQ29sb3JcIjtcbiAgdmFyIHVyaSA9IFwiaHR0cDovL3d3dy5vbWcub3JnL3NwZWMvQlBNTi9ub24tbm9ybWF0aXZlL2NvbG9yLzEuMFwiO1xuICB2YXIgcHJlZml4ID0gXCJjb2xvclwiO1xuICB2YXIgdHlwZXMgPSBbXG4gIFx0e1xuICBcdFx0bmFtZTogXCJDb2xvcmVkTGFiZWxcIixcbiAgXHRcdFwiZXh0ZW5kc1wiOiBbXG4gIFx0XHRcdFwiYnBtbmRpOkJQTU5MYWJlbFwiXG4gIFx0XHRdLFxuICBcdFx0cHJvcGVydGllczogW1xuICBcdFx0XHR7XG4gIFx0XHRcdFx0bmFtZTogXCJjb2xvclwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiQ29sb3JlZFNoYXBlXCIsXG4gIFx0XHRcImV4dGVuZHNcIjogW1xuICBcdFx0XHRcImJwbW5kaTpCUE1OU2hhcGVcIlxuICBcdFx0XSxcbiAgXHRcdHByb3BlcnRpZXM6IFtcbiAgXHRcdFx0e1xuICBcdFx0XHRcdG5hbWU6IFwiYmFja2dyb3VuZC1jb2xvclwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH0sXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImJvcmRlci1jb2xvclwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9LFxuICBcdHtcbiAgXHRcdG5hbWU6IFwiQ29sb3JlZEVkZ2VcIixcbiAgXHRcdFwiZXh0ZW5kc1wiOiBbXG4gIFx0XHRcdFwiYnBtbmRpOkJQTU5FZGdlXCJcbiAgXHRcdF0sXG4gIFx0XHRwcm9wZXJ0aWVzOiBbXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRuYW1lOiBcImJvcmRlci1jb2xvclwiLFxuICBcdFx0XHRcdGlzQXR0cjogdHJ1ZSxcbiAgXHRcdFx0XHR0eXBlOiBcIlN0cmluZ1wiXG4gIFx0XHRcdH1cbiAgXHRcdF1cbiAgXHR9XG4gIF07XG4gIHZhciBlbnVtZXJhdGlvbnMgPSBbXG4gIF07XG4gIHZhciBhc3NvY2lhdGlvbnMgPSBbXG4gIF07XG4gIHZhciBCcG1uSW5Db2xvclBhY2thZ2UgPSB7XG4gIFx0bmFtZTogbmFtZSxcbiAgXHR1cmk6IHVyaSxcbiAgXHRwcmVmaXg6IHByZWZpeCxcbiAgXHR0eXBlczogdHlwZXMsXG4gIFx0ZW51bWVyYXRpb25zOiBlbnVtZXJhdGlvbnMsXG4gIFx0YXNzb2NpYXRpb25zOiBhc3NvY2lhdGlvbnNcbiAgfTtcblxuICBjb25zdCBwYWNrYWdlcyA9IHtcclxuICAgIGJwbW46IEJwbW5QYWNrYWdlLFxyXG4gICAgYnBtbmRpOiBCcG1uRGlQYWNrYWdlLFxyXG4gICAgZGM6IERjUGFja2FnZSxcclxuICAgIGRpOiBEaVBhY2thZ2UsXHJcbiAgICBiaW9jOiBCaW9jUGFja2FnZSxcclxuICAgIGNvbG9yOiBCcG1uSW5Db2xvclBhY2thZ2VcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBTaW1wbGVCcG1uTW9kZGxlKGFkZGl0aW9uYWxQYWNrYWdlcywgb3B0aW9ucykge1xyXG4gICAgY29uc3QgcGtzID0gYXNzaWduJDEoe30sIHBhY2thZ2VzLCBhZGRpdGlvbmFsUGFja2FnZXMpO1xyXG5cclxuICAgIHJldHVybiBuZXcgQnBtbk1vZGRsZShwa3MsIG9wdGlvbnMpO1xyXG4gIH1cblxuICAvKipcclxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9tb2RlbC9UeXBlcycpLk1vZGRsZUVsZW1lbnR9IE1vZGRsZUVsZW1lbnRcclxuICAgKi9cclxuXHJcblxyXG4gIC8vIFRPRE8obmlra3UpOiByZW1vdmUgd2l0aCBmdXR1cmUgYnBtbi1qcyB2ZXJzaW9uXHJcblxyXG4gIHZhciBESV9FUlJPUl9NRVNTQUdFID0gJ1RyaWVkIHRvIGFjY2VzcyBkaSBmcm9tIHRoZSBidXNpbmVzc09iamVjdC4gVGhlIGRpIGlzIGF2YWlsYWJsZSB0aHJvdWdoIHRoZSBkaWFncmFtIGVsZW1lbnQgb25seS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYnBtbi1pby9icG1uLWpzL2lzc3Vlcy8xNDcyJztcclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gYnVzaW5lc3NPYmplY3RcclxuICAgKi9cclxuICBmdW5jdGlvbiBlbnN1cmVDb21wYXREaVJlZihidXNpbmVzc09iamVjdCkge1xyXG5cclxuICAgIC8vIGJwbW5FbGVtZW50IGNhbiBoYXZlIG11bHRpcGxlIGluZGVwZW5kZW50IERJc1xyXG4gICAgaWYgKCFoYXMkMShidXNpbmVzc09iamVjdCwgJ2RpJykpIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGJ1c2luZXNzT2JqZWN0LCAnZGknLCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihESV9FUlJPUl9NRVNTQUdFKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cblxuICAvKipcclxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9tb2RlbC9UeXBlcycpLk1vZGRsZUVsZW1lbnR9IE1vZGRsZUVsZW1lbnRcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIGFuIGVsZW1lbnQgaXMgb2YgdGhlIGdpdmVuIG1ldGEtbW9kZWwgdHlwZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGlzKGVsZW1lbnQsIHR5cGUpIHtcclxuICAgIHJldHVybiBlbGVtZW50LiRpbnN0YW5jZU9mKHR5cGUpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbmQgYSBzdWl0YWJsZSBkaXNwbGF5IGNhbmRpZGF0ZSBmb3IgZGVmaW5pdGlvbnMgd2hlcmUgdGhlIERJIGRvZXMgbm90XHJcbiAgICogY29ycmVjdGx5IHNwZWNpZnkgb25lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBkZWZpbml0aW9uc1xyXG4gICAqXHJcbiAgICogQHJldHVybiB7TW9kZGxlRWxlbWVudH1cclxuICAgKi9cclxuICBmdW5jdGlvbiBmaW5kRGlzcGxheUNhbmRpZGF0ZShkZWZpbml0aW9ucykge1xyXG4gICAgcmV0dXJuIGZpbmQoZGVmaW5pdGlvbnMucm9vdEVsZW1lbnRzLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgIHJldHVybiBpcyhlLCAnYnBtbjpQcm9jZXNzJykgfHwgaXMoZSwgJ2JwbW46Q29sbGFib3JhdGlvbicpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1JlY29yZDwnZWxlbWVudCcgfCAncm9vdCcgfCAnZXJyb3InLCBGdW5jdGlvbj59IGhhbmRsZXJcclxuICAgKi9cclxuICBmdW5jdGlvbiBCcG1uVHJlZVdhbGtlcihoYW5kbGVyKSB7XHJcblxyXG4gICAgLy8gbGlzdCBvZiBjb250YWluZXJzIGFscmVhZHkgd2Fsa2VkXHJcbiAgICB2YXIgaGFuZGxlZEVsZW1lbnRzID0ge307XHJcblxyXG4gICAgLy8gbGlzdCBvZiBlbGVtZW50cyB0byBoYW5kbGUgZGVmZXJyZWQgdG8gZW5zdXJlXHJcbiAgICAvLyBwcmVyZXF1aXNpdGVzIGFyZSBkcmF3blxyXG4gICAgdmFyIGRlZmVycmVkID0gW107XHJcblxyXG4gICAgdmFyIGRpTWFwID0ge307XHJcblxyXG4gICAgLy8gSGVscGVycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4gICAgZnVuY3Rpb24gY29udGV4dHVhbChmbiwgY3R4KSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgZm4oZSwgY3R4KTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVkKGVsZW1lbnQpIHtcclxuICAgICAgaGFuZGxlZEVsZW1lbnRzW2VsZW1lbnQuaWRdID0gZWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0hhbmRsZWQoZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gaGFuZGxlZEVsZW1lbnRzW2VsZW1lbnQuaWRdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHZpc2l0KGVsZW1lbnQsIGN0eCkge1xyXG5cclxuICAgICAgdmFyIGdmeCA9IGVsZW1lbnQuZ2Z4O1xyXG5cclxuICAgICAgLy8gYXZvaWQgbXVsdGlwbGUgcmVuZGVyaW5nIG9mIGVsZW1lbnRzXHJcbiAgICAgIGlmIChnZngpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICBgYWxyZWFkeSByZW5kZXJlZCAkeyBlbGVtZW50VG9TdHJpbmcoZWxlbWVudCkgfWBcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBjYWxsIGhhbmRsZXJcclxuICAgICAgcmV0dXJuIGhhbmRsZXIuZWxlbWVudChlbGVtZW50LCBkaU1hcFtlbGVtZW50LmlkXSwgY3R4KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB2aXNpdFJvb3QoZWxlbWVudCwgZGlhZ3JhbSkge1xyXG4gICAgICByZXR1cm4gaGFuZGxlci5yb290KGVsZW1lbnQsIGRpTWFwW2VsZW1lbnQuaWRdLCBkaWFncmFtKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB2aXNpdElmRGkoZWxlbWVudCwgY3R4KSB7XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHZhciBnZnggPSBkaU1hcFtlbGVtZW50LmlkXSAmJiB2aXNpdChlbGVtZW50LCBjdHgpO1xyXG5cclxuICAgICAgICBoYW5kbGVkKGVsZW1lbnQpO1xyXG5cclxuICAgICAgICByZXR1cm4gZ2Z4O1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGxvZ0Vycm9yKGVycm9yLm1lc3NhZ2UsIHsgZWxlbWVudCwgZXJyb3IgfSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYGZhaWxlZCB0byBpbXBvcnQgJHsgZWxlbWVudFRvU3RyaW5nKGVsZW1lbnQpIH1gLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2dFcnJvcihtZXNzYWdlLCBjb250ZXh0KSB7XHJcbiAgICAgIGhhbmRsZXIuZXJyb3IobWVzc2FnZSwgY29udGV4dCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gREkgaGFuZGxpbmcgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuICAgIHZhciByZWdpc3RlckRpID0gdGhpcy5yZWdpc3RlckRpID0gZnVuY3Rpb24gcmVnaXN0ZXJEaShkaSkge1xyXG4gICAgICB2YXIgYnBtbkVsZW1lbnQgPSBkaS5icG1uRWxlbWVudDtcclxuXHJcbiAgICAgIGlmIChicG1uRWxlbWVudCkge1xyXG4gICAgICAgIGlmIChkaU1hcFticG1uRWxlbWVudC5pZF0pIHtcclxuICAgICAgICAgIGxvZ0Vycm9yKFxyXG4gICAgICAgICAgICBgbXVsdGlwbGUgREkgZWxlbWVudHMgZGVmaW5lZCBmb3IgJHsgZWxlbWVudFRvU3RyaW5nKGJwbW5FbGVtZW50KSB9YCxcclxuICAgICAgICAgICAgeyBlbGVtZW50OiBicG1uRWxlbWVudCB9XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkaU1hcFticG1uRWxlbWVudC5pZF0gPSBkaTtcclxuXHJcbiAgICAgICAgICBlbnN1cmVDb21wYXREaVJlZihicG1uRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxvZ0Vycm9yKFxyXG4gICAgICAgICAgYG5vIGJwbW5FbGVtZW50IHJlZmVyZW5jZWQgaW4gJHsgZWxlbWVudFRvU3RyaW5nKGRpKSB9YCxcclxuICAgICAgICAgIHsgZWxlbWVudDogZGkgfVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlRGlhZ3JhbShkaWFncmFtKSB7XHJcbiAgICAgIGhhbmRsZVBsYW5lKGRpYWdyYW0ucGxhbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVBsYW5lKHBsYW5lKSB7XHJcbiAgICAgIHJlZ2lzdGVyRGkocGxhbmUpO1xyXG5cclxuICAgICAgZm9yRWFjaCQxKHBsYW5lLnBsYW5lRWxlbWVudCwgaGFuZGxlUGxhbmVFbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVQbGFuZUVsZW1lbnQocGxhbmVFbGVtZW50KSB7XHJcbiAgICAgIHJlZ2lzdGVyRGkocGxhbmVFbGVtZW50KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gU2VtYW50aWMgaGFuZGxpbmcgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIGRlZmluaXRpb25zIGFuZCByZXR1cm4gdGhlIHJlbmRlcmVkIGRpYWdyYW0gKGlmIGFueSkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBkZWZpbml0aW9ucyB0byB3YWxrIGFuZCBpbXBvcnRcclxuICAgICAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gW2RpYWdyYW1dIHNwZWNpZmljIGRpYWdyYW0gdG8gaW1wb3J0IGFuZCBkaXNwbGF5XHJcbiAgICAgKlxyXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGRpYWdyYW0gdG8gZGlzcGxheSBjb3VsZCBiZSBmb3VuZFxyXG4gICAgICovXHJcbiAgICB0aGlzLmhhbmRsZURlZmluaXRpb25zID0gZnVuY3Rpb24gaGFuZGxlRGVmaW5pdGlvbnMoZGVmaW5pdGlvbnMsIGRpYWdyYW0pIHtcclxuXHJcbiAgICAgIC8vIG1ha2Ugc3VyZSB3ZSB3YWxrIHRoZSBjb3JyZWN0IGJwbW5FbGVtZW50XHJcblxyXG4gICAgICB2YXIgZGlhZ3JhbXMgPSBkZWZpbml0aW9ucy5kaWFncmFtcztcclxuXHJcbiAgICAgIGlmIChkaWFncmFtICYmIGRpYWdyYW1zLmluZGV4T2YoZGlhZ3JhbSkgPT09IC0xKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWFncmFtIG5vdCBwYXJ0IG9mIDxicG1uOkRlZmluaXRpb25zIC8+Jyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghZGlhZ3JhbSAmJiBkaWFncmFtcyAmJiBkaWFncmFtcy5sZW5ndGgpIHtcclxuICAgICAgICBkaWFncmFtID0gZGlhZ3JhbXNbMF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIG5vIGRpYWdyYW0gLT4gbm90aGluZyB0byBpbXBvcnRcclxuICAgICAgaWYgKCFkaWFncmFtKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBkaWFncmFtIHRvIGRpc3BsYXknKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gbG9hZCBESSBmcm9tIHNlbGVjdGVkIGRpYWdyYW0gb25seVxyXG4gICAgICBkaU1hcCA9IHt9O1xyXG4gICAgICBoYW5kbGVEaWFncmFtKGRpYWdyYW0pO1xyXG5cclxuXHJcbiAgICAgIHZhciBwbGFuZSA9IGRpYWdyYW0ucGxhbmU7XHJcblxyXG4gICAgICBpZiAoIXBsYW5lKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgYG5vIHBsYW5lIGZvciAkeyBlbGVtZW50VG9TdHJpbmcoZGlhZ3JhbSkgfWBcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSBwbGFuZS5icG1uRWxlbWVudDtcclxuXHJcbiAgICAgIC8vIGVuc3VyZSB3ZSBkZWZhdWx0IHRvIGEgc3VpdGFibGUgZGlzcGxheSBjYW5kaWRhdGUgKHByb2Nlc3Mgb3IgY29sbGFib3JhdGlvbiksXHJcbiAgICAgIC8vIGV2ZW4gaWYgbm9uIGlzIHNwZWNpZmllZCBpbiBESVxyXG4gICAgICBpZiAoIXJvb3RFbGVtZW50KSB7XHJcbiAgICAgICAgcm9vdEVsZW1lbnQgPSBmaW5kRGlzcGxheUNhbmRpZGF0ZShkZWZpbml0aW9ucyk7XHJcblxyXG4gICAgICAgIGlmICghcm9vdEVsZW1lbnQpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gcHJvY2VzcyBvciBjb2xsYWJvcmF0aW9uIHRvIGRpc3BsYXknKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGxvZ0Vycm9yKFxyXG4gICAgICAgICAgICBgY29ycmVjdGluZyBtaXNzaW5nIGJwbW5FbGVtZW50IG9uICR7IGVsZW1lbnRUb1N0cmluZyhwbGFuZSkgfSB0byAkeyBlbGVtZW50VG9TdHJpbmcocm9vdEVsZW1lbnQpIH1gXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIC8vIGNvcnJlY3QgREkgb24gdGhlIGZseVxyXG4gICAgICAgICAgcGxhbmUuYnBtbkVsZW1lbnQgPSByb290RWxlbWVudDtcclxuICAgICAgICAgIHJlZ2lzdGVyRGkocGxhbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIHZhciBjdHggPSB2aXNpdFJvb3Qocm9vdEVsZW1lbnQsIHBsYW5lKTtcclxuXHJcbiAgICAgIGlmIChpcyhyb290RWxlbWVudCwgJ2JwbW46UHJvY2VzcycpIHx8IGlzKHJvb3RFbGVtZW50LCAnYnBtbjpTdWJQcm9jZXNzJykpIHtcclxuICAgICAgICBoYW5kbGVQcm9jZXNzKHJvb3RFbGVtZW50LCBjdHgpO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzKHJvb3RFbGVtZW50LCAnYnBtbjpDb2xsYWJvcmF0aW9uJykpIHtcclxuICAgICAgICBoYW5kbGVDb2xsYWJvcmF0aW9uKHJvb3RFbGVtZW50LCBjdHgpO1xyXG5cclxuICAgICAgICAvLyBmb3JjZSBkcmF3aW5nIG9mIGV2ZXJ5dGhpbmcgbm90IHlldCBkcmF3biB0aGF0IGlzIHBhcnQgb2YgdGhlIHRhcmdldCBESVxyXG4gICAgICAgIGhhbmRsZVVuaGFuZGxlZFByb2Nlc3NlcyhkZWZpbml0aW9ucy5yb290RWxlbWVudHMsIGN0eCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgYHVuc3VwcG9ydGVkIGJwbW5FbGVtZW50IGZvciAkeyBlbGVtZW50VG9TdHJpbmcocGxhbmUpIH06ICR7IGVsZW1lbnRUb1N0cmluZyhyb290RWxlbWVudCkgfWBcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBoYW5kbGUgYWxsIGRlZmVycmVkIGVsZW1lbnRzXHJcbiAgICAgIGhhbmRsZURlZmVycmVkKGRlZmVycmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGhhbmRsZURlZmVycmVkID0gdGhpcy5oYW5kbGVEZWZlcnJlZCA9IGZ1bmN0aW9uIGhhbmRsZURlZmVycmVkKCkge1xyXG5cclxuICAgICAgdmFyIGZuO1xyXG5cclxuICAgICAgLy8gZHJhaW4gZGVmZXJyZWQgdW50aWwgZW1wdHlcclxuICAgICAgd2hpbGUgKGRlZmVycmVkLmxlbmd0aCkge1xyXG4gICAgICAgIGZuID0gZGVmZXJyZWQuc2hpZnQoKTtcclxuXHJcbiAgICAgICAgZm4oKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVQcm9jZXNzKHByb2Nlc3MsIGNvbnRleHQpIHtcclxuICAgICAgaGFuZGxlRmxvd0VsZW1lbnRzQ29udGFpbmVyKHByb2Nlc3MsIGNvbnRleHQpO1xyXG4gICAgICBoYW5kbGVJb1NwZWNpZmljYXRpb24ocHJvY2Vzcy5pb1NwZWNpZmljYXRpb24sIGNvbnRleHQpO1xyXG5cclxuICAgICAgaGFuZGxlQXJ0aWZhY3RzKHByb2Nlc3MuYXJ0aWZhY3RzLCBjb250ZXh0KTtcclxuXHJcbiAgICAgIC8vIGxvZyBwcm9jZXNzIGhhbmRsZWRcclxuICAgICAgaGFuZGxlZChwcm9jZXNzKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVVbmhhbmRsZWRQcm9jZXNzZXMocm9vdEVsZW1lbnRzLCBjdHgpIHtcclxuXHJcbiAgICAgIC8vIHdhbGsgdGhyb3VnaCBhbGwgcHJvY2Vzc2VzIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW4gZHJhd24gYW5kIGRyYXcgdGhlbVxyXG4gICAgICAvLyBpZiB0aGV5IGNvbnRhaW4gbGFuZXMgd2l0aCBESSBpbmZvcm1hdGlvbi5cclxuICAgICAgLy8gd2UgZG8gdGhpcyB0byBwYXNzIHRoZSBmcmVlLWZsb2F0aW5nIGxhbmUgdGVzdCBjYXNlcyBpbiB0aGUgTUlXRyB0ZXN0IHN1aXRlXHJcbiAgICAgIHZhciBwcm9jZXNzZXMgPSBmaWx0ZXIocm9vdEVsZW1lbnRzLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgcmV0dXJuICFpc0hhbmRsZWQoZSkgJiYgaXMoZSwgJ2JwbW46UHJvY2VzcycpICYmIGUubGFuZVNldHM7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcHJvY2Vzc2VzLmZvckVhY2goY29udGV4dHVhbChoYW5kbGVQcm9jZXNzLCBjdHgpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlRmxvdyhtZXNzYWdlRmxvdywgY29udGV4dCkge1xyXG4gICAgICB2aXNpdElmRGkobWVzc2FnZUZsb3csIGNvbnRleHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2VGbG93cyhtZXNzYWdlRmxvd3MsIGNvbnRleHQpIHtcclxuICAgICAgZm9yRWFjaCQxKG1lc3NhZ2VGbG93cywgY29udGV4dHVhbChoYW5kbGVNZXNzYWdlRmxvdywgY29udGV4dCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZURhdGFBc3NvY2lhdGlvbihhc3NvY2lhdGlvbiwgY29udGV4dCkge1xyXG4gICAgICB2aXNpdElmRGkoYXNzb2NpYXRpb24sIGNvbnRleHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZURhdGFJbnB1dChkYXRhSW5wdXQsIGNvbnRleHQpIHtcclxuICAgICAgdmlzaXRJZkRpKGRhdGFJbnB1dCwgY29udGV4dCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlRGF0YU91dHB1dChkYXRhT3V0cHV0LCBjb250ZXh0KSB7XHJcbiAgICAgIHZpc2l0SWZEaShkYXRhT3V0cHV0LCBjb250ZXh0KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVBcnRpZmFjdChhcnRpZmFjdCwgY29udGV4dCkge1xyXG5cclxuICAgICAgLy8gYnBtbjpUZXh0QW5ub3RhdGlvblxyXG4gICAgICAvLyBicG1uOkdyb3VwXHJcbiAgICAgIC8vIGJwbW46QXNzb2NpYXRpb25cclxuXHJcbiAgICAgIHZpc2l0SWZEaShhcnRpZmFjdCwgY29udGV4dCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlQXJ0aWZhY3RzKGFydGlmYWN0cywgY29udGV4dCkge1xyXG5cclxuICAgICAgZm9yRWFjaCQxKGFydGlmYWN0cywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGlmIChpcyhlLCAnYnBtbjpBc3NvY2lhdGlvbicpKSB7XHJcbiAgICAgICAgICBkZWZlcnJlZC5wdXNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBoYW5kbGVBcnRpZmFjdChlLCBjb250ZXh0KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBoYW5kbGVBcnRpZmFjdChlLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZUlvU3BlY2lmaWNhdGlvbihpb1NwZWNpZmljYXRpb24sIGNvbnRleHQpIHtcclxuXHJcbiAgICAgIGlmICghaW9TcGVjaWZpY2F0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3JFYWNoJDEoaW9TcGVjaWZpY2F0aW9uLmRhdGFJbnB1dHMsIGNvbnRleHR1YWwoaGFuZGxlRGF0YUlucHV0LCBjb250ZXh0KSk7XHJcbiAgICAgIGZvckVhY2gkMShpb1NwZWNpZmljYXRpb24uZGF0YU91dHB1dHMsIGNvbnRleHR1YWwoaGFuZGxlRGF0YU91dHB1dCwgY29udGV4dCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBoYW5kbGVTdWJQcm9jZXNzID0gdGhpcy5oYW5kbGVTdWJQcm9jZXNzID0gZnVuY3Rpb24gaGFuZGxlU3ViUHJvY2VzcyhzdWJQcm9jZXNzLCBjb250ZXh0KSB7XHJcbiAgICAgIGhhbmRsZUZsb3dFbGVtZW50c0NvbnRhaW5lcihzdWJQcm9jZXNzLCBjb250ZXh0KTtcclxuICAgICAgaGFuZGxlQXJ0aWZhY3RzKHN1YlByb2Nlc3MuYXJ0aWZhY3RzLCBjb250ZXh0KTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlRmxvd05vZGUoZmxvd05vZGUsIGNvbnRleHQpIHtcclxuICAgICAgdmFyIGNoaWxkQ3R4ID0gdmlzaXRJZkRpKGZsb3dOb2RlLCBjb250ZXh0KTtcclxuXHJcbiAgICAgIGlmIChpcyhmbG93Tm9kZSwgJ2JwbW46U3ViUHJvY2VzcycpKSB7XHJcbiAgICAgICAgaGFuZGxlU3ViUHJvY2VzcyhmbG93Tm9kZSwgY2hpbGRDdHggfHwgY29udGV4dCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpcyhmbG93Tm9kZSwgJ2JwbW46QWN0aXZpdHknKSkge1xyXG4gICAgICAgIGhhbmRsZUlvU3BlY2lmaWNhdGlvbihmbG93Tm9kZS5pb1NwZWNpZmljYXRpb24sIGNvbnRleHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBkZWZlciBoYW5kbGluZyBvZiBhc3NvY2lhdGlvbnNcclxuICAgICAgLy8gYWZmZWN0ZWQgdHlwZXM6XHJcbiAgICAgIC8vXHJcbiAgICAgIC8vICAgKiBicG1uOkFjdGl2aXR5XHJcbiAgICAgIC8vICAgKiBicG1uOlRocm93RXZlbnRcclxuICAgICAgLy8gICAqIGJwbW46Q2F0Y2hFdmVudFxyXG4gICAgICAvL1xyXG4gICAgICBkZWZlcnJlZC5wdXNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGZvckVhY2gkMShmbG93Tm9kZS5kYXRhSW5wdXRBc3NvY2lhdGlvbnMsIGNvbnRleHR1YWwoaGFuZGxlRGF0YUFzc29jaWF0aW9uLCBjb250ZXh0KSk7XHJcbiAgICAgICAgZm9yRWFjaCQxKGZsb3dOb2RlLmRhdGFPdXRwdXRBc3NvY2lhdGlvbnMsIGNvbnRleHR1YWwoaGFuZGxlRGF0YUFzc29jaWF0aW9uLCBjb250ZXh0KSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVNlcXVlbmNlRmxvdyhzZXF1ZW5jZUZsb3csIGNvbnRleHQpIHtcclxuICAgICAgdmlzaXRJZkRpKHNlcXVlbmNlRmxvdywgY29udGV4dCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlRGF0YUVsZW1lbnQoZGF0YU9iamVjdCwgY29udGV4dCkge1xyXG4gICAgICB2aXNpdElmRGkoZGF0YU9iamVjdCwgY29udGV4dCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlTGFuZShsYW5lLCBjb250ZXh0KSB7XHJcblxyXG4gICAgICBkZWZlcnJlZC5wdXNoKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgbmV3Q29udGV4dCA9IHZpc2l0SWZEaShsYW5lLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgaWYgKGxhbmUuY2hpbGRMYW5lU2V0KSB7XHJcbiAgICAgICAgICBoYW5kbGVMYW5lU2V0KGxhbmUuY2hpbGRMYW5lU2V0LCBuZXdDb250ZXh0IHx8IGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2lyZUZsb3dOb2RlUmVmcyhsYW5lKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlTGFuZVNldChsYW5lU2V0LCBjb250ZXh0KSB7XHJcbiAgICAgIGZvckVhY2gkMShsYW5lU2V0LmxhbmVzLCBjb250ZXh0dWFsKGhhbmRsZUxhbmUsIGNvbnRleHQpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVMYW5lU2V0cyhsYW5lU2V0cywgY29udGV4dCkge1xyXG4gICAgICBmb3JFYWNoJDEobGFuZVNldHMsIGNvbnRleHR1YWwoaGFuZGxlTGFuZVNldCwgY29udGV4dCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZUZsb3dFbGVtZW50c0NvbnRhaW5lcihjb250YWluZXIsIGNvbnRleHQpIHtcclxuICAgICAgaGFuZGxlRmxvd0VsZW1lbnRzKGNvbnRhaW5lci5mbG93RWxlbWVudHMsIGNvbnRleHQpO1xyXG5cclxuICAgICAgaWYgKGNvbnRhaW5lci5sYW5lU2V0cykge1xyXG4gICAgICAgIGhhbmRsZUxhbmVTZXRzKGNvbnRhaW5lci5sYW5lU2V0cywgY29udGV4dCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVGbG93RWxlbWVudHMoZmxvd0VsZW1lbnRzLCBjb250ZXh0KSB7XHJcbiAgICAgIGZvckVhY2gkMShmbG93RWxlbWVudHMsIGZ1bmN0aW9uKGZsb3dFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKGlzKGZsb3dFbGVtZW50LCAnYnBtbjpTZXF1ZW5jZUZsb3cnKSkge1xyXG4gICAgICAgICAgZGVmZXJyZWQucHVzaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaGFuZGxlU2VxdWVuY2VGbG93KGZsb3dFbGVtZW50LCBjb250ZXh0KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXMoZmxvd0VsZW1lbnQsICdicG1uOkJvdW5kYXJ5RXZlbnQnKSkge1xyXG4gICAgICAgICAgZGVmZXJyZWQudW5zaGlmdChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaGFuZGxlRmxvd05vZGUoZmxvd0VsZW1lbnQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpcyhmbG93RWxlbWVudCwgJ2JwbW46Rmxvd05vZGUnKSkge1xyXG4gICAgICAgICAgaGFuZGxlRmxvd05vZGUoZmxvd0VsZW1lbnQsIGNvbnRleHQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXMoZmxvd0VsZW1lbnQsICdicG1uOkRhdGFPYmplY3QnKSkgOyBlbHNlIGlmIChpcyhmbG93RWxlbWVudCwgJ2JwbW46RGF0YVN0b3JlUmVmZXJlbmNlJykpIHtcclxuICAgICAgICAgIGhhbmRsZURhdGFFbGVtZW50KGZsb3dFbGVtZW50LCBjb250ZXh0KTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzKGZsb3dFbGVtZW50LCAnYnBtbjpEYXRhT2JqZWN0UmVmZXJlbmNlJykpIHtcclxuICAgICAgICAgIGhhbmRsZURhdGFFbGVtZW50KGZsb3dFbGVtZW50LCBjb250ZXh0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbG9nRXJyb3IoXHJcbiAgICAgICAgICAgIGB1bnJlY29nbml6ZWQgZmxvd0VsZW1lbnQgJHsgZWxlbWVudFRvU3RyaW5nKGZsb3dFbGVtZW50KSB9IGluIGNvbnRleHQgJHsgZWxlbWVudFRvU3RyaW5nKGNvbnRleHQgJiYgY29udGV4dC5idXNpbmVzc09iamVjdCkgfWAsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBlbGVtZW50OiBmbG93RWxlbWVudCxcclxuICAgICAgICAgICAgICBjb250ZXh0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVQYXJ0aWNpcGFudChwYXJ0aWNpcGFudCwgY29udGV4dCkge1xyXG4gICAgICB2YXIgbmV3Q3R4ID0gdmlzaXRJZkRpKHBhcnRpY2lwYW50LCBjb250ZXh0KTtcclxuXHJcbiAgICAgIHZhciBwcm9jZXNzID0gcGFydGljaXBhbnQucHJvY2Vzc1JlZjtcclxuICAgICAgaWYgKHByb2Nlc3MpIHtcclxuICAgICAgICBoYW5kbGVQcm9jZXNzKHByb2Nlc3MsIG5ld0N0eCB8fCBjb250ZXh0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZUNvbGxhYm9yYXRpb24oY29sbGFib3JhdGlvbiwgY29udGV4dCkge1xyXG5cclxuICAgICAgZm9yRWFjaCQxKGNvbGxhYm9yYXRpb24ucGFydGljaXBhbnRzLCBjb250ZXh0dWFsKGhhbmRsZVBhcnRpY2lwYW50LCBjb250ZXh0KSk7XHJcblxyXG4gICAgICBkZWZlcnJlZC5wdXNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGhhbmRsZU1lc3NhZ2VGbG93cyhjb2xsYWJvcmF0aW9uLm1lc3NhZ2VGbG93cywgY29udGV4dCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaGFuZGxlQXJ0aWZhY3RzKGNvbGxhYm9yYXRpb24uYXJ0aWZhY3RzLCBjb250ZXh0KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gd2lyZUZsb3dOb2RlUmVmcyhsYW5lKSB7XHJcblxyXG4gICAgICAvLyB3aXJlIHRoZSB2aXJ0dWFsIGZsb3dOb2RlUmVmcyA8LT4gcmVsYXRpb25zaGlwXHJcbiAgICAgIGZvckVhY2gkMShsYW5lLmZsb3dOb2RlUmVmLCBmdW5jdGlvbihmbG93Tm9kZSkge1xyXG4gICAgICAgIHZhciBsYW5lcyA9IGZsb3dOb2RlLmdldCgnbGFuZXMnKTtcclxuXHJcbiAgICAgICAgaWYgKGxhbmVzKSB7XHJcbiAgICAgICAgICBsYW5lcy5wdXNoKGxhbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxuXG4gIC8qKlxyXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL21vZGVsL1R5cGVzJykuTW9kZGxlRWxlbWVudH0gTW9kZGxlRWxlbWVudFxyXG4gICAqXHJcbiAgICogQHR5cGVkZWYgeyB7XHJcbiAgICogICB3YXJuaW5nczogc3RyaW5nW107XHJcbiAgICogfSB9IEltcG9ydEJQTU5EaWFncmFtUmVzdWx0XHJcbiAgICpcclxuICAgKiBAdHlwZWRlZiB7SW1wb3J0QlBNTkRpYWdyYW1SZXN1bHQgJiBFcnJvcn0gSW1wb3J0QlBNTkRpYWdyYW1FcnJvclxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBJbXBvcnQgdGhlIGRlZmluaXRpb25zIGludG8gYSBkaWFncmFtLlxyXG4gICAqXHJcbiAgICogRXJyb3JzIGFuZCB3YXJuaW5ncyBhcmUgcmVwb3J0ZWQgdGhyb3VnaCB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBkaWFncmFtXHJcbiAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBkZWZpbml0aW9uc1xyXG4gICAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gW2JwbW5EaWFncmFtXSBUaGUgZGlhZ3JhbSB0byBiZSByZW5kZXJlZCAoaWYgbm90XHJcbiAgICogcHJvdmlkZWQsIHRoZSBmaXJzdCBvbmUgd2lsbCBiZSByZW5kZXJlZCkuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEltcG9ydEJQTU5EaWFncmFtUmVzdWx0Pn1cclxuICAgKi9cclxuICBmdW5jdGlvbiBpbXBvcnRCcG1uRGlhZ3JhbShkaWFncmFtLCBkZWZpbml0aW9ucywgYnBtbkRpYWdyYW0pIHtcclxuXHJcbiAgICB2YXIgaW1wb3J0ZXIsXHJcbiAgICAgICAgZXZlbnRCdXMsXHJcbiAgICAgICAgY2FudmFzO1xyXG5cclxuICAgIHZhciBlcnJvcixcclxuICAgICAgICB3YXJuaW5ncyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2FsayB0aGUgZGlhZ3JhbSBzZW1hbnRpY2FsbHksIGltcG9ydGluZyAoPWRyYXdpbmcpXHJcbiAgICAgKiBhbGwgZWxlbWVudHMgeW91IGVuY291bnRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR9IGRlZmluaXRpb25zXHJcbiAgICAgKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR9IGJwbW5EaWFncmFtXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlbmRlcihkZWZpbml0aW9ucywgYnBtbkRpYWdyYW0pIHtcclxuXHJcbiAgICAgIHZhciB2aXNpdG9yID0ge1xyXG5cclxuICAgICAgICByb290OiBmdW5jdGlvbihlbGVtZW50LCBkaSkge1xyXG4gICAgICAgICAgcmV0dXJuIGltcG9ydGVyLmFkZChlbGVtZW50LCBkaSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgZGksIHBhcmVudFNoYXBlKSB7XHJcbiAgICAgICAgICByZXR1cm4gaW1wb3J0ZXIuYWRkKGVsZW1lbnQsIGRpLCBwYXJlbnRTaGFwZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKG1lc3NhZ2UsIGNvbnRleHQpIHtcclxuICAgICAgICAgIHdhcm5pbmdzLnB1c2goeyBtZXNzYWdlOiBtZXNzYWdlLCBjb250ZXh0OiBjb250ZXh0IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciB3YWxrZXIgPSBuZXcgQnBtblRyZWVXYWxrZXIodmlzaXRvcik7XHJcblxyXG5cclxuICAgICAgYnBtbkRpYWdyYW0gPSBicG1uRGlhZ3JhbSB8fCAoZGVmaW5pdGlvbnMuZGlhZ3JhbXMgJiYgZGVmaW5pdGlvbnMuZGlhZ3JhbXNbMF0pO1xyXG5cclxuICAgICAgdmFyIGRpYWdyYW1zVG9JbXBvcnQgPSBnZXREaWFncmFtc1RvSW1wb3J0KGRlZmluaXRpb25zLCBicG1uRGlhZ3JhbSk7XHJcblxyXG4gICAgICBpZiAoIWRpYWdyYW1zVG9JbXBvcnQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGRpYWdyYW0gdG8gZGlzcGxheScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB0cmF2ZXJzZSBCUE1OIDIuMCBkb2N1bWVudCBtb2RlbCxcclxuICAgICAgLy8gc3RhcnRpbmcgYXQgZGVmaW5pdGlvbnNcclxuICAgICAgZm9yRWFjaCQxKGRpYWdyYW1zVG9JbXBvcnQsIGZ1bmN0aW9uKGRpYWdyYW0pIHtcclxuICAgICAgICB3YWxrZXIuaGFuZGxlRGVmaW5pdGlvbnMoZGVmaW5pdGlvbnMsIGRpYWdyYW0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHZhciByb290SWQgPSBicG1uRGlhZ3JhbS5wbGFuZS5icG1uRWxlbWVudC5pZDtcclxuXHJcbiAgICAgIC8vIHdlIGRvIG5lZWQgdG8gYWNjb3VudCBmb3IgZGlmZmVyZW50IHdheXMgd2UgY3JlYXRlIHJvb3QgZWxlbWVudHNcclxuICAgICAgLy8gZWFjaCBuZXN0ZWQgaW1wb3J0ZWQgPHJvb3Q+IGRvIGhhdmUgdGhlIGBfcGxhbmVgIHN1ZmZpeCwgd2hpbGVcclxuICAgICAgLy8gdGhlIHJvb3QgPHJvb3Q+IGlzIGZvdW5kIHVuZGVyIHRoZSBidXNpbmVzcyBvYmplY3QgSURcclxuICAgICAgY2FudmFzLnNldFJvb3RFbGVtZW50KFxyXG4gICAgICAgIGNhbnZhcy5maW5kUm9vdChyb290SWQgKyAnX3BsYW5lJykgfHwgY2FudmFzLmZpbmRSb290KHJvb3RJZClcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaW1wb3J0ZXIgPSBkaWFncmFtLmdldCgnYnBtbkltcG9ydGVyJyk7XHJcbiAgICAgICAgZXZlbnRCdXMgPSBkaWFncmFtLmdldCgnZXZlbnRCdXMnKTtcclxuICAgICAgICBjYW52YXMgPSBkaWFncmFtLmdldCgnY2FudmFzJyk7XHJcblxyXG4gICAgICAgIGV2ZW50QnVzLmZpcmUoJ2ltcG9ydC5yZW5kZXIuc3RhcnQnLCB7IGRlZmluaXRpb25zOiBkZWZpbml0aW9ucyB9KTtcclxuXHJcbiAgICAgICAgcmVuZGVyKGRlZmluaXRpb25zLCBicG1uRGlhZ3JhbSk7XHJcblxyXG4gICAgICAgIGV2ZW50QnVzLmZpcmUoJ2ltcG9ydC5yZW5kZXIuY29tcGxldGUnLCB7XHJcbiAgICAgICAgICBlcnJvcjogZXJyb3IsXHJcbiAgICAgICAgICB3YXJuaW5nczogd2FybmluZ3NcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoeyB3YXJuaW5nczogd2FybmluZ3MgfSk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuXHJcbiAgICAgICAgZS53YXJuaW5ncyA9IHdhcm5pbmdzO1xyXG4gICAgICAgIHJldHVybiByZWplY3QoZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbGwgZGlhZ3JhbXMgaW4gdGhlIHNhbWUgaGllcmFyY2h5IGFzIHRoZSByZXF1ZXN0ZWQgZGlhZ3JhbS5cclxuICAgKiBJbmNsdWRlcyBhbGwgcGFyZW50IGFuZCBzdWIgcHJvY2VzcyBkaWFncmFtcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudH0gZGVmaW5pdGlvbnNcclxuICAgKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR9IGJwbW5EaWFncmFtXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtNb2RkbGVFbGVtZW50W119XHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZ2V0RGlhZ3JhbXNUb0ltcG9ydChkZWZpbml0aW9ucywgYnBtbkRpYWdyYW0pIHtcclxuICAgIGlmICghYnBtbkRpYWdyYW0gfHwgIWJwbW5EaWFncmFtLnBsYW5lKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYnBtbkVsZW1lbnQgPSBicG1uRGlhZ3JhbS5wbGFuZS5icG1uRWxlbWVudCxcclxuICAgICAgICByb290RWxlbWVudCA9IGJwbW5FbGVtZW50O1xyXG5cclxuICAgIGlmICghaXMkMShicG1uRWxlbWVudCwgJ2JwbW46UHJvY2VzcycpICYmICFpcyQxKGJwbW5FbGVtZW50LCAnYnBtbjpDb2xsYWJvcmF0aW9uJykpIHtcclxuICAgICAgcm9vdEVsZW1lbnQgPSBmaW5kUm9vdFByb2Nlc3MoYnBtbkVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGluIGNhc2UgdGhlIHByb2Nlc3MgaXMgcGFydCBvZiBhIGNvbGxhYm9yYXRpb24sIHRoZSBwbGFuZSByZWZlcmVuY2VzIHRoZVxyXG4gICAgLy8gY29sbGFib3JhdGlvbiwgbm90IHRoZSBwcm9jZXNzXHJcbiAgICB2YXIgY29sbGFib3JhdGlvbjtcclxuXHJcbiAgICBpZiAoaXMkMShyb290RWxlbWVudCwgJ2JwbW46Q29sbGFib3JhdGlvbicpKSB7XHJcbiAgICAgIGNvbGxhYm9yYXRpb24gPSByb290RWxlbWVudDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbGxhYm9yYXRpb24gPSBmaW5kKGRlZmluaXRpb25zLnJvb3RFbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICAgIGlmICghaXMkMShlbGVtZW50LCAnYnBtbjpDb2xsYWJvcmF0aW9uJykpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmaW5kKGVsZW1lbnQucGFydGljaXBhbnRzLCBmdW5jdGlvbihwYXJ0aWNpcGFudCkge1xyXG4gICAgICAgICAgcmV0dXJuIHBhcnRpY2lwYW50LnByb2Nlc3NSZWYgPT09IHJvb3RFbGVtZW50O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcm9vdEVsZW1lbnRzID0gWyByb290RWxlbWVudCBdO1xyXG5cclxuICAgIC8vIGFsbCBjb2xsYWJvcmF0aW9uIHByb2Nlc3NlcyBjYW4gY29udGFpbiBzdWItZGlhZ3JhbXNcclxuICAgIGlmIChjb2xsYWJvcmF0aW9uKSB7XHJcbiAgICAgIHJvb3RFbGVtZW50cyA9IG1hcCQxKGNvbGxhYm9yYXRpb24ucGFydGljaXBhbnRzLCBmdW5jdGlvbihwYXJ0aWNpcGFudCkge1xyXG4gICAgICAgIHJldHVybiBwYXJ0aWNpcGFudC5wcm9jZXNzUmVmO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJvb3RFbGVtZW50cy5wdXNoKGNvbGxhYm9yYXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhbGxDaGlsZHJlbiA9IHNlbGZBbmRBbGxGbG93RWxlbWVudHMocm9vdEVsZW1lbnRzKTtcclxuXHJcbiAgICAvLyBpZiB3ZSBoYXZlIG11bHRpcGxlIGRpYWdyYW1zIHJlZmVyZW5jaW5nIHRoZSBzYW1lIGVsZW1lbnQsIHdlXHJcbiAgICAvLyB1c2UgdGhlIGZpcnN0IGluIHRoZSBmaWxlXHJcbiAgICB2YXIgZGlhZ3JhbXNUb0ltcG9ydCA9IFsgYnBtbkRpYWdyYW0gXTtcclxuICAgIHZhciBoYW5kbGVkRWxlbWVudHMgPSBbIGJwbW5FbGVtZW50IF07XHJcblxyXG4gICAgZm9yRWFjaCQxKGRlZmluaXRpb25zLmRpYWdyYW1zLCBmdW5jdGlvbihkaWFncmFtKSB7XHJcblxyXG4gICAgICBpZiAoIWRpYWdyYW0ucGxhbmUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBidXNpbmVzc09iamVjdCA9IGRpYWdyYW0ucGxhbmUuYnBtbkVsZW1lbnQ7XHJcblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgYWxsQ2hpbGRyZW4uaW5kZXhPZihidXNpbmVzc09iamVjdCkgIT09IC0xICYmXHJcbiAgICAgICAgaGFuZGxlZEVsZW1lbnRzLmluZGV4T2YoYnVzaW5lc3NPYmplY3QpID09PSAtMVxyXG4gICAgICApIHtcclxuICAgICAgICBkaWFncmFtc1RvSW1wb3J0LnB1c2goZGlhZ3JhbSk7XHJcbiAgICAgICAgaGFuZGxlZEVsZW1lbnRzLnB1c2goYnVzaW5lc3NPYmplY3QpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgcmV0dXJuIGRpYWdyYW1zVG9JbXBvcnQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzZWxmQW5kQWxsRmxvd0VsZW1lbnRzKGVsZW1lbnRzKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gICAgZm9yRWFjaCQxKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVzdWx0LnB1c2goZWxlbWVudCk7XHJcblxyXG4gICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHNlbGZBbmRBbGxGbG93RWxlbWVudHMoZWxlbWVudC5mbG93RWxlbWVudHMpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmaW5kUm9vdFByb2Nlc3MoZWxlbWVudCkge1xyXG4gICAgdmFyIHBhcmVudCA9IGVsZW1lbnQ7XHJcblxyXG4gICAgd2hpbGUgKHBhcmVudCkge1xyXG4gICAgICBpZiAoaXMkMShwYXJlbnQsICdicG1uOlByb2Nlc3MnKSkge1xyXG4gICAgICAgIHJldHVybiBwYXJlbnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xyXG4gICAgfVxyXG4gIH1cblxuICAvKipcclxuICAgKiBUaGlzIGZpbGUgbXVzdCBub3QgYmUgY2hhbmdlZCBvciBleGNoYW5nZWQuXHJcbiAgICpcclxuICAgKiBAc2VlIGh0dHA6Ly9icG1uLmlvL2xpY2Vuc2UgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAgICovXHJcblxyXG5cclxuXHJcbiAgLy8gaW5saW5lZCAuLi8uLi9yZXNvdXJjZXMvbG9nby5zdmdcclxuICB2YXIgQlBNTklPX0xPR09fU1ZHID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMTQuMDIgNS41N1wiIHdpZHRoPVwiNTNcIiBoZWlnaHQ9XCIyMVwiPjxwYXRoIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBkPVwiTTEuODguOTJ2LjE0YzAgLjQxLS4xMy42OC0uNC44LjMzLjE0LjQ2LjQ0LjQ2Ljg2di4zM2MwIC42MS0uMzMuOTUtLjk1Ljk1SDBWMGguOTVjLjY1IDAgLjkzLjMuOTMuOTJ6TS42My41N3YxLjA2aC4yNGMuMjQgMCAuMzgtLjEuMzgtLjQzVi45OGMwLS4yOC0uMS0uNC0uMzItLjR6bTAgMS42M3YxLjIyaC4zNmMuMiAwIC4zMi0uMS4zMi0uMzl2LS4zNWMwLS4zNy0uMTItLjQ4LS40LS40OEguNjN6TTQuMTguOTl2LjUyYzAgLjY0LS4zMS45OC0uOTQuOThoLS4zVjRoLS42MlYwaC45MmMuNjMgMCAuOTQuMzUuOTQuOTl6TTIuOTQuNTd2MS4zNWguM2MuMiAwIC4zLS4wOS4zLS4zN3YtLjZjMC0uMjktLjEtLjM4LS4zLS4zOGgtLjN6bTIuODkgMi4yN0w2LjI1IDBoLjg4djRoLS42VjEuMTJMNi4xIDMuOTloLS42bC0uNDYtMi44MnYyLjgyaC0uNTVWMGguODd6TTguMTQgMS4xVjRoLS41NlYwaC43OUw5IDIuNFYwaC41NnY0aC0uNjR6bTIuNDkgMi4yOXYuNmgtLjZ2LS42ek0xMi4xMiAxYzAtLjYzLjMzLTEgLjk1LTEgLjYxIDAgLjk1LjM3Ljk1IDF2Mi4wNGMwIC42NC0uMzQgMS0uOTUgMS0uNjIgMC0uOTUtLjM3LS45NS0xem0uNjIgMi4wOGMwIC4yOC4xMy4zOS4zMy4zOXMuMzItLjEuMzItLjRWLjk4YzAtLjI5LS4xMi0uNC0uMzItLjRzLS4zMy4xMS0uMzMuNHpcIi8+PHBhdGggZmlsbD1cImN1cnJlbnRDb2xvclwiIGQ9XCJNMCA0LjUzaDE0LjAydjEuMDRIMHpNMTEuMDggMGguNjN2LjYyaC0uNjN6bS42MyA0VjFoLS42M3YyLjk4elwiLz48L3N2Zz4nO1xyXG5cclxuICB2YXIgQlBNTklPX0lNRyA9IEJQTU5JT19MT0dPX1NWRztcclxuXHJcbiAgdmFyIExPR09fU1RZTEVTID0ge1xyXG4gICAgdmVydGljYWxBbGlnbjogJ21pZGRsZSdcclxuICB9O1xyXG5cclxuICB2YXIgTElOS19TVFlMRVMgPSB7XHJcbiAgICAnY29sb3InOiAnIzQwNDA0MCdcclxuICB9O1xyXG5cclxuICB2YXIgTElHSFRCT1hfU1RZTEVTID0ge1xyXG4gICAgJ3pJbmRleCc6ICcxMDAxJyxcclxuICAgICdwb3NpdGlvbic6ICdmaXhlZCcsXHJcbiAgICAndG9wJzogJzAnLFxyXG4gICAgJ2xlZnQnOiAnMCcsXHJcbiAgICAncmlnaHQnOiAnMCcsXHJcbiAgICAnYm90dG9tJzogJzAnXHJcbiAgfTtcclxuXHJcbiAgdmFyIEJBQ0tEUk9QX1NUWUxFUyA9IHtcclxuICAgICd3aWR0aCc6ICcxMDAlJyxcclxuICAgICdoZWlnaHQnOiAnMTAwJScsXHJcbiAgICAnYmFja2dyb3VuZCc6ICdyZ2JhKDQwLDQwLDQwLDAuMiknXHJcbiAgfTtcclxuXHJcbiAgdmFyIE5PVElDRV9TVFlMRVMgPSB7XHJcbiAgICAncG9zaXRpb24nOiAnYWJzb2x1dGUnLFxyXG4gICAgJ2xlZnQnOiAnNTAlJyxcclxuICAgICd0b3AnOiAnNDAlJyxcclxuICAgICd0cmFuc2Zvcm0nOiAndHJhbnNsYXRlKC01MCUpJyxcclxuICAgICd3aWR0aCc6ICcyNjBweCcsXHJcbiAgICAncGFkZGluZyc6ICcxMHB4JyxcclxuICAgICdiYWNrZ3JvdW5kJzogJ3doaXRlJyxcclxuICAgICdib3hTaGFkb3cnOiAnMCAxcHggNHB4IHJnYmEoMCwwLDAsMC4zKScsXHJcbiAgICAnZm9udEZhbWlseSc6ICdIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmJyxcclxuICAgICdmb250U2l6ZSc6ICcxNHB4JyxcclxuICAgICdkaXNwbGF5JzogJ2ZsZXgnLFxyXG4gICAgJ2xpbmVIZWlnaHQnOiAnMS4zJ1xyXG4gIH07XHJcblxyXG4gIHZhciBMSUdIVEJPWF9NQVJLVVAgPVxyXG4gICAgJzxkaXYgY2xhc3M9XCJianMtcG93ZXJlZC1ieS1saWdodGJveFwiPicgK1xyXG4gICAgICAnPGRpdiBjbGFzcz1cImJhY2tkcm9wXCI+PC9kaXY+JyArXHJcbiAgICAgICc8ZGl2IGNsYXNzPVwibm90aWNlXCI+JyArXHJcbiAgICAgICAgJzxhIGhyZWY9XCJodHRwczovL2JwbW4uaW9cIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub29wZW5lclwiIGNsYXNzPVwibGlua1wiPicgK1xyXG4gICAgICAgICAgQlBNTklPX0lNRyArXHJcbiAgICAgICAgJzwvYT4nICtcclxuICAgICAgICAnPHNwYW4+JyArXHJcbiAgICAgICAgICAnV2ViLWJhc2VkIHRvb2xpbmcgZm9yIEJQTU4sIERNTiBhbmQgZm9ybXMgJyArXHJcbiAgICAgICAgICAncG93ZXJlZCBieSA8YSBocmVmPVwiaHR0cHM6Ly9icG1uLmlvXCIgdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXJcIj5icG1uLmlvPC9hPi4nICtcclxuICAgICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAnPC9kaXY+JyArXHJcbiAgICAnPC9kaXY+JztcclxuXHJcblxyXG4gIHZhciBsaWdodGJveDtcclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlTGlnaHRib3goKSB7XHJcbiAgICBsaWdodGJveCA9IGRvbWlmeSQxKExJR0hUQk9YX01BUktVUCk7XHJcblxyXG4gICAgYXNzaWduKGxpZ2h0Ym94LCBMSUdIVEJPWF9TVFlMRVMpO1xyXG4gICAgYXNzaWduKHF1ZXJ5KCdzdmcnLCBsaWdodGJveCksIExPR09fU1RZTEVTKTtcclxuICAgIGFzc2lnbihxdWVyeSgnLmJhY2tkcm9wJywgbGlnaHRib3gpLCBCQUNLRFJPUF9TVFlMRVMpO1xyXG4gICAgYXNzaWduKHF1ZXJ5KCcubm90aWNlJywgbGlnaHRib3gpLCBOT1RJQ0VfU1RZTEVTKTtcclxuICAgIGFzc2lnbihxdWVyeSgnLmxpbmsnLCBsaWdodGJveCksIExJTktfU1RZTEVTLCB7XHJcbiAgICAgICdtYXJnaW4nOiAnMTVweCAyMHB4IDE1cHggMTBweCcsXHJcbiAgICAgICdhbGlnblNlbGYnOiAnY2VudGVyJ1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvcGVuKCkge1xyXG5cclxuICAgIGlmICghbGlnaHRib3gpIHtcclxuICAgICAgY3JlYXRlTGlnaHRib3goKTtcclxuXHJcbiAgICAgIGRlbGVnYXRlLmJpbmQobGlnaHRib3gsICcuYmFja2Ryb3AnLCAnY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobGlnaHRib3gpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpZ2h0Ym94KTtcclxuICB9XG5cbiAgLyoqXHJcbiAgICogVGhlIGNvZGUgaW4gdGhlIDxwcm9qZWN0LWxvZ28+PC9wcm9qZWN0LWxvZ28+IGFyZWFcclxuICAgKiBtdXN0IG5vdCBiZSBjaGFuZ2VkLlxyXG4gICAqXHJcbiAgICogQHNlZSBodHRwOi8vYnBtbi5pby9saWNlbnNlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAdGVtcGxhdGUgVFxyXG4gICAqXHJcbiAgICogQHR5cGVkZWYgeyBpbXBvcnQoJ2RpYWdyYW0tanMvbGliL2NvcmUvRXZlbnRCdXMnKS5kZWZhdWx0PFQ+IH0gRXZlbnRCdXNcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQHRlbXBsYXRlIFRcclxuICAgKlxyXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJ2RpYWdyYW0tanMvbGliL2NvcmUvRXZlbnRCdXMnKS5FdmVudEJ1c0V2ZW50Q2FsbGJhY2s8VD59IEV2ZW50QnVzRXZlbnRDYWxsYmFja1xyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCdkaWRpJykuTW9kdWxlRGVjbGFyYXRpb259IE1vZHVsZURlY2xhcmF0aW9uXHJcbiAgICpcclxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuL21vZGVsL1R5cGVzJykuTW9kZGxlfSBNb2RkbGVcclxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuL21vZGVsL1R5cGVzJykuTW9kZGxlRWxlbWVudH0gTW9kZGxlRWxlbWVudFxyXG4gICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbW9kZWwvVHlwZXMnKS5Nb2RkbGVFeHRlbnNpb259IE1vZGRsZUV4dGVuc2lvblxyXG4gICAqXHJcbiAgICogQHR5cGVkZWYgeyB7XHJcbiAgICogICB3aWR0aD86IG51bWJlcnxzdHJpbmc7XHJcbiAgICogICBoZWlnaHQ/OiBudW1iZXJ8c3RyaW5nO1xyXG4gICAqICAgcG9zaXRpb24/OiBzdHJpbmc7XHJcbiAgICogICBjb250YWluZXI/OiBzdHJpbmd8SFRNTEVsZW1lbnQ7XHJcbiAgICogICBtb2RkbGVFeHRlbnNpb25zPzogTW9kZGxlRXh0ZW5zaW9ucztcclxuICAgKiAgIGFkZGl0aW9uYWxNb2R1bGVzPzogTW9kdWxlRGVjbGFyYXRpb25bXTtcclxuICAgKiB9ICYgUmVjb3JkPHN0cmluZywgYW55PiB9IEJhc2VWaWV3ZXJPcHRpb25zXHJcbiAgICpcclxuICAgKiBAdHlwZWRlZiB7UmVjb3JkPHN0cmluZywgTW9kZGxlRWxlbWVudD59IE1vZGRsZUVsZW1lbnRzQnlJZFxyXG4gICAqXHJcbiAgICogQHR5cGVkZWYgeyB7XHJcbiAgICogICBba2V5OiBzdHJpbmddOiBNb2RkbGVFeHRlbnNpb247XHJcbiAgICogfSB9IE1vZGRsZUV4dGVuc2lvbnNcclxuICAgKlxyXG4gICAqIEB0eXBlZGVmIHsge1xyXG4gICAqICAgd2FybmluZ3M6IHN0cmluZ1tdO1xyXG4gICAqIH0gfSBJbXBvcnRYTUxSZXN1bHRcclxuICAgKlxyXG4gICAqIEB0eXBlZGVmIHtJbXBvcnRYTUxSZXN1bHQgJiBFcnJvcn0gSW1wb3J0WE1MRXJyb3JcclxuICAgKlxyXG4gICAqIEB0eXBlZGVmIHtJbXBvcnRYTUxSZXN1bHR9IEltcG9ydERlZmluaXRpb25zUmVzdWx0XHJcbiAgICpcclxuICAgKiBAdHlwZWRlZiB7SW1wb3J0WE1MRXJyb3J9IEltcG9ydERlZmluaXRpb25zRXJyb3JcclxuICAgKlxyXG4gICAqIEB0eXBlZGVmIHtJbXBvcnRYTUxSZXN1bHR9IE9wZW5SZXN1bHRcclxuICAgKlxyXG4gICAqIEB0eXBlZGVmIHtJbXBvcnRYTUxFcnJvcn0gT3BlbkVycm9yXHJcbiAgICpcclxuICAgKiBAdHlwZWRlZiB7IHtcclxuICAgKiAgIGZvcm1hdD86IGJvb2xlYW47XHJcbiAgICogICBwcmVhbWJsZT86IGJvb2xlYW47XHJcbiAgICogfSB9IFNhdmVYTUxPcHRpb25zXHJcbiAgICpcclxuICAgKiBAdHlwZWRlZiB7IHtcclxuICAgKiAgIHhtbD86IHN0cmluZztcclxuICAgKiAgIGVycm9yPzogRXJyb3I7XHJcbiAgICogfSB9IFNhdmVYTUxSZXN1bHRcclxuICAgKlxyXG4gICAqIEB0eXBlZGVmIHsge1xyXG4gICAqICAgc3ZnOiBzdHJpbmc7XHJcbiAgICogfSB9IFNhdmVTVkdSZXN1bHRcclxuICAgKlxyXG4gICAqIEB0eXBlZGVmIHsge1xyXG4gICAqICAgeG1sOiBzdHJpbmc7XHJcbiAgICogfSB9IEltcG9ydFBhcnNlU3RhcnRFdmVudFxyXG4gICAqXHJcbiAgICogQHR5cGVkZWYgeyB7XHJcbiAgICogICBlcnJvcj86IEltcG9ydFhNTEVycm9yO1xyXG4gICAqICAgZGVmaW5pdGlvbnM/OiBNb2RkbGVFbGVtZW50O1xyXG4gICAqICAgZWxlbWVudHNCeUlkPzogTW9kZGxlRWxlbWVudHNCeUlkO1xyXG4gICAqICAgcmVmZXJlbmNlcz86IE1vZGRsZUVsZW1lbnRbXTtcclxuICAgKiAgIHdhcm5pbmdzOiBzdHJpbmdbXTtcclxuICAgKiB9IH0gSW1wb3J0UGFyc2VDb21wbGV0ZUV2ZW50XHJcbiAgICpcclxuICAgKiBAdHlwZWRlZiB7IHtcclxuICAgKiAgIGVycm9yPzogSW1wb3J0WE1MRXJyb3I7XHJcbiAgICogICB3YXJuaW5nczogc3RyaW5nW107XHJcbiAgICogfSB9IEltcG9ydERvbmVFdmVudFxyXG4gICAqXHJcbiAgICogQHR5cGVkZWYgeyB7XHJcbiAgICogICBkZWZpbml0aW9uczogTW9kZGxlRWxlbWVudDtcclxuICAgKiB9IH0gU2F2ZVhNTFN0YXJ0RXZlbnRcclxuICAgKlxyXG4gICAqIEB0eXBlZGVmIHtTYXZlWE1MUmVzdWx0fSBTYXZlWE1MRG9uZUV2ZW50XHJcbiAgICpcclxuICAgKiBAdHlwZWRlZiB7IHtcclxuICAgKiAgIGVycm9yPzogRXJyb3I7XHJcbiAgICogICBzdmc6IHN0cmluZztcclxuICAgKiB9IH0gU2F2ZVNWR0RvbmVFdmVudFxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBAdGVtcGxhdGUgVHlwZVxyXG4gICAqXHJcbiAgICogQHR5cGVkZWYgeyBUeXBlIGV4dGVuZHMgeyBldmVudEJ1czogRXZlbnRCdXM8aW5mZXIgWD4gfSA/IFggOiBuZXZlciB9IEV2ZW50TWFwXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEEgYmFzZSB2aWV3ZXIgZm9yIEJQTU4gMi4wIGRpYWdyYW1zLlxyXG4gICAqXHJcbiAgICogSGF2ZSBhIGxvb2sgYXQge0BsaW5rIGJwbW4tanMvbGliL1ZpZXdlcn0sIHtAbGluayBicG1uLWpzL2xpYi9OYXZpZ2F0ZWRWaWV3ZXJ9IG9yIHtAbGluayBicG1uLWpzL2xpYi9Nb2RlbGVyfSBmb3JcclxuICAgKiBidW5kbGVzIHRoYXQgaW5jbHVkZSBhY3R1YWwgZmVhdHVyZXMuXHJcbiAgICpcclxuICAgKiBAdGVtcGxhdGUgW1NlcnZpY2VNYXA9bnVsbF1cclxuICAgKlxyXG4gICAqIEBleHRlbmRzIERpYWdyYW08U2VydmljZU1hcD5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QmFzZVZpZXdlck9wdGlvbnN9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyB0byBjb25maWd1cmUgdGhlIHZpZXdlci5cclxuICAgKi9cclxuICBmdW5jdGlvbiBCYXNlVmlld2VyKG9wdGlvbnMpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtCYXNlVmlld2VyT3B0aW9uc31cclxuICAgICAqL1xyXG4gICAgb3B0aW9ucyA9IGFzc2lnbiQxKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge01vZGRsZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fbW9kZGxlID0gdGhpcy5fY3JlYXRlTW9kZGxlKG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9jb250YWluZXIgPSB0aGlzLl9jcmVhdGVDb250YWluZXIob3B0aW9ucyk7XHJcblxyXG4gICAgdGhpcy5faW5pdCh0aGlzLl9jb250YWluZXIsIHRoaXMuX21vZGRsZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgLyogPHByb2plY3QtbG9nbz4gKi9cclxuXHJcbiAgICBhZGRQcm9qZWN0TG9nbyh0aGlzLl9jb250YWluZXIpO1xyXG5cclxuICAgIC8qIDwvcHJvamVjdC1sb2dvPiAqL1xyXG4gIH1cclxuXHJcbiAgZShCYXNlVmlld2VyLCBEaWFncmFtKTtcclxuXHJcbiAgLyoqXHJcbiAgICogUGFyc2UgYW5kIHJlbmRlciBhIEJQTU4gMi4wIGRpYWdyYW0uXHJcbiAgICpcclxuICAgKiBPbmNlIGZpbmlzaGVkIHRoZSB2aWV3ZXIgcmVwb3J0cyBiYWNrIHRoZSByZXN1bHQgdG8gdGhlXHJcbiAgICogcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCAoZXJyLCB3YXJuaW5ncykuXHJcbiAgICpcclxuICAgKiAjIyBMaWZlLUN5Y2xlIEV2ZW50c1xyXG4gICAqXHJcbiAgICogRHVyaW5nIGltcG9ydCB0aGUgdmlld2VyIHdpbGwgZmlyZSBsaWZlLWN5Y2xlIGV2ZW50czpcclxuICAgKlxyXG4gICAqICAgKiBpbXBvcnQucGFyc2Uuc3RhcnQgKGFib3V0IHRvIHJlYWQgbW9kZWwgZnJvbSBYTUwpXHJcbiAgICogICAqIGltcG9ydC5wYXJzZS5jb21wbGV0ZSAobW9kZWwgcmVhZDsgbWF5IGhhdmUgd29ya2VkIG9yIG5vdClcclxuICAgKiAgICogaW1wb3J0LnJlbmRlci5zdGFydCAoZ3JhcGhpY2FsIGltcG9ydCBzdGFydClcclxuICAgKiAgICogaW1wb3J0LnJlbmRlci5jb21wbGV0ZSAoZ3JhcGhpY2FsIGltcG9ydCBmaW5pc2hlZClcclxuICAgKiAgICogaW1wb3J0LmRvbmUgKGV2ZXJ5dGhpbmcgZG9uZSlcclxuICAgKlxyXG4gICAqIFlvdSBjYW4gdXNlIHRoZXNlIGV2ZW50cyB0byBob29rIGludG8gdGhlIGxpZmUtY3ljbGUuXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIHtJbXBvcnRYTUxFcnJvcn0gQW4gZXJyb3IgdGhyb3duIGR1cmluZyB0aGUgaW1wb3J0IG9mIHRoZSBYTUwuXHJcbiAgICpcclxuICAgKiBAZmlyZXMgQmFzZVZpZXdlciNJbXBvcnRQYXJzZVN0YXJ0RXZlbnRcclxuICAgKiBAZmlyZXMgQmFzZVZpZXdlciNJbXBvcnRQYXJzZUNvbXBsZXRlRXZlbnRcclxuICAgKiBAZmlyZXMgSW1wb3J0ZXIjSW1wb3J0UmVuZGVyU3RhcnRFdmVudFxyXG4gICAqIEBmaXJlcyBJbXBvcnRlciNJbXBvcnRSZW5kZXJDb21wbGV0ZUV2ZW50XHJcbiAgICogQGZpcmVzIEJhc2VWaWV3ZXIjSW1wb3J0RG9uZUV2ZW50XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30geG1sIFRoZSBCUE1OIDIuMCBYTUwgdG8gYmUgaW1wb3J0ZWQuXHJcbiAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fHN0cmluZ30gW2JwbW5EaWFncmFtXSBUaGUgb3B0aW9uYWwgZGlhZ3JhbSBvciBJZCBvZiB0aGUgQlBNTiBkaWFncmFtIHRvIG9wZW4uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEltcG9ydFhNTFJlc3VsdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB3YXJuaW5ncyB0aGF0IHdlcmUgcHJvZHVjZWQgZHVyaW5nIHRoZSBpbXBvcnQuXHJcbiAgICovXHJcbiAgQmFzZVZpZXdlci5wcm90b3R5cGUuaW1wb3J0WE1MID0gYXN5bmMgZnVuY3Rpb24gaW1wb3J0WE1MKHhtbCwgYnBtbkRpYWdyYW0pIHtcclxuXHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICBmdW5jdGlvbiBQYXJzZUNvbXBsZXRlRXZlbnQoZGF0YSkge1xyXG4gICAgICByZXR1cm4gc2VsZi5nZXQoJ2V2ZW50QnVzJykuY3JlYXRlRXZlbnQoZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGFnZ3JlZ2F0ZWRXYXJuaW5ncyA9IFtdO1xyXG4gICAgdHJ5IHtcclxuXHJcbiAgICAgIC8vIGhvb2sgaW4gcHJlLXBhcnNlIGxpc3RlbmVycyArXHJcbiAgICAgIC8vIGFsbG93IHhtbCBtYW5pcHVsYXRpb25cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBBIGBpbXBvcnQucGFyc2Uuc3RhcnRgIGV2ZW50LlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZXZlbnQgQmFzZVZpZXdlciNJbXBvcnRQYXJzZVN0YXJ0RXZlbnRcclxuICAgICAgICogQHR5cGUge0ltcG9ydFBhcnNlU3RhcnRFdmVudH1cclxuICAgICAgICovXHJcbiAgICAgIHhtbCA9IHRoaXMuX2VtaXQoJ2ltcG9ydC5wYXJzZS5zdGFydCcsIHsgeG1sOiB4bWwgfSkgfHwgeG1sO1xyXG5cclxuICAgICAgbGV0IHBhcnNlUmVzdWx0O1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHBhcnNlUmVzdWx0ID0gYXdhaXQgdGhpcy5fbW9kZGxlLmZyb21YTUwoeG1sLCAnYnBtbjpEZWZpbml0aW9ucycpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHRoaXMuX2VtaXQoJ2ltcG9ydC5wYXJzZS5jb21wbGV0ZScsIHtcclxuICAgICAgICAgIGVycm9yXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgZGVmaW5pdGlvbnMgPSBwYXJzZVJlc3VsdC5yb290RWxlbWVudDtcclxuICAgICAgY29uc3QgcmVmZXJlbmNlcyA9IHBhcnNlUmVzdWx0LnJlZmVyZW5jZXM7XHJcbiAgICAgIGNvbnN0IHBhcnNlV2FybmluZ3MgPSBwYXJzZVJlc3VsdC53YXJuaW5ncztcclxuICAgICAgY29uc3QgZWxlbWVudHNCeUlkID0gcGFyc2VSZXN1bHQuZWxlbWVudHNCeUlkO1xyXG5cclxuICAgICAgYWdncmVnYXRlZFdhcm5pbmdzID0gYWdncmVnYXRlZFdhcm5pbmdzLmNvbmNhdChwYXJzZVdhcm5pbmdzKTtcclxuXHJcbiAgICAgIC8vIGhvb2sgaW4gcG9zdCBwYXJzZSBsaXN0ZW5lcnMgK1xyXG4gICAgICAvLyBhbGxvdyBkZWZpbml0aW9ucyBtYW5pcHVsYXRpb25cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBBIGBpbXBvcnQucGFyc2UuY29tcGxldGVgIGV2ZW50LlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZXZlbnQgQmFzZVZpZXdlciNJbXBvcnRQYXJzZUNvbXBsZXRlRXZlbnRcclxuICAgICAgICogQHR5cGUge0ltcG9ydFBhcnNlQ29tcGxldGVFdmVudH1cclxuICAgICAgICovXHJcbiAgICAgIGRlZmluaXRpb25zID0gdGhpcy5fZW1pdCgnaW1wb3J0LnBhcnNlLmNvbXBsZXRlJywgUGFyc2VDb21wbGV0ZUV2ZW50KHtcclxuICAgICAgICBlcnJvcjogbnVsbCxcclxuICAgICAgICBkZWZpbml0aW9uczogZGVmaW5pdGlvbnMsXHJcbiAgICAgICAgZWxlbWVudHNCeUlkOiBlbGVtZW50c0J5SWQsXHJcbiAgICAgICAgcmVmZXJlbmNlczogcmVmZXJlbmNlcyxcclxuICAgICAgICB3YXJuaW5nczogYWdncmVnYXRlZFdhcm5pbmdzXHJcbiAgICAgIH0pKSB8fCBkZWZpbml0aW9ucztcclxuXHJcbiAgICAgIGNvbnN0IGltcG9ydFJlc3VsdCA9IGF3YWl0IHRoaXMuaW1wb3J0RGVmaW5pdGlvbnMoZGVmaW5pdGlvbnMsIGJwbW5EaWFncmFtKTtcclxuXHJcbiAgICAgIGFnZ3JlZ2F0ZWRXYXJuaW5ncyA9IGFnZ3JlZ2F0ZWRXYXJuaW5ncy5jb25jYXQoaW1wb3J0UmVzdWx0Lndhcm5pbmdzKTtcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBBIGBpbXBvcnQucGFyc2UuY29tcGxldGVgIGV2ZW50LlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZXZlbnQgQmFzZVZpZXdlciNJbXBvcnREb25lRXZlbnRcclxuICAgICAgICogQHR5cGUge0ltcG9ydERvbmVFdmVudH1cclxuICAgICAgICovXHJcbiAgICAgIHRoaXMuX2VtaXQoJ2ltcG9ydC5kb25lJywgeyBlcnJvcjogbnVsbCwgd2FybmluZ3M6IGFnZ3JlZ2F0ZWRXYXJuaW5ncyB9KTtcclxuXHJcbiAgICAgIHJldHVybiB7IHdhcm5pbmdzOiBhZ2dyZWdhdGVkV2FybmluZ3MgfTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBsZXQgZXJyb3IgPSBlcnI7XHJcbiAgICAgIGFnZ3JlZ2F0ZWRXYXJuaW5ncyA9IGFnZ3JlZ2F0ZWRXYXJuaW5ncy5jb25jYXQoZXJyb3Iud2FybmluZ3MgfHwgW10pO1xyXG4gICAgICBhZGRXYXJuaW5nc1RvRXJyb3IoZXJyb3IsIGFnZ3JlZ2F0ZWRXYXJuaW5ncyk7XHJcblxyXG4gICAgICBlcnJvciA9IGNoZWNrVmFsaWRhdGlvbkVycm9yKGVycm9yKTtcclxuXHJcbiAgICAgIHRoaXMuX2VtaXQoJ2ltcG9ydC5kb25lJywgeyBlcnJvciwgd2FybmluZ3M6IGVycm9yLndhcm5pbmdzIH0pO1xyXG5cclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEltcG9ydCBwYXJzZWQgZGVmaW5pdGlvbnMgYW5kIHJlbmRlciBhIEJQTU4gMi4wIGRpYWdyYW0uXHJcbiAgICpcclxuICAgKiBPbmNlIGZpbmlzaGVkIHRoZSB2aWV3ZXIgcmVwb3J0cyBiYWNrIHRoZSByZXN1bHQgdG8gdGhlXHJcbiAgICogcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCAoZXJyLCB3YXJuaW5ncykuXHJcbiAgICpcclxuICAgKiAjIyBMaWZlLUN5Y2xlIEV2ZW50c1xyXG4gICAqXHJcbiAgICogRHVyaW5nIGltcG9ydCB0aGUgdmlld2VyIHdpbGwgZmlyZSBsaWZlLWN5Y2xlIGV2ZW50czpcclxuICAgKlxyXG4gICAqICAgKiBpbXBvcnQucmVuZGVyLnN0YXJ0IChncmFwaGljYWwgaW1wb3J0IHN0YXJ0KVxyXG4gICAqICAgKiBpbXBvcnQucmVuZGVyLmNvbXBsZXRlIChncmFwaGljYWwgaW1wb3J0IGZpbmlzaGVkKVxyXG4gICAqXHJcbiAgICogWW91IGNhbiB1c2UgdGhlc2UgZXZlbnRzIHRvIGhvb2sgaW50byB0aGUgbGlmZS1jeWNsZS5cclxuICAgKlxyXG4gICAqIEB0aHJvd3Mge0ltcG9ydERlZmluaXRpb25zRXJyb3J9IEFuIGVycm9yIHRocm93biBkdXJpbmcgdGhlIGltcG9ydCBvZiB0aGUgZGVmaW5pdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR9IGRlZmluaXRpb25zIFRoZSBkZWZpbml0aW9ucy5cclxuICAgKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR8c3RyaW5nfSBbYnBtbkRpYWdyYW1dIFRoZSBvcHRpb25hbCBkaWFncmFtIG9yIElEIG9mIHRoZSBCUE1OIGRpYWdyYW0gdG8gb3Blbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8SW1wb3J0RGVmaW5pdGlvbnNSZXN1bHQ+fSBBIHByb21pc2UgcmVzb2x2aW5nIHdpdGggd2FybmluZ3MgdGhhdCB3ZXJlIHByb2R1Y2VkIGR1cmluZyB0aGUgaW1wb3J0LlxyXG4gICAqL1xyXG4gIEJhc2VWaWV3ZXIucHJvdG90eXBlLmltcG9ydERlZmluaXRpb25zID0gYXN5bmMgZnVuY3Rpb24gaW1wb3J0RGVmaW5pdGlvbnMoZGVmaW5pdGlvbnMsIGJwbW5EaWFncmFtKSB7XHJcbiAgICB0aGlzLl9zZXREZWZpbml0aW9ucyhkZWZpbml0aW9ucyk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLm9wZW4oYnBtbkRpYWdyYW0pO1xyXG5cclxuICAgIHJldHVybiB7IHdhcm5pbmdzOiByZXN1bHQud2FybmluZ3MgfTtcclxuICB9O1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogT3BlbiBkaWFncmFtIG9mIHByZXZpb3VzbHkgaW1wb3J0ZWQgWE1MLlxyXG4gICAqXHJcbiAgICogT25jZSBmaW5pc2hlZCB0aGUgdmlld2VyIHJlcG9ydHMgYmFjayB0aGUgcmVzdWx0IHRvIHRoZVxyXG4gICAqIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggKGVyciwgd2FybmluZ3MpLlxyXG4gICAqXHJcbiAgICogIyMgTGlmZS1DeWNsZSBFdmVudHNcclxuICAgKlxyXG4gICAqIER1cmluZyBzd2l0Y2ggdGhlIHZpZXdlciB3aWxsIGZpcmUgbGlmZS1jeWNsZSBldmVudHM6XHJcbiAgICpcclxuICAgKiAgICogaW1wb3J0LnJlbmRlci5zdGFydCAoZ3JhcGhpY2FsIGltcG9ydCBzdGFydClcclxuICAgKiAgICogaW1wb3J0LnJlbmRlci5jb21wbGV0ZSAoZ3JhcGhpY2FsIGltcG9ydCBmaW5pc2hlZClcclxuICAgKlxyXG4gICAqIFlvdSBjYW4gdXNlIHRoZXNlIGV2ZW50cyB0byBob29rIGludG8gdGhlIGxpZmUtY3ljbGUuXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIHtPcGVuRXJyb3J9IEFuIGVycm9yIHRocm93biBkdXJpbmcgb3BlbmluZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudHxzdHJpbmd9IGJwbW5EaWFncmFtT3JJZCBUaGUgZGlhZ3JhbSBvciBJZCBvZiB0aGUgQlBNTiBkaWFncmFtIHRvIG9wZW4uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9wZW5SZXN1bHQ+fSBBIHByb21pc2UgcmVzb2x2aW5nIHdpdGggd2FybmluZ3MgdGhhdCB3ZXJlIHByb2R1Y2VkIGR1cmluZyBvcGVuaW5nLlxyXG4gICAqL1xyXG4gIEJhc2VWaWV3ZXIucHJvdG90eXBlLm9wZW4gPSBhc3luYyBmdW5jdGlvbiBvcGVuKGJwbW5EaWFncmFtT3JJZCkge1xyXG5cclxuICAgIGNvbnN0IGRlZmluaXRpb25zID0gdGhpcy5fZGVmaW5pdGlvbnM7XHJcbiAgICBsZXQgYnBtbkRpYWdyYW0gPSBicG1uRGlhZ3JhbU9ySWQ7XHJcblxyXG4gICAgaWYgKCFkZWZpbml0aW9ucykge1xyXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignbm8gWE1MIGltcG9ydGVkJyk7XHJcbiAgICAgIGFkZFdhcm5pbmdzVG9FcnJvcihlcnJvciwgW10pO1xyXG5cclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBicG1uRGlhZ3JhbU9ySWQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGJwbW5EaWFncmFtID0gZmluZEJQTU5EaWFncmFtKGRlZmluaXRpb25zLCBicG1uRGlhZ3JhbU9ySWQpO1xyXG5cclxuICAgICAgaWYgKCFicG1uRGlhZ3JhbSkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdCUE1ORGlhZ3JhbSA8JyArIGJwbW5EaWFncmFtT3JJZCArICc+IG5vdCBmb3VuZCcpO1xyXG4gICAgICAgIGFkZFdhcm5pbmdzVG9FcnJvcihlcnJvciwgW10pO1xyXG5cclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNsZWFyIGV4aXN0aW5nIHJlbmRlcmVkIGRpYWdyYW1cclxuICAgIC8vIGNhdGNoIHN5bmNocm9ub3VzIGV4Y2VwdGlvbnMgZHVyaW5nICNjbGVhcigpXHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBhZGRXYXJuaW5nc1RvRXJyb3IoZXJyb3IsIFtdKTtcclxuXHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHBlcmZvcm0gZ3JhcGhpY2FsIGltcG9ydFxyXG4gICAgY29uc3QgeyB3YXJuaW5ncyB9ID0gYXdhaXQgaW1wb3J0QnBtbkRpYWdyYW0odGhpcywgZGVmaW5pdGlvbnMsIGJwbW5EaWFncmFtKTtcclxuXHJcbiAgICByZXR1cm4geyB3YXJuaW5ncyB9O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4cG9ydCB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBCUE1OIDIuMCBkaWFncmFtIGFzXHJcbiAgICogYSBCUE1OIDIuMCBYTUwgZG9jdW1lbnQuXHJcbiAgICpcclxuICAgKiAjIyBMaWZlLUN5Y2xlIEV2ZW50c1xyXG4gICAqXHJcbiAgICogRHVyaW5nIFhNTCBzYXZpbmcgdGhlIHZpZXdlciB3aWxsIGZpcmUgbGlmZS1jeWNsZSBldmVudHM6XHJcbiAgICpcclxuICAgKiAgICogc2F2ZVhNTC5zdGFydCAoYmVmb3JlIHNlcmlhbGl6YXRpb24pXHJcbiAgICogICAqIHNhdmVYTUwuc2VyaWFsaXplZCAoYWZ0ZXIgeG1sIGdlbmVyYXRpb24pXHJcbiAgICogICAqIHNhdmVYTUwuZG9uZSAoZXZlcnl0aGluZyBkb25lKVxyXG4gICAqXHJcbiAgICogWW91IGNhbiB1c2UgdGhlc2UgZXZlbnRzIHRvIGhvb2sgaW50byB0aGUgbGlmZS1jeWNsZS5cclxuICAgKlxyXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBBbiBlcnJvciB0aHJvd24gZHVyaW5nIGV4cG9ydC5cclxuICAgKlxyXG4gICAqIEBmaXJlcyBCYXNlVmlld2VyI1NhdmVYTUxTdGFydFxyXG4gICAqIEBmaXJlcyBCYXNlVmlld2VyI1NhdmVYTUxEb25lXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1NhdmVYTUxPcHRpb25zfSBbb3B0aW9uc10gVGhlIG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFNhdmVYTUxSZXN1bHQ+fSBBIHByb21pc2UgcmVzb2x2aW5nIHdpdGggdGhlIFhNTC5cclxuICAgKi9cclxuICBCYXNlVmlld2VyLnByb3RvdHlwZS5zYXZlWE1MID0gYXN5bmMgZnVuY3Rpb24gc2F2ZVhNTChvcHRpb25zKSB7XHJcblxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgbGV0IGRlZmluaXRpb25zID0gdGhpcy5fZGVmaW5pdGlvbnMsXHJcbiAgICAgICAgZXJyb3IsIHhtbDtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoIWRlZmluaXRpb25zKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBkZWZpbml0aW9ucyBsb2FkZWQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gYWxsb3cgdG8gZmlkZGxlIGFyb3VuZCB3aXRoIGRlZmluaXRpb25zXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQSBgc2F2ZVhNTC5zdGFydGAgZXZlbnQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBldmVudCBCYXNlVmlld2VyI1NhdmVYTUxTdGFydEV2ZW50XHJcbiAgICAgICAqIEB0eXBlIHtTYXZlWE1MU3RhcnRFdmVudH1cclxuICAgICAgICovXHJcbiAgICAgIGRlZmluaXRpb25zID0gdGhpcy5fZW1pdCgnc2F2ZVhNTC5zdGFydCcsIHtcclxuICAgICAgICBkZWZpbml0aW9uc1xyXG4gICAgICB9KSB8fCBkZWZpbml0aW9ucztcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX21vZGRsZS50b1hNTChkZWZpbml0aW9ucywgb3B0aW9ucyk7XHJcbiAgICAgIHhtbCA9IHJlc3VsdC54bWw7XHJcblxyXG4gICAgICB4bWwgPSB0aGlzLl9lbWl0KCdzYXZlWE1MLnNlcmlhbGl6ZWQnLCB7XHJcbiAgICAgICAgeG1sXHJcbiAgICAgIH0pIHx8IHhtbDtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBlcnJvciA9IGVycjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSBlcnJvciA/IHsgZXJyb3IgfSA6IHsgeG1sIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBzYXZlWE1MLmRvbmVgIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBldmVudCBCYXNlVmlld2VyI1NhdmVYTUxEb25lRXZlbnRcclxuICAgICAqIEB0eXBlIHtTYXZlWE1MRG9uZUV2ZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9lbWl0KCdzYXZlWE1MLmRvbmUnLCByZXN1bHQpO1xyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG5cclxuICAvKipcclxuICAgKiBFeHBvcnQgdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgQlBNTiAyLjAgZGlhZ3JhbSBhc1xyXG4gICAqIGFuIFNWRyBpbWFnZS5cclxuICAgKlxyXG4gICAqICMjIExpZmUtQ3ljbGUgRXZlbnRzXHJcbiAgICpcclxuICAgKiBEdXJpbmcgU1ZHIHNhdmluZyB0aGUgdmlld2VyIHdpbGwgZmlyZSBsaWZlLWN5Y2xlIGV2ZW50czpcclxuICAgKlxyXG4gICAqICAgKiBzYXZlU1ZHLnN0YXJ0IChiZWZvcmUgc2VyaWFsaXphdGlvbilcclxuICAgKiAgICogc2F2ZVNWRy5kb25lIChldmVyeXRoaW5nIGRvbmUpXHJcbiAgICpcclxuICAgKiBZb3UgY2FuIHVzZSB0aGVzZSBldmVudHMgdG8gaG9vayBpbnRvIHRoZSBsaWZlLWN5Y2xlLlxyXG4gICAqXHJcbiAgICogQHRocm93cyB7RXJyb3J9IEFuIGVycm9yIHRocm93biBkdXJpbmcgZXhwb3J0LlxyXG4gICAqXHJcbiAgICogQGZpcmVzIEJhc2VWaWV3ZXIjU2F2ZVNWR0RvbmVcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8U2F2ZVNWR1Jlc3VsdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0aGUgU1ZHLlxyXG4gICAqL1xyXG4gIEJhc2VWaWV3ZXIucHJvdG90eXBlLnNhdmVTVkcgPSBhc3luYyBmdW5jdGlvbiBzYXZlU1ZHKCkge1xyXG4gICAgdGhpcy5fZW1pdCgnc2F2ZVNWRy5zdGFydCcpO1xyXG5cclxuICAgIGxldCBzdmcsIGVycjtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmdldCgnY2FudmFzJyk7XHJcblxyXG4gICAgICBjb25zdCBjb250ZW50Tm9kZSA9IGNhbnZhcy5nZXRBY3RpdmVMYXllcigpLFxyXG4gICAgICAgICAgICBkZWZzTm9kZSA9IHF1ZXJ5KCc6c2NvcGUgPiBkZWZzJywgY2FudmFzLl9zdmcpO1xyXG5cclxuICAgICAgY29uc3QgY29udGVudHMgPSBpbm5lclNWRyhjb250ZW50Tm9kZSksXHJcbiAgICAgICAgICAgIGRlZnMgPSBkZWZzTm9kZSA/ICc8ZGVmcz4nICsgaW5uZXJTVkcoZGVmc05vZGUpICsgJzwvZGVmcz4nIDogJyc7XHJcblxyXG4gICAgICBjb25zdCBiYm94ID0gY29udGVudE5vZGUuZ2V0QkJveCgpO1xyXG5cclxuICAgICAgc3ZnID1cclxuICAgICAgICAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwidXRmLThcIj8+XFxuJyArXHJcbiAgICAgICAgJzwhLS0gY3JlYXRlZCB3aXRoIGJwbW4tanMgLyBodHRwOi8vYnBtbi5pbyAtLT5cXG4nICtcclxuICAgICAgICAnPCFET0NUWVBFIHN2ZyBQVUJMSUMgXCItLy9XM0MvL0RURCBTVkcgMS4xLy9FTlwiIFwiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkXCI+XFxuJyArXHJcbiAgICAgICAgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiICcgK1xyXG4gICAgICAgICd3aWR0aD1cIicgKyBiYm94LndpZHRoICsgJ1wiIGhlaWdodD1cIicgKyBiYm94LmhlaWdodCArICdcIiAnICtcclxuICAgICAgICAndmlld0JveD1cIicgKyBiYm94LnggKyAnICcgKyBiYm94LnkgKyAnICcgKyBiYm94LndpZHRoICsgJyAnICsgYmJveC5oZWlnaHQgKyAnXCIgdmVyc2lvbj1cIjEuMVwiPicgK1xyXG4gICAgICAgIGRlZnMgKyBjb250ZW50cyArXHJcbiAgICAgICAgJzwvc3ZnPic7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGVyciA9IGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBzYXZlU1ZHLmRvbmVgIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBldmVudCBCYXNlVmlld2VyI1NhdmVTVkdEb25lRXZlbnRcclxuICAgICAqIEB0eXBlIHtTYXZlU1ZHRG9uZUV2ZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9lbWl0KCdzYXZlU1ZHLmRvbmUnLCB7XHJcbiAgICAgIGVycm9yOiBlcnIsXHJcbiAgICAgIHN2Zzogc3ZnXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoZXJyKSB7XHJcbiAgICAgIHRocm93IGVycjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBzdmcgfTtcclxuICB9O1xyXG5cclxuICBCYXNlVmlld2VyLnByb3RvdHlwZS5fc2V0RGVmaW5pdGlvbnMgPSBmdW5jdGlvbihkZWZpbml0aW9ucykge1xyXG4gICAgdGhpcy5fZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gbW9kdWxlcyB0byBpbnN0YW50aWF0ZSB3aXRoLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7TW9kdWxlRGVjbGFyYXRpb25bXX0gVGhlIG1vZHVsZXMuXHJcbiAgICovXHJcbiAgQmFzZVZpZXdlci5wcm90b3R5cGUuZ2V0TW9kdWxlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX21vZHVsZXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGFsbCBkcmF3biBlbGVtZW50cyBmcm9tIHRoZSB2aWV3ZXIuXHJcbiAgICpcclxuICAgKiBBZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIHRoZSB2aWV3ZXIgY2FuIHN0aWxsIGJlIHJldXNlZCBmb3Igb3BlbmluZyBhbm90aGVyXHJcbiAgICogZGlhZ3JhbS5cclxuICAgKi9cclxuICBCYXNlVmlld2VyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCF0aGlzLmdldERlZmluaXRpb25zKCkpIHtcclxuXHJcbiAgICAgIC8vIG5vIGRpYWdyYW0gdG8gY2xlYXJcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHJlbW92ZSBkcmF3biBlbGVtZW50c1xyXG4gICAgRGlhZ3JhbS5wcm90b3R5cGUuY2xlYXIuY2FsbCh0aGlzKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95IHRoZSB2aWV3ZXIgaW5zdGFuY2UgYW5kIHJlbW92ZSBhbGwgaXRzIHJlbWFpbmRlcnMgZnJvbSB0aGUgZG9jdW1lbnRcclxuICAgKiB0cmVlLlxyXG4gICAqL1xyXG4gIEJhc2VWaWV3ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvLyBkaWFncmFtIGRlc3Ryb3lcclxuICAgIERpYWdyYW0ucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAvLyBkb20gZGV0YWNoXHJcbiAgICByZW1vdmUkMSh0aGlzLl9jb250YWluZXIpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEBvdmVybG9yZFxyXG4gICAqXHJcbiAgICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGV2ZW50cyB3aXRoIHRoZSBnaXZlbiBuYW1lLlxyXG4gICAqXHJcbiAgICogVGhlIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCB3aXRoIGBldmVudCwgLi4uYWRkaXRpb25hbEFyZ3VtZW50c2BcclxuICAgKiB0aGF0IGhhdmUgYmVlbiBwYXNzZWQgdG8ge0BsaW5rIEV2ZW50QnVzI2ZpcmV9LlxyXG4gICAqXHJcbiAgICogUmV0dXJuaW5nIGZhbHNlIGZyb20gYSBsaXN0ZW5lciB3aWxsIHByZXZlbnQgdGhlIGV2ZW50cyBkZWZhdWx0IGFjdGlvblxyXG4gICAqIChpZiBhbnkgaXMgc3BlY2lmaWVkKS4gVG8gc3RvcCBhbiBldmVudCBmcm9tIGJlaW5nIHByb2Nlc3NlZCBmdXJ0aGVyIGluXHJcbiAgICogb3RoZXIgbGlzdGVuZXJzIGV4ZWN1dGUge0BsaW5rIEV2ZW50I3N0b3BQcm9wYWdhdGlvbn0uXHJcbiAgICpcclxuICAgKiBSZXR1cm5pbmcgYW55dGhpbmcgYnV0IGB1bmRlZmluZWRgIGZyb20gYSBsaXN0ZW5lciB3aWxsIHN0b3AgdGhlIGxpc3RlbmVyIHByb3BhZ2F0aW9uLlxyXG4gICAqXHJcbiAgICogQHRlbXBsYXRlIFRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBldmVudHMgVGhlIGV2ZW50KHMpIHRvIGxpc3RlbiB0by5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5XSBUaGUgcHJpb3JpdHkgd2l0aCB3aGljaCB0byBsaXN0ZW4uXHJcbiAgICogQHBhcmFtIHtFdmVudEJ1c0V2ZW50Q2FsbGJhY2s8VD59IGNhbGxiYWNrIFRoZSBjYWxsYmFjay5cclxuICAgKiBAcGFyYW0ge2FueX0gW3RoYXRdIFZhbHVlIG9mIGB0aGlzYCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aC5cclxuICAgKi9cclxuICAvKipcclxuICAgKiBSZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lciBmb3IgZXZlbnRzIHdpdGggdGhlIGdpdmVuIG5hbWUuXHJcbiAgICpcclxuICAgKiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIHdpdGggYGV2ZW50LCAuLi5hZGRpdGlvbmFsQXJndW1lbnRzYFxyXG4gICAqIHRoYXQgaGF2ZSBiZWVuIHBhc3NlZCB0byB7QGxpbmsgRXZlbnRCdXMjZmlyZX0uXHJcbiAgICpcclxuICAgKiBSZXR1cm5pbmcgZmFsc2UgZnJvbSBhIGxpc3RlbmVyIHdpbGwgcHJldmVudCB0aGUgZXZlbnRzIGRlZmF1bHQgYWN0aW9uXHJcbiAgICogKGlmIGFueSBpcyBzcGVjaWZpZWQpLiBUbyBzdG9wIGFuIGV2ZW50IGZyb20gYmVpbmcgcHJvY2Vzc2VkIGZ1cnRoZXIgaW5cclxuICAgKiBvdGhlciBsaXN0ZW5lcnMgZXhlY3V0ZSB7QGxpbmsgRXZlbnQjc3RvcFByb3BhZ2F0aW9ufS5cclxuICAgKlxyXG4gICAqIFJldHVybmluZyBhbnl0aGluZyBidXQgYHVuZGVmaW5lZGAgZnJvbSBhIGxpc3RlbmVyIHdpbGwgc3RvcCB0aGUgbGlzdGVuZXIgcHJvcGFnYXRpb24uXHJcbiAgICpcclxuICAgKiBAdGVtcGxhdGUge2tleW9mIEV2ZW50TWFwPFNlcnZpY2VNYXA+fSBFdmVudE5hbWVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnROYW1lfSBldmVudHMgdG8gc3Vic2NyaWJlIHRvXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT0xMDAwXSBsaXN0ZW4gcHJpb3JpdHlcclxuICAgKiBAcGFyYW0ge0V2ZW50QnVzRXZlbnRDYWxsYmFjazwoRXZlbnRNYXA8U2VydmljZU1hcD4pW0V2ZW50TmFtZV0+fSBjYWxsYmFja1xyXG4gICAqIEBwYXJhbSB7YW55fSBbdGhhdF0gY2FsbGJhY2sgY29udGV4dFxyXG4gICAqL1xyXG4gIEJhc2VWaWV3ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnRzLCBwcmlvcml0eSwgY2FsbGJhY2ssIHRoYXQpIHtcclxuICAgIHJldHVybiB0aGlzLmdldCgnZXZlbnRCdXMnKS5vbihldmVudHMsIHByaW9yaXR5LCBjYWxsYmFjaywgdGhhdCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGV2ZW50cyBUaGUgZXZlbnQocykuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgY2FsbGJhY2suXHJcbiAgICovXHJcbiAgQmFzZVZpZXdlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24oZXZlbnRzLCBjYWxsYmFjaykge1xyXG4gICAgdGhpcy5nZXQoJ2V2ZW50QnVzJykub2ZmKGV2ZW50cywgY2FsbGJhY2spO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaCB0aGUgdmlld2VyIHRvIGFuIEhUTUwgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudE5vZGUgVGhlIHBhcmVudCBub2RlIHRvIGF0dGFjaCB0by5cclxuICAgKi9cclxuICBCYXNlVmlld2VyLnByb3RvdHlwZS5hdHRhY2hUbyA9IGZ1bmN0aW9uKHBhcmVudE5vZGUpIHtcclxuXHJcbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJlbnROb2RlIHJlcXVpcmVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZW5zdXJlIHdlIGRldGFjaCBmcm9tIHRoZVxyXG4gICAgLy8gcHJldmlvdXMsIG9sZCBwYXJlbnRcclxuICAgIHRoaXMuZGV0YWNoKCk7XHJcblxyXG4gICAgLy8gdW53cmFwIGpRdWVyeSBpZiBwcm92aWRlZFxyXG4gICAgaWYgKHBhcmVudE5vZGUuZ2V0ICYmIHBhcmVudE5vZGUuY29uc3RydWN0b3IucHJvdG90eXBlLmpxdWVyeSkge1xyXG4gICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5nZXQoMCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBwYXJlbnROb2RlID09PSAnc3RyaW5nJykge1xyXG4gICAgICBwYXJlbnROb2RlID0gcXVlcnkocGFyZW50Tm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cclxuICAgIHRoaXMuX2VtaXQoJ2F0dGFjaCcsIHt9KTtcclxuXHJcbiAgICB0aGlzLmdldCgnY2FudmFzJykucmVzaXplZCgpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZGVmaW5pdGlvbnMgbW9kZWwgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge01vZGRsZUVsZW1lbnR9IFRoZSBkZWZpbml0aW9ucyBtb2RlbCBlbGVtZW50LlxyXG4gICAqL1xyXG4gIEJhc2VWaWV3ZXIucHJvdG90eXBlLmdldERlZmluaXRpb25zID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbnM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoIHRoZSB2aWV3ZXIuXHJcbiAgICpcclxuICAgKiBAZmlyZXMgQmFzZVZpZXdlciNEZXRhY2hFdmVudFxyXG4gICAqL1xyXG4gIEJhc2VWaWV3ZXIucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcclxuICAgICAgICAgIHBhcmVudE5vZGUgPSBjb250YWluZXIucGFyZW50Tm9kZTtcclxuXHJcbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgZGV0YWNoYCBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnQgQmFzZVZpZXdlciNEZXRhY2hFdmVudFxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fZW1pdCgnZGV0YWNoJywge30pO1xyXG5cclxuICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcclxuICB9O1xyXG5cclxuICBCYXNlVmlld2VyLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgbW9kZGxlLCBvcHRpb25zKSB7XHJcblxyXG4gICAgY29uc3QgYmFzZU1vZHVsZXMgPSBvcHRpb25zLm1vZHVsZXMgfHwgdGhpcy5nZXRNb2R1bGVzKG9wdGlvbnMpLFxyXG4gICAgICAgICAgYWRkaXRpb25hbE1vZHVsZXMgPSBvcHRpb25zLmFkZGl0aW9uYWxNb2R1bGVzIHx8IFtdLFxyXG4gICAgICAgICAgc3RhdGljTW9kdWxlcyA9IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIGJwbW5qczogWyAndmFsdWUnLCB0aGlzIF0sXHJcbiAgICAgICAgICAgICAgbW9kZGxlOiBbICd2YWx1ZScsIG1vZGRsZSBdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIF07XHJcblxyXG4gICAgY29uc3QgZGlhZ3JhbU1vZHVsZXMgPSBbXS5jb25jYXQoc3RhdGljTW9kdWxlcywgYmFzZU1vZHVsZXMsIGFkZGl0aW9uYWxNb2R1bGVzKTtcclxuXHJcbiAgICBjb25zdCBkaWFncmFtT3B0aW9ucyA9IGFzc2lnbiQxKG9taXQob3B0aW9ucywgWyAnYWRkaXRpb25hbE1vZHVsZXMnIF0pLCB7XHJcbiAgICAgIGNhbnZhczogYXNzaWduJDEoe30sIG9wdGlvbnMuY2FudmFzLCB7IGNvbnRhaW5lcjogY29udGFpbmVyIH0pLFxyXG4gICAgICBtb2R1bGVzOiBkaWFncmFtTW9kdWxlc1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gaW52b2tlIGRpYWdyYW0gY29uc3RydWN0b3JcclxuICAgIERpYWdyYW0uY2FsbCh0aGlzLCBkaWFncmFtT3B0aW9ucyk7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb250YWluZXIpIHtcclxuICAgICAgdGhpcy5hdHRhY2hUbyhvcHRpb25zLmNvbnRhaW5lcik7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRW1pdCBhbiBldmVudCBvbiB0aGUgdW5kZXJseWluZyB7QGxpbmsgRXZlbnRCdXN9XHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGVcclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGV2ZW50XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXR1cm4gdmFsdWUgYWZ0ZXIgY2FsbGluZyBhbGwgZXZlbnQgbGlzdGVuZXJzLlxyXG4gICAqL1xyXG4gIEJhc2VWaWV3ZXIucHJvdG90eXBlLl9lbWl0ID0gZnVuY3Rpb24odHlwZSwgZXZlbnQpIHtcclxuICAgIHJldHVybiB0aGlzLmdldCgnZXZlbnRCdXMnKS5maXJlKHR5cGUsIGV2ZW50KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0Jhc2VWaWV3ZXJPcHRpb25zfSBvcHRpb25zXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICAgKi9cclxuICBCYXNlVmlld2VyLnByb3RvdHlwZS5fY3JlYXRlQ29udGFpbmVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvbWlmeSQxKCc8ZGl2IGNsYXNzPVwiYmpzLWNvbnRhaW5lclwiPjwvZGl2PicpO1xyXG5cclxuICAgIGFzc2lnbihjb250YWluZXIsIHtcclxuICAgICAgd2lkdGg6IGVuc3VyZVVuaXQob3B0aW9ucy53aWR0aCksXHJcbiAgICAgIGhlaWdodDogZW5zdXJlVW5pdChvcHRpb25zLmhlaWdodCksXHJcbiAgICAgIHBvc2l0aW9uOiBvcHRpb25zLnBvc2l0aW9uXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gY29udGFpbmVyO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7QmFzZVZpZXdlck9wdGlvbnN9IG9wdGlvbnNcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge01vZGRsZX1cclxuICAgKi9cclxuICBCYXNlVmlld2VyLnByb3RvdHlwZS5fY3JlYXRlTW9kZGxlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgY29uc3QgbW9kZGxlT3B0aW9ucyA9IGFzc2lnbiQxKHt9LCB0aGlzLl9tb2RkbGVFeHRlbnNpb25zLCBvcHRpb25zLm1vZGRsZUV4dGVuc2lvbnMpO1xyXG5cclxuICAgIHJldHVybiBuZXcgU2ltcGxlQnBtbk1vZGRsZShtb2RkbGVPcHRpb25zKTtcclxuICB9O1xyXG5cclxuICBCYXNlVmlld2VyLnByb3RvdHlwZS5fbW9kdWxlcyA9IFtdO1xyXG5cclxuICAvLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vL1xyXG5cclxuICBmdW5jdGlvbiBhZGRXYXJuaW5nc1RvRXJyb3IoZXJyLCB3YXJuaW5nc0FyeSkge1xyXG4gICAgZXJyLndhcm5pbmdzID0gd2FybmluZ3NBcnk7XHJcbiAgICByZXR1cm4gZXJyO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2hlY2tWYWxpZGF0aW9uRXJyb3IoZXJyKSB7XHJcblxyXG4gICAgLy8gY2hlY2sgaWYgd2UgY2FuIGhlbHAgdGhlIHVzZXIgYnkgaW5kaWNhdGluZyB3cm9uZyBCUE1OIDIuMCB4bWxcclxuICAgIC8vIChpbiBjYXNlIGhlIG9yIHRoZSBleHBvcnRpbmcgdG9vbCBkaWQgbm90IGdldCB0aGF0IHJpZ2h0KVxyXG5cclxuICAgIGNvbnN0IHBhdHRlcm4gPSAvdW5wYXJzYWJsZSBjb250ZW50IDwoW14+XSspPiBkZXRlY3RlZChbXFxzXFxTXSopJC87XHJcbiAgICBjb25zdCBtYXRjaCA9IHBhdHRlcm4uZXhlYyhlcnIubWVzc2FnZSk7XHJcblxyXG4gICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgIGVyci5tZXNzYWdlID1cclxuICAgICAgICAndW5wYXJzYWJsZSBjb250ZW50IDwnICsgbWF0Y2hbMV0gKyAnPiBkZXRlY3RlZDsgJyArXHJcbiAgICAgICAgJ3RoaXMgbWF5IGluZGljYXRlIGFuIGludmFsaWQgQlBNTiAyLjAgZGlhZ3JhbSBmaWxlJyArIG1hdGNoWzJdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlcnI7XHJcbiAgfVxyXG5cclxuICBjb25zdCBERUZBVUxUX09QVElPTlMgPSB7XHJcbiAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xyXG4gIH07XHJcblxyXG5cclxuICAvKipcclxuICAgKiBFbnN1cmUgdGhlIHBhc3NlZCBhcmd1bWVudCBpcyBhIHByb3BlciB1bml0IChkZWZhdWx0aW5nIHRvIHB4KVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGVuc3VyZVVuaXQodmFsKSB7XHJcbiAgICByZXR1cm4gdmFsICsgKGlzTnVtYmVyKHZhbCkgPyAncHgnIDogJycpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbmQgQlBNTkRpYWdyYW0gaW4gZGVmaW5pdGlvbnMgYnkgSURcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TW9kZGxlRWxlbWVudDxEZWZpbml0aW9ucz59IGRlZmluaXRpb25zXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpYWdyYW1JZFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7TW9kZGxlRWxlbWVudDxCUE1ORGlhZ3JhbT58bnVsbH1cclxuICAgKi9cclxuICBmdW5jdGlvbiBmaW5kQlBNTkRpYWdyYW0oZGVmaW5pdGlvbnMsIGRpYWdyYW1JZCkge1xyXG4gICAgaWYgKCFkaWFncmFtSWQpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZpbmQoZGVmaW5pdGlvbnMuZGlhZ3JhbXMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIGVsZW1lbnQuaWQgPT09IGRpYWdyYW1JZDtcclxuICAgIH0pIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIHRoZSBwcm9qZWN0IGxvZ28gdG8gdGhlIGRpYWdyYW0gY29udGFpbmVyIGFzXHJcbiAgICogcmVxdWlyZWQgYnkgdGhlIGJwbW4uaW8gbGljZW5zZS5cclxuICAgKlxyXG4gICAqIEBzZWUgaHR0cDovL2JwbW4uaW8vbGljZW5zZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXJcclxuICAgKi9cclxuICBmdW5jdGlvbiBhZGRQcm9qZWN0TG9nbyhjb250YWluZXIpIHtcclxuICAgIGNvbnN0IGltZyA9IEJQTU5JT19JTUc7XHJcblxyXG4gICAgY29uc3QgbGlua01hcmt1cCA9XHJcbiAgICAgICc8YSBocmVmPVwiaHR0cDovL2JwbW4uaW9cIiAnICtcclxuICAgICAgJ3RhcmdldD1cIl9ibGFua1wiICcgK1xyXG4gICAgICAnY2xhc3M9XCJianMtcG93ZXJlZC1ieVwiICcgK1xyXG4gICAgICAndGl0bGU9XCJQb3dlcmVkIGJ5IGJwbW4uaW9cIiAnICtcclxuICAgICAgJz4nICtcclxuICAgICAgaW1nICtcclxuICAgICAgJzwvYT4nO1xyXG5cclxuICAgIGNvbnN0IGxpbmtFbGVtZW50ID0gZG9taWZ5JDEobGlua01hcmt1cCk7XHJcblxyXG4gICAgYXNzaWduKHF1ZXJ5KCdzdmcnLCBsaW5rRWxlbWVudCksIExPR09fU1RZTEVTKTtcclxuICAgIGFzc2lnbihsaW5rRWxlbWVudCwgTElOS19TVFlMRVMsIHtcclxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgIGJvdHRvbTogJzE1cHgnLFxyXG4gICAgICByaWdodDogJzE1cHgnLFxyXG4gICAgICB6SW5kZXg6ICcxMDAnXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobGlua0VsZW1lbnQpO1xyXG5cclxuICAgIGV2ZW50LmJpbmQobGlua0VsZW1lbnQsICdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgIG9wZW4oKTtcclxuXHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qIDwvcHJvamVjdC1sb2dvPiAqL1xuXG4gIC8qKlxyXG4gICAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL0Jhc2VWaWV3ZXInKS5CYXNlVmlld2VyT3B0aW9ucyB9IEJhc2VWaWV3ZXJPcHRpb25zXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEEgdmlld2VyIGZvciBCUE1OIDIuMCBkaWFncmFtcy5cclxuICAgKlxyXG4gICAqIEhhdmUgYSBsb29rIGF0IHtAbGluayBicG1uLWpzL2xpYi9OYXZpZ2F0ZWRWaWV3ZXJ9IG9yIHtAbGluayBicG1uLWpzL2xpYi9Nb2RlbGVyfSBmb3IgYnVuZGxlcyB0aGF0IGluY2x1ZGVcclxuICAgKiBhZGRpdGlvbmFsIGZlYXR1cmVzLlxyXG4gICAqXHJcbiAgICpcclxuICAgKiAjIyBFeHRlbmRpbmcgdGhlIFZpZXdlclxyXG4gICAqXHJcbiAgICogSW4gb3JkZXIgdG8gZXh0ZW5kIHRoZSB2aWV3ZXIgcGFzcyBleHRlbnNpb24gbW9kdWxlcyB0byBib290c3RyYXAgdmlhIHRoZVxyXG4gICAqIGBhZGRpdGlvbmFsTW9kdWxlc2Agb3B0aW9uLiBBbiBleHRlbnNpb24gbW9kdWxlIGlzIGFuIG9iamVjdCB0aGF0IGV4cG9zZXNcclxuICAgKiBuYW1lZCBzZXJ2aWNlcy5cclxuICAgKlxyXG4gICAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBkZXBpY3RzIHRoZSBpbnRlZ3JhdGlvbiBvZiBhIHNpbXBsZVxyXG4gICAqIGxvZ2dpbmcgY29tcG9uZW50IHRoYXQgaW50ZWdyYXRlcyB3aXRoIGludGVyYWN0aW9uIGV2ZW50czpcclxuICAgKlxyXG4gICAqXHJcbiAgICogYGBgamF2YXNjcmlwdFxyXG4gICAqXHJcbiAgICogLy8gbG9nZ2luZyBjb21wb25lbnRcclxuICAgKiBmdW5jdGlvbiBJbnRlcmFjdGlvbkxvZ2dlcihldmVudEJ1cykge1xyXG4gICAqICAgZXZlbnRCdXMub24oJ2VsZW1lbnQuaG92ZXInLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAqICAgICBjb25zb2xlLmxvZygpXHJcbiAgICogICB9KVxyXG4gICAqIH1cclxuICAgKlxyXG4gICAqIEludGVyYWN0aW9uTG9nZ2VyLiRpbmplY3QgPSBbICdldmVudEJ1cycgXTsgLy8gbWluaWZpY2F0aW9uIHNhdmVcclxuICAgKlxyXG4gICAqIC8vIGV4dGVuc2lvbiBtb2R1bGVcclxuICAgKiB2YXIgZXh0ZW5zaW9uTW9kdWxlID0ge1xyXG4gICAqICAgX19pbml0X186IFsgJ2ludGVyYWN0aW9uTG9nZ2VyJyBdLFxyXG4gICAqICAgaW50ZXJhY3Rpb25Mb2dnZXI6IFsgJ3R5cGUnLCBJbnRlcmFjdGlvbkxvZ2dlciBdXHJcbiAgICogfTtcclxuICAgKlxyXG4gICAqIC8vIGV4dGVuZCB0aGUgdmlld2VyXHJcbiAgICogdmFyIGJwbW5WaWV3ZXIgPSBuZXcgVmlld2VyKHsgYWRkaXRpb25hbE1vZHVsZXM6IFsgZXh0ZW5zaW9uTW9kdWxlIF0gfSk7XHJcbiAgICogYnBtblZpZXdlci5pbXBvcnRYTUwoLi4uKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEB0ZW1wbGF0ZSBbU2VydmljZU1hcD1udWxsXVxyXG4gICAqXHJcbiAgICogQGV4dGVuZHMgQmFzZVZpZXdlcjxTZXJ2aWNlTWFwPlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCYXNlVmlld2VyT3B0aW9uc30gW29wdGlvbnNdIFRoZSBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgdmlld2VyLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFZpZXdlcihvcHRpb25zKSB7XHJcbiAgICBCYXNlVmlld2VyLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICBlKFZpZXdlciwgQmFzZVZpZXdlcik7XHJcblxyXG4gIC8vIG1vZHVsZXMgdGhlIHZpZXdlciBpcyBjb21wb3NlZCBvZlxyXG4gIFZpZXdlci5wcm90b3R5cGUuX21vZHVsZXMgPSBbXHJcbiAgICBDb3JlTW9kdWxlJDEsXHJcbiAgICBEcmlsbGRvd25Nb2RkdWxlLFxyXG4gICAgT3ZlcmxheXNNb2R1bGUsXHJcbiAgICBTZWxlY3Rpb25Nb2R1bGUsXHJcbiAgICBUcmFuc2xhdGVNb2R1bGVcclxuICBdO1xyXG5cclxuICAvLyBkZWZhdWx0IG1vZGRsZSBleHRlbnNpb25zIHRoZSB2aWV3ZXIgaXMgY29tcG9zZWQgb2ZcclxuICBWaWV3ZXIucHJvdG90eXBlLl9tb2RkbGVFeHRlbnNpb25zID0ge307XG5cbiAgdmFyIEtFWVNfQ09QWSA9IFsgJ2MnLCAnQycgXTtcclxuICB2YXIgS0VZU19QQVNURSA9IFsgJ3YnLCAnVicgXTtcclxuICB2YXIgS0VZU19SRURPID0gWyAneScsICdZJyBdO1xyXG4gIHZhciBLRVlTX1VORE8gPSBbICd6JywgJ1onIF07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBldmVudCB3YXMgdHJpZ2dlcmVkIHdpdGggYW55IG1vZGlmaWVyXHJcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudFxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGhhc01vZGlmaWVyKGV2ZW50KSB7XHJcbiAgICByZXR1cm4gKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudFxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaXNDbWQoZXZlbnQpIHtcclxuXHJcbiAgICAvLyBlbnN1cmUgd2UgZG9uJ3QgcmVhY3QgdG8gQWx0R3JcclxuICAgIC8vIChtYXBwZWQgdG8gQ1RSTCArIEFMVClcclxuICAgIGlmIChldmVudC5hbHRLZXkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYga2V5IHByZXNzZWQgaXMgb25lIG9mIHByb3ZpZGVkIGtleXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0ga2V5c1xyXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGlzS2V5KGtleXMsIGV2ZW50KSB7XHJcbiAgICBrZXlzID0gaXNBcnJheSQyKGtleXMpID8ga2V5cyA6IFsga2V5cyBdO1xyXG5cclxuICAgIHJldHVybiBrZXlzLmluZGV4T2YoZXZlbnQua2V5KSAhPT0gLTEgfHwga2V5cy5pbmRleE9mKGV2ZW50LmNvZGUpICE9PSAtMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcclxuICAgKi9cclxuICBmdW5jdGlvbiBpc1NoaWZ0KGV2ZW50KSB7XHJcbiAgICByZXR1cm4gZXZlbnQuc2hpZnRLZXk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50XHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaXNDb3B5KGV2ZW50KSB7XHJcbiAgICByZXR1cm4gaXNDbWQoZXZlbnQpICYmIGlzS2V5KEtFWVNfQ09QWSwgZXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudFxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGlzUGFzdGUoZXZlbnQpIHtcclxuICAgIHJldHVybiBpc0NtZChldmVudCkgJiYgaXNLZXkoS0VZU19QQVNURSwgZXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudFxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGlzVW5kbyhldmVudCkge1xyXG4gICAgcmV0dXJuIGlzQ21kKGV2ZW50KSAmJiAhaXNTaGlmdChldmVudCkgJiYgaXNLZXkoS0VZU19VTkRPLCBldmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50XHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaXNSZWRvKGV2ZW50KSB7XHJcbiAgICByZXR1cm4gaXNDbWQoZXZlbnQpICYmIChcclxuICAgICAgaXNLZXkoS0VZU19SRURPLCBldmVudCkgfHwgKFxyXG4gICAgICAgIGlzS2V5KEtFWVNfVU5ETywgZXZlbnQpICYmIGlzU2hpZnQoZXZlbnQpXHJcbiAgICAgIClcclxuICAgICk7XHJcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi9jb3JlL0V2ZW50QnVzJykuZGVmYXVsdH0gRXZlbnRCdXNcbiAgICpcbiAgICogQHR5cGVkZWYgeyh7IGtleUV2ZW50OiBLZXlib2FyZEV2ZW50IH0pID0+IGFueX0gTGlzdGVuZXJcbiAgICovXG5cbiAgdmFyIEtFWURPV05fRVZFTlQgPSAna2V5Ym9hcmQua2V5ZG93bicsXG4gICAgICBLRVlVUF9FVkVOVCA9ICdrZXlib2FyZC5rZXl1cCc7XG5cbiAgdmFyIERFRkFVTFRfUFJJT1JJVFkgPSAxMDAwO1xuXG4gIHZhciBjb21wYXRNZXNzYWdlID0gJ0tleWJvYXJkIGJpbmRpbmcgaXMgbm93IGltcGxpY2l0OyBleHBsaWNpdCBiaW5kaW5nIHRvIGFuIGVsZW1lbnQgZ290IHJlbW92ZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2JwbW4taW8vZGlhZ3JhbS1qcy9pc3N1ZXMvNjYxJztcblxuXG4gIC8qKlxuICAgKiBBIGtleWJvYXJkIGFic3RyYWN0aW9uIHRoYXQgbWF5IGJlIGFjdGl2YXRlZCBhbmRcbiAgICogZGVhY3RpdmF0ZWQgYnkgdXNlcnMgYXQgd2lsbCwgY29uc3VtaW5nIGdsb2JhbCBrZXkgZXZlbnRzXG4gICAqIGFuZCB0cmlnZ2VyaW5nIGRpYWdyYW0gYWN0aW9ucy5cbiAgICpcbiAgICogRm9yIGtleXMgcHJlc3NlZCBkb3duLCBrZXlib2FyZCBmaXJlcyBga2V5Ym9hcmQua2V5ZG93bmAgZXZlbnQuXG4gICAqIFRoZSBldmVudCBjb250ZXh0IGNvbnRhaW5zIG9uZSBmaWVsZCB3aGljaCBpcyBgS2V5Ym9hcmRFdmVudGAgZXZlbnQuXG4gICAqXG4gICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBmaXJlcyB0aGUgZm9sbG93aW5nIGtleSBldmVudHMgdGhhdCBhbGxvd1xuICAgKiBvdGhlciBjb21wb25lbnRzIHRvIGhvb2sgaW50byBrZXkgaGFuZGxpbmc6XG4gICAqXG4gICAqICAtIGtleWJvYXJkLmJpbmRcbiAgICogIC0ga2V5Ym9hcmQudW5iaW5kXG4gICAqICAtIGtleWJvYXJkLmluaXRcbiAgICogIC0ga2V5Ym9hcmQuZGVzdHJveVxuICAgKlxuICAgKiBBbGwgZXZlbnRzIGNvbnRhaW4gb25lIGZpZWxkIHdoaWNoIGlzIG5vZGUuXG4gICAqXG4gICAqIFNwZWNpZnkgdGhlIGluaXRpYWwga2V5Ym9hcmQgYmluZGluZyBzdGF0ZSB2aWEgdGhlXG4gICAqIGBrZXlib2FyZC5iaW5kPXRydWV8ZmFsc2VgIGNvbmZpZ3VyYXRpb24gb3B0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbmZpZy5iaW5kXVxuICAgKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICAgKi9cbiAgZnVuY3Rpb24gS2V5Ym9hcmQoY29uZmlnLCBldmVudEJ1cykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICAgIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG5cbiAgICB0aGlzLl9rZXlkb3duSGFuZGxlciA9IHRoaXMuX2tleWRvd25IYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fa2V5dXBIYW5kbGVyID0gdGhpcy5fa2V5dXBIYW5kbGVyLmJpbmQodGhpcyk7XG5cbiAgICAvLyBwcm9wZXJseSBjbGVhbiBkb20gcmVnaXN0cmF0aW9uc1xuICAgIGV2ZW50QnVzLm9uKCdkaWFncmFtLmRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX2ZpcmUoJ2Rlc3Ryb3knKTtcblxuICAgICAgc2VsZi51bmJpbmQoKTtcbiAgICB9KTtcblxuICAgIGlmIChjb25maWcuYmluZFRvKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCd1bnN1cHBvcnRlZCBjb25maWd1cmF0aW9uIDxrZXlib2FyZC5iaW5kVG8+JywgbmV3IEVycm9yKGNvbXBhdE1lc3NhZ2UpKTtcbiAgICB9XG5cbiAgICB2YXIgYmluZCA9IGNvbmZpZyAmJiBjb25maWcuYmluZCAhPT0gZmFsc2U7XG5cbiAgICBldmVudEJ1cy5vbignY2FudmFzLmluaXQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgc2VsZi5fdGFyZ2V0ID0gZXZlbnQuc3ZnO1xuXG4gICAgICBpZiAoYmluZCkge1xuICAgICAgICBzZWxmLmJpbmQoKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5fZmlyZSgnaW5pdCcpO1xuICAgIH0pO1xuXG4gIH1cblxuICBLZXlib2FyZC4kaW5qZWN0ID0gW1xuICAgICdjb25maWcua2V5Ym9hcmQnLFxuICAgICdldmVudEJ1cydcbiAgXTtcblxuICBLZXlib2FyZC5wcm90b3R5cGUuX2tleWRvd25IYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB0aGlzLl9rZXlIYW5kbGVyKGV2ZW50LCBLRVlET1dOX0VWRU5UKTtcbiAgfTtcblxuICBLZXlib2FyZC5wcm90b3R5cGUuX2tleXVwSGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdGhpcy5fa2V5SGFuZGxlcihldmVudCwgS0VZVVBfRVZFTlQpO1xuICB9O1xuXG4gIEtleWJvYXJkLnByb3RvdHlwZS5fa2V5SGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50LCB0eXBlKSB7XG4gICAgdmFyIGV2ZW50QnVzUmVzdWx0O1xuXG4gICAgaWYgKHRoaXMuX2lzRXZlbnRJZ25vcmVkKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAga2V5RXZlbnQ6IGV2ZW50XG4gICAgfTtcblxuICAgIGV2ZW50QnVzUmVzdWx0ID0gdGhpcy5fZXZlbnRCdXMuZmlyZSh0eXBlIHx8IEtFWURPV05fRVZFTlQsIGNvbnRleHQpO1xuXG4gICAgaWYgKGV2ZW50QnVzUmVzdWx0KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfTtcblxuICBLZXlib2FyZC5wcm90b3R5cGUuX2lzRXZlbnRJZ25vcmVkID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJpbmQga2V5Ym9hcmQgZXZlbnRzIHRvIHRoZSBnaXZlbiBET00gbm9kZS5cbiAgICpcbiAgICogQG92ZXJsb3JkXG4gICAqIEBkZXByZWNhdGVkIE5vIGxvbmdlciBpbiB1c2Ugc2luY2UgdmVyc2lvbiAxNS4wLjAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IG5vZGVcbiAgICovXG4gIC8qKlxuICAgKiBCaW5kIGtleWJvYXJkIGV2ZW50cyB0byB0aGUgY2FudmFzIG5vZGUuXG4gICAqL1xuICBLZXlib2FyZC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICAgIC8vIGxlZ2FjeSA8bm9kZT4gYXJndW1lbnQgcHJvdmlkZWRcbiAgICBpZiAobm9kZSkge1xuICAgICAgY29uc29sZS5lcnJvcigndW5zdXBwb3J0ZWQgYXJndW1lbnQgPG5vZGU+JywgbmV3IEVycm9yKGNvbXBhdE1lc3NhZ2UpKTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUga2V5Ym9hcmQgaXMgb25seSBib3VuZCBvbmNlIHRvIHRoZSBET01cbiAgICB0aGlzLnVuYmluZCgpO1xuXG4gICAgbm9kZSA9IHRoaXMuX25vZGUgPSB0aGlzLl90YXJnZXQ7XG5cbiAgICAvLyBiaW5kIGtleSBldmVudHNcbiAgICBldmVudC5iaW5kKG5vZGUsICdrZXlkb3duJywgdGhpcy5fa2V5ZG93bkhhbmRsZXIpO1xuICAgIGV2ZW50LmJpbmQobm9kZSwgJ2tleXVwJywgdGhpcy5fa2V5dXBIYW5kbGVyKTtcblxuICAgIHRoaXMuX2ZpcmUoJ2JpbmQnKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7RXZlbnRUYXJnZXR9XG4gICAqL1xuICBLZXlib2FyZC5wcm90b3R5cGUuZ2V0QmluZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9ub2RlO1xuICB9O1xuXG4gIEtleWJvYXJkLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGU7XG5cbiAgICBpZiAobm9kZSkge1xuICAgICAgdGhpcy5fZmlyZSgndW5iaW5kJyk7XG5cbiAgICAgIC8vIHVuYmluZCBrZXkgZXZlbnRzXG4gICAgICBldmVudC51bmJpbmQobm9kZSwgJ2tleWRvd24nLCB0aGlzLl9rZXlkb3duSGFuZGxlcik7XG4gICAgICBldmVudC51bmJpbmQobm9kZSwgJ2tleXVwJywgdGhpcy5fa2V5dXBIYW5kbGVyKTtcbiAgICB9XG5cbiAgICB0aGlzLl9ub2RlID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqL1xuICBLZXlib2FyZC5wcm90b3R5cGUuX2ZpcmUgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHRoaXMuX2V2ZW50QnVzLmZpcmUoJ2tleWJvYXJkLicgKyBldmVudCwgeyBub2RlOiB0aGlzLl9ub2RlIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBsaXN0ZW5lciBmdW5jdGlvbiB0aGF0IGlzIG5vdGlmaWVkIHdpdGggYEtleWJvYXJkRXZlbnRgIHdoZW5ldmVyXG4gICAqIHRoZSBrZXlib2FyZCBpcyBib3VuZCBhbmQgdGhlIHVzZXIgcHJlc3NlcyBhIGtleS4gSWYgbm8gcHJpb3JpdHkgaXNcbiAgICogcHJvdmlkZWQsIHRoZSBkZWZhdWx0IHZhbHVlIG9mIDEwMDAgaXMgdXNlZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eV1cbiAgICogQHBhcmFtIHtMaXN0ZW5lcn0gbGlzdGVuZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlPSdrZXlib2FyZC5rZXlkb3duJ11cbiAgICovXG4gIEtleWJvYXJkLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHByaW9yaXR5LCBsaXN0ZW5lciwgdHlwZSkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHByaW9yaXR5KSkge1xuICAgICAgdHlwZSA9IGxpc3RlbmVyO1xuICAgICAgbGlzdGVuZXIgPSBwcmlvcml0eTtcbiAgICAgIHByaW9yaXR5ID0gREVGQVVMVF9QUklPUklUWTtcbiAgICB9XG5cbiAgICB0aGlzLl9ldmVudEJ1cy5vbih0eXBlIHx8IEtFWURPV05fRVZFTlQsIHByaW9yaXR5LCBsaXN0ZW5lcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0xpc3RlbmVyfSBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9J2tleWJvYXJkLmtleWRvd24nXVxuICAgKi9cbiAgS2V5Ym9hcmQucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIsIHR5cGUpIHtcbiAgICB0aGlzLl9ldmVudEJ1cy5vZmYodHlwZSB8fCBLRVlET1dOX0VWRU5ULCBsaXN0ZW5lcik7XG4gIH07XG5cbiAgS2V5Ym9hcmQucHJvdG90eXBlLmhhc01vZGlmaWVyID0gaGFzTW9kaWZpZXI7XG4gIEtleWJvYXJkLnByb3RvdHlwZS5pc0NtZCA9IGlzQ21kO1xuICBLZXlib2FyZC5wcm90b3R5cGUuaXNTaGlmdCA9IGlzU2hpZnQ7XG4gIEtleWJvYXJkLnByb3RvdHlwZS5pc0tleSA9IGlzS2V5O1xuXG4gIHZhciBMT1dfUFJJT1JJVFkgPSA1MDA7XG5cblxuICAvKipcbiAgICogQWRkcyBkZWZhdWx0IGtleWJvYXJkIGJpbmRpbmdzLlxuICAgKlxuICAgKiBUaGlzIGRvZXMgbm90IHB1bGwgaW4gYW55IGZlYXR1cmVzIHdpbGwgYmluZCBvbmx5IGFjdGlvbnMgdGhhdFxuICAgKiBoYXZlIHByZXZpb3VzbHkgYmVlbiByZWdpc3RlcmVkIGFnYWluc3QgdGhlIGVkaXRvckFjdGlvbnMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50QnVzfSBldmVudEJ1c1xuICAgKiBAcGFyYW0ge0tleWJvYXJkfSBrZXlib2FyZFxuICAgKi9cbiAgZnVuY3Rpb24gS2V5Ym9hcmRCaW5kaW5ncyhldmVudEJ1cywga2V5Ym9hcmQpIHtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGV2ZW50QnVzLm9uKCdlZGl0b3JBY3Rpb25zLmluaXQnLCBMT1dfUFJJT1JJVFksIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgIHZhciBlZGl0b3JBY3Rpb25zID0gZXZlbnQuZWRpdG9yQWN0aW9ucztcblxuICAgICAgc2VsZi5yZWdpc3RlckJpbmRpbmdzKGtleWJvYXJkLCBlZGl0b3JBY3Rpb25zKTtcbiAgICB9KTtcbiAgfVxuXG4gIEtleWJvYXJkQmluZGluZ3MuJGluamVjdCA9IFtcbiAgICAnZXZlbnRCdXMnLFxuICAgICdrZXlib2FyZCdcbiAgXTtcblxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhdmFpbGFibGUga2V5Ym9hcmQgYmluZGluZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmR9IGtleWJvYXJkXG4gICAqIEBwYXJhbSB7RWRpdG9yQWN0aW9uc30gZWRpdG9yQWN0aW9uc1xuICAgKi9cbiAgS2V5Ym9hcmRCaW5kaW5ncy5wcm90b3R5cGUucmVnaXN0ZXJCaW5kaW5ncyA9IGZ1bmN0aW9uKGtleWJvYXJkLCBlZGl0b3JBY3Rpb25zKSB7XG5cbiAgICAvKipcbiAgICAgKiBBZGQga2V5Ym9hcmQgYmluZGluZyBpZiByZXNwZWN0aXZlIGVkaXRvciBhY3Rpb25cbiAgICAgKiBpcyByZWdpc3RlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvbiBuYW1lXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdGhhdCBpbXBsZW1lbnRzIHRoZSBrZXkgYmluZGluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZExpc3RlbmVyKGFjdGlvbiwgZm4pIHtcblxuICAgICAgaWYgKGVkaXRvckFjdGlvbnMuaXNSZWdpc3RlcmVkKGFjdGlvbikpIHtcbiAgICAgICAga2V5Ym9hcmQuYWRkTGlzdGVuZXIoZm4pO1xuICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gdW5kb1xuICAgIC8vIChDVFJMfENNRCkgKyBaXG4gICAgYWRkTGlzdGVuZXIoJ3VuZG8nLCBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgICAgIHZhciBldmVudCA9IGNvbnRleHQua2V5RXZlbnQ7XG5cbiAgICAgIGlmIChpc1VuZG8oZXZlbnQpKSB7XG4gICAgICAgIGVkaXRvckFjdGlvbnMudHJpZ2dlcigndW5kbycpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gcmVkb1xuICAgIC8vIENUUkwgKyBZXG4gICAgLy8gQ01EICsgU0hJRlQgKyBaXG4gICAgYWRkTGlzdGVuZXIoJ3JlZG8nLCBmdW5jdGlvbihjb250ZXh0KSB7XG5cbiAgICAgIHZhciBldmVudCA9IGNvbnRleHQua2V5RXZlbnQ7XG5cbiAgICAgIGlmIChpc1JlZG8oZXZlbnQpKSB7XG4gICAgICAgIGVkaXRvckFjdGlvbnMudHJpZ2dlcigncmVkbycpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gY29weVxuICAgIC8vIENUUkwvQ01EICsgQ1xuICAgIGFkZExpc3RlbmVyKCdjb3B5JywgZnVuY3Rpb24oY29udGV4dCkge1xuXG4gICAgICB2YXIgZXZlbnQgPSBjb250ZXh0LmtleUV2ZW50O1xuXG4gICAgICBpZiAoaXNDb3B5KGV2ZW50KSkge1xuICAgICAgICBlZGl0b3JBY3Rpb25zLnRyaWdnZXIoJ2NvcHknKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHBhc3RlXG4gICAgLy8gQ1RSTC9DTUQgKyBWXG4gICAgYWRkTGlzdGVuZXIoJ3Bhc3RlJywgZnVuY3Rpb24oY29udGV4dCkge1xuXG4gICAgICB2YXIgZXZlbnQgPSBjb250ZXh0LmtleUV2ZW50O1xuXG4gICAgICBpZiAoaXNQYXN0ZShldmVudCkpIHtcbiAgICAgICAgZWRpdG9yQWN0aW9ucy50cmlnZ2VyKCdwYXN0ZScpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gem9vbSBpbiBvbmUgc3RlcFxuICAgIC8vIENUUkwvQ01EICsgK1xuICAgIGFkZExpc3RlbmVyKCdzdGVwWm9vbScsIGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICAgICAgdmFyIGV2ZW50ID0gY29udGV4dC5rZXlFdmVudDtcblxuICAgICAgLy8gcXVpcms6IGl0IGhhcyB0byBiZSB0cmlnZ2VyZWQgYnkgYD1gIGFzIHdlbGwgdG8gd29yayBvbiBpbnRlcm5hdGlvbmFsIGtleWJvYXJkIGxheW91dFxuICAgICAgLy8gY2Y6IGh0dHBzOi8vZ2l0aHViLmNvbS9icG1uLWlvL2JwbW4tanMvaXNzdWVzLzEzNjIjaXNzdWVjb21tZW50LTcyMjk4OTc1NFxuICAgICAgaWYgKGlzS2V5KFsgJysnLCAnQWRkJywgJz0nIF0sIGV2ZW50KSAmJiBpc0NtZChldmVudCkpIHtcbiAgICAgICAgZWRpdG9yQWN0aW9ucy50cmlnZ2VyKCdzdGVwWm9vbScsIHsgdmFsdWU6IDEgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyB6b29tIG91dCBvbmUgc3RlcFxuICAgIC8vIENUUkwgKyAtXG4gICAgYWRkTGlzdGVuZXIoJ3N0ZXBab29tJywgZnVuY3Rpb24oY29udGV4dCkge1xuXG4gICAgICB2YXIgZXZlbnQgPSBjb250ZXh0LmtleUV2ZW50O1xuXG4gICAgICBpZiAoaXNLZXkoWyAnLScsICdTdWJ0cmFjdCcgXSwgZXZlbnQpICYmIGlzQ21kKGV2ZW50KSkge1xuICAgICAgICBlZGl0b3JBY3Rpb25zLnRyaWdnZXIoJ3N0ZXBab29tJywgeyB2YWx1ZTogLTEgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyB6b29tIHRvIHRoZSBkZWZhdWx0IGxldmVsXG4gICAgLy8gQ1RSTCArIDBcbiAgICBhZGRMaXN0ZW5lcignem9vbScsIGZ1bmN0aW9uKGNvbnRleHQpIHtcblxuICAgICAgdmFyIGV2ZW50ID0gY29udGV4dC5rZXlFdmVudDtcblxuICAgICAgaWYgKGlzS2V5KCcwJywgZXZlbnQpICYmIGlzQ21kKGV2ZW50KSkge1xuICAgICAgICBlZGl0b3JBY3Rpb25zLnRyaWdnZXIoJ3pvb20nLCB7IHZhbHVlOiAxIH0pO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZGVsZXRlIHNlbGVjdGVkIGVsZW1lbnRcbiAgICAvLyBERUxcbiAgICBhZGRMaXN0ZW5lcigncmVtb3ZlU2VsZWN0aW9uJywgZnVuY3Rpb24oY29udGV4dCkge1xuXG4gICAgICB2YXIgZXZlbnQgPSBjb250ZXh0LmtleUV2ZW50O1xuXG4gICAgICBpZiAoaXNLZXkoWyAnQmFja3NwYWNlJywgJ0RlbGV0ZScsICdEZWwnIF0sIGV2ZW50KSkge1xuICAgICAgICBlZGl0b3JBY3Rpb25zLnRyaWdnZXIoJ3JlbW92ZVNlbGVjdGlvbicpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7IGltcG9ydCgnZGlkaScpLk1vZHVsZURlY2xhcmF0aW9uIH1cbiAgICovXG4gIHZhciBLZXlib2FyZE1vZHVsZSA9IHtcbiAgICBfX2luaXRfXzogWyAna2V5Ym9hcmQnLCAna2V5Ym9hcmRCaW5kaW5ncycgXSxcbiAgICBrZXlib2FyZDogWyAndHlwZScsIEtleWJvYXJkIF0sXG4gICAga2V5Ym9hcmRCaW5kaW5nczogWyAndHlwZScsIEtleWJvYXJkQmluZGluZ3MgXVxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi9jb3JlL0NhbnZhcycpLmRlZmF1bHR9IENhbnZhc1xuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi9mZWF0dXJlcy9rZXlib2FyZC9LZXlib2FyZCcpLmRlZmF1bHR9IEtleWJvYXJkXG4gICAqL1xuXG4gIHZhciBERUZBVUxUX0NPTkZJRyA9IHtcbiAgICBtb3ZlU3BlZWQ6IDUwLFxuICAgIG1vdmVTcGVlZEFjY2VsZXJhdGVkOiAyMDBcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBBIGZlYXR1cmUgdGhhdCBhbGxvd3MgdXNlcnMgdG8gbW92ZSB0aGUgY2FudmFzIHVzaW5nIHRoZSBrZXlib2FyZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5tb3ZlU3BlZWQ9NTBdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLm1vdmVTcGVlZEFjY2VsZXJhdGVkPTIwMF1cbiAgICogQHBhcmFtIHtLZXlib2FyZH0ga2V5Ym9hcmRcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICAgKi9cbiAgZnVuY3Rpb24gS2V5Ym9hcmRNb3ZlKFxuICAgICAgY29uZmlnLFxuICAgICAga2V5Ym9hcmQsXG4gICAgICBjYW52YXNcbiAgKSB7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLl9jb25maWcgPSBhc3NpZ24kMSh7fSwgREVGQVVMVF9DT05GSUcsIGNvbmZpZyB8fCB7fSk7XG5cbiAgICBrZXlib2FyZC5hZGRMaXN0ZW5lcihhcnJvd3NMaXN0ZW5lcik7XG5cblxuICAgIGZ1bmN0aW9uIGFycm93c0xpc3RlbmVyKGNvbnRleHQpIHtcblxuICAgICAgdmFyIGV2ZW50ID0gY29udGV4dC5rZXlFdmVudCxcbiAgICAgICAgICBjb25maWcgPSBzZWxmLl9jb25maWc7XG5cbiAgICAgIGlmICgha2V5Ym9hcmQuaXNDbWQoZXZlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleWJvYXJkLmlzS2V5KFtcbiAgICAgICAgJ0Fycm93TGVmdCcsICdMZWZ0JyxcbiAgICAgICAgJ0Fycm93VXAnLCAnVXAnLFxuICAgICAgICAnQXJyb3dEb3duJywgJ0Rvd24nLFxuICAgICAgICAnQXJyb3dSaWdodCcsICdSaWdodCdcbiAgICAgIF0sIGV2ZW50KSkge1xuXG4gICAgICAgIHZhciBzcGVlZCA9IChcbiAgICAgICAgICBrZXlib2FyZC5pc1NoaWZ0KGV2ZW50KSA/XG4gICAgICAgICAgICBjb25maWcubW92ZVNwZWVkQWNjZWxlcmF0ZWQgOlxuICAgICAgICAgICAgY29uZmlnLm1vdmVTcGVlZFxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBkaXJlY3Rpb247XG5cbiAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgY2FzZSAnTGVmdCc6XG4gICAgICAgICAgZGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgY2FzZSAnVXAnOlxuICAgICAgICAgIGRpcmVjdGlvbiA9ICd1cCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgICBjYXNlICdSaWdodCc6XG4gICAgICAgICAgZGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgY2FzZSAnRG93bic6XG4gICAgICAgICAgZGlyZWN0aW9uID0gJ2Rvd24nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5tb3ZlQ2FudmFzKHtcbiAgICAgICAgICBzcGVlZDogc3BlZWQsXG4gICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICBkaXJlY3Rpb246ICd1cCcgfCAnZG93bicgfCAnbGVmdCcgfCAncmlnaHQnO1xuICAgICAqICAgc3BlZWQ6IG51bWJlcjtcbiAgICAgKiB9fSBvcHRpb25zXG4gICAgICovXG4gICAgdGhpcy5tb3ZlQ2FudmFzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICB2YXIgZHggPSAwLFxuICAgICAgICAgIGR5ID0gMCxcbiAgICAgICAgICBzcGVlZCA9IG9wdGlvbnMuc3BlZWQ7XG5cbiAgICAgIHZhciBhY3R1YWxTcGVlZCA9IHNwZWVkIC8gTWF0aC5taW4oTWF0aC5zcXJ0KGNhbnZhcy52aWV3Ym94KCkuc2NhbGUpLCAxKTtcblxuICAgICAgc3dpdGNoIChvcHRpb25zLmRpcmVjdGlvbikge1xuICAgICAgY2FzZSAnbGVmdCc6IC8vIExlZnRcbiAgICAgICAgZHggPSBhY3R1YWxTcGVlZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1cCc6IC8vIFVwXG4gICAgICAgIGR5ID0gYWN0dWFsU3BlZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQnOiAvLyBSaWdodFxuICAgICAgICBkeCA9IC1hY3R1YWxTcGVlZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkb3duJzogLy8gRG93blxuICAgICAgICBkeSA9IC1hY3R1YWxTcGVlZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhbnZhcy5zY3JvbGwoe1xuICAgICAgICBkeDogZHgsXG4gICAgICAgIGR5OiBkeVxuICAgICAgfSk7XG4gICAgfTtcblxuICB9XG5cblxuICBLZXlib2FyZE1vdmUuJGluamVjdCA9IFtcbiAgICAnY29uZmlnLmtleWJvYXJkTW92ZScsXG4gICAgJ2tleWJvYXJkJyxcbiAgICAnY2FudmFzJ1xuICBdO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7IGltcG9ydCgnZGlkaScpLk1vZHVsZURlY2xhcmF0aW9uIH1cbiAgICovXG4gIHZhciBLZXlib2FyZE1vdmVNb2R1bGUgPSB7XG4gICAgX19kZXBlbmRzX186IFtcbiAgICAgIEtleWJvYXJkTW9kdWxlXG4gICAgXSxcbiAgICBfX2luaXRfXzogWyAna2V5Ym9hcmRNb3ZlJyBdLFxuICAgIGtleWJvYXJkTW92ZTogWyAndHlwZScsIEtleWJvYXJkTW92ZSBdXG4gIH07XG5cbiAgdmFyIENVUlNPUl9DTFNfUEFUVEVSTiA9IC9eZGpzLWN1cnNvci0uKiQvO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZVxuICAgKi9cbiAgZnVuY3Rpb24gc2V0KG1vZGUpIHtcbiAgICB2YXIgY2xhc3NlcyQxID0gY2xhc3Nlcyhkb2N1bWVudC5ib2R5KTtcblxuICAgIGNsYXNzZXMkMS5yZW1vdmVNYXRjaGluZyhDVVJTT1JfQ0xTX1BBVFRFUk4pO1xuXG4gICAgaWYgKG1vZGUpIHtcbiAgICAgIGNsYXNzZXMkMS5hZGQoJ2Rqcy1jdXJzb3ItJyArIG1vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVuc2V0KCkge1xuICAgIHNldChudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9jb3JlL0V2ZW50QnVzJykuZGVmYXVsdH0gRXZlbnRCdXNcbiAgICovXG5cbiAgdmFyIFRSQVBfUFJJT1JJVFkgPSA1MDAwO1xuXG4gIC8qKlxuICAgKiBJbnN0YWxscyBhIGNsaWNrIHRyYXAgdGhhdCBwcmV2ZW50cyBhIGdob3N0IGNsaWNrIGZvbGxvd2luZyBhIGRyYWdnaW5nIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudEJ1c30gZXZlbnRCdXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtldmVudE5hbWU9J2VsZW1lbnQuY2xpY2snXVxuICAgKlxuICAgKiBAcmV0dXJuIHsoKSA9PiB2b2lkfSBhIGZ1bmN0aW9uIHRvIGltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgaW5zdGFsbGVkIHRyYXAuXG4gICAqL1xuICBmdW5jdGlvbiBpbnN0YWxsKGV2ZW50QnVzLCBldmVudE5hbWUpIHtcblxuICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZSB8fCAnZWxlbWVudC5jbGljayc7XG5cbiAgICBmdW5jdGlvbiB0cmFwKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGV2ZW50QnVzLm9uY2UoZXZlbnROYW1lLCBUUkFQX1BSSU9SSVRZLCB0cmFwKTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGV2ZW50QnVzLm9mZihldmVudE5hbWUsIHRyYXApO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdXRpbC9UeXBlcycpLlBvaW50fSBQb2ludFxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi91dGlsL1R5cGVzJykuUmVjdH0gUmVjdFxuICAgKi9cblxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UG9pbnR9IGFcbiAgICogQHBhcmFtIHtQb2ludH0gYlxuICAgKiBAcmV0dXJuIHtQb2ludH1cbiAgICovXG4gIGZ1bmN0aW9uIGRlbHRhKGEsIGIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogYS54IC0gYi54LFxuICAgICAgeTogYS55IC0gYi55XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi9jb3JlL0NhbnZhcycpLmRlZmF1bHR9IENhbnZhc1xuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi9jb3JlL0V2ZW50QnVzJykuZGVmYXVsdH0gRXZlbnRCdXNcbiAgICovXG5cbiAgdmFyIFRIUkVTSE9MRCA9IDE1O1xuXG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGNhbnZhcyB2aWEgbW91c2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICovXG4gIGZ1bmN0aW9uIE1vdmVDYW52YXMoZXZlbnRCdXMsIGNhbnZhcykge1xuXG4gICAgdmFyIGNvbnRleHQ7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZWRvd24oZXZlbnQpIHtcbiAgICAgIHJldHVybiBoYW5kbGVTdGFydChldmVudC5vcmlnaW5hbEV2ZW50KTtcbiAgICB9XG5cbiAgICAvLyBsaXN0ZW4gZm9yIG1vdmUgb24gZWxlbWVudCBtb3VzZSBkb3duO1xuICAgIC8vIGFsbG93IG90aGVycyB0byBob29rIGludG8gdGhlIGV2ZW50IGJlZm9yZSB1cyB0aG91Z2hcbiAgICAvLyAoZHJhZ2dpbmcgLyBlbGVtZW50IG1vdmluZyB3aWxsIGRvIHRoaXMpXG4gICAgZXZlbnRCdXMub24oJ2NhbnZhcy5mb2N1cy5jaGFuZ2VkJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5mb2N1c2VkKSB7XG4gICAgICAgIGV2ZW50QnVzLm9uKCdlbGVtZW50Lm1vdXNlZG93bicsIDUwMCwgaGFuZGxlTW91c2Vkb3duKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50QnVzLm9mZignZWxlbWVudC5tb3VzZWRvd24nLCBoYW5kbGVNb3VzZWRvd24pO1xuICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3ZlKGV2ZW50KSB7XG5cbiAgICAgIHZhciBzdGFydCA9IGNvbnRleHQuc3RhcnQsXG4gICAgICAgICAgYnV0dG9uID0gY29udGV4dC5idXR0b24sXG4gICAgICAgICAgcG9zaXRpb24gPSB0b1BvaW50KGV2ZW50KSxcbiAgICAgICAgICBkZWx0YSQxID0gZGVsdGEocG9zaXRpb24sIHN0YXJ0KTtcblxuICAgICAgaWYgKCFjb250ZXh0LmRyYWdnaW5nICYmIGxlbmd0aChkZWx0YSQxKSA+IFRIUkVTSE9MRCkge1xuICAgICAgICBjb250ZXh0LmRyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAoYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgaW5zdGFsbChldmVudEJ1cyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXQoJ2dyYWInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnRleHQuZHJhZ2dpbmcpIHtcblxuICAgICAgICB2YXIgbGFzdFBvc2l0aW9uID0gY29udGV4dC5sYXN0IHx8IGNvbnRleHQuc3RhcnQ7XG5cbiAgICAgICAgZGVsdGEkMSA9IGRlbHRhKHBvc2l0aW9uLCBsYXN0UG9zaXRpb24pO1xuXG4gICAgICAgIGNhbnZhcy5zY3JvbGwoe1xuICAgICAgICAgIGR4OiBkZWx0YSQxLngsXG4gICAgICAgICAgZHk6IGRlbHRhJDEueVxuICAgICAgICB9KTtcblxuICAgICAgICBjb250ZXh0Lmxhc3QgPSBwb3NpdGlvbjtcbiAgICAgIH1cblxuICAgICAgLy8gcHJldmVudCBzZWxlY3RcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFbmQoZXZlbnQkMSkge1xuICAgICAgZXZlbnQudW5iaW5kKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgaGFuZGxlTW92ZSk7XG4gICAgICBldmVudC51bmJpbmQoZG9jdW1lbnQsICdtb3VzZXVwJywgaGFuZGxlRW5kKTtcblxuICAgICAgY29udGV4dCA9IG51bGw7XG5cbiAgICAgIHVuc2V0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RhcnQoZXZlbnQkMSkge1xuXG4gICAgICAvLyBldmVudCBpcyBhbHJlYWR5IGhhbmRsZWQgYnkgJy5kanMtZHJhZ2dhYmxlJ1xuICAgICAgaWYgKGNsb3Nlc3QoZXZlbnQkMS50YXJnZXQsICcuZGpzLWRyYWdnYWJsZScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGJ1dHRvbiA9IGV2ZW50JDEuYnV0dG9uO1xuXG4gICAgICAvLyByZWplY3QgcmlnaHQgbW91c2UgYnV0dG9uIG9yIG1vZGlmaWVyIGtleVxuICAgICAgaWYgKGJ1dHRvbiA+PSAyIHx8IGV2ZW50JDEuY3RybEtleSB8fCBldmVudCQxLnNoaWZ0S2V5IHx8IGV2ZW50JDEuYWx0S2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29udGV4dCA9IHtcbiAgICAgICAgYnV0dG9uOiBidXR0b24sXG4gICAgICAgIHN0YXJ0OiB0b1BvaW50KGV2ZW50JDEpXG4gICAgICB9O1xuXG4gICAgICBldmVudC5iaW5kKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgaGFuZGxlTW92ZSk7XG4gICAgICBldmVudC5iaW5kKGRvY3VtZW50LCAnbW91c2V1cCcsIGhhbmRsZUVuZCk7XG5cbiAgICAgIC8vIHdlJ3ZlIGhhbmRsZWQgdGhlIGV2ZW50XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmlzQWN0aXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gISFjb250ZXh0O1xuICAgIH07XG5cbiAgfVxuXG5cbiAgTW92ZUNhbnZhcy4kaW5qZWN0ID0gW1xuICAgICdldmVudEJ1cycsXG4gICAgJ2NhbnZhcydcbiAgXTtcblxuXG5cbiAgLy8gaGVscGVycyAvLy8vLy8vXG5cbiAgZnVuY3Rpb24gbGVuZ3RoKHBvaW50KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwb2ludC54LCAyKSArIE1hdGgucG93KHBvaW50LnksIDIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7IGltcG9ydCgnZGlkaScpLk1vZHVsZURlY2xhcmF0aW9uIH1cbiAgICovXG4gIHZhciBNb3ZlQ2FudmFzTW9kdWxlID0ge1xuICAgIF9faW5pdF9fOiBbICdtb3ZlQ2FudmFzJyBdLFxuICAgIG1vdmVDYW52YXM6IFsgJ3R5cGUnLCBNb3ZlQ2FudmFzIF1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBsb2dhcml0aG0gb2YgeCB3aXRoIGJhc2UgMTAuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqL1xuICBmdW5jdGlvbiBsb2cxMCh4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5sb2coMTApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzdGVwIHNpemUgZm9yIGdpdmVuIHJhbmdlIGFuZCBudW1iZXIgb2Ygc3RlcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByYW5nZVxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFuZ2UubWluXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYW5nZS5tYXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXBzXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdGVwU2l6ZShyYW5nZSwgc3RlcHMpIHtcblxuICAgIHZhciBtaW5MaW5lYXJSYW5nZSA9IGxvZzEwKHJhbmdlLm1pbiksXG4gICAgICAgIG1heExpbmVhclJhbmdlID0gbG9nMTAocmFuZ2UubWF4KTtcblxuICAgIHZhciBhYnNvbHV0ZUxpbmVhclJhbmdlID0gTWF0aC5hYnMobWluTGluZWFyUmFuZ2UpICsgTWF0aC5hYnMobWF4TGluZWFyUmFuZ2UpO1xuXG4gICAgcmV0dXJuIGFic29sdXRlTGluZWFyUmFuZ2UgLyBzdGVwcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmFuZ2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhbmdlLm1pblxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFuZ2UubWF4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVxuICAgKi9cbiAgZnVuY3Rpb24gY2FwKHJhbmdlLCBzY2FsZSkge1xuICAgIHJldHVybiBNYXRoLm1heChyYW5nZS5taW4sIE1hdGgubWluKHJhbmdlLm1heCwgc2NhbGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi9jb3JlL0NhbnZhcycpLmRlZmF1bHR9IENhbnZhc1xuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi9jb3JlL0V2ZW50QnVzJykuZGVmYXVsdH0gRXZlbnRCdXNcbiAgICpcbiAgICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vdXRpbC9UeXBlcycpLlBvaW50fSBQb2ludFxuICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi91dGlsL1R5cGVzJykuU2Nyb2xsRGVsdGF9IFNjcm9sbERlbHRhXG4gICAqL1xuXG4gIHZhciBzaWduID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gbiA+PSAwID8gMSA6IC0xO1xuICB9O1xuXG4gIHZhciBSQU5HRSA9IHsgbWluOiAwLjIsIG1heDogNCB9LFxuICAgICAgTlVNX1NURVBTID0gMTA7XG5cbiAgdmFyIERFTFRBX1RIUkVTSE9MRCA9IDAuMTtcblxuICB2YXIgREVGQVVMVF9TQ0FMRSA9IDAuNzU7XG5cbiAgLyoqXG4gICAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHpvb21pbmcgYW5kIHNjcm9sbGluZyB3aXRoaW4gdGhlXG4gICAqIHtAbGluayBDYW52YXN9IHZpYSB0aGUgbW91c2Ugd2hlZWwuXG4gICAqXG4gICAqIE1vdXNlIHdoZWVsIHpvb21pbmcgLyBzY3JvbGxpbmcgbWF5IGJlIGRpc2FibGVkIHVzaW5nXG4gICAqIHRoZSB7QGxpbmsgdG9nZ2xlKGVuYWJsZWQpfSBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb25maWcuZW5hYmxlZD10cnVlXSBkZWZhdWx0IGVuYWJsZWQgc3RhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcuc2NhbGU9Ljc1XSBzY3JvbGwgc2Vuc2l2aXR5XG4gICAqIEBwYXJhbSB7RXZlbnRCdXN9IGV2ZW50QnVzXG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICovXG4gIGZ1bmN0aW9uIFpvb21TY3JvbGwoY29uZmlnLCBldmVudEJ1cywgY2FudmFzKSB7XG5cbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG5cbiAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5fY29udGFpbmVyID0gY2FudmFzLl9jb250YWluZXI7XG5cbiAgICB0aGlzLl9oYW5kbGVXaGVlbCA9IGJpbmQkMih0aGlzLl9oYW5kbGVXaGVlbCwgdGhpcyk7XG5cbiAgICB0aGlzLl90b3RhbERlbHRhID0gMDtcbiAgICB0aGlzLl9zY2FsZSA9IGNvbmZpZy5zY2FsZSB8fCBERUZBVUxUX1NDQUxFO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZXZlbnRCdXMub24oJ2NhbnZhcy5mb2N1cy5jaGFuZ2VkJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHNlbGYuX2luaXQoZXZlbnQuZm9jdXNlZCAmJiBjb25maWcuZW5hYmxlZCAhPT0gZmFsc2UpO1xuICAgIH0pO1xuICB9XG5cbiAgWm9vbVNjcm9sbC4kaW5qZWN0ID0gW1xuICAgICdjb25maWcuem9vbVNjcm9sbCcsXG4gICAgJ2V2ZW50QnVzJyxcbiAgICAnY2FudmFzJ1xuICBdO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1Njcm9sbERlbHRhfSBkZWx0YVxuICAgKi9cbiAgWm9vbVNjcm9sbC5wcm90b3R5cGUuc2Nyb2xsID0gZnVuY3Rpb24gc2Nyb2xsKGRlbHRhKSB7XG4gICAgdGhpcy5fY2FudmFzLnNjcm9sbChkZWx0YSk7XG4gIH07XG5cblxuICBab29tU2Nyb2xsLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMuX2NhbnZhcy56b29tKCdmaXQtdmlld3BvcnQnKTtcbiAgfTtcblxuICAvKipcbiAgICogWm9vbSBkZXBlbmRpbmcgb24gZGVsdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVxuICAgKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvblxuICAgKi9cbiAgWm9vbVNjcm9sbC5wcm90b3R5cGUuem9vbSA9IGZ1bmN0aW9uIHpvb20oZGVsdGEsIHBvc2l0aW9uKSB7XG5cbiAgICAvLyB6b29tIHdpdGggaGFsZiB0aGUgc3RlcCBzaXplIG9mIHN0ZXBab29tXG4gICAgdmFyIHN0ZXBTaXplID0gZ2V0U3RlcFNpemUoUkFOR0UsIE5VTV9TVEVQUyAqIDIpO1xuXG4gICAgLy8gYWRkIHVudGlsIHRocmVzaG9sZCByZWFjaGVkXG4gICAgdGhpcy5fdG90YWxEZWx0YSArPSBkZWx0YTtcblxuICAgIGlmIChNYXRoLmFicyh0aGlzLl90b3RhbERlbHRhKSA+IERFTFRBX1RIUkVTSE9MRCkge1xuICAgICAgdGhpcy5fem9vbShkZWx0YSwgcG9zaXRpb24sIHN0ZXBTaXplKTtcblxuICAgICAgLy8gcmVzZXRcbiAgICAgIHRoaXMuX3RvdGFsRGVsdGEgPSAwO1xuICAgIH1cbiAgfTtcblxuXG4gIFpvb21TY3JvbGwucHJvdG90eXBlLl9oYW5kbGVXaGVlbCA9IGZ1bmN0aW9uIGhhbmRsZVdoZWVsKGV2ZW50KSB7XG5cbiAgICBpZiAoIXRoaXMuX2NhbnZhcy5pc0ZvY3VzZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0gdGhpcy5fY29udGFpbmVyO1xuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIC8vIHBpbmNoIHRvIHpvb20gaXMgbWFwcGVkIHRvIHdoZWVsICsgY3RybEtleSA9IHRydWVcbiAgICAvLyBpbiBtb2Rlcm4gYnJvd3NlcnMgKCEpXG5cbiAgICB2YXIgaXNab29tID0gZXZlbnQuY3RybEtleSB8fCAoaXNNYWMoKSAmJiBldmVudC5tZXRhS2V5KTtcblxuICAgIHZhciBpc0hvcml6b250YWxTY3JvbGwgPSBldmVudC5zaGlmdEtleTtcblxuICAgIHZhciBmYWN0b3IgPSAtMSAqIHRoaXMuX3NjYWxlLFxuICAgICAgICBkZWx0YTtcblxuICAgIGlmIChpc1pvb20pIHtcbiAgICAgIGZhY3RvciAqPSBldmVudC5kZWx0YU1vZGUgPT09IDAgPyAwLjAyMCA6IDAuMzI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZhY3RvciAqPSBldmVudC5kZWx0YU1vZGUgPT09IDAgPyAxLjAgOiAxNi4wO1xuICAgIH1cblxuICAgIGlmIChpc1pvb20pIHtcbiAgICAgIHZhciBlbGVtZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIHZhciBvZmZzZXQgPSB7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSBlbGVtZW50UmVjdC5sZWZ0LFxuICAgICAgICB5OiBldmVudC5jbGllbnRZIC0gZWxlbWVudFJlY3QudG9wXG4gICAgICB9O1xuXG4gICAgICBkZWx0YSA9IChcbiAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgIE1hdGgucG93KGV2ZW50LmRlbHRhWSwgMikgK1xuICAgICAgICAgIE1hdGgucG93KGV2ZW50LmRlbHRhWCwgMilcbiAgICAgICAgKSAqIHNpZ24oZXZlbnQuZGVsdGFZKSAqIGZhY3RvclxuICAgICAgKTtcblxuICAgICAgLy8gem9vbSBpbiByZWxhdGl2ZSB0byBkaWFncmFtIHt4LHl9IGNvb3JkaW5hdGVzXG4gICAgICB0aGlzLnpvb20oZGVsdGEsIG9mZnNldCk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgaWYgKGlzSG9yaXpvbnRhbFNjcm9sbCkge1xuICAgICAgICBkZWx0YSA9IHtcbiAgICAgICAgICBkeDogZmFjdG9yICogZXZlbnQuZGVsdGFZLFxuICAgICAgICAgIGR5OiAwXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWx0YSA9IHtcbiAgICAgICAgICBkeDogZmFjdG9yICogZXZlbnQuZGVsdGFYLFxuICAgICAgICAgIGR5OiBmYWN0b3IgKiBldmVudC5kZWx0YVlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY3JvbGwoZGVsdGEpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogWm9vbSB3aXRoIGZpeGVkIHN0ZXAgc2l6ZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIFpvb20gZGVsdGEgKDEgZm9yIHpvb21pbmcgaW4sIC0xIGZvciB6b29taW5nIG91dCkuXG4gICAqIEBwYXJhbSB7UG9pbnR9IFtwb3NpdGlvbl1cbiAgICovXG4gIFpvb21TY3JvbGwucHJvdG90eXBlLnN0ZXBab29tID0gZnVuY3Rpb24gc3RlcFpvb20oZGVsdGEsIHBvc2l0aW9uKSB7XG5cbiAgICB2YXIgc3RlcFNpemUgPSBnZXRTdGVwU2l6ZShSQU5HRSwgTlVNX1NURVBTKTtcblxuICAgIHRoaXMuX3pvb20oZGVsdGEsIHBvc2l0aW9uLCBzdGVwU2l6ZSk7XG4gIH07XG5cblxuICAvKipcbiAgICogWm9vbSBpbi9vdXQgZ2l2ZW4gYSBzdGVwIHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVxuICAgKiBAcGFyYW0ge1BvaW50fSBbcG9zaXRpb25dXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwU2l6ZVxuICAgKi9cbiAgWm9vbVNjcm9sbC5wcm90b3R5cGUuX3pvb20gPSBmdW5jdGlvbihkZWx0YSwgcG9zaXRpb24sIHN0ZXBTaXplKSB7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcblxuICAgIHZhciBkaXJlY3Rpb24gPSBkZWx0YSA+IDAgPyAxIDogLTE7XG5cbiAgICB2YXIgY3VycmVudExpbmVhclpvb21MZXZlbCA9IGxvZzEwKGNhbnZhcy56b29tKCkpO1xuXG4gICAgLy8gc25hcCB0byBhIHByb3hpbWF0ZSB6b29tIHN0ZXBcbiAgICB2YXIgbmV3TGluZWFyWm9vbUxldmVsID0gTWF0aC5yb3VuZChjdXJyZW50TGluZWFyWm9vbUxldmVsIC8gc3RlcFNpemUpICogc3RlcFNpemU7XG5cbiAgICAvLyBpbmNyZWFzZSBvciBkZWNyZWFzZSBvbmUgem9vbSBzdGVwIGluIHRoZSBnaXZlbiBkaXJlY3Rpb25cbiAgICBuZXdMaW5lYXJab29tTGV2ZWwgKz0gc3RlcFNpemUgKiBkaXJlY3Rpb247XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIGFic29sdXRlIGxvZ2FyaXRobWljIHpvb20gbGV2ZWwgYmFzZWQgb24gdGhlIGxpbmVhciB6b29tIGxldmVsXG4gICAgLy8gKGUuZy4gMiBmb3IgYW4gYWJzb2x1dGUgeDIgem9vbSlcbiAgICB2YXIgbmV3TG9nWm9vbUxldmVsID0gTWF0aC5wb3coMTAsIG5ld0xpbmVhclpvb21MZXZlbCk7XG5cbiAgICBjYW52YXMuem9vbShjYXAoUkFOR0UsIG5ld0xvZ1pvb21MZXZlbCksIHBvc2l0aW9uKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBUb2dnbGUgdGhlIHpvb20gc2Nyb2xsIGFiaWxpdHkgdmlhIG1vdXNlIHdoZWVsLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtuZXdFbmFibGVkXSBuZXcgZW5hYmxlZCBzdGF0ZVxuICAgKi9cbiAgWm9vbVNjcm9sbC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKG5ld0VuYWJsZWQpIHtcblxuICAgIHZhciBlbGVtZW50ID0gdGhpcy5fY29udGFpbmVyO1xuICAgIHZhciBoYW5kbGVXaGVlbCA9IHRoaXMuX2hhbmRsZVdoZWVsO1xuXG4gICAgdmFyIG9sZEVuYWJsZWQgPSB0aGlzLl9lbmFibGVkO1xuXG4gICAgaWYgKHR5cGVvZiBuZXdFbmFibGVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbmV3RW5hYmxlZCA9ICFvbGRFbmFibGVkO1xuICAgIH1cblxuICAgIC8vIG9ubHkgcmVhY3Qgb24gYWN0dWFsIGNoYW5nZXNcbiAgICBpZiAob2xkRW5hYmxlZCAhPT0gbmV3RW5hYmxlZCkge1xuXG4gICAgICAvLyBhZGQgb3IgcmVtb3ZlIHdoZWVsIGxpc3RlbmVyIGJhc2VkIG9uXG4gICAgICAvLyBjaGFuZ2VkIGVuYWJsZWQgc3RhdGVcbiAgICAgIGV2ZW50W25ld0VuYWJsZWQgPyAnYmluZCcgOiAndW5iaW5kJ10oZWxlbWVudCwgJ3doZWVsJywgaGFuZGxlV2hlZWwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbmFibGVkID0gbmV3RW5hYmxlZDtcblxuICAgIHJldHVybiBuZXdFbmFibGVkO1xuICB9O1xuXG5cbiAgWm9vbVNjcm9sbC5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbihuZXdFbmFibGVkKSB7XG4gICAgdGhpcy50b2dnbGUobmV3RW5hYmxlZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsgaW1wb3J0KCdkaWRpJykuTW9kdWxlRGVjbGFyYXRpb24gfVxuICAgKi9cbiAgdmFyIFpvb21TY3JvbGxNb2R1bGUgPSB7XG4gICAgX19pbml0X186IFsgJ3pvb21TY3JvbGwnIF0sXG4gICAgem9vbVNjcm9sbDogWyAndHlwZScsIFpvb21TY3JvbGwgXVxuICB9O1xuXG4gIC8qKlxyXG4gICAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL0Jhc2VWaWV3ZXInKS5CYXNlVmlld2VyT3B0aW9ucyB9IEJhc2VWaWV3ZXJPcHRpb25zXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEEgdmlld2VyIHdpdGggbW91c2UgYW5kIGtleWJvYXJkIG5hdmlnYXRpb24gZmVhdHVyZXMuXHJcbiAgICpcclxuICAgKiBAdGVtcGxhdGUgW1NlcnZpY2VNYXA9bnVsbF1cclxuICAgKlxyXG4gICAqIEBleHRlbmRzIFZpZXdlcjxTZXJ2aWNlTWFwPlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCYXNlVmlld2VyT3B0aW9uc30gW29wdGlvbnNdXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gTmF2aWdhdGVkVmlld2VyKG9wdGlvbnMpIHtcclxuICAgIFZpZXdlci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgZShOYXZpZ2F0ZWRWaWV3ZXIsIFZpZXdlcik7XHJcblxyXG5cclxuICBOYXZpZ2F0ZWRWaWV3ZXIucHJvdG90eXBlLl9uYXZpZ2F0aW9uTW9kdWxlcyA9IFtcclxuICAgIEtleWJvYXJkTW92ZU1vZHVsZSxcclxuICAgIE1vdmVDYW52YXNNb2R1bGUsXHJcbiAgICBab29tU2Nyb2xsTW9kdWxlXHJcbiAgXTtcclxuXHJcbiAgTmF2aWdhdGVkVmlld2VyLnByb3RvdHlwZS5fbW9kdWxlcyA9IFtdLmNvbmNhdChcclxuICAgIFZpZXdlci5wcm90b3R5cGUuX21vZHVsZXMsXHJcbiAgICBOYXZpZ2F0ZWRWaWV3ZXIucHJvdG90eXBlLl9uYXZpZ2F0aW9uTW9kdWxlc1xyXG4gICk7XG5cbiAgcmV0dXJuIE5hdmlnYXRlZFZpZXdlcjtcblxufSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/bpmn-js/dist/bpmn-navigated-viewer.development.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/bpmn-js/dist/assets/bpmn-font/css/bpmn.css":
/*!*********************************************************************!*\
  !*** ../../node_modules/bpmn-js/dist/assets/bpmn-font/css/bpmn.css ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"9054d3ef134d\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2JwbW4tanMvZGlzdC9hc3NldHMvYnBtbi1mb250L2Nzcy9icG1uLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL3F1YWRkcmEtd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9icG1uLWpzL2Rpc3QvYXNzZXRzL2JwbW4tZm9udC9jc3MvYnBtbi5jc3M/YWVmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjkwNTRkM2VmMTM0ZFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/bpmn-js/dist/assets/bpmn-font/css/bpmn.css\n");

/***/ }),

/***/ "(ssr)/../../node_modules/bpmn-js/dist/assets/diagram-js.css":
/*!*************************************************************!*\
  !*** ../../node_modules/bpmn-js/dist/assets/diagram-js.css ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"6c5f53bbe49f\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2JwbW4tanMvZGlzdC9hc3NldHMvZGlhZ3JhbS1qcy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFkZHJhLXdlYi8uLi8uLi9ub2RlX21vZHVsZXMvYnBtbi1qcy9kaXN0L2Fzc2V0cy9kaWFncmFtLWpzLmNzcz9kOGFmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNmM1ZjUzYmJlNDlmXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/bpmn-js/dist/assets/diagram-js.css\n");

/***/ })

};
;