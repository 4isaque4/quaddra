"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/saxen";
exports.ids = ["vendor-chunks/saxen"];
exports.modules = {

/***/ "(ssr)/../../node_modules/saxen/dist/index.js":
/*!**********************************************!*\
  !*** ../../node_modules/saxen/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   decode: () => (/* binding */ decodeEntities)\n/* harmony export */ });\nvar fromCharCode = String.fromCharCode;\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar ENTITY_PATTERN = /&#(\\d+);|&#x([0-9a-f]+);|&(\\w+);/ig;\n\nvar ENTITY_MAPPING = {\n  'amp': '&',\n  'apos': '\\'',\n  'gt': '>',\n  'lt': '<',\n  'quot': '\"'\n};\n\n// map UPPERCASE variants of supported special chars\nObject.keys(ENTITY_MAPPING).forEach(function(k) {\n  ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];\n});\n\n\nfunction replaceEntities(_, d, x, z) {\n\n  // reserved names, i.e. &nbsp;\n  if (z) {\n    if (hasOwnProperty.call(ENTITY_MAPPING, z)) {\n      return ENTITY_MAPPING[z];\n    } else {\n\n      // fall back to original value\n      return '&' + z + ';';\n    }\n  }\n\n  // decimal encoded char\n  if (d) {\n    return fromCharCode(d);\n  }\n\n  // hex encoded char\n  return fromCharCode(parseInt(x, 16));\n}\n\n\n/**\n * A basic entity decoder that can decode a minimal\n * sub-set of reserved names (&amp;) as well as\n * hex (&#xaaf;) and decimal (&#1231;) encoded characters.\n *\n * @param {string} s\n *\n * @return {string} decoded string\n */\nfunction decodeEntities(s) {\n  if (s.length > 3 && s.indexOf('&') !== -1) {\n    return s.replace(ENTITY_PATTERN, replaceEntities);\n  }\n\n  return s;\n}\n\nvar NON_WHITESPACE_OUTSIDE_ROOT_NODE = 'non-whitespace outside of root node';\n\nfunction error(msg) {\n  return new Error(msg);\n}\n\nfunction missingNamespaceForPrefix(prefix) {\n  return 'missing namespace for prefix <' + prefix + '>';\n}\n\nfunction getter(getFn) {\n  return {\n    'get': getFn,\n    'enumerable': true\n  };\n}\n\nfunction cloneNsMatrix(nsMatrix) {\n  var clone = {}, key;\n  for (key in nsMatrix) {\n    clone[key] = nsMatrix[key];\n  }\n  return clone;\n}\n\nfunction uriPrefix(prefix) {\n  return prefix + '$uri';\n}\n\nfunction buildNsMatrix(nsUriToPrefix) {\n  var nsMatrix = {},\n      uri,\n      prefix;\n\n  for (uri in nsUriToPrefix) {\n    prefix = nsUriToPrefix[uri];\n    nsMatrix[prefix] = prefix;\n    nsMatrix[uriPrefix(prefix)] = uri;\n  }\n\n  return nsMatrix;\n}\n\nfunction noopGetContext() {\n  return { line: 0, column: 0 };\n}\n\nfunction throwFunc(err) {\n  throw err;\n}\n\n/**\n * Creates a new parser with the given options.\n *\n * @constructor\n *\n * @param  {!Object<string, ?>=} options\n */\nfunction Parser(options) {\n\n  if (!this) {\n    return new Parser(options);\n  }\n\n  var proxy = options && options['proxy'];\n\n  var onText,\n      onOpenTag,\n      onCloseTag,\n      onCDATA,\n      onError = throwFunc,\n      onWarning,\n      onComment,\n      onQuestion,\n      onAttention;\n\n  var getContext = noopGetContext;\n\n  /**\n   * Do we need to parse the current elements attributes for namespaces?\n   *\n   * @type {boolean}\n   */\n  var maybeNS = false;\n\n  /**\n   * Do we process namespaces at all?\n   *\n   * @type {boolean}\n   */\n  var isNamespace = false;\n\n  /**\n   * The caught error returned on parse end\n   *\n   * @type {Error}\n   */\n  var returnError = null;\n\n  /**\n   * Should we stop parsing?\n   *\n   * @type {boolean}\n   */\n  var parseStop = false;\n\n  /**\n   * A map of { uri: prefix } used by the parser.\n   *\n   * This map will ensure we can normalize prefixes during processing;\n   * for each uri, only one prefix will be exposed to the handlers.\n   *\n   * @type {!Object<string, string>}}\n   */\n  var nsUriToPrefix;\n\n  /**\n   * Handle parse error.\n   *\n   * @param  {string|Error} err\n   */\n  function handleError(err) {\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n\n    returnError = err;\n\n    onError(err, getContext);\n  }\n\n  /**\n   * Handle parse error.\n   *\n   * @param  {string|Error} err\n   */\n  function handleWarning(err) {\n\n    if (!onWarning) {\n      return;\n    }\n\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n\n    onWarning(err, getContext);\n  }\n\n  /**\n   * Register parse listener.\n   *\n   * @param  {string}   name\n   * @param  {Function} cb\n   *\n   * @return {Parser}\n   */\n  this['on'] = function(name, cb) {\n\n    if (typeof cb !== 'function') {\n      throw error('required args <name, cb>');\n    }\n\n    switch (name) {\n    case 'openTag': onOpenTag = cb; break;\n    case 'text': onText = cb; break;\n    case 'closeTag': onCloseTag = cb; break;\n    case 'error': onError = cb; break;\n    case 'warn': onWarning = cb; break;\n    case 'cdata': onCDATA = cb; break;\n    case 'attention': onAttention = cb; break; // <!XXXXX zzzz=\"eeee\">\n    case 'question': onQuestion = cb; break; // <? ....  ?>\n    case 'comment': onComment = cb; break;\n    default:\n      throw error('unsupported event: ' + name);\n    }\n\n    return this;\n  };\n\n  /**\n   * Set the namespace to prefix mapping.\n   *\n   * @example\n   *\n   * parser.ns({\n   *   'http://foo': 'foo',\n   *   'http://bar': 'bar'\n   * });\n   *\n   * @param  {!Object<string, string>} nsMap\n   *\n   * @return {Parser}\n   */\n  this['ns'] = function(nsMap) {\n\n    if (typeof nsMap === 'undefined') {\n      nsMap = {};\n    }\n\n    if (typeof nsMap !== 'object') {\n      throw error('required args <nsMap={}>');\n    }\n\n    var _nsUriToPrefix = {}, k;\n\n    for (k in nsMap) {\n      _nsUriToPrefix[k] = nsMap[k];\n    }\n\n    isNamespace = true;\n    nsUriToPrefix = _nsUriToPrefix;\n\n    return this;\n  };\n\n  /**\n   * Parse xml string.\n   *\n   * @param  {string} xml\n   *\n   * @return {Error} returnError, if not thrown\n   */\n  this['parse'] = function(xml) {\n    if (typeof xml !== 'string') {\n      throw error('required args <xml=string>');\n    }\n\n    returnError = null;\n\n    parse(xml);\n\n    getContext = noopGetContext;\n    parseStop = false;\n\n    return returnError;\n  };\n\n  /**\n   * Stop parsing.\n   */\n  this['stop'] = function() {\n    parseStop = true;\n  };\n\n  /**\n   * Parse string, invoking configured listeners on element.\n   *\n   * @param  {string} xml\n   */\n  function parse(xml) {\n    var nsMatrixStack = isNamespace ? [] : null,\n        nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,\n        _nsMatrix,\n        nodeStack = [],\n        anonymousNsCount = 0,\n        tagStart = false,\n        tagEnd = false,\n        i = 0, j = 0,\n        x, y, q, w, v,\n        xmlns,\n        elementName,\n        _elementName,\n        elementProxy\n        ;\n\n    var attrsString = '',\n        attrsStart = 0,\n        cachedAttrs // false = parsed with errors, null = needs parsing\n        ;\n\n    /**\n     * Parse attributes on demand and returns the parsed attributes.\n     *\n     * Return semantics: (1) `false` on attribute parse error,\n     * (2) object hash on extracted attrs.\n     *\n     * @return {boolean|Object}\n     */\n    function getAttrs() {\n      if (cachedAttrs !== null) {\n        return cachedAttrs;\n      }\n\n      var nsUri,\n          nsUriPrefix,\n          nsName,\n          defaultAlias = isNamespace && nsMatrix['xmlns'],\n          attrList = isNamespace && maybeNS ? [] : null,\n          i = attrsStart,\n          s = attrsString,\n          l = s.length,\n          hasNewMatrix,\n          newalias,\n          value,\n          alias,\n          name,\n          attrs = {},\n          seenAttrs = {},\n          skipAttr,\n          w,\n          j;\n\n      parseAttr:\n      for (; i < l; i++) {\n        skipAttr = false;\n        w = s.charCodeAt(i);\n\n        if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE={ \\f\\n\\r\\t\\v}\n          continue;\n        }\n\n        // wait for non whitespace character\n        if (w < 65 || w > 122 || (w > 90 && w < 97)) {\n          if (w !== 95 && w !== 58) { // char 95\"_\" 58\":\"\n            handleWarning('illegal first char attribute name');\n            skipAttr = true;\n          }\n        }\n\n        // parse attribute name\n        for (j = i + 1; j < l; j++) {\n          w = s.charCodeAt(j);\n\n          if (\n            w > 96 && w < 123 ||\n            w > 64 && w < 91 ||\n            w > 47 && w < 59 ||\n            w === 46 || // '.'\n            w === 45 || // '-'\n            w === 95 // '_'\n          ) {\n            continue;\n          }\n\n          // unexpected whitespace\n          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n            handleWarning('missing attribute value');\n            i = j;\n\n            continue parseAttr;\n          }\n\n          // expected \"=\"\n          if (w === 61) { // \"=\" == 61\n            break;\n          }\n\n          handleWarning('illegal attribute name char');\n          skipAttr = true;\n        }\n\n        name = s.substring(i, j);\n\n        if (name === 'xmlns:xmlns') {\n          handleWarning('illegal declaration of xmlns');\n          skipAttr = true;\n        }\n\n        w = s.charCodeAt(j + 1);\n\n        if (w === 34) { // '\"'\n          j = s.indexOf('\"', i = j + 2);\n\n          if (j === -1) {\n            j = s.indexOf('\\'', i);\n\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n\n        } else if (w === 39) { // \"'\"\n          j = s.indexOf('\\'', i = j + 2);\n\n          if (j === -1) {\n            j = s.indexOf('\"', i);\n\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n\n        } else {\n          handleWarning('missing attribute value quotes');\n          skipAttr = true;\n\n          // skip to next space\n          for (j = j + 1; j < l; j++) {\n            w = s.charCodeAt(j + 1);\n\n            if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n              break;\n            }\n          }\n\n        }\n\n        if (j === -1) {\n          handleWarning('missing closing quotes');\n\n          j = l;\n          skipAttr = true;\n        }\n\n        if (!skipAttr) {\n          value = s.substring(i, j);\n        }\n\n        i = j;\n\n        // ensure SPACE follows attribute\n        // skip illegal content otherwise\n        // example a=\"b\"c\n        for (; j + 1 < l; j++) {\n          w = s.charCodeAt(j + 1);\n\n          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n            break;\n          }\n\n          // FIRST ILLEGAL CHAR\n          if (i === j) {\n            handleWarning('illegal character after attribute end');\n            skipAttr = true;\n          }\n        }\n\n        // advance cursor to next attribute\n        i = j + 1;\n\n        if (skipAttr) {\n          continue parseAttr;\n        }\n\n        // check attribute re-declaration\n        if (name in seenAttrs) {\n          handleWarning('attribute <' + name + '> already defined');\n          continue;\n        }\n\n        seenAttrs[name] = true;\n\n        if (!isNamespace) {\n          attrs[name] = value;\n          continue;\n        }\n\n        // try to extract namespace information\n        if (maybeNS) {\n          newalias = (\n            name === 'xmlns'\n              ? 'xmlns'\n              : (name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:')\n                ? name.substr(6)\n                : null\n          );\n\n          // handle xmlns(:alias) assignment\n          if (newalias !== null) {\n            nsUri = decodeEntities(value);\n            nsUriPrefix = uriPrefix(newalias);\n\n            alias = nsUriToPrefix[nsUri];\n\n            if (!alias) {\n\n              // no prefix defined or prefix collision\n              if (\n                (newalias === 'xmlns') ||\n                (nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri)\n              ) {\n\n                // alocate free ns prefix\n                do {\n                  alias = 'ns' + (anonymousNsCount++);\n                } while (typeof nsMatrix[alias] !== 'undefined');\n              } else {\n                alias = newalias;\n              }\n\n              nsUriToPrefix[nsUri] = alias;\n            }\n\n            if (nsMatrix[newalias] !== alias) {\n              if (!hasNewMatrix) {\n                nsMatrix = cloneNsMatrix(nsMatrix);\n                hasNewMatrix = true;\n              }\n\n              nsMatrix[newalias] = alias;\n              if (newalias === 'xmlns') {\n                nsMatrix[uriPrefix(alias)] = nsUri;\n                defaultAlias = alias;\n              }\n\n              nsMatrix[nsUriPrefix] = nsUri;\n            }\n\n            // expose xmlns(:asd)=\"...\" in attributes\n            attrs[name] = value;\n            continue;\n          }\n\n          // collect attributes until all namespace\n          // declarations are processed\n          attrList.push(name, value);\n          continue;\n\n        } /** end if (maybeNs) */\n\n        // handle attributes on element without\n        // namespace declarations\n        w = name.indexOf(':');\n        if (w === -1) {\n          attrs[name] = value;\n          continue;\n        }\n\n        // normalize ns attribute name\n        if (!(nsName = nsMatrix[name.substring(0, w)])) {\n          handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n          continue;\n        }\n\n        name = defaultAlias === nsName\n          ? name.substr(w + 1)\n          : nsName + name.substr(w);\n\n        // end: normalize ns attribute name\n\n        attrs[name] = value;\n      }\n\n\n      // handle deferred, possibly namespaced attributes\n      if (maybeNS) {\n\n        // normalize captured attributes\n        for (i = 0, l = attrList.length; i < l; i++) {\n\n          name = attrList[i++];\n          value = attrList[i];\n\n          w = name.indexOf(':');\n\n          if (w !== -1) {\n\n            // normalize ns attribute name\n            if (!(nsName = nsMatrix[name.substring(0, w)])) {\n              handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n              continue;\n            }\n\n            name = defaultAlias === nsName\n              ? name.substr(w + 1)\n              : nsName + name.substr(w);\n\n            // end: normalize ns attribute name\n          }\n\n          attrs[name] = value;\n        }\n\n        // end: normalize captured attributes\n      }\n\n      return cachedAttrs = attrs;\n    }\n\n    /**\n     * Extract the parse context { line, column, part }\n     * from the current parser position.\n     *\n     * @return {Object} parse context\n     */\n    function getParseContext() {\n      var splitsRe = /(\\r\\n|\\r|\\n)/g;\n\n      var line = 0;\n      var column = 0;\n      var startOfLine = 0;\n      var endOfLine = j;\n      var match;\n      var data;\n\n      while (i >= startOfLine) {\n\n        match = splitsRe.exec(xml);\n\n        if (!match) {\n          break;\n        }\n\n        // end of line = (break idx + break chars)\n        endOfLine = match[0].length + match.index;\n\n        if (endOfLine > i) {\n          break;\n        }\n\n        // advance to next line\n        line += 1;\n\n        startOfLine = endOfLine;\n      }\n\n      // EOF errors\n      if (i == -1) {\n        column = endOfLine;\n        data = xml.substring(j);\n      } else\n\n      // start errors\n      if (j === 0) {\n        data = xml.substring(j, i);\n      }\n\n      // other errors\n      else {\n        column = i - startOfLine;\n        data = (j == -1 ? xml.substring(i) : xml.substring(i, j + 1));\n      }\n\n      return {\n        'data': data,\n        'line': line,\n        'column': column\n      };\n    }\n\n    getContext = getParseContext;\n\n\n    if (proxy) {\n      elementProxy = Object.create({}, {\n        'name': getter(function() {\n          return elementName;\n        }),\n        'originalName': getter(function() {\n          return _elementName;\n        }),\n        'attrs': getter(getAttrs),\n        'ns': getter(function() {\n          return nsMatrix;\n        })\n      });\n    }\n\n    // actual parse logic\n    while (j !== -1) {\n\n      if (xml.charCodeAt(j) === 60) { // \"<\"\n        i = j;\n      } else {\n        i = xml.indexOf('<', j);\n      }\n\n      // parse end\n      if (i === -1) {\n        if (nodeStack.length) {\n          return handleError('unexpected end of file');\n        }\n\n        if (j === 0) {\n          return handleError('missing start tag');\n        }\n\n        if (j < xml.length) {\n          if (xml.substring(j).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n          }\n        }\n\n        return;\n      }\n\n      // parse text\n      if (j !== i) {\n\n        if (nodeStack.length) {\n          if (onText) {\n            onText(xml.substring(j, i), decodeEntities, getContext);\n\n            if (parseStop) {\n              return;\n            }\n          }\n        } else {\n          if (xml.substring(j, i).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n\n            if (parseStop) {\n              return;\n            }\n          }\n        }\n      }\n\n      w = xml.charCodeAt(i + 1);\n\n      // parse comments + CDATA\n      if (w === 33) { // \"!\"\n        q = xml.charCodeAt(i + 2);\n\n        // CDATA section\n        if (q === 91 && xml.substr(i + 3, 6) === 'CDATA[') { // 91 == \"[\"\n          j = xml.indexOf(']]>', i);\n          if (j === -1) {\n            return handleError('unclosed cdata');\n          }\n\n          if (onCDATA) {\n            onCDATA(xml.substring(i + 9, j), getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n\n          j += 3;\n          continue;\n        }\n\n        // comment\n        if (q === 45 && xml.charCodeAt(i + 3) === 45) { // 45 == \"-\"\n          j = xml.indexOf('-->', i);\n          if (j === -1) {\n            return handleError('unclosed comment');\n          }\n\n\n          if (onComment) {\n            onComment(xml.substring(i + 4, j), decodeEntities, getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n\n          j += 3;\n          continue;\n        }\n      }\n\n      // parse question <? ... ?>\n      if (w === 63) { // \"?\"\n        j = xml.indexOf('?>', i);\n        if (j === -1) {\n          return handleError('unclosed question');\n        }\n\n        if (onQuestion) {\n          onQuestion(xml.substring(i, j + 2), getContext);\n          if (parseStop) {\n            return;\n          }\n        }\n\n        j += 2;\n        continue;\n      }\n\n      // find matching closing tag for attention or standard tags\n      // for that we must skip through attribute values\n      // (enclosed in single or double quotes)\n      for (x = i + 1; ; x++) {\n        v = xml.charCodeAt(x);\n        if (isNaN(v)) {\n          j = -1;\n          return handleError('unclosed tag');\n        }\n\n        // [10] AttValue ::= '\"' ([^<&\"] | Reference)* '\"' | \"'\" ([^<&'] | Reference)* \"'\"\n        // skips the quoted string\n        // (double quotes) does not appear in a literal enclosed by (double quotes)\n        // (single quote) does not appear in a literal enclosed by (single quote)\n        if (v === 34) { //  '\"'\n          q = xml.indexOf('\"', x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 39) { // \"'\"\n          q = xml.indexOf(\"'\", x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 62) { // '>'\n          j = x;\n          break;\n        }\n      }\n\n\n      // parse attention <! ...>\n      // previously comment and CDATA have already been parsed\n      if (w === 33) { // \"!\"\n\n        if (onAttention) {\n          onAttention(xml.substring(i, j + 1), decodeEntities, getContext);\n          if (parseStop) {\n            return;\n          }\n        }\n\n        j += 1;\n        continue;\n      }\n\n      // don't process attributes;\n      // there are none\n      cachedAttrs = {};\n\n      // if (xml.charCodeAt(i+1) === 47) { // </...\n      if (w === 47) { // </...\n        tagStart = false;\n        tagEnd = true;\n\n        if (!nodeStack.length) {\n          return handleError('missing open tag');\n        }\n\n        // verify open <-> close tag match\n        x = elementName = nodeStack.pop();\n        q = i + 2 + x.length;\n\n        if (xml.substring(i + 2, q) !== x) {\n          return handleError('closing tag mismatch');\n        }\n\n        // verify chars in close tag\n        for (; q < j; q++) {\n          w = xml.charCodeAt(q);\n\n          if (w === 32 || (w > 8 && w < 14)) { // \\f\\n\\r\\t\\v space\n            continue;\n          }\n\n          return handleError('close tag');\n        }\n\n      } else {\n        if (xml.charCodeAt(j - 1) === 47) { // .../>\n          x = elementName = xml.substring(i + 1, j - 1);\n\n          tagStart = true;\n          tagEnd = true;\n\n        } else {\n          x = elementName = xml.substring(i + 1, j);\n\n          tagStart = true;\n          tagEnd = false;\n        }\n\n        if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) { // char 95\"_\" 58\":\"\n          return handleError('illegal first char nodeName');\n        }\n\n        for (q = 1, y = x.length; q < y; q++) {\n          w = x.charCodeAt(q);\n\n          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {\n            continue;\n          }\n\n          if (w === 32 || (w < 14 && w > 8)) { // \\f\\n\\r\\t\\v space\n            elementName = x.substring(0, q);\n\n            // maybe there are attributes\n            cachedAttrs = null;\n            break;\n          }\n\n          return handleError('invalid nodeName');\n        }\n\n        if (!tagEnd) {\n          nodeStack.push(elementName);\n        }\n      }\n\n      if (isNamespace) {\n\n        _nsMatrix = nsMatrix;\n\n        if (tagStart) {\n\n          // remember old namespace\n          // unless we're self-closing\n          if (!tagEnd) {\n            nsMatrixStack.push(_nsMatrix);\n          }\n\n          if (cachedAttrs === null) {\n\n            // quick check, whether there may be namespace\n            // declarations on the node; if that is the case\n            // we need to eagerly parse the node attributes\n            if ((maybeNS = x.indexOf('xmlns', q) !== -1)) {\n              attrsStart = q;\n              attrsString = x;\n\n              getAttrs();\n\n              maybeNS = false;\n            }\n          }\n        }\n\n        _elementName = elementName;\n\n        w = elementName.indexOf(':');\n        if (w !== -1) {\n          xmlns = nsMatrix[elementName.substring(0, w)];\n\n          // prefix given; namespace must exist\n          if (!xmlns) {\n            return handleError('missing namespace on <' + _elementName + '>');\n          }\n\n          elementName = elementName.substr(w + 1);\n        } else {\n          xmlns = nsMatrix['xmlns'];\n\n          // if no default namespace is defined,\n          // we'll import the element as anonymous.\n          //\n          // it is up to users to correct that to the document defined\n          // targetNamespace, or whatever their undersanding of the\n          // XML spec mandates.\n        }\n\n        // adjust namespace prefixs as configured\n        if (xmlns) {\n          elementName = xmlns + ':' + elementName;\n        }\n\n      }\n\n      if (tagStart) {\n        attrsStart = q;\n        attrsString = x;\n\n        if (onOpenTag) {\n          if (proxy) {\n            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);\n          } else {\n            onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);\n          }\n\n          if (parseStop) {\n            return;\n          }\n        }\n\n      }\n\n      if (tagEnd) {\n\n        if (onCloseTag) {\n          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);\n\n          if (parseStop) {\n            return;\n          }\n        }\n\n        // restore old namespace\n        if (isNamespace) {\n          if (!tagStart) {\n            nsMatrix = nsMatrixStack.pop();\n          } else {\n            nsMatrix = _nsMatrix;\n          }\n        }\n      }\n\n      j += 1;\n    }\n  } /** end parse */\n\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3NheGVuL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7QUFFQTs7QUFFQSw4QkFBOEIsZ0JBQWdCLFFBQVE7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxlQUFlLHNCQUFzQjtBQUNyQztBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsUUFBUTtBQUNSLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBOztBQUVBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0ZBQWdGO0FBQ2hGO0FBQ0E7O0FBRUEsa0NBQWtDLE9BQU87QUFDekM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRTRDO0FBQzVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhZGRyYS13ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL3NheGVuL2Rpc3QvaW5kZXguanM/Yzg3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIEVOVElUWV9QQVRURVJOID0gLyYjKFxcZCspO3wmI3goWzAtOWEtZl0rKTt8JihcXHcrKTsvaWc7XG5cbnZhciBFTlRJVFlfTUFQUElORyA9IHtcbiAgJ2FtcCc6ICcmJyxcbiAgJ2Fwb3MnOiAnXFwnJyxcbiAgJ2d0JzogJz4nLFxuICAnbHQnOiAnPCcsXG4gICdxdW90JzogJ1wiJ1xufTtcblxuLy8gbWFwIFVQUEVSQ0FTRSB2YXJpYW50cyBvZiBzdXBwb3J0ZWQgc3BlY2lhbCBjaGFyc1xuT2JqZWN0LmtleXMoRU5USVRZX01BUFBJTkcpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICBFTlRJVFlfTUFQUElOR1trLnRvVXBwZXJDYXNlKCldID0gRU5USVRZX01BUFBJTkdba107XG59KTtcblxuXG5mdW5jdGlvbiByZXBsYWNlRW50aXRpZXMoXywgZCwgeCwgeikge1xuXG4gIC8vIHJlc2VydmVkIG5hbWVzLCBpLmUuICZuYnNwO1xuICBpZiAoeikge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKEVOVElUWV9NQVBQSU5HLCB6KSkge1xuICAgICAgcmV0dXJuIEVOVElUWV9NQVBQSU5HW3pdO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIGZhbGwgYmFjayB0byBvcmlnaW5hbCB2YWx1ZVxuICAgICAgcmV0dXJuICcmJyArIHogKyAnOyc7XG4gICAgfVxuICB9XG5cbiAgLy8gZGVjaW1hbCBlbmNvZGVkIGNoYXJcbiAgaWYgKGQpIHtcbiAgICByZXR1cm4gZnJvbUNoYXJDb2RlKGQpO1xuICB9XG5cbiAgLy8gaGV4IGVuY29kZWQgY2hhclxuICByZXR1cm4gZnJvbUNoYXJDb2RlKHBhcnNlSW50KHgsIDE2KSk7XG59XG5cblxuLyoqXG4gKiBBIGJhc2ljIGVudGl0eSBkZWNvZGVyIHRoYXQgY2FuIGRlY29kZSBhIG1pbmltYWxcbiAqIHN1Yi1zZXQgb2YgcmVzZXJ2ZWQgbmFtZXMgKCZhbXA7KSBhcyB3ZWxsIGFzXG4gKiBoZXggKCYjeGFhZjspIGFuZCBkZWNpbWFsICgmIzEyMzE7KSBlbmNvZGVkIGNoYXJhY3RlcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGRlY29kZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUVudGl0aWVzKHMpIHtcbiAgaWYgKHMubGVuZ3RoID4gMyAmJiBzLmluZGV4T2YoJyYnKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKEVOVElUWV9QQVRURVJOLCByZXBsYWNlRW50aXRpZXMpO1xuICB9XG5cbiAgcmV0dXJuIHM7XG59XG5cbnZhciBOT05fV0hJVEVTUEFDRV9PVVRTSURFX1JPT1RfTk9ERSA9ICdub24td2hpdGVzcGFjZSBvdXRzaWRlIG9mIHJvb3Qgbm9kZSc7XG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICByZXR1cm4gbmV3IEVycm9yKG1zZyk7XG59XG5cbmZ1bmN0aW9uIG1pc3NpbmdOYW1lc3BhY2VGb3JQcmVmaXgocHJlZml4KSB7XG4gIHJldHVybiAnbWlzc2luZyBuYW1lc3BhY2UgZm9yIHByZWZpeCA8JyArIHByZWZpeCArICc+Jztcbn1cblxuZnVuY3Rpb24gZ2V0dGVyKGdldEZuKSB7XG4gIHJldHVybiB7XG4gICAgJ2dldCc6IGdldEZuLFxuICAgICdlbnVtZXJhYmxlJzogdHJ1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjbG9uZU5zTWF0cml4KG5zTWF0cml4KSB7XG4gIHZhciBjbG9uZSA9IHt9LCBrZXk7XG4gIGZvciAoa2V5IGluIG5zTWF0cml4KSB7XG4gICAgY2xvbmVba2V5XSA9IG5zTWF0cml4W2tleV07XG4gIH1cbiAgcmV0dXJuIGNsb25lO1xufVxuXG5mdW5jdGlvbiB1cmlQcmVmaXgocHJlZml4KSB7XG4gIHJldHVybiBwcmVmaXggKyAnJHVyaSc7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTnNNYXRyaXgobnNVcmlUb1ByZWZpeCkge1xuICB2YXIgbnNNYXRyaXggPSB7fSxcbiAgICAgIHVyaSxcbiAgICAgIHByZWZpeDtcblxuICBmb3IgKHVyaSBpbiBuc1VyaVRvUHJlZml4KSB7XG4gICAgcHJlZml4ID0gbnNVcmlUb1ByZWZpeFt1cmldO1xuICAgIG5zTWF0cml4W3ByZWZpeF0gPSBwcmVmaXg7XG4gICAgbnNNYXRyaXhbdXJpUHJlZml4KHByZWZpeCldID0gdXJpO1xuICB9XG5cbiAgcmV0dXJuIG5zTWF0cml4O1xufVxuXG5mdW5jdGlvbiBub29wR2V0Q29udGV4dCgpIHtcbiAgcmV0dXJuIHsgbGluZTogMCwgY29sdW1uOiAwIH07XG59XG5cbmZ1bmN0aW9uIHRocm93RnVuYyhlcnIpIHtcbiAgdGhyb3cgZXJyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcGFyc2VyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtICB7IU9iamVjdDxzdHJpbmcsID8+PX0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBQYXJzZXIob3B0aW9ucykge1xuXG4gIGlmICghdGhpcykge1xuICAgIHJldHVybiBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIHByb3h5ID0gb3B0aW9ucyAmJiBvcHRpb25zWydwcm94eSddO1xuXG4gIHZhciBvblRleHQsXG4gICAgICBvbk9wZW5UYWcsXG4gICAgICBvbkNsb3NlVGFnLFxuICAgICAgb25DREFUQSxcbiAgICAgIG9uRXJyb3IgPSB0aHJvd0Z1bmMsXG4gICAgICBvbldhcm5pbmcsXG4gICAgICBvbkNvbW1lbnQsXG4gICAgICBvblF1ZXN0aW9uLFxuICAgICAgb25BdHRlbnRpb247XG5cbiAgdmFyIGdldENvbnRleHQgPSBub29wR2V0Q29udGV4dDtcblxuICAvKipcbiAgICogRG8gd2UgbmVlZCB0byBwYXJzZSB0aGUgY3VycmVudCBlbGVtZW50cyBhdHRyaWJ1dGVzIGZvciBuYW1lc3BhY2VzP1xuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHZhciBtYXliZU5TID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIERvIHdlIHByb2Nlc3MgbmFtZXNwYWNlcyBhdCBhbGw/XG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdmFyIGlzTmFtZXNwYWNlID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBjYXVnaHQgZXJyb3IgcmV0dXJuZWQgb24gcGFyc2UgZW5kXG4gICAqXG4gICAqIEB0eXBlIHtFcnJvcn1cbiAgICovXG4gIHZhciByZXR1cm5FcnJvciA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFNob3VsZCB3ZSBzdG9wIHBhcnNpbmc/XG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdmFyIHBhcnNlU3RvcCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBIG1hcCBvZiB7IHVyaTogcHJlZml4IH0gdXNlZCBieSB0aGUgcGFyc2VyLlxuICAgKlxuICAgKiBUaGlzIG1hcCB3aWxsIGVuc3VyZSB3ZSBjYW4gbm9ybWFsaXplIHByZWZpeGVzIGR1cmluZyBwcm9jZXNzaW5nO1xuICAgKiBmb3IgZWFjaCB1cmksIG9ubHkgb25lIHByZWZpeCB3aWxsIGJlIGV4cG9zZWQgdG8gdGhlIGhhbmRsZXJzLlxuICAgKlxuICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz59fVxuICAgKi9cbiAgdmFyIG5zVXJpVG9QcmVmaXg7XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwYXJzZSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfEVycm9yfSBlcnJcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycikge1xuICAgIGlmICghKGVyciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgZXJyID0gZXJyb3IoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm5FcnJvciA9IGVycjtcblxuICAgIG9uRXJyb3IoZXJyLCBnZXRDb250ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcGFyc2UgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xFcnJvcn0gZXJyXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVXYXJuaW5nKGVycikge1xuXG4gICAgaWYgKCFvbldhcm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgIGVyciA9IGVycm9yKGVycik7XG4gICAgfVxuXG4gICAgb25XYXJuaW5nKGVyciwgZ2V0Q29udGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgcGFyc2UgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBuYW1lXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKlxuICAgKiBAcmV0dXJuIHtQYXJzZXJ9XG4gICAqL1xuICB0aGlzWydvbiddID0gZnVuY3Rpb24obmFtZSwgY2IpIHtcblxuICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IGVycm9yKCdyZXF1aXJlZCBhcmdzIDxuYW1lLCBjYj4nKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdvcGVuVGFnJzogb25PcGVuVGFnID0gY2I7IGJyZWFrO1xuICAgIGNhc2UgJ3RleHQnOiBvblRleHQgPSBjYjsgYnJlYWs7XG4gICAgY2FzZSAnY2xvc2VUYWcnOiBvbkNsb3NlVGFnID0gY2I7IGJyZWFrO1xuICAgIGNhc2UgJ2Vycm9yJzogb25FcnJvciA9IGNiOyBicmVhaztcbiAgICBjYXNlICd3YXJuJzogb25XYXJuaW5nID0gY2I7IGJyZWFrO1xuICAgIGNhc2UgJ2NkYXRhJzogb25DREFUQSA9IGNiOyBicmVhaztcbiAgICBjYXNlICdhdHRlbnRpb24nOiBvbkF0dGVudGlvbiA9IGNiOyBicmVhazsgLy8gPCFYWFhYWCB6enp6PVwiZWVlZVwiPlxuICAgIGNhc2UgJ3F1ZXN0aW9uJzogb25RdWVzdGlvbiA9IGNiOyBicmVhazsgLy8gPD8gLi4uLiAgPz5cbiAgICBjYXNlICdjb21tZW50Jzogb25Db21tZW50ID0gY2I7IGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBlcnJvcigndW5zdXBwb3J0ZWQgZXZlbnQ6ICcgKyBuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBuYW1lc3BhY2UgdG8gcHJlZml4IG1hcHBpbmcuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHBhcnNlci5ucyh7XG4gICAqICAgJ2h0dHA6Ly9mb28nOiAnZm9vJyxcbiAgICogICAnaHR0cDovL2Jhcic6ICdiYXInXG4gICAqIH0pO1xuICAgKlxuICAgKiBAcGFyYW0gIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn0gbnNNYXBcbiAgICpcbiAgICogQHJldHVybiB7UGFyc2VyfVxuICAgKi9cbiAgdGhpc1snbnMnXSA9IGZ1bmN0aW9uKG5zTWFwKSB7XG5cbiAgICBpZiAodHlwZW9mIG5zTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbnNNYXAgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5zTWFwICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgZXJyb3IoJ3JlcXVpcmVkIGFyZ3MgPG5zTWFwPXt9PicpO1xuICAgIH1cblxuICAgIHZhciBfbnNVcmlUb1ByZWZpeCA9IHt9LCBrO1xuXG4gICAgZm9yIChrIGluIG5zTWFwKSB7XG4gICAgICBfbnNVcmlUb1ByZWZpeFtrXSA9IG5zTWFwW2tdO1xuICAgIH1cblxuICAgIGlzTmFtZXNwYWNlID0gdHJ1ZTtcbiAgICBuc1VyaVRvUHJlZml4ID0gX25zVXJpVG9QcmVmaXg7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2UgeG1sIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB4bWxcbiAgICpcbiAgICogQHJldHVybiB7RXJyb3J9IHJldHVybkVycm9yLCBpZiBub3QgdGhyb3duXG4gICAqL1xuICB0aGlzWydwYXJzZSddID0gZnVuY3Rpb24oeG1sKSB7XG4gICAgaWYgKHR5cGVvZiB4bWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBlcnJvcigncmVxdWlyZWQgYXJncyA8eG1sPXN0cmluZz4nKTtcbiAgICB9XG5cbiAgICByZXR1cm5FcnJvciA9IG51bGw7XG5cbiAgICBwYXJzZSh4bWwpO1xuXG4gICAgZ2V0Q29udGV4dCA9IG5vb3BHZXRDb250ZXh0O1xuICAgIHBhcnNlU3RvcCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHJldHVybkVycm9yO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9wIHBhcnNpbmcuXG4gICAqL1xuICB0aGlzWydzdG9wJ10gPSBmdW5jdGlvbigpIHtcbiAgICBwYXJzZVN0b3AgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBzdHJpbmcsIGludm9raW5nIGNvbmZpZ3VyZWQgbGlzdGVuZXJzIG9uIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30geG1sXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZSh4bWwpIHtcbiAgICB2YXIgbnNNYXRyaXhTdGFjayA9IGlzTmFtZXNwYWNlID8gW10gOiBudWxsLFxuICAgICAgICBuc01hdHJpeCA9IGlzTmFtZXNwYWNlID8gYnVpbGROc01hdHJpeChuc1VyaVRvUHJlZml4KSA6IG51bGwsXG4gICAgICAgIF9uc01hdHJpeCxcbiAgICAgICAgbm9kZVN0YWNrID0gW10sXG4gICAgICAgIGFub255bW91c05zQ291bnQgPSAwLFxuICAgICAgICB0YWdTdGFydCA9IGZhbHNlLFxuICAgICAgICB0YWdFbmQgPSBmYWxzZSxcbiAgICAgICAgaSA9IDAsIGogPSAwLFxuICAgICAgICB4LCB5LCBxLCB3LCB2LFxuICAgICAgICB4bWxucyxcbiAgICAgICAgZWxlbWVudE5hbWUsXG4gICAgICAgIF9lbGVtZW50TmFtZSxcbiAgICAgICAgZWxlbWVudFByb3h5XG4gICAgICAgIDtcblxuICAgIHZhciBhdHRyc1N0cmluZyA9ICcnLFxuICAgICAgICBhdHRyc1N0YXJ0ID0gMCxcbiAgICAgICAgY2FjaGVkQXR0cnMgLy8gZmFsc2UgPSBwYXJzZWQgd2l0aCBlcnJvcnMsIG51bGwgPSBuZWVkcyBwYXJzaW5nXG4gICAgICAgIDtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGF0dHJpYnV0ZXMgb24gZGVtYW5kIGFuZCByZXR1cm5zIHRoZSBwYXJzZWQgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIFJldHVybiBzZW1hbnRpY3M6ICgxKSBgZmFsc2VgIG9uIGF0dHJpYnV0ZSBwYXJzZSBlcnJvcixcbiAgICAgKiAoMikgb2JqZWN0IGhhc2ggb24gZXh0cmFjdGVkIGF0dHJzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbnxPYmplY3R9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QXR0cnMoKSB7XG4gICAgICBpZiAoY2FjaGVkQXR0cnMgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEF0dHJzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbnNVcmksXG4gICAgICAgICAgbnNVcmlQcmVmaXgsXG4gICAgICAgICAgbnNOYW1lLFxuICAgICAgICAgIGRlZmF1bHRBbGlhcyA9IGlzTmFtZXNwYWNlICYmIG5zTWF0cml4Wyd4bWxucyddLFxuICAgICAgICAgIGF0dHJMaXN0ID0gaXNOYW1lc3BhY2UgJiYgbWF5YmVOUyA/IFtdIDogbnVsbCxcbiAgICAgICAgICBpID0gYXR0cnNTdGFydCxcbiAgICAgICAgICBzID0gYXR0cnNTdHJpbmcsXG4gICAgICAgICAgbCA9IHMubGVuZ3RoLFxuICAgICAgICAgIGhhc05ld01hdHJpeCxcbiAgICAgICAgICBuZXdhbGlhcyxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBhbGlhcyxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGF0dHJzID0ge30sXG4gICAgICAgICAgc2VlbkF0dHJzID0ge30sXG4gICAgICAgICAgc2tpcEF0dHIsXG4gICAgICAgICAgdyxcbiAgICAgICAgICBqO1xuXG4gICAgICBwYXJzZUF0dHI6XG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBza2lwQXR0ciA9IGZhbHNlO1xuICAgICAgICB3ID0gcy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmICh3ID09PSAzMiB8fCAodyA8IDE0ICYmIHcgPiA4KSkgeyAvLyBXSElURVNQQUNFPXsgXFxmXFxuXFxyXFx0XFx2fVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2FpdCBmb3Igbm9uIHdoaXRlc3BhY2UgY2hhcmFjdGVyXG4gICAgICAgIGlmICh3IDwgNjUgfHwgdyA+IDEyMiB8fCAodyA+IDkwICYmIHcgPCA5NykpIHtcbiAgICAgICAgICBpZiAodyAhPT0gOTUgJiYgdyAhPT0gNTgpIHsgLy8gY2hhciA5NVwiX1wiIDU4XCI6XCJcbiAgICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ2lsbGVnYWwgZmlyc3QgY2hhciBhdHRyaWJ1dGUgbmFtZScpO1xuICAgICAgICAgICAgc2tpcEF0dHIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhcnNlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgdyA9IHMuY2hhckNvZGVBdChqKTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHcgPiA5NiAmJiB3IDwgMTIzIHx8XG4gICAgICAgICAgICB3ID4gNjQgJiYgdyA8IDkxIHx8XG4gICAgICAgICAgICB3ID4gNDcgJiYgdyA8IDU5IHx8XG4gICAgICAgICAgICB3ID09PSA0NiB8fCAvLyAnLidcbiAgICAgICAgICAgIHcgPT09IDQ1IHx8IC8vICctJ1xuICAgICAgICAgICAgdyA9PT0gOTUgLy8gJ18nXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHdoaXRlc3BhY2VcbiAgICAgICAgICBpZiAodyA9PT0gMzIgfHwgKHcgPCAxNCAmJiB3ID4gOCkpIHsgLy8gV0hJVEVTUEFDRVxuICAgICAgICAgICAgaGFuZGxlV2FybmluZygnbWlzc2luZyBhdHRyaWJ1dGUgdmFsdWUnKTtcbiAgICAgICAgICAgIGkgPSBqO1xuXG4gICAgICAgICAgICBjb250aW51ZSBwYXJzZUF0dHI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZXhwZWN0ZWQgXCI9XCJcbiAgICAgICAgICBpZiAodyA9PT0gNjEpIHsgLy8gXCI9XCIgPT0gNjFcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ2lsbGVnYWwgYXR0cmlidXRlIG5hbWUgY2hhcicpO1xuICAgICAgICAgIHNraXBBdHRyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWUgPSBzLnN1YnN0cmluZyhpLCBqKTtcblxuICAgICAgICBpZiAobmFtZSA9PT0gJ3htbG5zOnhtbG5zJykge1xuICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ2lsbGVnYWwgZGVjbGFyYXRpb24gb2YgeG1sbnMnKTtcbiAgICAgICAgICBza2lwQXR0ciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB3ID0gcy5jaGFyQ29kZUF0KGogKyAxKTtcblxuICAgICAgICBpZiAodyA9PT0gMzQpIHsgLy8gJ1wiJ1xuICAgICAgICAgIGogPSBzLmluZGV4T2YoJ1wiJywgaSA9IGogKyAyKTtcblxuICAgICAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICAgICAgaiA9IHMuaW5kZXhPZignXFwnJywgaSk7XG5cbiAgICAgICAgICAgIGlmIChqICE9PSAtMSkge1xuICAgICAgICAgICAgICBoYW5kbGVXYXJuaW5nKCdhdHRyaWJ1dGUgdmFsdWUgcXVvdGUgbWlzc21hdGNoJyk7XG4gICAgICAgICAgICAgIHNraXBBdHRyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmICh3ID09PSAzOSkgeyAvLyBcIidcIlxuICAgICAgICAgIGogPSBzLmluZGV4T2YoJ1xcJycsIGkgPSBqICsgMik7XG5cbiAgICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICAgIGogPSBzLmluZGV4T2YoJ1wiJywgaSk7XG5cbiAgICAgICAgICAgIGlmIChqICE9PSAtMSkge1xuICAgICAgICAgICAgICBoYW5kbGVXYXJuaW5nKCdhdHRyaWJ1dGUgdmFsdWUgcXVvdGUgbWlzc21hdGNoJyk7XG4gICAgICAgICAgICAgIHNraXBBdHRyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVXYXJuaW5nKCdtaXNzaW5nIGF0dHJpYnV0ZSB2YWx1ZSBxdW90ZXMnKTtcbiAgICAgICAgICBza2lwQXR0ciA9IHRydWU7XG5cbiAgICAgICAgICAvLyBza2lwIHRvIG5leHQgc3BhY2VcbiAgICAgICAgICBmb3IgKGogPSBqICsgMTsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgdyA9IHMuY2hhckNvZGVBdChqICsgMSk7XG5cbiAgICAgICAgICAgIGlmICh3ID09PSAzMiB8fCAodyA8IDE0ICYmIHcgPiA4KSkgeyAvLyBXSElURVNQQUNFXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGogPT09IC0xKSB7XG4gICAgICAgICAgaGFuZGxlV2FybmluZygnbWlzc2luZyBjbG9zaW5nIHF1b3RlcycpO1xuXG4gICAgICAgICAgaiA9IGw7XG4gICAgICAgICAgc2tpcEF0dHIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFza2lwQXR0cikge1xuICAgICAgICAgIHZhbHVlID0gcy5zdWJzdHJpbmcoaSwgaik7XG4gICAgICAgIH1cblxuICAgICAgICBpID0gajtcblxuICAgICAgICAvLyBlbnN1cmUgU1BBQ0UgZm9sbG93cyBhdHRyaWJ1dGVcbiAgICAgICAgLy8gc2tpcCBpbGxlZ2FsIGNvbnRlbnQgb3RoZXJ3aXNlXG4gICAgICAgIC8vIGV4YW1wbGUgYT1cImJcImNcbiAgICAgICAgZm9yICg7IGogKyAxIDwgbDsgaisrKSB7XG4gICAgICAgICAgdyA9IHMuY2hhckNvZGVBdChqICsgMSk7XG5cbiAgICAgICAgICBpZiAodyA9PT0gMzIgfHwgKHcgPCAxNCAmJiB3ID4gOCkpIHsgLy8gV0hJVEVTUEFDRVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRklSU1QgSUxMRUdBTCBDSEFSXG4gICAgICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ2lsbGVnYWwgY2hhcmFjdGVyIGFmdGVyIGF0dHJpYnV0ZSBlbmQnKTtcbiAgICAgICAgICAgIHNraXBBdHRyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZHZhbmNlIGN1cnNvciB0byBuZXh0IGF0dHJpYnV0ZVxuICAgICAgICBpID0gaiArIDE7XG5cbiAgICAgICAgaWYgKHNraXBBdHRyKSB7XG4gICAgICAgICAgY29udGludWUgcGFyc2VBdHRyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgYXR0cmlidXRlIHJlLWRlY2xhcmF0aW9uXG4gICAgICAgIGlmIChuYW1lIGluIHNlZW5BdHRycykge1xuICAgICAgICAgIGhhbmRsZVdhcm5pbmcoJ2F0dHJpYnV0ZSA8JyArIG5hbWUgKyAnPiBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlZW5BdHRyc1tuYW1lXSA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFpc05hbWVzcGFjZSkge1xuICAgICAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cnkgdG8gZXh0cmFjdCBuYW1lc3BhY2UgaW5mb3JtYXRpb25cbiAgICAgICAgaWYgKG1heWJlTlMpIHtcbiAgICAgICAgICBuZXdhbGlhcyA9IChcbiAgICAgICAgICAgIG5hbWUgPT09ICd4bWxucydcbiAgICAgICAgICAgICAgPyAneG1sbnMnXG4gICAgICAgICAgICAgIDogKG5hbWUuY2hhckNvZGVBdCgwKSA9PT0gMTIwICYmIG5hbWUuc3Vic3RyKDAsIDYpID09PSAneG1sbnM6JylcbiAgICAgICAgICAgICAgICA/IG5hbWUuc3Vic3RyKDYpXG4gICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIGhhbmRsZSB4bWxucyg6YWxpYXMpIGFzc2lnbm1lbnRcbiAgICAgICAgICBpZiAobmV3YWxpYXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5zVXJpID0gZGVjb2RlRW50aXRpZXModmFsdWUpO1xuICAgICAgICAgICAgbnNVcmlQcmVmaXggPSB1cmlQcmVmaXgobmV3YWxpYXMpO1xuXG4gICAgICAgICAgICBhbGlhcyA9IG5zVXJpVG9QcmVmaXhbbnNVcmldO1xuXG4gICAgICAgICAgICBpZiAoIWFsaWFzKSB7XG5cbiAgICAgICAgICAgICAgLy8gbm8gcHJlZml4IGRlZmluZWQgb3IgcHJlZml4IGNvbGxpc2lvblxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKG5ld2FsaWFzID09PSAneG1sbnMnKSB8fFxuICAgICAgICAgICAgICAgIChuc1VyaVByZWZpeCBpbiBuc01hdHJpeCAmJiBuc01hdHJpeFtuc1VyaVByZWZpeF0gIT09IG5zVXJpKVxuICAgICAgICAgICAgICApIHtcblxuICAgICAgICAgICAgICAgIC8vIGFsb2NhdGUgZnJlZSBucyBwcmVmaXhcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICBhbGlhcyA9ICducycgKyAoYW5vbnltb3VzTnNDb3VudCsrKTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0eXBlb2YgbnNNYXRyaXhbYWxpYXNdICE9PSAndW5kZWZpbmVkJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxpYXMgPSBuZXdhbGlhcztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG5zVXJpVG9QcmVmaXhbbnNVcmldID0gYWxpYXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuc01hdHJpeFtuZXdhbGlhc10gIT09IGFsaWFzKSB7XG4gICAgICAgICAgICAgIGlmICghaGFzTmV3TWF0cml4KSB7XG4gICAgICAgICAgICAgICAgbnNNYXRyaXggPSBjbG9uZU5zTWF0cml4KG5zTWF0cml4KTtcbiAgICAgICAgICAgICAgICBoYXNOZXdNYXRyaXggPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbnNNYXRyaXhbbmV3YWxpYXNdID0gYWxpYXM7XG4gICAgICAgICAgICAgIGlmIChuZXdhbGlhcyA9PT0gJ3htbG5zJykge1xuICAgICAgICAgICAgICAgIG5zTWF0cml4W3VyaVByZWZpeChhbGlhcyldID0gbnNVcmk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdEFsaWFzID0gYWxpYXM7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBuc01hdHJpeFtuc1VyaVByZWZpeF0gPSBuc1VyaTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZXhwb3NlIHhtbG5zKDphc2QpPVwiLi4uXCIgaW4gYXR0cmlidXRlc1xuICAgICAgICAgICAgYXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNvbGxlY3QgYXR0cmlidXRlcyB1bnRpbCBhbGwgbmFtZXNwYWNlXG4gICAgICAgICAgLy8gZGVjbGFyYXRpb25zIGFyZSBwcm9jZXNzZWRcbiAgICAgICAgICBhdHRyTGlzdC5wdXNoKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICB9IC8qKiBlbmQgaWYgKG1heWJlTnMpICovXG5cbiAgICAgICAgLy8gaGFuZGxlIGF0dHJpYnV0ZXMgb24gZWxlbWVudCB3aXRob3V0XG4gICAgICAgIC8vIG5hbWVzcGFjZSBkZWNsYXJhdGlvbnNcbiAgICAgICAgdyA9IG5hbWUuaW5kZXhPZignOicpO1xuICAgICAgICBpZiAodyA9PT0gLTEpIHtcbiAgICAgICAgICBhdHRyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIG5zIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgIGlmICghKG5zTmFtZSA9IG5zTWF0cml4W25hbWUuc3Vic3RyaW5nKDAsIHcpXSkpIHtcbiAgICAgICAgICBoYW5kbGVXYXJuaW5nKG1pc3NpbmdOYW1lc3BhY2VGb3JQcmVmaXgobmFtZS5zdWJzdHJpbmcoMCwgdykpKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWUgPSBkZWZhdWx0QWxpYXMgPT09IG5zTmFtZVxuICAgICAgICAgID8gbmFtZS5zdWJzdHIodyArIDEpXG4gICAgICAgICAgOiBuc05hbWUgKyBuYW1lLnN1YnN0cih3KTtcblxuICAgICAgICAvLyBlbmQ6IG5vcm1hbGl6ZSBucyBhdHRyaWJ1dGUgbmFtZVxuXG4gICAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG5cblxuICAgICAgLy8gaGFuZGxlIGRlZmVycmVkLCBwb3NzaWJseSBuYW1lc3BhY2VkIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChtYXliZU5TKSB7XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIGNhcHR1cmVkIGF0dHJpYnV0ZXNcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGF0dHJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXG4gICAgICAgICAgbmFtZSA9IGF0dHJMaXN0W2krK107XG4gICAgICAgICAgdmFsdWUgPSBhdHRyTGlzdFtpXTtcblxuICAgICAgICAgIHcgPSBuYW1lLmluZGV4T2YoJzonKTtcblxuICAgICAgICAgIGlmICh3ICE9PSAtMSkge1xuXG4gICAgICAgICAgICAvLyBub3JtYWxpemUgbnMgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgICAgIGlmICghKG5zTmFtZSA9IG5zTWF0cml4W25hbWUuc3Vic3RyaW5nKDAsIHcpXSkpIHtcbiAgICAgICAgICAgICAgaGFuZGxlV2FybmluZyhtaXNzaW5nTmFtZXNwYWNlRm9yUHJlZml4KG5hbWUuc3Vic3RyaW5nKDAsIHcpKSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuYW1lID0gZGVmYXVsdEFsaWFzID09PSBuc05hbWVcbiAgICAgICAgICAgICAgPyBuYW1lLnN1YnN0cih3ICsgMSlcbiAgICAgICAgICAgICAgOiBuc05hbWUgKyBuYW1lLnN1YnN0cih3KTtcblxuICAgICAgICAgICAgLy8gZW5kOiBub3JtYWxpemUgbnMgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhdHRyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5kOiBub3JtYWxpemUgY2FwdHVyZWQgYXR0cmlidXRlc1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FjaGVkQXR0cnMgPSBhdHRycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IHRoZSBwYXJzZSBjb250ZXh0IHsgbGluZSwgY29sdW1uLCBwYXJ0IH1cbiAgICAgKiBmcm9tIHRoZSBjdXJyZW50IHBhcnNlciBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gcGFyc2UgY29udGV4dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFBhcnNlQ29udGV4dCgpIHtcbiAgICAgIHZhciBzcGxpdHNSZSA9IC8oXFxyXFxufFxccnxcXG4pL2c7XG5cbiAgICAgIHZhciBsaW5lID0gMDtcbiAgICAgIHZhciBjb2x1bW4gPSAwO1xuICAgICAgdmFyIHN0YXJ0T2ZMaW5lID0gMDtcbiAgICAgIHZhciBlbmRPZkxpbmUgPSBqO1xuICAgICAgdmFyIG1hdGNoO1xuICAgICAgdmFyIGRhdGE7XG5cbiAgICAgIHdoaWxlIChpID49IHN0YXJ0T2ZMaW5lKSB7XG5cbiAgICAgICAgbWF0Y2ggPSBzcGxpdHNSZS5leGVjKHhtbCk7XG5cbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5kIG9mIGxpbmUgPSAoYnJlYWsgaWR4ICsgYnJlYWsgY2hhcnMpXG4gICAgICAgIGVuZE9mTGluZSA9IG1hdGNoWzBdLmxlbmd0aCArIG1hdGNoLmluZGV4O1xuXG4gICAgICAgIGlmIChlbmRPZkxpbmUgPiBpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZHZhbmNlIHRvIG5leHQgbGluZVxuICAgICAgICBsaW5lICs9IDE7XG5cbiAgICAgICAgc3RhcnRPZkxpbmUgPSBlbmRPZkxpbmU7XG4gICAgICB9XG5cbiAgICAgIC8vIEVPRiBlcnJvcnNcbiAgICAgIGlmIChpID09IC0xKSB7XG4gICAgICAgIGNvbHVtbiA9IGVuZE9mTGluZTtcbiAgICAgICAgZGF0YSA9IHhtbC5zdWJzdHJpbmcoaik7XG4gICAgICB9IGVsc2VcblxuICAgICAgLy8gc3RhcnQgZXJyb3JzXG4gICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICBkYXRhID0geG1sLnN1YnN0cmluZyhqLCBpKTtcbiAgICAgIH1cblxuICAgICAgLy8gb3RoZXIgZXJyb3JzXG4gICAgICBlbHNlIHtcbiAgICAgICAgY29sdW1uID0gaSAtIHN0YXJ0T2ZMaW5lO1xuICAgICAgICBkYXRhID0gKGogPT0gLTEgPyB4bWwuc3Vic3RyaW5nKGkpIDogeG1sLnN1YnN0cmluZyhpLCBqICsgMSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAnZGF0YSc6IGRhdGEsXG4gICAgICAgICdsaW5lJzogbGluZSxcbiAgICAgICAgJ2NvbHVtbic6IGNvbHVtblxuICAgICAgfTtcbiAgICB9XG5cbiAgICBnZXRDb250ZXh0ID0gZ2V0UGFyc2VDb250ZXh0O1xuXG5cbiAgICBpZiAocHJveHkpIHtcbiAgICAgIGVsZW1lbnRQcm94eSA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgJ25hbWUnOiBnZXR0ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnROYW1lO1xuICAgICAgICB9KSxcbiAgICAgICAgJ29yaWdpbmFsTmFtZSc6IGdldHRlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX2VsZW1lbnROYW1lO1xuICAgICAgICB9KSxcbiAgICAgICAgJ2F0dHJzJzogZ2V0dGVyKGdldEF0dHJzKSxcbiAgICAgICAgJ25zJzogZ2V0dGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuc01hdHJpeDtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGFjdHVhbCBwYXJzZSBsb2dpY1xuICAgIHdoaWxlIChqICE9PSAtMSkge1xuXG4gICAgICBpZiAoeG1sLmNoYXJDb2RlQXQoaikgPT09IDYwKSB7IC8vIFwiPFwiXG4gICAgICAgIGkgPSBqO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSA9IHhtbC5pbmRleE9mKCc8Jywgaik7XG4gICAgICB9XG5cbiAgICAgIC8vIHBhcnNlIGVuZFxuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIGlmIChub2RlU3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCd1bmV4cGVjdGVkIGVuZCBvZiBmaWxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcignbWlzc2luZyBzdGFydCB0YWcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqIDwgeG1sLmxlbmd0aCkge1xuICAgICAgICAgIGlmICh4bWwuc3Vic3RyaW5nKGopLnRyaW0oKSkge1xuICAgICAgICAgICAgaGFuZGxlV2FybmluZyhOT05fV0hJVEVTUEFDRV9PVVRTSURFX1JPT1RfTk9ERSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBwYXJzZSB0ZXh0XG4gICAgICBpZiAoaiAhPT0gaSkge1xuXG4gICAgICAgIGlmIChub2RlU3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG9uVGV4dCkge1xuICAgICAgICAgICAgb25UZXh0KHhtbC5zdWJzdHJpbmcoaiwgaSksIGRlY29kZUVudGl0aWVzLCBnZXRDb250ZXh0KTtcblxuICAgICAgICAgICAgaWYgKHBhcnNlU3RvcCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh4bWwuc3Vic3RyaW5nKGosIGkpLnRyaW0oKSkge1xuICAgICAgICAgICAgaGFuZGxlV2FybmluZyhOT05fV0hJVEVTUEFDRV9PVVRTSURFX1JPT1RfTk9ERSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3ID0geG1sLmNoYXJDb2RlQXQoaSArIDEpO1xuXG4gICAgICAvLyBwYXJzZSBjb21tZW50cyArIENEQVRBXG4gICAgICBpZiAodyA9PT0gMzMpIHsgLy8gXCIhXCJcbiAgICAgICAgcSA9IHhtbC5jaGFyQ29kZUF0KGkgKyAyKTtcblxuICAgICAgICAvLyBDREFUQSBzZWN0aW9uXG4gICAgICAgIGlmIChxID09PSA5MSAmJiB4bWwuc3Vic3RyKGkgKyAzLCA2KSA9PT0gJ0NEQVRBWycpIHsgLy8gOTEgPT0gXCJbXCJcbiAgICAgICAgICBqID0geG1sLmluZGV4T2YoJ11dPicsIGkpO1xuICAgICAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCd1bmNsb3NlZCBjZGF0YScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvbkNEQVRBKSB7XG4gICAgICAgICAgICBvbkNEQVRBKHhtbC5zdWJzdHJpbmcoaSArIDksIGopLCBnZXRDb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGogKz0gMztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbW1lbnRcbiAgICAgICAgaWYgKHEgPT09IDQ1ICYmIHhtbC5jaGFyQ29kZUF0KGkgKyAzKSA9PT0gNDUpIHsgLy8gNDUgPT0gXCItXCJcbiAgICAgICAgICBqID0geG1sLmluZGV4T2YoJy0tPicsIGkpO1xuICAgICAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCd1bmNsb3NlZCBjb21tZW50Jyk7XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgICBpZiAob25Db21tZW50KSB7XG4gICAgICAgICAgICBvbkNvbW1lbnQoeG1sLnN1YnN0cmluZyhpICsgNCwgaiksIGRlY29kZUVudGl0aWVzLCBnZXRDb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChwYXJzZVN0b3ApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGogKz0gMztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBwYXJzZSBxdWVzdGlvbiA8PyAuLi4gPz5cbiAgICAgIGlmICh3ID09PSA2MykgeyAvLyBcIj9cIlxuICAgICAgICBqID0geG1sLmluZGV4T2YoJz8+JywgaSk7XG4gICAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcigndW5jbG9zZWQgcXVlc3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvblF1ZXN0aW9uKSB7XG4gICAgICAgICAgb25RdWVzdGlvbih4bWwuc3Vic3RyaW5nKGksIGogKyAyKSwgZ2V0Q29udGV4dCk7XG4gICAgICAgICAgaWYgKHBhcnNlU3RvcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGogKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGZpbmQgbWF0Y2hpbmcgY2xvc2luZyB0YWcgZm9yIGF0dGVudGlvbiBvciBzdGFuZGFyZCB0YWdzXG4gICAgICAvLyBmb3IgdGhhdCB3ZSBtdXN0IHNraXAgdGhyb3VnaCBhdHRyaWJ1dGUgdmFsdWVzXG4gICAgICAvLyAoZW5jbG9zZWQgaW4gc2luZ2xlIG9yIGRvdWJsZSBxdW90ZXMpXG4gICAgICBmb3IgKHggPSBpICsgMTsgOyB4KyspIHtcbiAgICAgICAgdiA9IHhtbC5jaGFyQ29kZUF0KHgpO1xuICAgICAgICBpZiAoaXNOYU4odikpIHtcbiAgICAgICAgICBqID0gLTE7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCd1bmNsb3NlZCB0YWcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFsxMF0gQXR0VmFsdWUgOjo9ICdcIicgKFtePCZcIl0gfCBSZWZlcmVuY2UpKiAnXCInIHwgXCInXCIgKFtePCYnXSB8IFJlZmVyZW5jZSkqIFwiJ1wiXG4gICAgICAgIC8vIHNraXBzIHRoZSBxdW90ZWQgc3RyaW5nXG4gICAgICAgIC8vIChkb3VibGUgcXVvdGVzKSBkb2VzIG5vdCBhcHBlYXIgaW4gYSBsaXRlcmFsIGVuY2xvc2VkIGJ5IChkb3VibGUgcXVvdGVzKVxuICAgICAgICAvLyAoc2luZ2xlIHF1b3RlKSBkb2VzIG5vdCBhcHBlYXIgaW4gYSBsaXRlcmFsIGVuY2xvc2VkIGJ5IChzaW5nbGUgcXVvdGUpXG4gICAgICAgIGlmICh2ID09PSAzNCkgeyAvLyAgJ1wiJ1xuICAgICAgICAgIHEgPSB4bWwuaW5kZXhPZignXCInLCB4ICsgMSk7XG4gICAgICAgICAgeCA9IHEgIT09IC0xID8gcSA6IHg7XG4gICAgICAgIH0gZWxzZSBpZiAodiA9PT0gMzkpIHsgLy8gXCInXCJcbiAgICAgICAgICBxID0geG1sLmluZGV4T2YoXCInXCIsIHggKyAxKTtcbiAgICAgICAgICB4ID0gcSAhPT0gLTEgPyBxIDogeDtcbiAgICAgICAgfSBlbHNlIGlmICh2ID09PSA2MikgeyAvLyAnPidcbiAgICAgICAgICBqID0geDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIC8vIHBhcnNlIGF0dGVudGlvbiA8ISAuLi4+XG4gICAgICAvLyBwcmV2aW91c2x5IGNvbW1lbnQgYW5kIENEQVRBIGhhdmUgYWxyZWFkeSBiZWVuIHBhcnNlZFxuICAgICAgaWYgKHcgPT09IDMzKSB7IC8vIFwiIVwiXG5cbiAgICAgICAgaWYgKG9uQXR0ZW50aW9uKSB7XG4gICAgICAgICAgb25BdHRlbnRpb24oeG1sLnN1YnN0cmluZyhpLCBqICsgMSksIGRlY29kZUVudGl0aWVzLCBnZXRDb250ZXh0KTtcbiAgICAgICAgICBpZiAocGFyc2VTdG9wKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaiArPSAxO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZG9uJ3QgcHJvY2VzcyBhdHRyaWJ1dGVzO1xuICAgICAgLy8gdGhlcmUgYXJlIG5vbmVcbiAgICAgIGNhY2hlZEF0dHJzID0ge307XG5cbiAgICAgIC8vIGlmICh4bWwuY2hhckNvZGVBdChpKzEpID09PSA0NykgeyAvLyA8Ly4uLlxuICAgICAgaWYgKHcgPT09IDQ3KSB7IC8vIDwvLi4uXG4gICAgICAgIHRhZ1N0YXJ0ID0gZmFsc2U7XG4gICAgICAgIHRhZ0VuZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFub2RlU3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCdtaXNzaW5nIG9wZW4gdGFnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2ZXJpZnkgb3BlbiA8LT4gY2xvc2UgdGFnIG1hdGNoXG4gICAgICAgIHggPSBlbGVtZW50TmFtZSA9IG5vZGVTdGFjay5wb3AoKTtcbiAgICAgICAgcSA9IGkgKyAyICsgeC5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHhtbC5zdWJzdHJpbmcoaSArIDIsIHEpICE9PSB4KSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCdjbG9zaW5nIHRhZyBtaXNtYXRjaCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmVyaWZ5IGNoYXJzIGluIGNsb3NlIHRhZ1xuICAgICAgICBmb3IgKDsgcSA8IGo7IHErKykge1xuICAgICAgICAgIHcgPSB4bWwuY2hhckNvZGVBdChxKTtcblxuICAgICAgICAgIGlmICh3ID09PSAzMiB8fCAodyA+IDggJiYgdyA8IDE0KSkgeyAvLyBcXGZcXG5cXHJcXHRcXHYgc3BhY2VcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcignY2xvc2UgdGFnJyk7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHhtbC5jaGFyQ29kZUF0KGogLSAxKSA9PT0gNDcpIHsgLy8gLi4uLz5cbiAgICAgICAgICB4ID0gZWxlbWVudE5hbWUgPSB4bWwuc3Vic3RyaW5nKGkgKyAxLCBqIC0gMSk7XG5cbiAgICAgICAgICB0YWdTdGFydCA9IHRydWU7XG4gICAgICAgICAgdGFnRW5kID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSBlbGVtZW50TmFtZSA9IHhtbC5zdWJzdHJpbmcoaSArIDEsIGopO1xuXG4gICAgICAgICAgdGFnU3RhcnQgPSB0cnVlO1xuICAgICAgICAgIHRhZ0VuZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEodyA+IDk2ICYmIHcgPCAxMjMgfHwgdyA+IDY0ICYmIHcgPCA5MSB8fCB3ID09PSA5NSB8fCB3ID09PSA1OCkpIHsgLy8gY2hhciA5NVwiX1wiIDU4XCI6XCJcbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoJ2lsbGVnYWwgZmlyc3QgY2hhciBub2RlTmFtZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChxID0gMSwgeSA9IHgubGVuZ3RoOyBxIDwgeTsgcSsrKSB7XG4gICAgICAgICAgdyA9IHguY2hhckNvZGVBdChxKTtcblxuICAgICAgICAgIGlmICh3ID4gOTYgJiYgdyA8IDEyMyB8fCB3ID4gNjQgJiYgdyA8IDkxIHx8IHcgPiA0NyAmJiB3IDwgNTkgfHwgdyA9PT0gNDUgfHwgdyA9PT0gOTUgfHwgdyA9PSA0Nikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHcgPT09IDMyIHx8ICh3IDwgMTQgJiYgdyA+IDgpKSB7IC8vIFxcZlxcblxcclxcdFxcdiBzcGFjZVxuICAgICAgICAgICAgZWxlbWVudE5hbWUgPSB4LnN1YnN0cmluZygwLCBxKTtcblxuICAgICAgICAgICAgLy8gbWF5YmUgdGhlcmUgYXJlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGNhY2hlZEF0dHJzID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcignaW52YWxpZCBub2RlTmFtZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0YWdFbmQpIHtcbiAgICAgICAgICBub2RlU3RhY2sucHVzaChlbGVtZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzTmFtZXNwYWNlKSB7XG5cbiAgICAgICAgX25zTWF0cml4ID0gbnNNYXRyaXg7XG5cbiAgICAgICAgaWYgKHRhZ1N0YXJ0KSB7XG5cbiAgICAgICAgICAvLyByZW1lbWJlciBvbGQgbmFtZXNwYWNlXG4gICAgICAgICAgLy8gdW5sZXNzIHdlJ3JlIHNlbGYtY2xvc2luZ1xuICAgICAgICAgIGlmICghdGFnRW5kKSB7XG4gICAgICAgICAgICBuc01hdHJpeFN0YWNrLnB1c2goX25zTWF0cml4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2FjaGVkQXR0cnMgPT09IG51bGwpIHtcblxuICAgICAgICAgICAgLy8gcXVpY2sgY2hlY2ssIHdoZXRoZXIgdGhlcmUgbWF5IGJlIG5hbWVzcGFjZVxuICAgICAgICAgICAgLy8gZGVjbGFyYXRpb25zIG9uIHRoZSBub2RlOyBpZiB0aGF0IGlzIHRoZSBjYXNlXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGVhZ2VybHkgcGFyc2UgdGhlIG5vZGUgYXR0cmlidXRlc1xuICAgICAgICAgICAgaWYgKChtYXliZU5TID0geC5pbmRleE9mKCd4bWxucycsIHEpICE9PSAtMSkpIHtcbiAgICAgICAgICAgICAgYXR0cnNTdGFydCA9IHE7XG4gICAgICAgICAgICAgIGF0dHJzU3RyaW5nID0geDtcblxuICAgICAgICAgICAgICBnZXRBdHRycygpO1xuXG4gICAgICAgICAgICAgIG1heWJlTlMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfZWxlbWVudE5hbWUgPSBlbGVtZW50TmFtZTtcblxuICAgICAgICB3ID0gZWxlbWVudE5hbWUuaW5kZXhPZignOicpO1xuICAgICAgICBpZiAodyAhPT0gLTEpIHtcbiAgICAgICAgICB4bWxucyA9IG5zTWF0cml4W2VsZW1lbnROYW1lLnN1YnN0cmluZygwLCB3KV07XG5cbiAgICAgICAgICAvLyBwcmVmaXggZ2l2ZW47IG5hbWVzcGFjZSBtdXN0IGV4aXN0XG4gICAgICAgICAgaWYgKCF4bWxucykge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCdtaXNzaW5nIG5hbWVzcGFjZSBvbiA8JyArIF9lbGVtZW50TmFtZSArICc+Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudE5hbWUgPSBlbGVtZW50TmFtZS5zdWJzdHIodyArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhtbG5zID0gbnNNYXRyaXhbJ3htbG5zJ107XG5cbiAgICAgICAgICAvLyBpZiBubyBkZWZhdWx0IG5hbWVzcGFjZSBpcyBkZWZpbmVkLFxuICAgICAgICAgIC8vIHdlJ2xsIGltcG9ydCB0aGUgZWxlbWVudCBhcyBhbm9ueW1vdXMuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBpdCBpcyB1cCB0byB1c2VycyB0byBjb3JyZWN0IHRoYXQgdG8gdGhlIGRvY3VtZW50IGRlZmluZWRcbiAgICAgICAgICAvLyB0YXJnZXROYW1lc3BhY2UsIG9yIHdoYXRldmVyIHRoZWlyIHVuZGVyc2FuZGluZyBvZiB0aGVcbiAgICAgICAgICAvLyBYTUwgc3BlYyBtYW5kYXRlcy5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkanVzdCBuYW1lc3BhY2UgcHJlZml4cyBhcyBjb25maWd1cmVkXG4gICAgICAgIGlmICh4bWxucykge1xuICAgICAgICAgIGVsZW1lbnROYW1lID0geG1sbnMgKyAnOicgKyBlbGVtZW50TmFtZTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmICh0YWdTdGFydCkge1xuICAgICAgICBhdHRyc1N0YXJ0ID0gcTtcbiAgICAgICAgYXR0cnNTdHJpbmcgPSB4O1xuXG4gICAgICAgIGlmIChvbk9wZW5UYWcpIHtcbiAgICAgICAgICBpZiAocHJveHkpIHtcbiAgICAgICAgICAgIG9uT3BlblRhZyhlbGVtZW50UHJveHksIGRlY29kZUVudGl0aWVzLCB0YWdFbmQsIGdldENvbnRleHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvbk9wZW5UYWcoZWxlbWVudE5hbWUsIGdldEF0dHJzLCBkZWNvZGVFbnRpdGllcywgdGFnRW5kLCBnZXRDb250ZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGFyc2VTdG9wKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYgKHRhZ0VuZCkge1xuXG4gICAgICAgIGlmIChvbkNsb3NlVGFnKSB7XG4gICAgICAgICAgb25DbG9zZVRhZyhwcm94eSA/IGVsZW1lbnRQcm94eSA6IGVsZW1lbnROYW1lLCBkZWNvZGVFbnRpdGllcywgdGFnU3RhcnQsIGdldENvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKHBhcnNlU3RvcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc3RvcmUgb2xkIG5hbWVzcGFjZVxuICAgICAgICBpZiAoaXNOYW1lc3BhY2UpIHtcbiAgICAgICAgICBpZiAoIXRhZ1N0YXJ0KSB7XG4gICAgICAgICAgICBuc01hdHJpeCA9IG5zTWF0cml4U3RhY2sucG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5zTWF0cml4ID0gX25zTWF0cml4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBqICs9IDE7XG4gICAgfVxuICB9IC8qKiBlbmQgcGFyc2UgKi9cblxufVxuXG5leHBvcnQgeyBQYXJzZXIsIGRlY29kZUVudGl0aWVzIGFzIGRlY29kZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/saxen/dist/index.js\n");

/***/ })

};
;