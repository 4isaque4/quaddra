"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/object-refs";
exports.ids = ["vendor-chunks/object-refs"];
exports.modules = {

/***/ "(ssr)/../../node_modules/object-refs/dist/index.js":
/*!****************************************************!*\
  !*** ../../node_modules/object-refs/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Collection: () => (/* binding */ collection),\n/* harmony export */   Refs: () => (/* binding */ Refs)\n/* harmony export */ });\n/**\n * Extends a collection with {@link Refs} aware methods\n *\n * @param {Array<Object>} collection\n * @param {Refs} refs instance\n * @param {Object} property represented by the collection\n * @param {Object} target object the collection is attached to\n *\n * @return {RefsCollection<Object>} the extended array\n */\nfunction extend(collection, refs, property, target) {\n  var inverseProperty = property.inverse;\n\n  /**\n   * Removes the given element from the array and returns it.\n   *\n   * @method RefsCollection#remove\n   *\n   * @param {Object} element the element to remove\n   */\n  Object.defineProperty(collection, 'remove', {\n    value: function (element) {\n      var idx = this.indexOf(element);\n      if (idx !== -1) {\n        this.splice(idx, 1);\n\n        // unset inverse\n        refs.unset(element, inverseProperty, target);\n      }\n      return element;\n    }\n  });\n\n  /**\n   * Returns true if the collection contains the given element\n   *\n   * @method RefsCollection#contains\n   *\n   * @param {Object} element the element to check for\n   */\n  Object.defineProperty(collection, 'contains', {\n    value: function (element) {\n      return this.indexOf(element) !== -1;\n    }\n  });\n\n  /**\n   * Adds an element to the array, unless it exists already (set semantics).\n   *\n   * @method RefsCollection#add\n   *\n   * @param {Object} element the element to add\n   * @param {Number} optional index to add element to\n   *                 (possibly moving other elements around)\n   */\n  Object.defineProperty(collection, 'add', {\n    value: function (element, idx) {\n      var currentIdx = this.indexOf(element);\n      if (typeof idx === 'undefined') {\n        if (currentIdx !== -1) {\n          // element already in collection (!)\n          return;\n        }\n\n        // add to end of array, as no idx is specified\n        idx = this.length;\n      }\n\n      // handle already in collection\n      if (currentIdx !== -1) {\n        // remove element from currentIdx\n        this.splice(currentIdx, 1);\n      }\n\n      // add element at idx\n      this.splice(idx, 0, element);\n      if (currentIdx === -1) {\n        // set inverse, unless element was\n        // in collection already\n        refs.set(element, inverseProperty, target);\n      }\n    }\n  });\n\n  // a simple marker, identifying this element\n  // as being a refs collection\n  Object.defineProperty(collection, '__refs_collection', {\n    value: true\n  });\n  return collection;\n}\n\n/**\n * Checks if a given collection is extended\n *\n * @param {Array<Object>} collection\n *\n * @return {boolean}\n */\nfunction isExtended(collection) {\n  return collection.__refs_collection === true;\n}\n\nvar collection = {\n  __proto__: null,\n  extend: extend,\n  isExtended: isExtended\n};\n\nfunction hasOwnProperty(e, property) {\n  return Object.prototype.hasOwnProperty.call(e, property.name || property);\n}\nfunction defineCollectionProperty(ref, property, target) {\n  var collection = extend(target[property.name] || [], ref, property, target);\n  Object.defineProperty(target, property.name, {\n    enumerable: property.enumerable,\n    value: collection\n  });\n  if (collection.length) {\n    collection.forEach(function (o) {\n      ref.set(o, property.inverse, target);\n    });\n  }\n}\nfunction defineProperty(ref, property, target) {\n  var inverseProperty = property.inverse;\n  var _value = target[property.name];\n  Object.defineProperty(target, property.name, {\n    configurable: property.configurable,\n    enumerable: property.enumerable,\n    get: function () {\n      return _value;\n    },\n    set: function (value) {\n      // return if we already performed all changes\n      if (value === _value) {\n        return;\n      }\n      var old = _value;\n\n      // temporary set null\n      _value = null;\n      if (old) {\n        ref.unset(old, inverseProperty, target);\n      }\n\n      // set new value\n      _value = value;\n\n      // set inverse value\n      ref.set(_value, inverseProperty, target);\n    }\n  });\n}\n\n/**\n * Creates a new references object defining two inversly related\n * attribute descriptors a and b.\n *\n * <p>\n *   When bound to an object using {@link Refs#bind} the references\n *   get activated and ensure that add and remove operations are applied\n *   reversely, too.\n * </p>\n *\n * <p>\n *   For attributes represented as collections {@link Refs} provides the\n *   {@link RefsCollection#add}, {@link RefsCollection#remove} and {@link RefsCollection#contains} extensions\n *   that must be used to properly hook into the inverse change mechanism.\n * </p>\n *\n * @class Refs\n *\n * @classdesc A bi-directional reference between two attributes.\n *\n * @param {Refs.AttributeDescriptor} a property descriptor\n * @param {Refs.AttributeDescriptor} b property descriptor\n *\n * @example\n *\n * var refs = Refs({ name: 'wheels', collection: true, enumerable: true }, { name: 'car' });\n *\n * var car = { name: 'toyota' };\n * var wheels = [{ pos: 'front-left' }, { pos: 'front-right' }];\n *\n * refs.bind(car, 'wheels');\n *\n * car.wheels // []\n * car.wheels.add(wheels[0]);\n * car.wheels.add(wheels[1]);\n *\n * car.wheels // [{ pos: 'front-left' }, { pos: 'front-right' }]\n *\n * wheels[0].car // { name: 'toyota' };\n * car.wheels.remove(wheels[0]);\n *\n * wheels[0].car // undefined\n */\nfunction Refs(a, b) {\n  if (!(this instanceof Refs)) {\n    return new Refs(a, b);\n  }\n\n  // link\n  a.inverse = b;\n  b.inverse = a;\n  this.props = {};\n  this.props[a.name] = a;\n  this.props[b.name] = b;\n}\n\n/**\n * Binds one side of a bi-directional reference to a\n * target object.\n *\n * @memberOf Refs\n *\n * @param  {Object} target\n * @param  {String} property\n */\nRefs.prototype.bind = function (target, property) {\n  if (typeof property === 'string') {\n    if (!this.props[property]) {\n      throw new Error('no property <' + property + '> in ref');\n    }\n    property = this.props[property];\n  }\n  if (property.collection) {\n    defineCollectionProperty(this, property, target);\n  } else {\n    defineProperty(this, property, target);\n  }\n};\nRefs.prototype.ensureRefsCollection = function (target, property) {\n  var collection = target[property.name];\n  if (!isExtended(collection)) {\n    defineCollectionProperty(this, property, target);\n  }\n  return collection;\n};\nRefs.prototype.ensureBound = function (target, property) {\n  if (!hasOwnProperty(target, property)) {\n    this.bind(target, property);\n  }\n};\nRefs.prototype.unset = function (target, property, value) {\n  if (target) {\n    this.ensureBound(target, property);\n    if (property.collection) {\n      this.ensureRefsCollection(target, property).remove(value);\n    } else {\n      target[property.name] = undefined;\n    }\n  }\n};\nRefs.prototype.set = function (target, property, value) {\n  if (target) {\n    this.ensureBound(target, property);\n    if (property.collection) {\n      this.ensureRefsCollection(target, property).add(value);\n    } else {\n      target[property.name] = value;\n    }\n  }\n};\n\n/**\n * An attribute descriptor to be used specify an attribute in a {@link Refs} instance\n *\n * @typedef {Object} Refs.AttributeDescriptor\n * @property {String} name\n * @property {boolean} [collection=false]\n * @property {boolean} [enumerable=false]\n */\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL29iamVjdC1yZWZzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQsTUFBTSx5QkFBeUIsR0FBRyw2QkFBNkIsS0FBSywrQkFBK0I7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLDBCQUEwQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQW9ELElBQUksYUFBYTtBQUMxRjtBQUNBLGVBQWU7QUFDZixtQkFBbUIsbUJBQW1CLElBQUksb0JBQW9CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQixJQUFJLG9CQUFvQjtBQUMvRDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUUsWUFBWTtBQUM3RTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2Qjs7QUFFMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFkZHJhLXdlYi8uLi8uLi9ub2RlX21vZHVsZXMvb2JqZWN0LXJlZnMvZGlzdC9pbmRleC5qcz9jNWJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZW5kcyBhIGNvbGxlY3Rpb24gd2l0aCB7QGxpbmsgUmVmc30gYXdhcmUgbWV0aG9kc1xuICpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gY29sbGVjdGlvblxuICogQHBhcmFtIHtSZWZzfSByZWZzIGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydHkgcmVwcmVzZW50ZWQgYnkgdGhlIGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgb2JqZWN0IHRoZSBjb2xsZWN0aW9uIGlzIGF0dGFjaGVkIHRvXG4gKlxuICogQHJldHVybiB7UmVmc0NvbGxlY3Rpb248T2JqZWN0Pn0gdGhlIGV4dGVuZGVkIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChjb2xsZWN0aW9uLCByZWZzLCBwcm9wZXJ0eSwgdGFyZ2V0KSB7XG4gIHZhciBpbnZlcnNlUHJvcGVydHkgPSBwcm9wZXJ0eS5pbnZlcnNlO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBlbGVtZW50IGZyb20gdGhlIGFycmF5IGFuZCByZXR1cm5zIGl0LlxuICAgKlxuICAgKiBAbWV0aG9kIFJlZnNDb2xsZWN0aW9uI3JlbW92ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCB0aGUgZWxlbWVudCB0byByZW1vdmVcbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb2xsZWN0aW9uLCAncmVtb3ZlJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgdmFyIGlkeCA9IHRoaXMuaW5kZXhPZihlbGVtZW50KTtcbiAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuc3BsaWNlKGlkeCwgMSk7XG5cbiAgICAgICAgLy8gdW5zZXQgaW52ZXJzZVxuICAgICAgICByZWZzLnVuc2V0KGVsZW1lbnQsIGludmVyc2VQcm9wZXJ0eSwgdGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29sbGVjdGlvbiBjb250YWlucyB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgKlxuICAgKiBAbWV0aG9kIFJlZnNDb2xsZWN0aW9uI2NvbnRhaW5zXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIGNoZWNrIGZvclxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbGxlY3Rpb24sICdjb250YWlucycsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4T2YoZWxlbWVudCkgIT09IC0xO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gZWxlbWVudCB0byB0aGUgYXJyYXksIHVubGVzcyBpdCBleGlzdHMgYWxyZWFkeSAoc2V0IHNlbWFudGljcykuXG4gICAqXG4gICAqIEBtZXRob2QgUmVmc0NvbGxlY3Rpb24jYWRkXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIGFkZFxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgaW5kZXggdG8gYWRkIGVsZW1lbnQgdG9cbiAgICogICAgICAgICAgICAgICAgIChwb3NzaWJseSBtb3Zpbmcgb3RoZXIgZWxlbWVudHMgYXJvdW5kKVxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbGxlY3Rpb24sICdhZGQnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChlbGVtZW50LCBpZHgpIHtcbiAgICAgIHZhciBjdXJyZW50SWR4ID0gdGhpcy5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgaWYgKHR5cGVvZiBpZHggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChjdXJyZW50SWR4ICE9PSAtMSkge1xuICAgICAgICAgIC8vIGVsZW1lbnQgYWxyZWFkeSBpbiBjb2xsZWN0aW9uICghKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0byBlbmQgb2YgYXJyYXksIGFzIG5vIGlkeCBpcyBzcGVjaWZpZWRcbiAgICAgICAgaWR4ID0gdGhpcy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSBhbHJlYWR5IGluIGNvbGxlY3Rpb25cbiAgICAgIGlmIChjdXJyZW50SWR4ICE9PSAtMSkge1xuICAgICAgICAvLyByZW1vdmUgZWxlbWVudCBmcm9tIGN1cnJlbnRJZHhcbiAgICAgICAgdGhpcy5zcGxpY2UoY3VycmVudElkeCwgMSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCBlbGVtZW50IGF0IGlkeFxuICAgICAgdGhpcy5zcGxpY2UoaWR4LCAwLCBlbGVtZW50KTtcbiAgICAgIGlmIChjdXJyZW50SWR4ID09PSAtMSkge1xuICAgICAgICAvLyBzZXQgaW52ZXJzZSwgdW5sZXNzIGVsZW1lbnQgd2FzXG4gICAgICAgIC8vIGluIGNvbGxlY3Rpb24gYWxyZWFkeVxuICAgICAgICByZWZzLnNldChlbGVtZW50LCBpbnZlcnNlUHJvcGVydHksIHRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBhIHNpbXBsZSBtYXJrZXIsIGlkZW50aWZ5aW5nIHRoaXMgZWxlbWVudFxuICAvLyBhcyBiZWluZyBhIHJlZnMgY29sbGVjdGlvblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29sbGVjdGlvbiwgJ19fcmVmc19jb2xsZWN0aW9uJywge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBjb2xsZWN0aW9uIGlzIGV4dGVuZGVkXG4gKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBjb2xsZWN0aW9uXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFeHRlbmRlZChjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBjb2xsZWN0aW9uLl9fcmVmc19jb2xsZWN0aW9uID09PSB0cnVlO1xufVxuXG52YXIgY29sbGVjdGlvbiA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBleHRlbmQ6IGV4dGVuZCxcbiAgaXNFeHRlbmRlZDogaXNFeHRlbmRlZFxufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkoZSwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCBwcm9wZXJ0eS5uYW1lIHx8IHByb3BlcnR5KTtcbn1cbmZ1bmN0aW9uIGRlZmluZUNvbGxlY3Rpb25Qcm9wZXJ0eShyZWYsIHByb3BlcnR5LCB0YXJnZXQpIHtcbiAgdmFyIGNvbGxlY3Rpb24gPSBleHRlbmQodGFyZ2V0W3Byb3BlcnR5Lm5hbWVdIHx8IFtdLCByZWYsIHByb3BlcnR5LCB0YXJnZXQpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eS5uYW1lLCB7XG4gICAgZW51bWVyYWJsZTogcHJvcGVydHkuZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogY29sbGVjdGlvblxuICB9KTtcbiAgaWYgKGNvbGxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICByZWYuc2V0KG8sIHByb3BlcnR5LmludmVyc2UsIHRhcmdldCk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHJlZiwgcHJvcGVydHksIHRhcmdldCkge1xuICB2YXIgaW52ZXJzZVByb3BlcnR5ID0gcHJvcGVydHkuaW52ZXJzZTtcbiAgdmFyIF92YWx1ZSA9IHRhcmdldFtwcm9wZXJ0eS5uYW1lXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkubmFtZSwge1xuICAgIGNvbmZpZ3VyYWJsZTogcHJvcGVydHkuY29uZmlndXJhYmxlLFxuICAgIGVudW1lcmFibGU6IHByb3BlcnR5LmVudW1lcmFibGUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3ZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIHJldHVybiBpZiB3ZSBhbHJlYWR5IHBlcmZvcm1lZCBhbGwgY2hhbmdlc1xuICAgICAgaWYgKHZhbHVlID09PSBfdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG9sZCA9IF92YWx1ZTtcblxuICAgICAgLy8gdGVtcG9yYXJ5IHNldCBudWxsXG4gICAgICBfdmFsdWUgPSBudWxsO1xuICAgICAgaWYgKG9sZCkge1xuICAgICAgICByZWYudW5zZXQob2xkLCBpbnZlcnNlUHJvcGVydHksIHRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIF92YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAvLyBzZXQgaW52ZXJzZSB2YWx1ZVxuICAgICAgcmVmLnNldChfdmFsdWUsIGludmVyc2VQcm9wZXJ0eSwgdGFyZ2V0KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcmVmZXJlbmNlcyBvYmplY3QgZGVmaW5pbmcgdHdvIGludmVyc2x5IHJlbGF0ZWRcbiAqIGF0dHJpYnV0ZSBkZXNjcmlwdG9ycyBhIGFuZCBiLlxuICpcbiAqIDxwPlxuICogICBXaGVuIGJvdW5kIHRvIGFuIG9iamVjdCB1c2luZyB7QGxpbmsgUmVmcyNiaW5kfSB0aGUgcmVmZXJlbmNlc1xuICogICBnZXQgYWN0aXZhdGVkIGFuZCBlbnN1cmUgdGhhdCBhZGQgYW5kIHJlbW92ZSBvcGVyYXRpb25zIGFyZSBhcHBsaWVkXG4gKiAgIHJldmVyc2VseSwgdG9vLlxuICogPC9wPlxuICpcbiAqIDxwPlxuICogICBGb3IgYXR0cmlidXRlcyByZXByZXNlbnRlZCBhcyBjb2xsZWN0aW9ucyB7QGxpbmsgUmVmc30gcHJvdmlkZXMgdGhlXG4gKiAgIHtAbGluayBSZWZzQ29sbGVjdGlvbiNhZGR9LCB7QGxpbmsgUmVmc0NvbGxlY3Rpb24jcmVtb3ZlfSBhbmQge0BsaW5rIFJlZnNDb2xsZWN0aW9uI2NvbnRhaW5zfSBleHRlbnNpb25zXG4gKiAgIHRoYXQgbXVzdCBiZSB1c2VkIHRvIHByb3Blcmx5IGhvb2sgaW50byB0aGUgaW52ZXJzZSBjaGFuZ2UgbWVjaGFuaXNtLlxuICogPC9wPlxuICpcbiAqIEBjbGFzcyBSZWZzXG4gKlxuICogQGNsYXNzZGVzYyBBIGJpLWRpcmVjdGlvbmFsIHJlZmVyZW5jZSBiZXR3ZWVuIHR3byBhdHRyaWJ1dGVzLlxuICpcbiAqIEBwYXJhbSB7UmVmcy5BdHRyaWJ1dGVEZXNjcmlwdG9yfSBhIHByb3BlcnR5IGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7UmVmcy5BdHRyaWJ1dGVEZXNjcmlwdG9yfSBiIHByb3BlcnR5IGRlc2NyaXB0b3JcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciByZWZzID0gUmVmcyh7IG5hbWU6ICd3aGVlbHMnLCBjb2xsZWN0aW9uOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlIH0sIHsgbmFtZTogJ2NhcicgfSk7XG4gKlxuICogdmFyIGNhciA9IHsgbmFtZTogJ3RveW90YScgfTtcbiAqIHZhciB3aGVlbHMgPSBbeyBwb3M6ICdmcm9udC1sZWZ0JyB9LCB7IHBvczogJ2Zyb250LXJpZ2h0JyB9XTtcbiAqXG4gKiByZWZzLmJpbmQoY2FyLCAnd2hlZWxzJyk7XG4gKlxuICogY2FyLndoZWVscyAvLyBbXVxuICogY2FyLndoZWVscy5hZGQod2hlZWxzWzBdKTtcbiAqIGNhci53aGVlbHMuYWRkKHdoZWVsc1sxXSk7XG4gKlxuICogY2FyLndoZWVscyAvLyBbeyBwb3M6ICdmcm9udC1sZWZ0JyB9LCB7IHBvczogJ2Zyb250LXJpZ2h0JyB9XVxuICpcbiAqIHdoZWVsc1swXS5jYXIgLy8geyBuYW1lOiAndG95b3RhJyB9O1xuICogY2FyLndoZWVscy5yZW1vdmUod2hlZWxzWzBdKTtcbiAqXG4gKiB3aGVlbHNbMF0uY2FyIC8vIHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBSZWZzKGEsIGIpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlZnMpKSB7XG4gICAgcmV0dXJuIG5ldyBSZWZzKGEsIGIpO1xuICB9XG5cbiAgLy8gbGlua1xuICBhLmludmVyc2UgPSBiO1xuICBiLmludmVyc2UgPSBhO1xuICB0aGlzLnByb3BzID0ge307XG4gIHRoaXMucHJvcHNbYS5uYW1lXSA9IGE7XG4gIHRoaXMucHJvcHNbYi5uYW1lXSA9IGI7XG59XG5cbi8qKlxuICogQmluZHMgb25lIHNpZGUgb2YgYSBiaS1kaXJlY3Rpb25hbCByZWZlcmVuY2UgdG8gYVxuICogdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBAbWVtYmVyT2YgUmVmc1xuICpcbiAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gIHtTdHJpbmd9IHByb3BlcnR5XG4gKi9cblJlZnMucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnc3RyaW5nJykge1xuICAgIGlmICghdGhpcy5wcm9wc1twcm9wZXJ0eV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gcHJvcGVydHkgPCcgKyBwcm9wZXJ0eSArICc+IGluIHJlZicpO1xuICAgIH1cbiAgICBwcm9wZXJ0eSA9IHRoaXMucHJvcHNbcHJvcGVydHldO1xuICB9XG4gIGlmIChwcm9wZXJ0eS5jb2xsZWN0aW9uKSB7XG4gICAgZGVmaW5lQ29sbGVjdGlvblByb3BlcnR5KHRoaXMsIHByb3BlcnR5LCB0YXJnZXQpO1xuICB9IGVsc2Uge1xuICAgIGRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BlcnR5LCB0YXJnZXQpO1xuICB9XG59O1xuUmVmcy5wcm90b3R5cGUuZW5zdXJlUmVmc0NvbGxlY3Rpb24gPSBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICB2YXIgY29sbGVjdGlvbiA9IHRhcmdldFtwcm9wZXJ0eS5uYW1lXTtcbiAgaWYgKCFpc0V4dGVuZGVkKGNvbGxlY3Rpb24pKSB7XG4gICAgZGVmaW5lQ29sbGVjdGlvblByb3BlcnR5KHRoaXMsIHByb3BlcnR5LCB0YXJnZXQpO1xuICB9XG4gIHJldHVybiBjb2xsZWN0aW9uO1xufTtcblJlZnMucHJvdG90eXBlLmVuc3VyZUJvdW5kID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSkge1xuICAgIHRoaXMuYmluZCh0YXJnZXQsIHByb3BlcnR5KTtcbiAgfVxufTtcblJlZnMucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIGlmICh0YXJnZXQpIHtcbiAgICB0aGlzLmVuc3VyZUJvdW5kKHRhcmdldCwgcHJvcGVydHkpO1xuICAgIGlmIChwcm9wZXJ0eS5jb2xsZWN0aW9uKSB7XG4gICAgICB0aGlzLmVuc3VyZVJlZnNDb2xsZWN0aW9uKHRhcmdldCwgcHJvcGVydHkpLnJlbW92ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldFtwcm9wZXJ0eS5uYW1lXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn07XG5SZWZzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgaWYgKHRhcmdldCkge1xuICAgIHRoaXMuZW5zdXJlQm91bmQodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgaWYgKHByb3BlcnR5LmNvbGxlY3Rpb24pIHtcbiAgICAgIHRoaXMuZW5zdXJlUmVmc0NvbGxlY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eSkuYWRkKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0W3Byb3BlcnR5Lm5hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEFuIGF0dHJpYnV0ZSBkZXNjcmlwdG9yIHRvIGJlIHVzZWQgc3BlY2lmeSBhbiBhdHRyaWJ1dGUgaW4gYSB7QGxpbmsgUmVmc30gaW5zdGFuY2VcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZWZzLkF0dHJpYnV0ZURlc2NyaXB0b3JcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBuYW1lXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb2xsZWN0aW9uPWZhbHNlXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbZW51bWVyYWJsZT1mYWxzZV1cbiAqL1xuXG5leHBvcnQgeyBjb2xsZWN0aW9uIGFzIENvbGxlY3Rpb24sIFJlZnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/object-refs/dist/index.js\n");

/***/ })

};
;