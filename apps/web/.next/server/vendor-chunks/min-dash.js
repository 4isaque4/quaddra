"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/min-dash";
exports.ids = ["vendor-chunks/min-dash"];
exports.modules = {

/***/ "(ssr)/../../node_modules/min-dash/dist/index.esm.js":
/*!*****************************************************!*\
  !*** ../../node_modules/min-dash/dist/index.esm.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   bind: () => (/* binding */ bind),\n/* harmony export */   debounce: () => (/* binding */ debounce),\n/* harmony export */   ensureArray: () => (/* binding */ ensureArray),\n/* harmony export */   every: () => (/* binding */ every),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   find: () => (/* binding */ find),\n/* harmony export */   findIndex: () => (/* binding */ findIndex),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   forEach: () => (/* binding */ forEach),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   groupBy: () => (/* binding */ groupBy),\n/* harmony export */   has: () => (/* binding */ has),\n/* harmony export */   isArray: () => (/* binding */ isArray),\n/* harmony export */   isDefined: () => (/* binding */ isDefined),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isNil: () => (/* binding */ isNil),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isUndefined: () => (/* binding */ isUndefined),\n/* harmony export */   keys: () => (/* binding */ keys),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   matchPattern: () => (/* binding */ matchPattern),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   reduce: () => (/* binding */ reduce),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   some: () => (/* binding */ some),\n/* harmony export */   sortBy: () => (/* binding */ sortBy),\n/* harmony export */   throttle: () => (/* binding */ throttle),\n/* harmony export */   unionBy: () => (/* binding */ unionBy),\n/* harmony export */   uniqueBy: () => (/* binding */ uniqueBy),\n/* harmony export */   values: () => (/* binding */ values),\n/* harmony export */   without: () => (/* binding */ without)\n/* harmony export */ });\n/**\n * Flatten array, one level deep.\n *\n * @template T\n *\n * @param {T[][] | T[] | null} [arr]\n *\n * @return {T[]}\n */\nfunction flatten(arr) {\n  return Array.prototype.concat.apply([], arr);\n}\n\nconst nativeToString = Object.prototype.toString;\nconst nativeHasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction isUndefined(obj) {\n  return obj === undefined;\n}\n\nfunction isDefined(obj) {\n  return obj !== undefined;\n}\n\nfunction isNil(obj) {\n  return obj == null;\n}\n\nfunction isArray(obj) {\n  return nativeToString.call(obj) === '[object Array]';\n}\n\nfunction isObject(obj) {\n  return nativeToString.call(obj) === '[object Object]';\n}\n\nfunction isNumber(obj) {\n  return nativeToString.call(obj) === '[object Number]';\n}\n\n/**\n * @param {any} obj\n *\n * @return {boolean}\n */\nfunction isFunction(obj) {\n  const tag = nativeToString.call(obj);\n\n  return (\n    tag === '[object Function]' ||\n    tag === '[object AsyncFunction]' ||\n    tag === '[object GeneratorFunction]' ||\n    tag === '[object AsyncGeneratorFunction]' ||\n    tag === '[object Proxy]'\n  );\n}\n\nfunction isString(obj) {\n  return nativeToString.call(obj) === '[object String]';\n}\n\n\n/**\n * Ensure collection is an array.\n *\n * @param {Object} obj\n */\nfunction ensureArray(obj) {\n\n  if (isArray(obj)) {\n    return;\n  }\n\n  throw new Error('must supply array');\n}\n\n/**\n * Return true, if target owns a property with the given key.\n *\n * @param {Object} target\n * @param {String} key\n *\n * @return {Boolean}\n */\nfunction has(target, key) {\n  return !isNil(target) && nativeHasOwnProperty.call(target, key);\n}\n\n/**\n * @template T\n * @typedef { (\n *   ((e: T) => boolean) |\n *   ((e: T, idx: number) => boolean) |\n *   ((e: T, key: string) => boolean) |\n *   string |\n *   number\n * ) } Matcher\n */\n\n/**\n * @template T\n * @template U\n *\n * @typedef { (\n *   ((e: T) => U) | string | number\n * ) } Extractor\n */\n\n\n/**\n * @template T\n * @typedef { (val: T, key: any) => boolean } MatchFn\n */\n\n/**\n * @template T\n * @typedef { T[] } ArrayCollection\n */\n\n/**\n * @template T\n * @typedef { { [key: string]: T } } StringKeyValueCollection\n */\n\n/**\n * @template T\n * @typedef { { [key: number]: T } } NumberKeyValueCollection\n */\n\n/**\n * @template T\n * @typedef { StringKeyValueCollection<T> | NumberKeyValueCollection<T> } KeyValueCollection\n */\n\n/**\n * @template T\n * @typedef { KeyValueCollection<T> | ArrayCollection<T> } Collection\n */\n\n/**\n * Find element in collection.\n *\n * @template T\n * @param {Collection<T>} collection\n * @param {Matcher<T>} matcher\n *\n * @return {Object}\n */\nfunction find(collection, matcher) {\n\n  const matchFn = toMatcher(matcher);\n\n  let match;\n\n  forEach(collection, function(val, key) {\n    if (matchFn(val, key)) {\n      match = val;\n\n      return false;\n    }\n  });\n\n  return match;\n\n}\n\n\n/**\n * Find element index in collection.\n *\n * @template T\n * @param {Collection<T>} collection\n * @param {Matcher<T>} matcher\n *\n * @return {number | string | undefined}\n */\nfunction findIndex(collection, matcher) {\n\n  const matchFn = toMatcher(matcher);\n\n  let idx = isArray(collection) ? -1 : undefined;\n\n  forEach(collection, function(val, key) {\n    if (matchFn(val, key)) {\n      idx = key;\n\n      return false;\n    }\n  });\n\n  return idx;\n}\n\n\n/**\n * Filter elements in collection.\n *\n * @template T\n * @param {Collection<T>} collection\n * @param {Matcher<T>} matcher\n *\n * @return {T[]} result\n */\nfunction filter(collection, matcher) {\n\n  const matchFn = toMatcher(matcher);\n\n  let result = [];\n\n  forEach(collection, function(val, key) {\n    if (matchFn(val, key)) {\n      result.push(val);\n    }\n  });\n\n  return result;\n}\n\n\n/**\n * Iterate over collection; returning something\n * (non-undefined) will stop iteration.\n *\n * @template T\n * @param {Collection<T>} collection\n * @param { ((item: T, idx: number) => (boolean|void)) | ((item: T, key: string) => (boolean|void)) } iterator\n *\n * @return {T} return result that stopped the iteration\n */\nfunction forEach(collection, iterator) {\n\n  let val,\n      result;\n\n  if (isUndefined(collection)) {\n    return;\n  }\n\n  const convertKey = isArray(collection) ? toNum : identity;\n\n  for (let key in collection) {\n\n    if (has(collection, key)) {\n      val = collection[key];\n\n      result = iterator(val, convertKey(key));\n\n      if (result === false) {\n        return val;\n      }\n    }\n  }\n}\n\n/**\n * Return collection without element.\n *\n * @template T\n * @param {ArrayCollection<T>} arr\n * @param {Matcher<T>} matcher\n *\n * @return {T[]}\n */\nfunction without(arr, matcher) {\n\n  if (isUndefined(arr)) {\n    return [];\n  }\n\n  ensureArray(arr);\n\n  const matchFn = toMatcher(matcher);\n\n  return arr.filter(function(el, idx) {\n    return !matchFn(el, idx);\n  });\n\n}\n\n\n/**\n * Reduce collection, returning a single result.\n *\n * @template T\n * @template V\n *\n * @param {Collection<T>} collection\n * @param {(result: V, entry: T, index: any) => V} iterator\n * @param {V} result\n *\n * @return {V} result returned from last iterator\n */\nfunction reduce(collection, iterator, result) {\n\n  forEach(collection, function(value, idx) {\n    result = iterator(result, value, idx);\n  });\n\n  return result;\n}\n\n\n/**\n * Return true if every element in the collection\n * matches the criteria.\n *\n * @param  {Object|Array} collection\n * @param  {Function} matcher\n *\n * @return {Boolean}\n */\nfunction every(collection, matcher) {\n\n  return !!reduce(collection, function(matches, val, key) {\n    return matches && matcher(val, key);\n  }, true);\n}\n\n\n/**\n * Return true if some elements in the collection\n * match the criteria.\n *\n * @param  {Object|Array} collection\n * @param  {Function} matcher\n *\n * @return {Boolean}\n */\nfunction some(collection, matcher) {\n\n  return !!find(collection, matcher);\n}\n\n\n/**\n * Transform a collection into another collection\n * by piping each member through the given fn.\n *\n * @param  {Object|Array}   collection\n * @param  {Function} fn\n *\n * @return {Array} transformed collection\n */\nfunction map(collection, fn) {\n\n  let result = [];\n\n  forEach(collection, function(val, key) {\n    result.push(fn(val, key));\n  });\n\n  return result;\n}\n\n\n/**\n * Get the collections keys.\n *\n * @param  {Object|Array} collection\n *\n * @return {Array}\n */\nfunction keys(collection) {\n  return collection && Object.keys(collection) || [];\n}\n\n\n/**\n * Shorthand for `keys(o).length`.\n *\n * @param  {Object|Array} collection\n *\n * @return {Number}\n */\nfunction size(collection) {\n  return keys(collection).length;\n}\n\n\n/**\n * Get the values in the collection.\n *\n * @param  {Object|Array} collection\n *\n * @return {Array}\n */\nfunction values(collection) {\n  return map(collection, (val) => val);\n}\n\n\n/**\n * Group collection members by attribute.\n *\n * @param {Object|Array} collection\n * @param {Extractor} extractor\n *\n * @return {Object} map with { attrValue => [ a, b, c ] }\n */\nfunction groupBy(collection, extractor, grouped = {}) {\n\n  extractor = toExtractor(extractor);\n\n  forEach(collection, function(val) {\n    let discriminator = extractor(val) || '_';\n\n    let group = grouped[discriminator];\n\n    if (!group) {\n      group = grouped[discriminator] = [];\n    }\n\n    group.push(val);\n  });\n\n  return grouped;\n}\n\n\nfunction uniqueBy(extractor, ...collections) {\n\n  extractor = toExtractor(extractor);\n\n  let grouped = {};\n\n  forEach(collections, (c) => groupBy(c, extractor, grouped));\n\n  let result = map(grouped, function(val, key) {\n    return val[0];\n  });\n\n  return result;\n}\n\n\nconst unionBy = uniqueBy;\n\n\n\n/**\n * Sort collection by criteria.\n *\n * @template T\n *\n * @param {Collection<T>} collection\n * @param {Extractor<T, number | string>} extractor\n *\n * @return {Array}\n */\nfunction sortBy(collection, extractor) {\n\n  extractor = toExtractor(extractor);\n\n  let sorted = [];\n\n  forEach(collection, function(value, key) {\n    let disc = extractor(value, key);\n\n    let entry = {\n      d: disc,\n      v: value\n    };\n\n    for (var idx = 0; idx < sorted.length; idx++) {\n      let { d } = sorted[idx];\n\n      if (disc < d) {\n        sorted.splice(idx, 0, entry);\n        return;\n      }\n    }\n\n    // not inserted, append (!)\n    sorted.push(entry);\n  });\n\n  return map(sorted, (e) => e.v);\n}\n\n\n/**\n * Create an object pattern matcher.\n *\n * @example\n *\n * ```javascript\n * const matcher = matchPattern({ id: 1 });\n *\n * let element = find(elements, matcher);\n * ```\n *\n * @template T\n *\n * @param {T} pattern\n *\n * @return { (el: any) =>  boolean } matcherFn\n */\nfunction matchPattern(pattern) {\n\n  return function(el) {\n\n    return every(pattern, function(val, key) {\n      return el[key] === val;\n    });\n\n  };\n}\n\n\n/**\n * @param {string | ((e: any) => any) } extractor\n *\n * @return { (e: any) => any }\n */\nfunction toExtractor(extractor) {\n\n  /**\n   * @satisfies { (e: any) => any }\n   */\n  return isFunction(extractor) ? extractor : (e) => {\n\n    // @ts-ignore: just works\n    return e[extractor];\n  };\n}\n\n\n/**\n * @template T\n * @param {Matcher<T>} matcher\n *\n * @return {MatchFn<T>}\n */\nfunction toMatcher(matcher) {\n  return isFunction(matcher) ? matcher : (e) => {\n    return e === matcher;\n  };\n}\n\n\nfunction identity(arg) {\n  return arg;\n}\n\nfunction toNum(arg) {\n  return Number(arg);\n}\n\n/* global setTimeout clearTimeout */\n\n/**\n * @typedef { {\n *   (...args: any[]): any;\n *   flush: () => void;\n *   cancel: () => void;\n * } } DebouncedFunction\n */\n\n/**\n * Debounce fn, calling it only once if the given time\n * elapsed between calls.\n *\n * Lodash-style the function exposes methods to `#clear`\n * and `#flush` to control internal behavior.\n *\n * @param  {Function} fn\n * @param  {Number} timeout\n *\n * @return {DebouncedFunction} debounced function\n */\nfunction debounce(fn, timeout) {\n\n  let timer;\n\n  let lastArgs;\n  let lastThis;\n\n  let lastNow;\n\n  function fire(force) {\n\n    let now = Date.now();\n\n    let scheduledDiff = force ? 0 : (lastNow + timeout) - now;\n\n    if (scheduledDiff > 0) {\n      return schedule(scheduledDiff);\n    }\n\n    fn.apply(lastThis, lastArgs);\n\n    clear();\n  }\n\n  function schedule(timeout) {\n    timer = setTimeout(fire, timeout);\n  }\n\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n    }\n\n    timer = lastNow = lastArgs = lastThis = undefined;\n  }\n\n  function flush() {\n    if (timer) {\n      fire(true);\n    }\n\n    clear();\n  }\n\n  /**\n   * @type { DebouncedFunction }\n   */\n  function callback(...args) {\n    lastNow = Date.now();\n\n    lastArgs = args;\n    lastThis = this;\n\n    // ensure an execution is scheduled\n    if (!timer) {\n      schedule(timeout);\n    }\n  }\n\n  callback.flush = flush;\n  callback.cancel = clear;\n\n  return callback;\n}\n\n/**\n * Throttle fn, calling at most once\n * in the given interval.\n *\n * @param  {Function} fn\n * @param  {Number} interval\n *\n * @return {Function} throttled function\n */\nfunction throttle(fn, interval) {\n  let throttling = false;\n\n  return function(...args) {\n\n    if (throttling) {\n      return;\n    }\n\n    fn(...args);\n    throttling = true;\n\n    setTimeout(() => {\n      throttling = false;\n    }, interval);\n  };\n}\n\n/**\n * Bind function against target <this>.\n *\n * @param  {Function} fn\n * @param  {Object}   target\n *\n * @return {Function} bound function\n */\nfunction bind(fn, target) {\n  return fn.bind(target);\n}\n\n/**\n * Convenience wrapper for `Object.assign`.\n *\n * @param {Object} target\n * @param {...Object} others\n *\n * @return {Object} the target\n */\nfunction assign(target, ...others) {\n  return Object.assign(target, ...others);\n}\n\n/**\n * Sets a nested property of a given object to the specified value.\n *\n * This mutates the object and returns it.\n *\n * @template T\n *\n * @param {T} target The target of the set operation.\n * @param {(string|number)[]} path The path to the nested value.\n * @param {any} value The value to set.\n *\n * @return {T}\n */\nfunction set(target, path, value) {\n\n  let currentTarget = target;\n\n  forEach(path, function(key, idx) {\n\n    if (typeof key !== 'number' && typeof key !== 'string') {\n      throw new Error('illegal key type: ' + typeof key + '. Key should be of type number or string.');\n    }\n\n    if (key === 'constructor') {\n      throw new Error('illegal key: constructor');\n    }\n\n    if (key === '__proto__') {\n      throw new Error('illegal key: __proto__');\n    }\n\n    let nextKey = path[idx + 1];\n    let nextTarget = currentTarget[key];\n\n    if (isDefined(nextKey) && isNil(nextTarget)) {\n      nextTarget = currentTarget[key] = isNaN(+nextKey) ? {} : [];\n    }\n\n    if (isUndefined(nextKey)) {\n      if (isUndefined(value)) {\n        delete currentTarget[key];\n      } else {\n        currentTarget[key] = value;\n      }\n    } else {\n      currentTarget = nextTarget;\n    }\n  });\n\n  return target;\n}\n\n\n/**\n * Gets a nested property of a given object.\n *\n * @param {Object} target The target of the get operation.\n * @param {(string|number)[]} path The path to the nested value.\n * @param {any} [defaultValue] The value to return if no value exists.\n *\n * @return {any}\n */\nfunction get(target, path, defaultValue) {\n\n  let currentTarget = target;\n\n  forEach(path, function(key) {\n\n    // accessing nil property yields <undefined>\n    if (isNil(currentTarget)) {\n      currentTarget = undefined;\n\n      return false;\n    }\n\n    currentTarget = currentTarget[key];\n  });\n\n  return isUndefined(currentTarget) ? defaultValue : currentTarget;\n}\n\n/**\n * Pick properties from the given target.\n *\n * @template T\n * @template {any[]} V\n *\n * @param {T} target\n * @param {V} properties\n *\n * @return Pick<T, V>\n */\nfunction pick(target, properties) {\n\n  let result = {};\n\n  let obj = Object(target);\n\n  forEach(properties, function(prop) {\n\n    if (prop in obj) {\n      result[prop] = target[prop];\n    }\n  });\n\n  return result;\n}\n\n/**\n * Pick all target properties, excluding the given ones.\n *\n * @template T\n * @template {any[]} V\n *\n * @param {T} target\n * @param {V} properties\n *\n * @return {Omit<T, V>} target\n */\nfunction omit(target, properties) {\n\n  let result = {};\n\n  let obj = Object(target);\n\n  forEach(obj, function(prop, key) {\n\n    if (properties.indexOf(key) === -1) {\n      result[key] = prop;\n    }\n  });\n\n  return result;\n}\n\n/**\n * Recursively merge `...sources` into given target.\n *\n * Does support merging objects; does not support merging arrays.\n *\n * @param {Object} target\n * @param {...Object} sources\n *\n * @return {Object} the target\n */\nfunction merge(target, ...sources) {\n\n  if (!sources.length) {\n    return target;\n  }\n\n  forEach(sources, function(source) {\n\n    // skip non-obj sources, i.e. null\n    if (!source || !isObject(source)) {\n      return;\n    }\n\n    forEach(source, function(sourceVal, key) {\n\n      if (key === '__proto__') {\n        return;\n      }\n\n      let targetVal = target[key];\n\n      if (isObject(sourceVal)) {\n\n        if (!isObject(targetVal)) {\n\n          // override target[key] with object\n          targetVal = {};\n        }\n\n        target[key] = merge(targetVal, sourceVal);\n      } else {\n        target[key] = sourceVal;\n      }\n\n    });\n  });\n\n  return target;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL21pbi1kYXNoL2Rpc3QvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYyxnQ0FBZ0M7QUFDOUM7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0EsY0FBYyw0REFBNEQ7QUFDMUU7O0FBRUE7QUFDQTtBQUNBLGNBQWMsNkNBQTZDO0FBQzNEOztBQUVBO0FB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QUFDZDtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBOztBQUVpVSIsInNvdXJjZXMiOlsid2VicGFjazovL3F1YWRkcmEtd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9taW4tZGFzaC9kaXN0L2luZGV4LmVzbS5qcz9iZmEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRmxhdHRlbiBhcnJheSwgb25lIGxldmVsIGRlZXAuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqXG4gKiBAcGFyYW0ge1RbXVtdIHwgVFtdIHwgbnVsbH0gW2Fycl1cbiAqXG4gKiBAcmV0dXJuIHtUW119XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnIpO1xufVxuXG5jb25zdCBuYXRpdmVUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCBuYXRpdmVIYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xuICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzRGVmaW5lZChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc05pbChvYmopIHtcbiAgcmV0dXJuIG9iaiA9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICByZXR1cm4gbmF0aXZlVG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG5hdGl2ZVRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKG9iaikge1xuICByZXR1cm4gbmF0aXZlVG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBOdW1iZXJdJztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gb2JqXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgY29uc3QgdGFnID0gbmF0aXZlVG9TdHJpbmcuY2FsbChvYmopO1xuXG4gIHJldHVybiAoXG4gICAgdGFnID09PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8XG4gICAgdGFnID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScgfHxcbiAgICB0YWcgPT09ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScgfHxcbiAgICB0YWcgPT09ICdbb2JqZWN0IEFzeW5jR2VuZXJhdG9yRnVuY3Rpb25dJyB8fFxuICAgIHRhZyA9PT0gJ1tvYmplY3QgUHJveHldJ1xuICApO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgcmV0dXJuIG5hdGl2ZVRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59XG5cblxuLyoqXG4gKiBFbnN1cmUgY29sbGVjdGlvbiBpcyBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZUFycmF5KG9iaikge1xuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3VwcGx5IGFycmF5Jyk7XG59XG5cbi8qKlxuICogUmV0dXJuIHRydWUsIGlmIHRhcmdldCBvd25zIGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4ga2V5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBoYXModGFyZ2V0LCBrZXkpIHtcbiAgcmV0dXJuICFpc05pbCh0YXJnZXQpICYmIG5hdGl2ZUhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7IChcbiAqICAgKChlOiBUKSA9PiBib29sZWFuKSB8XG4gKiAgICgoZTogVCwgaWR4OiBudW1iZXIpID0+IGJvb2xlYW4pIHxcbiAqICAgKChlOiBULCBrZXk6IHN0cmluZykgPT4gYm9vbGVhbikgfFxuICogICBzdHJpbmcgfFxuICogICBudW1iZXJcbiAqICkgfSBNYXRjaGVyXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIFVcbiAqXG4gKiBAdHlwZWRlZiB7IChcbiAqICAgKChlOiBUKSA9PiBVKSB8IHN0cmluZyB8IG51bWJlclxuICogKSB9IEV4dHJhY3RvclxuICovXG5cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYgeyAodmFsOiBULCBrZXk6IGFueSkgPT4gYm9vbGVhbiB9IE1hdGNoRm5cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7IFRbXSB9IEFycmF5Q29sbGVjdGlvblxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHsgeyBba2V5OiBzdHJpbmddOiBUIH0gfSBTdHJpbmdLZXlWYWx1ZUNvbGxlY3Rpb25cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7IHsgW2tleTogbnVtYmVyXTogVCB9IH0gTnVtYmVyS2V5VmFsdWVDb2xsZWN0aW9uXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYgeyBTdHJpbmdLZXlWYWx1ZUNvbGxlY3Rpb248VD4gfCBOdW1iZXJLZXlWYWx1ZUNvbGxlY3Rpb248VD4gfSBLZXlWYWx1ZUNvbGxlY3Rpb25cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7IEtleVZhbHVlQ29sbGVjdGlvbjxUPiB8IEFycmF5Q29sbGVjdGlvbjxUPiB9IENvbGxlY3Rpb25cbiAqL1xuXG4vKipcbiAqIEZpbmQgZWxlbWVudCBpbiBjb2xsZWN0aW9uLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb248VD59IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7TWF0Y2hlcjxUPn0gbWF0Y2hlclxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZmluZChjb2xsZWN0aW9uLCBtYXRjaGVyKSB7XG5cbiAgY29uc3QgbWF0Y2hGbiA9IHRvTWF0Y2hlcihtYXRjaGVyKTtcblxuICBsZXQgbWF0Y2g7XG5cbiAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgIGlmIChtYXRjaEZuKHZhbCwga2V5KSkge1xuICAgICAgbWF0Y2ggPSB2YWw7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBtYXRjaDtcblxufVxuXG5cbi8qKlxuICogRmluZCBlbGVtZW50IGluZGV4IGluIGNvbGxlY3Rpb24uXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7Q29sbGVjdGlvbjxUPn0gY29sbGVjdGlvblxuICogQHBhcmFtIHtNYXRjaGVyPFQ+fSBtYXRjaGVyXG4gKlxuICogQHJldHVybiB7bnVtYmVyIHwgc3RyaW5nIHwgdW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoY29sbGVjdGlvbiwgbWF0Y2hlcikge1xuXG4gIGNvbnN0IG1hdGNoRm4gPSB0b01hdGNoZXIobWF0Y2hlcik7XG5cbiAgbGV0IGlkeCA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyAtMSA6IHVuZGVmaW5lZDtcblxuICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgaWYgKG1hdGNoRm4odmFsLCBrZXkpKSB7XG4gICAgICBpZHggPSBrZXk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZHg7XG59XG5cblxuLyoqXG4gKiBGaWx0ZXIgZWxlbWVudHMgaW4gY29sbGVjdGlvbi5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtDb2xsZWN0aW9uPFQ+fSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge01hdGNoZXI8VD59IG1hdGNoZXJcbiAqXG4gKiBAcmV0dXJuIHtUW119IHJlc3VsdFxuICovXG5mdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgbWF0Y2hlcikge1xuXG4gIGNvbnN0IG1hdGNoRm4gPSB0b01hdGNoZXIobWF0Y2hlcik7XG5cbiAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICBpZiAobWF0Y2hGbih2YWwsIGtleSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGNvbGxlY3Rpb247IHJldHVybmluZyBzb21ldGhpbmdcbiAqIChub24tdW5kZWZpbmVkKSB3aWxsIHN0b3AgaXRlcmF0aW9uLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb248VD59IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7ICgoaXRlbTogVCwgaWR4OiBudW1iZXIpID0+IChib29sZWFufHZvaWQpKSB8ICgoaXRlbTogVCwga2V5OiBzdHJpbmcpID0+IChib29sZWFufHZvaWQpKSB9IGl0ZXJhdG9yXG4gKlxuICogQHJldHVybiB7VH0gcmV0dXJuIHJlc3VsdCB0aGF0IHN0b3BwZWQgdGhlIGl0ZXJhdGlvblxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdG9yKSB7XG5cbiAgbGV0IHZhbCxcbiAgICAgIHJlc3VsdDtcblxuICBpZiAoaXNVbmRlZmluZWQoY29sbGVjdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBjb252ZXJ0S2V5ID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IHRvTnVtIDogaWRlbnRpdHk7XG5cbiAgZm9yIChsZXQga2V5IGluIGNvbGxlY3Rpb24pIHtcblxuICAgIGlmIChoYXMoY29sbGVjdGlvbiwga2V5KSkge1xuICAgICAgdmFsID0gY29sbGVjdGlvbltrZXldO1xuXG4gICAgICByZXN1bHQgPSBpdGVyYXRvcih2YWwsIGNvbnZlcnRLZXkoa2V5KSk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIGNvbGxlY3Rpb24gd2l0aG91dCBlbGVtZW50LlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FycmF5Q29sbGVjdGlvbjxUPn0gYXJyXG4gKiBAcGFyYW0ge01hdGNoZXI8VD59IG1hdGNoZXJcbiAqXG4gKiBAcmV0dXJuIHtUW119XG4gKi9cbmZ1bmN0aW9uIHdpdGhvdXQoYXJyLCBtYXRjaGVyKSB7XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGFycikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBlbnN1cmVBcnJheShhcnIpO1xuXG4gIGNvbnN0IG1hdGNoRm4gPSB0b01hdGNoZXIobWF0Y2hlcik7XG5cbiAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24oZWwsIGlkeCkge1xuICAgIHJldHVybiAhbWF0Y2hGbihlbCwgaWR4KTtcbiAgfSk7XG5cbn1cblxuXG4vKipcbiAqIFJlZHVjZSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgYSBzaW5nbGUgcmVzdWx0LlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUgVlxuICpcbiAqIEBwYXJhbSB7Q29sbGVjdGlvbjxUPn0gY29sbGVjdGlvblxuICogQHBhcmFtIHsocmVzdWx0OiBWLCBlbnRyeTogVCwgaW5kZXg6IGFueSkgPT4gVn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7Vn0gcmVzdWx0XG4gKlxuICogQHJldHVybiB7Vn0gcmVzdWx0IHJldHVybmVkIGZyb20gbGFzdCBpdGVyYXRvclxuICovXG5mdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0b3IsIHJlc3VsdCkge1xuXG4gIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGlkeCkge1xuICAgIHJlc3VsdCA9IGl0ZXJhdG9yKHJlc3VsdCwgdmFsdWUsIGlkeCk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBldmVyeSBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uXG4gKiBtYXRjaGVzIHRoZSBjcml0ZXJpYS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBtYXRjaGVyXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgbWF0Y2hlcikge1xuXG4gIHJldHVybiAhIXJlZHVjZShjb2xsZWN0aW9uLCBmdW5jdGlvbihtYXRjaGVzLCB2YWwsIGtleSkge1xuICAgIHJldHVybiBtYXRjaGVzICYmIG1hdGNoZXIodmFsLCBrZXkpO1xuICB9LCB0cnVlKTtcbn1cblxuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHNvbWUgZWxlbWVudHMgaW4gdGhlIGNvbGxlY3Rpb25cbiAqIG1hdGNoIHRoZSBjcml0ZXJpYS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBtYXRjaGVyXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBtYXRjaGVyKSB7XG5cbiAgcmV0dXJuICEhZmluZChjb2xsZWN0aW9uLCBtYXRjaGVyKTtcbn1cblxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIGNvbGxlY3Rpb24gaW50byBhbm90aGVyIGNvbGxlY3Rpb25cbiAqIGJ5IHBpcGluZyBlYWNoIG1lbWJlciB0aHJvdWdoIHRoZSBnaXZlbiBmbi5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9ICAgY29sbGVjdGlvblxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IHRyYW5zZm9ybWVkIGNvbGxlY3Rpb25cbiAqL1xuZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGZuKSB7XG5cbiAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICByZXN1bHQucHVzaChmbih2YWwsIGtleSkpO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBjb2xsZWN0aW9ucyBrZXlzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdHxBcnJheX0gY29sbGVjdGlvblxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBrZXlzKGNvbGxlY3Rpb24pIHtcbiAgcmV0dXJuIGNvbGxlY3Rpb24gJiYgT2JqZWN0LmtleXMoY29sbGVjdGlvbikgfHwgW107XG59XG5cblxuLyoqXG4gKiBTaG9ydGhhbmQgZm9yIGBrZXlzKG8pLmxlbmd0aGAuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fSBjb2xsZWN0aW9uXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgcmV0dXJuIGtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZXMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fSBjb2xsZWN0aW9uXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHZhbHVlcyhjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBtYXAoY29sbGVjdGlvbiwgKHZhbCkgPT4gdmFsKTtcbn1cblxuXG4vKipcbiAqIEdyb3VwIGNvbGxlY3Rpb24gbWVtYmVycyBieSBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7RXh0cmFjdG9yfSBleHRyYWN0b3JcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IG1hcCB3aXRoIHsgYXR0clZhbHVlID0+IFsgYSwgYiwgYyBdIH1cbiAqL1xuZnVuY3Rpb24gZ3JvdXBCeShjb2xsZWN0aW9uLCBleHRyYWN0b3IsIGdyb3VwZWQgPSB7fSkge1xuXG4gIGV4dHJhY3RvciA9IHRvRXh0cmFjdG9yKGV4dHJhY3Rvcik7XG5cbiAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWwpIHtcbiAgICBsZXQgZGlzY3JpbWluYXRvciA9IGV4dHJhY3Rvcih2YWwpIHx8ICdfJztcblxuICAgIGxldCBncm91cCA9IGdyb3VwZWRbZGlzY3JpbWluYXRvcl07XG5cbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICBncm91cCA9IGdyb3VwZWRbZGlzY3JpbWluYXRvcl0gPSBbXTtcbiAgICB9XG5cbiAgICBncm91cC5wdXNoKHZhbCk7XG4gIH0pO1xuXG4gIHJldHVybiBncm91cGVkO1xufVxuXG5cbmZ1bmN0aW9uIHVuaXF1ZUJ5KGV4dHJhY3RvciwgLi4uY29sbGVjdGlvbnMpIHtcblxuICBleHRyYWN0b3IgPSB0b0V4dHJhY3RvcihleHRyYWN0b3IpO1xuXG4gIGxldCBncm91cGVkID0ge307XG5cbiAgZm9yRWFjaChjb2xsZWN0aW9ucywgKGMpID0+IGdyb3VwQnkoYywgZXh0cmFjdG9yLCBncm91cGVkKSk7XG5cbiAgbGV0IHJlc3VsdCA9IG1hcChncm91cGVkLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgIHJldHVybiB2YWxbMF07XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuY29uc3QgdW5pb25CeSA9IHVuaXF1ZUJ5O1xuXG5cblxuLyoqXG4gKiBTb3J0IGNvbGxlY3Rpb24gYnkgY3JpdGVyaWEuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb248VD59IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7RXh0cmFjdG9yPFQsIG51bWJlciB8IHN0cmluZz59IGV4dHJhY3RvclxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBzb3J0QnkoY29sbGVjdGlvbiwgZXh0cmFjdG9yKSB7XG5cbiAgZXh0cmFjdG9yID0gdG9FeHRyYWN0b3IoZXh0cmFjdG9yKTtcblxuICBsZXQgc29ydGVkID0gW107XG5cbiAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgbGV0IGRpc2MgPSBleHRyYWN0b3IodmFsdWUsIGtleSk7XG5cbiAgICBsZXQgZW50cnkgPSB7XG4gICAgICBkOiBkaXNjLFxuICAgICAgdjogdmFsdWVcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgc29ydGVkLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGxldCB7IGQgfSA9IHNvcnRlZFtpZHhdO1xuXG4gICAgICBpZiAoZGlzYyA8IGQpIHtcbiAgICAgICAgc29ydGVkLnNwbGljZShpZHgsIDAsIGVudHJ5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vdCBpbnNlcnRlZCwgYXBwZW5kICghKVxuICAgIHNvcnRlZC5wdXNoKGVudHJ5KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG1hcChzb3J0ZWQsIChlKSA9PiBlLnYpO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGFuIG9iamVjdCBwYXR0ZXJuIG1hdGNoZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBtYXRjaGVyID0gbWF0Y2hQYXR0ZXJuKHsgaWQ6IDEgfSk7XG4gKlxuICogbGV0IGVsZW1lbnQgPSBmaW5kKGVsZW1lbnRzLCBtYXRjaGVyKTtcbiAqIGBgYFxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKlxuICogQHBhcmFtIHtUfSBwYXR0ZXJuXG4gKlxuICogQHJldHVybiB7IChlbDogYW55KSA9PiAgYm9vbGVhbiB9IG1hdGNoZXJGblxuICovXG5mdW5jdGlvbiBtYXRjaFBhdHRlcm4ocGF0dGVybikge1xuXG4gIHJldHVybiBmdW5jdGlvbihlbCkge1xuXG4gICAgcmV0dXJuIGV2ZXJ5KHBhdHRlcm4sIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICByZXR1cm4gZWxba2V5XSA9PT0gdmFsO1xuICAgIH0pO1xuXG4gIH07XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8ICgoZTogYW55KSA9PiBhbnkpIH0gZXh0cmFjdG9yXG4gKlxuICogQHJldHVybiB7IChlOiBhbnkpID0+IGFueSB9XG4gKi9cbmZ1bmN0aW9uIHRvRXh0cmFjdG9yKGV4dHJhY3Rvcikge1xuXG4gIC8qKlxuICAgKiBAc2F0aXNmaWVzIHsgKGU6IGFueSkgPT4gYW55IH1cbiAgICovXG4gIHJldHVybiBpc0Z1bmN0aW9uKGV4dHJhY3RvcikgPyBleHRyYWN0b3IgOiAoZSkgPT4ge1xuXG4gICAgLy8gQHRzLWlnbm9yZToganVzdCB3b3Jrc1xuICAgIHJldHVybiBlW2V4dHJhY3Rvcl07XG4gIH07XG59XG5cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtNYXRjaGVyPFQ+fSBtYXRjaGVyXG4gKlxuICogQHJldHVybiB7TWF0Y2hGbjxUPn1cbiAqL1xuZnVuY3Rpb24gdG9NYXRjaGVyKG1hdGNoZXIpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24obWF0Y2hlcikgPyBtYXRjaGVyIDogKGUpID0+IHtcbiAgICByZXR1cm4gZSA9PT0gbWF0Y2hlcjtcbiAgfTtcbn1cblxuXG5mdW5jdGlvbiBpZGVudGl0eShhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn1cblxuZnVuY3Rpb24gdG9OdW0oYXJnKSB7XG4gIHJldHVybiBOdW1iZXIoYXJnKTtcbn1cblxuLyogZ2xvYmFsIHNldFRpbWVvdXQgY2xlYXJUaW1lb3V0ICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyB7XG4gKiAgICguLi5hcmdzOiBhbnlbXSk6IGFueTtcbiAqICAgZmx1c2g6ICgpID0+IHZvaWQ7XG4gKiAgIGNhbmNlbDogKCkgPT4gdm9pZDtcbiAqIH0gfSBEZWJvdW5jZWRGdW5jdGlvblxuICovXG5cbi8qKlxuICogRGVib3VuY2UgZm4sIGNhbGxpbmcgaXQgb25seSBvbmNlIGlmIHRoZSBnaXZlbiB0aW1lXG4gKiBlbGFwc2VkIGJldHdlZW4gY2FsbHMuXG4gKlxuICogTG9kYXNoLXN0eWxlIHRoZSBmdW5jdGlvbiBleHBvc2VzIG1ldGhvZHMgdG8gYCNjbGVhcmBcbiAqIGFuZCBgI2ZsdXNoYCB0byBjb250cm9sIGludGVybmFsIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lb3V0XG4gKlxuICogQHJldHVybiB7RGVib3VuY2VkRnVuY3Rpb259IGRlYm91bmNlZCBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgdGltZW91dCkge1xuXG4gIGxldCB0aW1lcjtcblxuICBsZXQgbGFzdEFyZ3M7XG4gIGxldCBsYXN0VGhpcztcblxuICBsZXQgbGFzdE5vdztcblxuICBmdW5jdGlvbiBmaXJlKGZvcmNlKSB7XG5cbiAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGxldCBzY2hlZHVsZWREaWZmID0gZm9yY2UgPyAwIDogKGxhc3ROb3cgKyB0aW1lb3V0KSAtIG5vdztcblxuICAgIGlmIChzY2hlZHVsZWREaWZmID4gMCkge1xuICAgICAgcmV0dXJuIHNjaGVkdWxlKHNjaGVkdWxlZERpZmYpO1xuICAgIH1cblxuICAgIGZuLmFwcGx5KGxhc3RUaGlzLCBsYXN0QXJncyk7XG5cbiAgICBjbGVhcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGUodGltZW91dCkge1xuICAgIHRpbWVyID0gc2V0VGltZW91dChmaXJlLCB0aW1lb3V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGlmICh0aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB9XG5cbiAgICB0aW1lciA9IGxhc3ROb3cgPSBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICBmaXJlKHRydWUpO1xuICAgIH1cblxuICAgIGNsZWFyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyBEZWJvdW5jZWRGdW5jdGlvbiB9XG4gICAqL1xuICBmdW5jdGlvbiBjYWxsYmFjayguLi5hcmdzKSB7XG4gICAgbGFzdE5vdyA9IERhdGUubm93KCk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3M7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuXG4gICAgLy8gZW5zdXJlIGFuIGV4ZWN1dGlvbiBpcyBzY2hlZHVsZWRcbiAgICBpZiAoIXRpbWVyKSB7XG4gICAgICBzY2hlZHVsZSh0aW1lb3V0KTtcbiAgICB9XG4gIH1cblxuICBjYWxsYmFjay5mbHVzaCA9IGZsdXNoO1xuICBjYWxsYmFjay5jYW5jZWwgPSBjbGVhcjtcblxuICByZXR1cm4gY2FsbGJhY2s7XG59XG5cbi8qKlxuICogVGhyb3R0bGUgZm4sIGNhbGxpbmcgYXQgbW9zdCBvbmNlXG4gKiBpbiB0aGUgZ2l2ZW4gaW50ZXJ2YWwuXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGludGVydmFsXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259IHRocm90dGxlZCBmdW5jdGlvblxuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmbiwgaW50ZXJ2YWwpIHtcbiAgbGV0IHRocm90dGxpbmcgPSBmYWxzZTtcblxuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuXG4gICAgaWYgKHRocm90dGxpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmbiguLi5hcmdzKTtcbiAgICB0aHJvdHRsaW5nID0gdHJ1ZTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3R0bGluZyA9IGZhbHNlO1xuICAgIH0sIGludGVydmFsKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBCaW5kIGZ1bmN0aW9uIGFnYWluc3QgdGFyZ2V0IDx0aGlzPi5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSAge09iamVjdH0gICB0YXJnZXRcbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gYm91bmQgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gYmluZChmbiwgdGFyZ2V0KSB7XG4gIHJldHVybiBmbi5iaW5kKHRhcmdldCk7XG59XG5cbi8qKlxuICogQ29udmVuaWVuY2Ugd3JhcHBlciBmb3IgYE9iamVjdC5hc3NpZ25gLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBvdGhlcnNcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSB0YXJnZXRcbiAqL1xuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgLi4ub3RoZXJzKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHRhcmdldCwgLi4ub3RoZXJzKTtcbn1cblxuLyoqXG4gKiBTZXRzIGEgbmVzdGVkIHByb3BlcnR5IG9mIGEgZ2l2ZW4gb2JqZWN0IHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUuXG4gKlxuICogVGhpcyBtdXRhdGVzIHRoZSBvYmplY3QgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqXG4gKiBAcGFyYW0ge1R9IHRhcmdldCBUaGUgdGFyZ2V0IG9mIHRoZSBzZXQgb3BlcmF0aW9uLlxuICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcilbXX0gcGF0aCBUaGUgcGF0aCB0byB0aGUgbmVzdGVkIHZhbHVlLlxuICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKlxuICogQHJldHVybiB7VH1cbiAqL1xuZnVuY3Rpb24gc2V0KHRhcmdldCwgcGF0aCwgdmFsdWUpIHtcblxuICBsZXQgY3VycmVudFRhcmdldCA9IHRhcmdldDtcblxuICBmb3JFYWNoKHBhdGgsIGZ1bmN0aW9uKGtleSwgaWR4KSB7XG5cbiAgICBpZiAodHlwZW9mIGtleSAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaWxsZWdhbCBrZXkgdHlwZTogJyArIHR5cGVvZiBrZXkgKyAnLiBLZXkgc2hvdWxkIGJlIG9mIHR5cGUgbnVtYmVyIG9yIHN0cmluZy4nKTtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lsbGVnYWwga2V5OiBjb25zdHJ1Y3RvcicpO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lsbGVnYWwga2V5OiBfX3Byb3RvX18nKTtcbiAgICB9XG5cbiAgICBsZXQgbmV4dEtleSA9IHBhdGhbaWR4ICsgMV07XG4gICAgbGV0IG5leHRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0W2tleV07XG5cbiAgICBpZiAoaXNEZWZpbmVkKG5leHRLZXkpICYmIGlzTmlsKG5leHRUYXJnZXQpKSB7XG4gICAgICBuZXh0VGFyZ2V0ID0gY3VycmVudFRhcmdldFtrZXldID0gaXNOYU4oK25leHRLZXkpID8ge30gOiBbXTtcbiAgICB9XG5cbiAgICBpZiAoaXNVbmRlZmluZWQobmV4dEtleSkpIHtcbiAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgZGVsZXRlIGN1cnJlbnRUYXJnZXRba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRUYXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50VGFyZ2V0ID0gbmV4dFRhcmdldDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cblxuLyoqXG4gKiBHZXRzIGEgbmVzdGVkIHByb3BlcnR5IG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvZiB0aGUgZ2V0IG9wZXJhdGlvbi5cbiAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXIpW119IHBhdGggVGhlIHBhdGggdG8gdGhlIG5lc3RlZCB2YWx1ZS5cbiAqIEBwYXJhbSB7YW55fSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIG5vIHZhbHVlIGV4aXN0cy5cbiAqXG4gKiBAcmV0dXJuIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGdldCh0YXJnZXQsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuXG4gIGxldCBjdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xuXG4gIGZvckVhY2gocGF0aCwgZnVuY3Rpb24oa2V5KSB7XG5cbiAgICAvLyBhY2Nlc3NpbmcgbmlsIHByb3BlcnR5IHlpZWxkcyA8dW5kZWZpbmVkPlxuICAgIGlmIChpc05pbChjdXJyZW50VGFyZ2V0KSkge1xuICAgICAgY3VycmVudFRhcmdldCA9IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0W2tleV07XG4gIH0pO1xuXG4gIHJldHVybiBpc1VuZGVmaW5lZChjdXJyZW50VGFyZ2V0KSA/IGRlZmF1bHRWYWx1ZSA6IGN1cnJlbnRUYXJnZXQ7XG59XG5cbi8qKlxuICogUGljayBwcm9wZXJ0aWVzIGZyb20gdGhlIGdpdmVuIHRhcmdldC5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIHthbnlbXX0gVlxuICpcbiAqIEBwYXJhbSB7VH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1Z9IHByb3BlcnRpZXNcbiAqXG4gKiBAcmV0dXJuIFBpY2s8VCwgVj5cbiAqL1xuZnVuY3Rpb24gcGljayh0YXJnZXQsIHByb3BlcnRpZXMpIHtcblxuICBsZXQgcmVzdWx0ID0ge307XG5cbiAgbGV0IG9iaiA9IE9iamVjdCh0YXJnZXQpO1xuXG4gIGZvckVhY2gocHJvcGVydGllcywgZnVuY3Rpb24ocHJvcCkge1xuXG4gICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSB0YXJnZXRbcHJvcF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFBpY2sgYWxsIHRhcmdldCBwcm9wZXJ0aWVzLCBleGNsdWRpbmcgdGhlIGdpdmVuIG9uZXMuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSB7YW55W119IFZcbiAqXG4gKiBAcGFyYW0ge1R9IHRhcmdldFxuICogQHBhcmFtIHtWfSBwcm9wZXJ0aWVzXG4gKlxuICogQHJldHVybiB7T21pdDxULCBWPn0gdGFyZ2V0XG4gKi9cbmZ1bmN0aW9uIG9taXQodGFyZ2V0LCBwcm9wZXJ0aWVzKSB7XG5cbiAgbGV0IHJlc3VsdCA9IHt9O1xuXG4gIGxldCBvYmogPSBPYmplY3QodGFyZ2V0KTtcblxuICBmb3JFYWNoKG9iaiwgZnVuY3Rpb24ocHJvcCwga2V5KSB7XG5cbiAgICBpZiAocHJvcGVydGllcy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHByb3A7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IG1lcmdlIGAuLi5zb3VyY2VzYCBpbnRvIGdpdmVuIHRhcmdldC5cbiAqXG4gKiBEb2VzIHN1cHBvcnQgbWVyZ2luZyBvYmplY3RzOyBkb2VzIG5vdCBzdXBwb3J0IG1lcmdpbmcgYXJyYXlzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgdGFyZ2V0XG4gKi9cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgLi4uc291cmNlcykge1xuXG4gIGlmICghc291cmNlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZm9yRWFjaChzb3VyY2VzLCBmdW5jdGlvbihzb3VyY2UpIHtcblxuICAgIC8vIHNraXAgbm9uLW9iaiBzb3VyY2VzLCBpLmUuIG51bGxcbiAgICBpZiAoIXNvdXJjZSB8fCAhaXNPYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvckVhY2goc291cmNlLCBmdW5jdGlvbihzb3VyY2VWYWwsIGtleSkge1xuXG4gICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCB0YXJnZXRWYWwgPSB0YXJnZXRba2V5XTtcblxuICAgICAgaWYgKGlzT2JqZWN0KHNvdXJjZVZhbCkpIHtcblxuICAgICAgICBpZiAoIWlzT2JqZWN0KHRhcmdldFZhbCkpIHtcblxuICAgICAgICAgIC8vIG92ZXJyaWRlIHRhcmdldFtrZXldIHdpdGggb2JqZWN0XG4gICAgICAgICAgdGFyZ2V0VmFsID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlKHRhcmdldFZhbCwgc291cmNlVmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlVmFsO1xuICAgICAgfVxuXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmV4cG9ydCB7IGFzc2lnbiwgYmluZCwgZGVib3VuY2UsIGVuc3VyZUFycmF5LCBldmVyeSwgZmlsdGVyLCBmaW5kLCBmaW5kSW5kZXgsIGZsYXR0ZW4sIGZvckVhY2gsIGdldCwgZ3JvdXBCeSwgaGFzLCBpc0FycmF5LCBpc0RlZmluZWQsIGlzRnVuY3Rpb24sIGlzTmlsLCBpc051bWJlciwgaXNPYmplY3QsIGlzU3RyaW5nLCBpc1VuZGVmaW5lZCwga2V5cywgbWFwLCBtYXRjaFBhdHRlcm4sIG1lcmdlLCBvbWl0LCBwaWNrLCByZWR1Y2UsIHNldCwgc2l6ZSwgc29tZSwgc29ydEJ5LCB0aHJvdHRsZSwgdW5pb25CeSwgdW5pcXVlQnksIHZhbHVlcywgd2l0aG91dCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/min-dash/dist/index.esm.js\n");

/***/ })

};
;