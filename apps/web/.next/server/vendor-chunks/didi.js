"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/didi";
exports.ids = ["vendor-chunks/didi"];
exports.modules = {

/***/ "(ssr)/../../node_modules/didi/dist/index.js":
/*!*********************************************!*\
  !*** ../../node_modules/didi/dist/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Injector: () => (/* binding */ Injector),\n/* harmony export */   annotate: () => (/* binding */ annotate),\n/* harmony export */   parseAnnotations: () => (/* binding */ parseAnnotations)\n/* harmony export */ });\nconst CLASS_PATTERN = /^class[ {]/;\n\n\n/**\n * @param {function} fn\n *\n * @return {boolean}\n */\nfunction isClass(fn) {\n  return CLASS_PATTERN.test(fn.toString());\n}\n\n/**\n * @param {any} obj\n *\n * @return {boolean}\n */\nfunction isArray(obj) {\n  return Array.isArray(obj);\n}\n\n/**\n * @param {any} obj\n * @param {string} prop\n *\n * @return {boolean}\n */\nfunction hasOwnProp(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n/**\n * @typedef {import('./index.js').InjectAnnotated } InjectAnnotated\n */\n\n/**\n * @template T\n *\n * @params {[...string[], T] | ...string[], T} args\n *\n * @return {T & InjectAnnotated}\n */\nfunction annotate(...args) {\n\n  if (args.length === 1 && isArray(args[0])) {\n    args = args[0];\n  }\n\n  args = [ ...args ];\n\n  const fn = args.pop();\n\n  fn.$inject = args;\n\n  return fn;\n}\n\n\n// Current limitations:\n// - can't put into \"function arg\" comments\n// function /* (no parenthesis like this) */ (){}\n// function abc( /* xx (no parenthesis like this) */ a, b) {}\n//\n// Just put the comment before function or inside:\n// /* (((this is fine))) */ function(a, b) {}\n// function abc(a) { /* (((this is fine))) */}\n//\n// - can't reliably auto-annotate constructor; we'll match the\n// first constructor(...) pattern found which may be the one\n// of a nested class, too.\n\nconst CONSTRUCTOR_ARGS = /constructor\\s*[^(]*\\(\\s*([^)]*)\\)/m;\nconst FN_ARGS = /^(?:async\\s+)?(?:function\\s*[^(]*)?(?:\\(\\s*([^)]*)\\)|(\\w+))/m;\nconst FN_ARG = /\\/\\*([^*]*)\\*\\//m;\n\n/**\n * @param {unknown} fn\n *\n * @return {string[]}\n */\nfunction parseAnnotations(fn) {\n\n  if (typeof fn !== 'function') {\n    throw new Error(`Cannot annotate \"${fn}\". Expected a function!`);\n  }\n\n  const match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);\n\n  // may parse class without constructor\n  if (!match) {\n    return [];\n  }\n\n  const args = match[1] || match[2];\n\n  return args && args.split(',').map(arg => {\n    const argMatch = arg.match(FN_ARG);\n    return (argMatch && argMatch[1] || arg).trim();\n  }) || [];\n}\n\n/**\n * @typedef { import('./index.js').ModuleDeclaration } ModuleDeclaration\n * @typedef { import('./index.js').ModuleDefinition } ModuleDefinition\n * @typedef { import('./index.js').InjectorContext } InjectorContext\n *\n * @typedef { import('./index.js').TypedDeclaration<any, any> } TypedDeclaration\n */\n\n/**\n * Create a new injector with the given modules.\n *\n * @param {ModuleDefinition[]} modules\n * @param {InjectorContext} [_parent]\n */\nfunction Injector(modules, _parent) {\n\n  const parent = _parent || /** @type InjectorContext */ ({\n    get: function(name, strict) {\n      currentlyResolving.push(name);\n\n      if (strict === false) {\n        return null;\n      } else {\n        throw error(`No provider for \"${ name }\"!`);\n      }\n    }\n  });\n\n  const currentlyResolving = [];\n  const providers = this._providers = Object.create(parent._providers || null);\n  const instances = this._instances = Object.create(null);\n\n  const self = instances.injector = this;\n\n  const error = function(msg) {\n    const stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? `${ msg } (Resolving: ${ stack })` : msg);\n  };\n\n  /**\n   * Return a named service.\n   *\n   * @param {string} name\n   * @param {boolean} [strict=true] if false, resolve missing services to null\n   *\n   * @return {any}\n   */\n  function get(name, strict) {\n    if (!providers[name] && name.includes('.')) {\n\n      const parts = name.split('.');\n      let pivot = get(/** @type { string } */ (parts.shift()));\n\n      while (parts.length) {\n        pivot = pivot[/** @type { string } */ (parts.shift())];\n      }\n\n      return pivot;\n    }\n\n    if (hasOwnProp(instances, name)) {\n      return instances[name];\n    }\n\n    if (hasOwnProp(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Cannot resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n\n      return instances[name];\n    }\n\n    return parent.get(name, strict);\n  }\n\n  function fnDef(fn, locals) {\n\n    if (typeof locals === 'undefined') {\n      locals = {};\n    }\n\n    if (typeof fn !== 'function') {\n      if (isArray(fn)) {\n        fn = annotate(fn.slice());\n      } else {\n        throw error(`Cannot invoke \"${ fn }\". Expected a function!`);\n      }\n    }\n\n    /**\n     * @type {string[]}\n     */\n    const inject = fn.$inject || parseAnnotations(fn);\n    const dependencies = inject.map(dep => {\n      if (hasOwnProp(locals, dep)) {\n        return locals[dep];\n      } else {\n        return get(dep);\n      }\n    });\n\n    return {\n      fn: fn,\n      dependencies\n    };\n  }\n\n  /**\n   * Instantiate the given type, injecting dependencies.\n   *\n   * @template T\n   *\n   * @param { Function | [...string[], Function ]} type\n   *\n   * @return T\n   */\n  function instantiate(type) {\n    const {\n      fn,\n      dependencies\n    } = fnDef(type);\n\n    // instantiate var args constructor\n    const Constructor = Function.prototype.bind.call(fn, null, ...dependencies);\n\n    return new Constructor();\n  }\n\n  /**\n   * Invoke the given function, injecting dependencies. Return the result.\n   *\n   * @template T\n   *\n   * @param { Function | [...string[], Function ]} func\n   * @param { Object } [context]\n   * @param { Object } [locals]\n   *\n   * @return {T} invocation result\n   */\n  function invoke(func, context, locals) {\n    const {\n      fn,\n      dependencies\n    } = fnDef(func, locals);\n\n    return fn.apply(context, dependencies);\n  }\n\n  /**\n   * @param {Injector} childInjector\n   *\n   * @return {Function}\n   */\n  function createPrivateInjectorFactory(childInjector) {\n    return annotate(key => childInjector.get(key));\n  }\n\n  /**\n   * @param {ModuleDefinition[]} modules\n   * @param {string[]} [forceNewInstances]\n   *\n   * @return {Injector}\n   */\n  function createChild(modules, forceNewInstances) {\n    if (forceNewInstances && forceNewInstances.length) {\n      const fromParentModule = Object.create(null);\n      const matchedScopes = Object.create(null);\n\n      const privateInjectorsCache = [];\n      const privateChildInjectors = [];\n      const privateChildFactories = [];\n\n      let provider;\n      let cacheIdx;\n      let privateChildInjector;\n      let privateChildInjectorFactory;\n\n      for (let name in providers) {\n        provider = providers[name];\n\n        if (forceNewInstances.indexOf(name) !== -1) {\n          if (provider[2] === 'private') {\n            cacheIdx = privateInjectorsCache.indexOf(provider[3]);\n            if (cacheIdx === -1) {\n              privateChildInjector = provider[3].createChild([], forceNewInstances);\n              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);\n              privateInjectorsCache.push(provider[3]);\n              privateChildInjectors.push(privateChildInjector);\n              privateChildFactories.push(privateChildInjectorFactory);\n              fromParentModule[name] = [ privateChildInjectorFactory, name, 'private', privateChildInjector ];\n            } else {\n              fromParentModule[name] = [ privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx] ];\n            }\n          } else {\n            fromParentModule[name] = [ provider[2], provider[1] ];\n          }\n          matchedScopes[name] = true;\n        }\n\n        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {\n          /* jshint -W083 */\n          forceNewInstances.forEach(scope => {\n            if (provider[1].$scope.indexOf(scope) !== -1) {\n              fromParentModule[name] = [ provider[2], provider[1] ];\n              matchedScopes[scope] = true;\n            }\n          });\n        }\n      }\n\n      forceNewInstances.forEach(scope => {\n        if (!matchedScopes[scope]) {\n          throw new Error('No provider for \"' + scope + '\". Cannot use provider from the parent!');\n        }\n      });\n\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, self);\n  }\n\n  const factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function(value) {\n      return value;\n    }\n  };\n\n  /**\n   * @param {ModuleDefinition} moduleDefinition\n   * @param {Injector} injector\n   */\n  function createInitializer(moduleDefinition, injector) {\n\n    const initializers = moduleDefinition.__init__ || [];\n\n    return function() {\n      initializers.forEach(initializer => {\n\n        // eagerly resolve component (fn or string)\n        if (typeof initializer === 'string') {\n          injector.get(initializer);\n        } else {\n          injector.invoke(initializer);\n        }\n      });\n    };\n  }\n\n  /**\n   * @param {ModuleDefinition} moduleDefinition\n   */\n  function loadModule(moduleDefinition) {\n\n    const moduleExports = moduleDefinition.__exports__;\n\n    // private module\n    if (moduleExports) {\n      const nestedModules = moduleDefinition.__modules__;\n\n      const clonedModule = Object.keys(moduleDefinition).reduce((clonedModule, key) => {\n\n        if (key !== '__exports__' && key !== '__modules__' && key !== '__init__' && key !== '__depends__') {\n          clonedModule[key] = moduleDefinition[key];\n        }\n\n        return clonedModule;\n      }, Object.create(null));\n\n      const childModules = (nestedModules || []).concat(clonedModule);\n\n      const privateInjector = createChild(childModules);\n      const getFromPrivateInjector = annotate(function(key) {\n        return privateInjector.get(key);\n      });\n\n      moduleExports.forEach(function(key) {\n        providers[key] = [ getFromPrivateInjector, key, 'private', privateInjector ];\n      });\n\n      // ensure child injector initializes\n      const initializers = (moduleDefinition.__init__ || []).slice();\n\n      initializers.unshift(function() {\n        privateInjector.init();\n      });\n\n      moduleDefinition = Object.assign({}, moduleDefinition, {\n        __init__: initializers\n      });\n\n      return createInitializer(moduleDefinition, privateInjector);\n    }\n\n    // normal module\n    Object.keys(moduleDefinition).forEach(function(key) {\n\n      if (key === '__init__' || key === '__depends__') {\n        return;\n      }\n\n      const typeDeclaration = /** @type { TypedDeclaration } */ (\n        moduleDefinition[key]\n      );\n\n      if (typeDeclaration[2] === 'private') {\n        providers[key] = typeDeclaration;\n        return;\n      }\n\n      const type = typeDeclaration[0];\n      const value = typeDeclaration[1];\n\n      providers[key] = [ factoryMap[type], arrayUnwrap(type, value), type ];\n    });\n\n    return createInitializer(moduleDefinition, self);\n  }\n\n  /**\n   * @param {ModuleDefinition[]} moduleDefinitions\n   * @param {ModuleDefinition} moduleDefinition\n   *\n   * @return {ModuleDefinition[]}\n   */\n  function resolveDependencies(moduleDefinitions, moduleDefinition) {\n\n    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {\n      return moduleDefinitions;\n    }\n\n    moduleDefinitions = (moduleDefinition.__depends__ || []).reduce(resolveDependencies, moduleDefinitions);\n\n    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {\n      return moduleDefinitions;\n    }\n\n    return moduleDefinitions.concat(moduleDefinition);\n  }\n\n  /**\n   * @param {ModuleDefinition[]} moduleDefinitions\n   *\n   * @return { () => void } initializerFn\n   */\n  function bootstrap(moduleDefinitions) {\n\n    const initializers = moduleDefinitions\n      .reduce(resolveDependencies, [])\n      .map(loadModule);\n\n    let initialized = false;\n\n    return function() {\n\n      if (initialized) {\n        return;\n      }\n\n      initialized = true;\n\n      initializers.forEach(initializer => initializer());\n    };\n  }\n\n  // public API\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n\n  // setup\n  this.init = bootstrap(modules);\n}\n\n\n// helpers ///////////////\n\nfunction arrayUnwrap(type, value) {\n  if (type !== 'value' && isArray(value)) {\n    value = annotate(value.slice());\n  }\n\n  return value;\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZGkvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxnQ0FBZ0M7OztBQUdoQztBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHVDQUF1QztBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1DQUFtQztBQUMvQztBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLCtDQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLEdBQUc7QUFDM0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsY0FBYyx5Q0FBeUM7QUFDdkQsY0FBYyx3Q0FBd0M7QUFDdEQsY0FBYyx1Q0FBdUM7QUFDckQ7QUFDQSxjQUFjLGtEQUFrRDtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHlDQUF5QyxNQUFNO0FBQy9DO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7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QTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRWdEO0FBQ2hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhZGRyYS13ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZGkvZGlzdC9pbmRleC5qcz9jZTYyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IENMQVNTX1BBVFRFUk4gPSAvXmNsYXNzWyB7XS87XG5cblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmblxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQ2xhc3MoZm4pIHtcbiAgcmV0dXJuIENMQVNTX1BBVFRFUk4udGVzdChmbi50b1N0cmluZygpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gb2JqXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gb2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc093blByb3Aob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2luZGV4LmpzJykuSW5qZWN0QW5ub3RhdGVkIH0gSW5qZWN0QW5ub3RhdGVkXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICpcbiAqIEBwYXJhbXMge1suLi5zdHJpbmdbXSwgVF0gfCAuLi5zdHJpbmdbXSwgVH0gYXJnc1xuICpcbiAqIEByZXR1cm4ge1QgJiBJbmplY3RBbm5vdGF0ZWR9XG4gKi9cbmZ1bmN0aW9uIGFubm90YXRlKC4uLmFyZ3MpIHtcblxuICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShhcmdzWzBdKSkge1xuICAgIGFyZ3MgPSBhcmdzWzBdO1xuICB9XG5cbiAgYXJncyA9IFsgLi4uYXJncyBdO1xuXG4gIGNvbnN0IGZuID0gYXJncy5wb3AoKTtcblxuICBmbi4kaW5qZWN0ID0gYXJncztcblxuICByZXR1cm4gZm47XG59XG5cblxuLy8gQ3VycmVudCBsaW1pdGF0aW9uczpcbi8vIC0gY2FuJ3QgcHV0IGludG8gXCJmdW5jdGlvbiBhcmdcIiBjb21tZW50c1xuLy8gZnVuY3Rpb24gLyogKG5vIHBhcmVudGhlc2lzIGxpa2UgdGhpcykgKi8gKCl7fVxuLy8gZnVuY3Rpb24gYWJjKCAvKiB4eCAobm8gcGFyZW50aGVzaXMgbGlrZSB0aGlzKSAqLyBhLCBiKSB7fVxuLy9cbi8vIEp1c3QgcHV0IHRoZSBjb21tZW50IGJlZm9yZSBmdW5jdGlvbiBvciBpbnNpZGU6XG4vLyAvKiAoKCh0aGlzIGlzIGZpbmUpKSkgKi8gZnVuY3Rpb24oYSwgYikge31cbi8vIGZ1bmN0aW9uIGFiYyhhKSB7IC8qICgoKHRoaXMgaXMgZmluZSkpKSAqL31cbi8vXG4vLyAtIGNhbid0IHJlbGlhYmx5IGF1dG8tYW5ub3RhdGUgY29uc3RydWN0b3I7IHdlJ2xsIG1hdGNoIHRoZVxuLy8gZmlyc3QgY29uc3RydWN0b3IoLi4uKSBwYXR0ZXJuIGZvdW5kIHdoaWNoIG1heSBiZSB0aGUgb25lXG4vLyBvZiBhIG5lc3RlZCBjbGFzcywgdG9vLlxuXG5jb25zdCBDT05TVFJVQ1RPUl9BUkdTID0gL2NvbnN0cnVjdG9yXFxzKlteKF0qXFwoXFxzKihbXildKilcXCkvbTtcbmNvbnN0IEZOX0FSR1MgPSAvXig/OmFzeW5jXFxzKyk/KD86ZnVuY3Rpb25cXHMqW14oXSopPyg/OlxcKFxccyooW14pXSopXFwpfChcXHcrKSkvbTtcbmNvbnN0IEZOX0FSRyA9IC9cXC9cXCooW14qXSopXFwqXFwvL207XG5cbi8qKlxuICogQHBhcmFtIHt1bmtub3dufSBmblxuICpcbiAqIEByZXR1cm4ge3N0cmluZ1tdfVxuICovXG5mdW5jdGlvbiBwYXJzZUFubm90YXRpb25zKGZuKSB7XG5cbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGFubm90YXRlIFwiJHtmbn1cIi4gRXhwZWN0ZWQgYSBmdW5jdGlvbiFgKTtcbiAgfVxuXG4gIGNvbnN0IG1hdGNoID0gZm4udG9TdHJpbmcoKS5tYXRjaChpc0NsYXNzKGZuKSA/IENPTlNUUlVDVE9SX0FSR1MgOiBGTl9BUkdTKTtcblxuICAvLyBtYXkgcGFyc2UgY2xhc3Mgd2l0aG91dCBjb25zdHJ1Y3RvclxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgYXJncyA9IG1hdGNoWzFdIHx8IG1hdGNoWzJdO1xuXG4gIHJldHVybiBhcmdzICYmIGFyZ3Muc3BsaXQoJywnKS5tYXAoYXJnID0+IHtcbiAgICBjb25zdCBhcmdNYXRjaCA9IGFyZy5tYXRjaChGTl9BUkcpO1xuICAgIHJldHVybiAoYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV0gfHwgYXJnKS50cmltKCk7XG4gIH0pIHx8IFtdO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2luZGV4LmpzJykuTW9kdWxlRGVjbGFyYXRpb24gfSBNb2R1bGVEZWNsYXJhdGlvblxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vaW5kZXguanMnKS5Nb2R1bGVEZWZpbml0aW9uIH0gTW9kdWxlRGVmaW5pdGlvblxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vaW5kZXguanMnKS5JbmplY3RvckNvbnRleHQgfSBJbmplY3RvckNvbnRleHRcbiAqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9pbmRleC5qcycpLlR5cGVkRGVjbGFyYXRpb248YW55LCBhbnk+IH0gVHlwZWREZWNsYXJhdGlvblxuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluamVjdG9yIHdpdGggdGhlIGdpdmVuIG1vZHVsZXMuXG4gKlxuICogQHBhcmFtIHtNb2R1bGVEZWZpbml0aW9uW119IG1vZHVsZXNcbiAqIEBwYXJhbSB7SW5qZWN0b3JDb250ZXh0fSBbX3BhcmVudF1cbiAqL1xuZnVuY3Rpb24gSW5qZWN0b3IobW9kdWxlcywgX3BhcmVudCkge1xuXG4gIGNvbnN0IHBhcmVudCA9IF9wYXJlbnQgfHwgLyoqIEB0eXBlIEluamVjdG9yQ29udGV4dCAqLyAoe1xuICAgIGdldDogZnVuY3Rpb24obmFtZSwgc3RyaWN0KSB7XG4gICAgICBjdXJyZW50bHlSZXNvbHZpbmcucHVzaChuYW1lKTtcblxuICAgICAgaWYgKHN0cmljdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJvcihgTm8gcHJvdmlkZXIgZm9yIFwiJHsgbmFtZSB9XCIhYCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBjdXJyZW50bHlSZXNvbHZpbmcgPSBbXTtcbiAgY29uc3QgcHJvdmlkZXJzID0gdGhpcy5fcHJvdmlkZXJzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQuX3Byb3ZpZGVycyB8fCBudWxsKTtcbiAgY29uc3QgaW5zdGFuY2VzID0gdGhpcy5faW5zdGFuY2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBjb25zdCBzZWxmID0gaW5zdGFuY2VzLmluamVjdG9yID0gdGhpcztcblxuICBjb25zdCBlcnJvciA9IGZ1bmN0aW9uKG1zZykge1xuICAgIGNvbnN0IHN0YWNrID0gY3VycmVudGx5UmVzb2x2aW5nLmpvaW4oJyAtPiAnKTtcbiAgICBjdXJyZW50bHlSZXNvbHZpbmcubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gbmV3IEVycm9yKHN0YWNrID8gYCR7IG1zZyB9IChSZXNvbHZpbmc6ICR7IHN0YWNrIH0pYCA6IG1zZyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG5hbWVkIHNlcnZpY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0cmljdD10cnVlXSBpZiBmYWxzZSwgcmVzb2x2ZSBtaXNzaW5nIHNlcnZpY2VzIHRvIG51bGxcbiAgICpcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0KG5hbWUsIHN0cmljdCkge1xuICAgIGlmICghcHJvdmlkZXJzW25hbWVdICYmIG5hbWUuaW5jbHVkZXMoJy4nKSkge1xuXG4gICAgICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgIGxldCBwaXZvdCA9IGdldCgvKiogQHR5cGUgeyBzdHJpbmcgfSAqLyAocGFydHMuc2hpZnQoKSkpO1xuXG4gICAgICB3aGlsZSAocGFydHMubGVuZ3RoKSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3RbLyoqIEB0eXBlIHsgc3RyaW5nIH0gKi8gKHBhcnRzLnNoaWZ0KCkpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBpdm90O1xuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wKGluc3RhbmNlcywgbmFtZSkpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZXNbbmFtZV07XG4gICAgfVxuXG4gICAgaWYgKGhhc093blByb3AocHJvdmlkZXJzLCBuYW1lKSkge1xuICAgICAgaWYgKGN1cnJlbnRseVJlc29sdmluZy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICBjdXJyZW50bHlSZXNvbHZpbmcucHVzaChuYW1lKTtcbiAgICAgICAgdGhyb3cgZXJyb3IoJ0Nhbm5vdCByZXNvbHZlIGNpcmN1bGFyIGRlcGVuZGVuY3khJyk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRseVJlc29sdmluZy5wdXNoKG5hbWUpO1xuICAgICAgaW5zdGFuY2VzW25hbWVdID0gcHJvdmlkZXJzW25hbWVdWzBdKHByb3ZpZGVyc1tuYW1lXVsxXSk7XG4gICAgICBjdXJyZW50bHlSZXNvbHZpbmcucG9wKCk7XG5cbiAgICAgIHJldHVybiBpbnN0YW5jZXNbbmFtZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudC5nZXQobmFtZSwgc3RyaWN0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZuRGVmKGZuLCBsb2NhbHMpIHtcblxuICAgIGlmICh0eXBlb2YgbG9jYWxzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbG9jYWxzID0ge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGlzQXJyYXkoZm4pKSB7XG4gICAgICAgIGZuID0gYW5ub3RhdGUoZm4uc2xpY2UoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJvcihgQ2Fubm90IGludm9rZSBcIiR7IGZuIH1cIi4gRXhwZWN0ZWQgYSBmdW5jdGlvbiFgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICovXG4gICAgY29uc3QgaW5qZWN0ID0gZm4uJGluamVjdCB8fCBwYXJzZUFubm90YXRpb25zKGZuKTtcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBpbmplY3QubWFwKGRlcCA9PiB7XG4gICAgICBpZiAoaGFzT3duUHJvcChsb2NhbHMsIGRlcCkpIHtcbiAgICAgICAgcmV0dXJuIGxvY2Fsc1tkZXBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldChkZXApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZuOiBmbixcbiAgICAgIGRlcGVuZGVuY2llc1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFudGlhdGUgdGhlIGdpdmVuIHR5cGUsIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqXG4gICAqIEBwYXJhbSB7IEZ1bmN0aW9uIHwgWy4uLnN0cmluZ1tdLCBGdW5jdGlvbiBdfSB0eXBlXG4gICAqXG4gICAqIEByZXR1cm4gVFxuICAgKi9cbiAgZnVuY3Rpb24gaW5zdGFudGlhdGUodHlwZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZuLFxuICAgICAgZGVwZW5kZW5jaWVzXG4gICAgfSA9IGZuRGVmKHR5cGUpO1xuXG4gICAgLy8gaW5zdGFudGlhdGUgdmFyIGFyZ3MgY29uc3RydWN0b3JcbiAgICBjb25zdCBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoZm4sIG51bGwsIC4uLmRlcGVuZGVuY2llcyk7XG5cbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKCk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlIHRoZSBnaXZlbiBmdW5jdGlvbiwgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy4gUmV0dXJuIHRoZSByZXN1bHQuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqXG4gICAqIEBwYXJhbSB7IEZ1bmN0aW9uIHwgWy4uLnN0cmluZ1tdLCBGdW5jdGlvbiBdfSBmdW5jXG4gICAqIEBwYXJhbSB7IE9iamVjdCB9IFtjb250ZXh0XVxuICAgKiBAcGFyYW0geyBPYmplY3QgfSBbbG9jYWxzXVxuICAgKlxuICAgKiBAcmV0dXJuIHtUfSBpbnZvY2F0aW9uIHJlc3VsdFxuICAgKi9cbiAgZnVuY3Rpb24gaW52b2tlKGZ1bmMsIGNvbnRleHQsIGxvY2Fscykge1xuICAgIGNvbnN0IHtcbiAgICAgIGZuLFxuICAgICAgZGVwZW5kZW5jaWVzXG4gICAgfSA9IGZuRGVmKGZ1bmMsIGxvY2Fscyk7XG5cbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgZGVwZW5kZW5jaWVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0luamVjdG9yfSBjaGlsZEluamVjdG9yXG4gICAqXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlUHJpdmF0ZUluamVjdG9yRmFjdG9yeShjaGlsZEluamVjdG9yKSB7XG4gICAgcmV0dXJuIGFubm90YXRlKGtleSA9PiBjaGlsZEluamVjdG9yLmdldChrZXkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vZHVsZURlZmluaXRpb25bXX0gbW9kdWxlc1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbZm9yY2VOZXdJbnN0YW5jZXNdXG4gICAqXG4gICAqIEByZXR1cm4ge0luamVjdG9yfVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGQobW9kdWxlcywgZm9yY2VOZXdJbnN0YW5jZXMpIHtcbiAgICBpZiAoZm9yY2VOZXdJbnN0YW5jZXMgJiYgZm9yY2VOZXdJbnN0YW5jZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBmcm9tUGFyZW50TW9kdWxlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIGNvbnN0IG1hdGNoZWRTY29wZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICBjb25zdCBwcml2YXRlSW5qZWN0b3JzQ2FjaGUgPSBbXTtcbiAgICAgIGNvbnN0IHByaXZhdGVDaGlsZEluamVjdG9ycyA9IFtdO1xuICAgICAgY29uc3QgcHJpdmF0ZUNoaWxkRmFjdG9yaWVzID0gW107XG5cbiAgICAgIGxldCBwcm92aWRlcjtcbiAgICAgIGxldCBjYWNoZUlkeDtcbiAgICAgIGxldCBwcml2YXRlQ2hpbGRJbmplY3RvcjtcbiAgICAgIGxldCBwcml2YXRlQ2hpbGRJbmplY3RvckZhY3Rvcnk7XG5cbiAgICAgIGZvciAobGV0IG5hbWUgaW4gcHJvdmlkZXJzKSB7XG4gICAgICAgIHByb3ZpZGVyID0gcHJvdmlkZXJzW25hbWVdO1xuXG4gICAgICAgIGlmIChmb3JjZU5ld0luc3RhbmNlcy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgIGlmIChwcm92aWRlclsyXSA9PT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICBjYWNoZUlkeCA9IHByaXZhdGVJbmplY3RvcnNDYWNoZS5pbmRleE9mKHByb3ZpZGVyWzNdKTtcbiAgICAgICAgICAgIGlmIChjYWNoZUlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcHJpdmF0ZUNoaWxkSW5qZWN0b3IgPSBwcm92aWRlclszXS5jcmVhdGVDaGlsZChbXSwgZm9yY2VOZXdJbnN0YW5jZXMpO1xuICAgICAgICAgICAgICBwcml2YXRlQ2hpbGRJbmplY3RvckZhY3RvcnkgPSBjcmVhdGVQcml2YXRlSW5qZWN0b3JGYWN0b3J5KHByaXZhdGVDaGlsZEluamVjdG9yKTtcbiAgICAgICAgICAgICAgcHJpdmF0ZUluamVjdG9yc0NhY2hlLnB1c2gocHJvdmlkZXJbM10pO1xuICAgICAgICAgICAgICBwcml2YXRlQ2hpbGRJbmplY3RvcnMucHVzaChwcml2YXRlQ2hpbGRJbmplY3Rvcik7XG4gICAgICAgICAgICAgIHByaXZhdGVDaGlsZEZhY3Rvcmllcy5wdXNoKHByaXZhdGVDaGlsZEluamVjdG9yRmFjdG9yeSk7XG4gICAgICAgICAgICAgIGZyb21QYXJlbnRNb2R1bGVbbmFtZV0gPSBbIHByaXZhdGVDaGlsZEluamVjdG9yRmFjdG9yeSwgbmFtZSwgJ3ByaXZhdGUnLCBwcml2YXRlQ2hpbGRJbmplY3RvciBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbVBhcmVudE1vZHVsZVtuYW1lXSA9IFsgcHJpdmF0ZUNoaWxkRmFjdG9yaWVzW2NhY2hlSWR4XSwgbmFtZSwgJ3ByaXZhdGUnLCBwcml2YXRlQ2hpbGRJbmplY3RvcnNbY2FjaGVJZHhdIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21QYXJlbnRNb2R1bGVbbmFtZV0gPSBbIHByb3ZpZGVyWzJdLCBwcm92aWRlclsxXSBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXRjaGVkU2NvcGVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgocHJvdmlkZXJbMl0gPT09ICdmYWN0b3J5JyB8fCBwcm92aWRlclsyXSA9PT0gJ3R5cGUnKSAmJiBwcm92aWRlclsxXS4kc2NvcGUpIHtcbiAgICAgICAgICAvKiBqc2hpbnQgLVcwODMgKi9cbiAgICAgICAgICBmb3JjZU5ld0luc3RhbmNlcy5mb3JFYWNoKHNjb3BlID0+IHtcbiAgICAgICAgICAgIGlmIChwcm92aWRlclsxXS4kc2NvcGUuaW5kZXhPZihzY29wZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgIGZyb21QYXJlbnRNb2R1bGVbbmFtZV0gPSBbIHByb3ZpZGVyWzJdLCBwcm92aWRlclsxXSBdO1xuICAgICAgICAgICAgICBtYXRjaGVkU2NvcGVzW3Njb3BlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yY2VOZXdJbnN0YW5jZXMuZm9yRWFjaChzY29wZSA9PiB7XG4gICAgICAgIGlmICghbWF0Y2hlZFNjb3Blc1tzY29wZV0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHByb3ZpZGVyIGZvciBcIicgKyBzY29wZSArICdcIi4gQ2Fubm90IHVzZSBwcm92aWRlciBmcm9tIHRoZSBwYXJlbnQhJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBtb2R1bGVzLnVuc2hpZnQoZnJvbVBhcmVudE1vZHVsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBJbmplY3Rvcihtb2R1bGVzLCBzZWxmKTtcbiAgfVxuXG4gIGNvbnN0IGZhY3RvcnlNYXAgPSB7XG4gICAgZmFjdG9yeTogaW52b2tlLFxuICAgIHR5cGU6IGluc3RhbnRpYXRlLFxuICAgIHZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtNb2R1bGVEZWZpbml0aW9ufSBtb2R1bGVEZWZpbml0aW9uXG4gICAqIEBwYXJhbSB7SW5qZWN0b3J9IGluamVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVJbml0aWFsaXplcihtb2R1bGVEZWZpbml0aW9uLCBpbmplY3Rvcikge1xuXG4gICAgY29uc3QgaW5pdGlhbGl6ZXJzID0gbW9kdWxlRGVmaW5pdGlvbi5fX2luaXRfXyB8fCBbXTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGluaXRpYWxpemVycy5mb3JFYWNoKGluaXRpYWxpemVyID0+IHtcblxuICAgICAgICAvLyBlYWdlcmx5IHJlc29sdmUgY29tcG9uZW50IChmbiBvciBzdHJpbmcpXG4gICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbGl6ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaW5qZWN0b3IuZ2V0KGluaXRpYWxpemVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmplY3Rvci5pbnZva2UoaW5pdGlhbGl6ZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TW9kdWxlRGVmaW5pdGlvbn0gbW9kdWxlRGVmaW5pdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gbG9hZE1vZHVsZShtb2R1bGVEZWZpbml0aW9uKSB7XG5cbiAgICBjb25zdCBtb2R1bGVFeHBvcnRzID0gbW9kdWxlRGVmaW5pdGlvbi5fX2V4cG9ydHNfXztcblxuICAgIC8vIHByaXZhdGUgbW9kdWxlXG4gICAgaWYgKG1vZHVsZUV4cG9ydHMpIHtcbiAgICAgIGNvbnN0IG5lc3RlZE1vZHVsZXMgPSBtb2R1bGVEZWZpbml0aW9uLl9fbW9kdWxlc19fO1xuXG4gICAgICBjb25zdCBjbG9uZWRNb2R1bGUgPSBPYmplY3Qua2V5cyhtb2R1bGVEZWZpbml0aW9uKS5yZWR1Y2UoKGNsb25lZE1vZHVsZSwga2V5KSA9PiB7XG5cbiAgICAgICAgaWYgKGtleSAhPT0gJ19fZXhwb3J0c19fJyAmJiBrZXkgIT09ICdfX21vZHVsZXNfXycgJiYga2V5ICE9PSAnX19pbml0X18nICYmIGtleSAhPT0gJ19fZGVwZW5kc19fJykge1xuICAgICAgICAgIGNsb25lZE1vZHVsZVtrZXldID0gbW9kdWxlRGVmaW5pdGlvbltrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsb25lZE1vZHVsZTtcbiAgICAgIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG4gICAgICBjb25zdCBjaGlsZE1vZHVsZXMgPSAobmVzdGVkTW9kdWxlcyB8fCBbXSkuY29uY2F0KGNsb25lZE1vZHVsZSk7XG5cbiAgICAgIGNvbnN0IHByaXZhdGVJbmplY3RvciA9IGNyZWF0ZUNoaWxkKGNoaWxkTW9kdWxlcyk7XG4gICAgICBjb25zdCBnZXRGcm9tUHJpdmF0ZUluamVjdG9yID0gYW5ub3RhdGUoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlSW5qZWN0b3IuZ2V0KGtleSk7XG4gICAgICB9KTtcblxuICAgICAgbW9kdWxlRXhwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBwcm92aWRlcnNba2V5XSA9IFsgZ2V0RnJvbVByaXZhdGVJbmplY3Rvciwga2V5LCAncHJpdmF0ZScsIHByaXZhdGVJbmplY3RvciBdO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGVuc3VyZSBjaGlsZCBpbmplY3RvciBpbml0aWFsaXplc1xuICAgICAgY29uc3QgaW5pdGlhbGl6ZXJzID0gKG1vZHVsZURlZmluaXRpb24uX19pbml0X18gfHwgW10pLnNsaWNlKCk7XG5cbiAgICAgIGluaXRpYWxpemVycy51bnNoaWZ0KGZ1bmN0aW9uKCkge1xuICAgICAgICBwcml2YXRlSW5qZWN0b3IuaW5pdCgpO1xuICAgICAgfSk7XG5cbiAgICAgIG1vZHVsZURlZmluaXRpb24gPSBPYmplY3QuYXNzaWduKHt9LCBtb2R1bGVEZWZpbml0aW9uLCB7XG4gICAgICAgIF9faW5pdF9fOiBpbml0aWFsaXplcnNcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gY3JlYXRlSW5pdGlhbGl6ZXIobW9kdWxlRGVmaW5pdGlvbiwgcHJpdmF0ZUluamVjdG9yKTtcbiAgICB9XG5cbiAgICAvLyBub3JtYWwgbW9kdWxlXG4gICAgT2JqZWN0LmtleXMobW9kdWxlRGVmaW5pdGlvbikuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblxuICAgICAgaWYgKGtleSA9PT0gJ19faW5pdF9fJyB8fCBrZXkgPT09ICdfX2RlcGVuZHNfXycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0eXBlRGVjbGFyYXRpb24gPSAvKiogQHR5cGUgeyBUeXBlZERlY2xhcmF0aW9uIH0gKi8gKFxuICAgICAgICBtb2R1bGVEZWZpbml0aW9uW2tleV1cbiAgICAgICk7XG5cbiAgICAgIGlmICh0eXBlRGVjbGFyYXRpb25bMl0gPT09ICdwcml2YXRlJykge1xuICAgICAgICBwcm92aWRlcnNba2V5XSA9IHR5cGVEZWNsYXJhdGlvbjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0eXBlID0gdHlwZURlY2xhcmF0aW9uWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSB0eXBlRGVjbGFyYXRpb25bMV07XG5cbiAgICAgIHByb3ZpZGVyc1trZXldID0gWyBmYWN0b3J5TWFwW3R5cGVdLCBhcnJheVVud3JhcCh0eXBlLCB2YWx1ZSksIHR5cGUgXTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjcmVhdGVJbml0aWFsaXplcihtb2R1bGVEZWZpbml0aW9uLCBzZWxmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vZHVsZURlZmluaXRpb25bXX0gbW9kdWxlRGVmaW5pdGlvbnNcbiAgICogQHBhcmFtIHtNb2R1bGVEZWZpbml0aW9ufSBtb2R1bGVEZWZpbml0aW9uXG4gICAqXG4gICAqIEByZXR1cm4ge01vZHVsZURlZmluaXRpb25bXX1cbiAgICovXG4gIGZ1bmN0aW9uIHJlc29sdmVEZXBlbmRlbmNpZXMobW9kdWxlRGVmaW5pdGlvbnMsIG1vZHVsZURlZmluaXRpb24pIHtcblxuICAgIGlmIChtb2R1bGVEZWZpbml0aW9ucy5pbmRleE9mKG1vZHVsZURlZmluaXRpb24pICE9PSAtMSkge1xuICAgICAgcmV0dXJuIG1vZHVsZURlZmluaXRpb25zO1xuICAgIH1cblxuICAgIG1vZHVsZURlZmluaXRpb25zID0gKG1vZHVsZURlZmluaXRpb24uX19kZXBlbmRzX18gfHwgW10pLnJlZHVjZShyZXNvbHZlRGVwZW5kZW5jaWVzLCBtb2R1bGVEZWZpbml0aW9ucyk7XG5cbiAgICBpZiAobW9kdWxlRGVmaW5pdGlvbnMuaW5kZXhPZihtb2R1bGVEZWZpbml0aW9uKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBtb2R1bGVEZWZpbml0aW9ucztcbiAgICB9XG5cbiAgICByZXR1cm4gbW9kdWxlRGVmaW5pdGlvbnMuY29uY2F0KG1vZHVsZURlZmluaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TW9kdWxlRGVmaW5pdGlvbltdfSBtb2R1bGVEZWZpbml0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJuIHsgKCkgPT4gdm9pZCB9IGluaXRpYWxpemVyRm5cbiAgICovXG4gIGZ1bmN0aW9uIGJvb3RzdHJhcChtb2R1bGVEZWZpbml0aW9ucykge1xuXG4gICAgY29uc3QgaW5pdGlhbGl6ZXJzID0gbW9kdWxlRGVmaW5pdGlvbnNcbiAgICAgIC5yZWR1Y2UocmVzb2x2ZURlcGVuZGVuY2llcywgW10pXG4gICAgICAubWFwKGxvYWRNb2R1bGUpO1xuXG4gICAgbGV0IGluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmIChpbml0aWFsaXplZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgaW5pdGlhbGl6ZXJzLmZvckVhY2goaW5pdGlhbGl6ZXIgPT4gaW5pdGlhbGl6ZXIoKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHB1YmxpYyBBUElcbiAgdGhpcy5nZXQgPSBnZXQ7XG4gIHRoaXMuaW52b2tlID0gaW52b2tlO1xuICB0aGlzLmluc3RhbnRpYXRlID0gaW5zdGFudGlhdGU7XG4gIHRoaXMuY3JlYXRlQ2hpbGQgPSBjcmVhdGVDaGlsZDtcblxuICAvLyBzZXR1cFxuICB0aGlzLmluaXQgPSBib290c3RyYXAobW9kdWxlcyk7XG59XG5cblxuLy8gaGVscGVycyAvLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gYXJyYXlVbndyYXAodHlwZSwgdmFsdWUpIHtcbiAgaWYgKHR5cGUgIT09ICd2YWx1ZScgJiYgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IGFubm90YXRlKHZhbHVlLnNsaWNlKCkpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgeyBJbmplY3RvciwgYW5ub3RhdGUsIHBhcnNlQW5ub3RhdGlvbnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/didi/dist/index.js\n");

/***/ })

};
;