"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/moddle-xml";
exports.ids = ["vendor-chunks/moddle-xml"];
exports.modules = {

/***/ "(ssr)/../../node_modules/moddle-xml/dist/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/moddle-xml/dist/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Reader: () => (/* binding */ Reader),\n/* harmony export */   Writer: () => (/* binding */ Writer)\n/* harmony export */ });\n/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ \"(ssr)/../../node_modules/min-dash/dist/index.esm.js\");\n/* harmony import */ var saxen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! saxen */ \"(ssr)/../../node_modules/saxen/dist/index.js\");\n/* harmony import */ var moddle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! moddle */ \"(ssr)/../../node_modules/moddle/dist/index.js\");\n\n\n\n\nfunction hasLowerCaseAlias(pkg) {\n  return pkg.xml && pkg.xml.tagAlias === 'lowerCase';\n}\n\nvar DEFAULT_NS_MAP = {\n  'xsi': 'http://www.w3.org/2001/XMLSchema-instance',\n  'xml': 'http://www.w3.org/XML/1998/namespace'\n};\n\nvar SERIALIZE_PROPERTY = 'property';\n\nfunction getSerialization(element) {\n  return element.xml && element.xml.serialize;\n}\n\nfunction getSerializationType(element) {\n  const type = getSerialization(element);\n\n  return type !== SERIALIZE_PROPERTY && (type || null);\n}\n\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction aliasToName(aliasNs, pkg) {\n\n  if (!hasLowerCaseAlias(pkg)) {\n    return aliasNs.name;\n  }\n\n  return aliasNs.prefix + ':' + capitalize(aliasNs.localName);\n}\n\n/**\n * Un-prefix a potentially prefixed type name.\n *\n * @param {NsName} nameNs\n * @param {Object} [pkg]\n *\n * @return {string}\n */\nfunction prefixedToName(nameNs, pkg) {\n\n  var name = nameNs.name,\n      localName = nameNs.localName;\n\n  var typePrefix = pkg && pkg.xml && pkg.xml.typePrefix;\n\n  if (typePrefix && localName.indexOf(typePrefix) === 0) {\n    return nameNs.prefix + ':' + localName.slice(typePrefix.length);\n  } else {\n    return name;\n  }\n}\n\nfunction normalizeTypeName(name, nsMap, model) {\n\n  // normalize against actual NS\n  const nameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name, nsMap.xmlns);\n\n  const normalizedName = `${ nsMap[nameNs.prefix] || nameNs.prefix }:${ nameNs.localName }`;\n\n  const normalizedNameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(normalizedName);\n\n  // determine actual type name, based on package-defined prefix\n  var pkg = model.getPackage(normalizedNameNs.prefix);\n\n  return prefixedToName(normalizedNameNs, pkg);\n}\n\nfunction error(message) {\n  return new Error(message);\n}\n\n/**\n * Get the moddle descriptor for a given instance or type.\n *\n * @param  {ModdleElement|Function} element\n *\n * @return {Object} the moddle descriptor\n */\nfunction getModdleDescriptor(element) {\n  return element.$descriptor;\n}\n\n\n/**\n * A parse context.\n *\n * @class\n *\n * @param {Object} options\n * @param {ElementHandler} options.rootHandler the root handler for parsing a document\n * @param {boolean} [options.lax=false] whether or not to ignore invalid elements\n */\nfunction Context(options) {\n\n  /**\n   * @property {ElementHandler} rootHandler\n   */\n\n  /**\n   * @property {Boolean} lax\n   */\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(this, options);\n\n  this.elementsById = {};\n  this.references = [];\n  this.warnings = [];\n\n  /**\n   * Add an unresolved reference.\n   *\n   * @param {Object} reference\n   */\n  this.addReference = function(reference) {\n    this.references.push(reference);\n  };\n\n  /**\n   * Add a processed element.\n   *\n   * @param {ModdleElement} element\n   */\n  this.addElement = function(element) {\n\n    if (!element) {\n      throw error('expected element');\n    }\n\n    var elementsById = this.elementsById;\n\n    var descriptor = getModdleDescriptor(element);\n\n    var idProperty = descriptor.idProperty,\n        id;\n\n    if (idProperty) {\n      id = element.get(idProperty.name);\n\n      if (id) {\n\n        // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar\n        if (!/^([a-z][\\w-.]*:)?[a-z_][\\w-.]*$/i.test(id)) {\n          throw new Error('illegal ID <' + id + '>');\n        }\n\n        if (elementsById[id]) {\n          throw error('duplicate ID <' + id + '>');\n        }\n\n        elementsById[id] = element;\n      }\n    }\n  };\n\n  /**\n   * Add an import warning.\n   *\n   * @param {Object} warning\n   * @param {String} warning.message\n   * @param {Error} [warning.error]\n   */\n  this.addWarning = function(warning) {\n    this.warnings.push(warning);\n  };\n}\n\nfunction BaseHandler() {}\n\nBaseHandler.prototype.handleEnd = function() {};\nBaseHandler.prototype.handleText = function() {};\nBaseHandler.prototype.handleNode = function() {};\n\n\n/**\n * A simple pass through handler that does nothing except for\n * ignoring all input it receives.\n *\n * This is used to ignore unknown elements and\n * attributes.\n */\nfunction NoopHandler() { }\n\nNoopHandler.prototype = Object.create(BaseHandler.prototype);\n\nNoopHandler.prototype.handleNode = function() {\n  return this;\n};\n\nfunction BodyHandler() {}\n\nBodyHandler.prototype = Object.create(BaseHandler.prototype);\n\nBodyHandler.prototype.handleText = function(text) {\n  this.body = (this.body || '') + text;\n};\n\nfunction ReferenceHandler(property, context) {\n  this.property = property;\n  this.context = context;\n}\n\nReferenceHandler.prototype = Object.create(BodyHandler.prototype);\n\nReferenceHandler.prototype.handleNode = function(node) {\n\n  if (this.element) {\n    throw error('expected no sub nodes');\n  } else {\n    this.element = this.createReference(node);\n  }\n\n  return this;\n};\n\nReferenceHandler.prototype.handleEnd = function() {\n  this.element.id = this.body;\n};\n\nReferenceHandler.prototype.createReference = function(node) {\n  return {\n    property: this.property.ns.name,\n    id: ''\n  };\n};\n\nfunction ValueHandler(propertyDesc, element) {\n  this.element = element;\n  this.propertyDesc = propertyDesc;\n}\n\nValueHandler.prototype = Object.create(BodyHandler.prototype);\n\nValueHandler.prototype.handleEnd = function() {\n\n  var value = this.body || '',\n      element = this.element,\n      propertyDesc = this.propertyDesc;\n\n  value = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.coerceType)(propertyDesc.type, value);\n\n  if (propertyDesc.isMany) {\n    element.get(propertyDesc.name).push(value);\n  } else {\n    element.set(propertyDesc.name, value);\n  }\n};\n\n\nfunction BaseElementHandler() {}\n\nBaseElementHandler.prototype = Object.create(BodyHandler.prototype);\n\nBaseElementHandler.prototype.handleNode = function(node) {\n  var parser = this,\n      element = this.element;\n\n  if (!element) {\n    element = this.element = this.createElement(node);\n\n    this.context.addElement(element);\n  } else {\n    parser = this.handleChild(node);\n  }\n\n  return parser;\n};\n\n/**\n * @class Reader.ElementHandler\n *\n */\nfunction ElementHandler(model, typeName, context) {\n  this.model = model;\n  this.type = model.getType(typeName);\n  this.context = context;\n}\n\nElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\nElementHandler.prototype.addReference = function(reference) {\n  this.context.addReference(reference);\n};\n\nElementHandler.prototype.handleText = function(text) {\n\n  var element = this.element,\n      descriptor = getModdleDescriptor(element),\n      bodyProperty = descriptor.bodyProperty;\n\n  if (!bodyProperty) {\n    throw error('unexpected body text <' + text + '>');\n  }\n\n  BodyHandler.prototype.handleText.call(this, text);\n};\n\nElementHandler.prototype.handleEnd = function() {\n\n  var value = this.body,\n      element = this.element,\n      descriptor = getModdleDescriptor(element),\n      bodyProperty = descriptor.bodyProperty;\n\n  if (bodyProperty && value !== undefined) {\n    value = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.coerceType)(bodyProperty.type, value);\n    element.set(bodyProperty.name, value);\n  }\n};\n\n/**\n * Create an instance of the model from the given node.\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.createElement = function(node) {\n  var attributes = node.attributes,\n      Type = this.type,\n      descriptor = getModdleDescriptor(Type),\n      context = this.context,\n      instance = new Type({}),\n      model = this.model,\n      propNameNs;\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attributes, function(value, name) {\n\n    var prop = descriptor.propertiesByName[name],\n        values;\n\n    if (prop && prop.isReference) {\n\n      if (!prop.isMany) {\n        context.addReference({\n          element: instance,\n          property: prop.ns.name,\n          id: value\n        });\n      } else {\n\n        // IDREFS: parse references as whitespace-separated list\n        values = value.split(' ');\n\n        (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(values, function(v) {\n          context.addReference({\n            element: instance,\n            property: prop.ns.name,\n            id: v\n          });\n        });\n      }\n\n    } else {\n      if (prop) {\n        value = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.coerceType)(prop.type, value);\n      } else if (name === 'xmlns') {\n        name = ':' + name;\n      } else {\n        propNameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name, descriptor.ns.prefix);\n\n        // check whether attribute is defined in a well-known namespace\n        // if that is the case we emit a warning to indicate potential misuse\n        if (model.getPackage(propNameNs.prefix)) {\n\n          context.addWarning({\n            message: 'unknown attribute <' + name + '>',\n            element: instance,\n            property: name,\n            value: value\n          });\n        }\n      }\n\n      instance.set(name, value);\n    }\n  });\n\n  return instance;\n};\n\nElementHandler.prototype.getPropertyForNode = function(node) {\n\n  var name = node.name;\n  var nameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name);\n\n  var type = this.type,\n      model = this.model,\n      descriptor = getModdleDescriptor(type);\n\n  var propertyName = nameNs.name,\n      property = descriptor.propertiesByName[propertyName];\n\n  // search for properties by name first\n\n  if (property && !property.isAttr) {\n\n    const serializationType = getSerializationType(property);\n\n    if (serializationType) {\n      const elementTypeName = node.attributes[serializationType];\n\n      // type is optional, if it does not exists the\n      // default type is assumed\n      if (elementTypeName) {\n\n        // convert the prefix used to the mapped form, but also\n        // take possible type prefixes from XML\n        // into account, i.e.: xsi:type=\"t{ActualType}\",\n        const normalizedTypeName = normalizeTypeName(elementTypeName, node.ns, model);\n\n        const elementType = model.getType(normalizedTypeName);\n\n        return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({}, property, {\n          effectiveType: getModdleDescriptor(elementType).name\n        });\n      }\n    }\n\n    // search for properties by name first\n    return property;\n  }\n\n  var pkg = model.getPackage(nameNs.prefix);\n\n  if (pkg) {\n    const elementTypeName = aliasToName(nameNs, pkg);\n    const elementType = model.getType(elementTypeName);\n\n    // search for collection members later\n    property = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.find)(descriptor.properties, function(p) {\n      return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);\n    });\n\n    if (property) {\n      return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({}, property, {\n        effectiveType: getModdleDescriptor(elementType).name\n      });\n    }\n  } else {\n\n    // parse unknown element (maybe extension)\n    property = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.find)(descriptor.properties, function(p) {\n      return !p.isReference && !p.isAttribute && p.type === 'Element';\n    });\n\n    if (property) {\n      return property;\n    }\n  }\n\n  throw error('unrecognized element <' + nameNs.name + '>');\n};\n\nElementHandler.prototype.toString = function() {\n  return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';\n};\n\nElementHandler.prototype.valueHandler = function(propertyDesc, element) {\n  return new ValueHandler(propertyDesc, element);\n};\n\nElementHandler.prototype.referenceHandler = function(propertyDesc) {\n  return new ReferenceHandler(propertyDesc, this.context);\n};\n\nElementHandler.prototype.handler = function(type) {\n  if (type === 'Element') {\n    return new GenericElementHandler(this.model, type, this.context);\n  } else {\n    return new ElementHandler(this.model, type, this.context);\n  }\n};\n\n/**\n * Handle the child element parsing\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.handleChild = function(node) {\n  var propertyDesc, type, element, childHandler;\n\n  propertyDesc = this.getPropertyForNode(node);\n  element = this.element;\n\n  type = propertyDesc.effectiveType || propertyDesc.type;\n\n  if ((0,moddle__WEBPACK_IMPORTED_MODULE_1__.isSimpleType)(type)) {\n    return this.valueHandler(propertyDesc, element);\n  }\n\n  if (propertyDesc.isReference) {\n    childHandler = this.referenceHandler(propertyDesc).handleNode(node);\n  } else {\n    childHandler = this.handler(type).handleNode(node);\n  }\n\n  var newElement = childHandler.element;\n\n  // child handles may decide to skip elements\n  // by not returning anything\n  if (newElement !== undefined) {\n\n    if (propertyDesc.isMany) {\n      element.get(propertyDesc.name).push(newElement);\n    } else {\n      element.set(propertyDesc.name, newElement);\n    }\n\n    if (propertyDesc.isReference) {\n      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(newElement, {\n        element: element\n      });\n\n      this.context.addReference(newElement);\n    } else {\n\n      // establish child -> parent relationship\n      newElement.$parent = element;\n    }\n  }\n\n  return childHandler;\n};\n\n/**\n * An element handler that performs special validation\n * to ensure the node it gets initialized with matches\n * the handlers type (namespace wise).\n *\n * @param {Moddle} model\n * @param {String} typeName\n * @param {Context} context\n */\nfunction RootElementHandler(model, typeName, context) {\n  ElementHandler.call(this, model, typeName, context);\n}\n\nRootElementHandler.prototype = Object.create(ElementHandler.prototype);\n\nRootElementHandler.prototype.createElement = function(node) {\n\n  var name = node.name,\n      nameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name),\n      model = this.model,\n      type = this.type,\n      pkg = model.getPackage(nameNs.prefix),\n      typeName = pkg && aliasToName(nameNs, pkg) || name;\n\n  // verify the correct namespace if we parse\n  // the first element in the handler tree\n  //\n  // this ensures we don't mistakenly import wrong namespace elements\n  if (!type.hasType(typeName)) {\n    throw error('unexpected element <' + node.originalName + '>');\n  }\n\n  return ElementHandler.prototype.createElement.call(this, node);\n};\n\n\nfunction GenericElementHandler(model, typeName, context) {\n  this.model = model;\n  this.context = context;\n}\n\nGenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\nGenericElementHandler.prototype.createElement = function(node) {\n\n  var name = node.name,\n      ns = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name),\n      prefix = ns.prefix,\n      uri = node.ns[prefix + '$uri'],\n      attributes = node.attributes;\n\n  return this.model.createAny(name, uri, attributes);\n};\n\nGenericElementHandler.prototype.handleChild = function(node) {\n\n  var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),\n      element = this.element;\n\n  var newElement = handler.element,\n      children;\n\n  if (newElement !== undefined) {\n    children = element.$children = element.$children || [];\n    children.push(newElement);\n\n    // establish child -> parent relationship\n    newElement.$parent = element;\n  }\n\n  return handler;\n};\n\nGenericElementHandler.prototype.handleEnd = function() {\n  if (this.body) {\n    this.element.$body = this.body;\n  }\n};\n\n/**\n * A reader for a meta-model\n *\n * @param {Object} options\n * @param {Model} options.model used to read xml files\n * @param {Boolean} options.lax whether to make parse errors warnings\n */\nfunction Reader(options) {\n\n  if (options instanceof moddle__WEBPACK_IMPORTED_MODULE_1__.Moddle) {\n    options = {\n      model: options\n    };\n  }\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(this, { lax: false }, options);\n}\n\n/**\n * The fromXML result.\n *\n * @typedef {Object} ParseResult\n *\n * @property {ModdleElement} rootElement\n * @property {Array<Object>} references\n * @property {Array<Error>} warnings\n * @property {Object} elementsById - a mapping containing each ID -> ModdleElement\n */\n\n/**\n * The fromXML result.\n *\n * @typedef {Error} ParseError\n *\n * @property {Array<Error>} warnings\n */\n\n/**\n * Parse the given XML into a moddle document tree.\n *\n * @param {String} xml\n * @param {ElementHandler|Object} options or rootHandler\n *\n * @returns {Promise<ParseResult, ParseError>}\n */\nReader.prototype.fromXML = function(xml, options, done) {\n\n  var rootHandler = options.rootHandler;\n\n  if (options instanceof ElementHandler) {\n\n    // root handler passed via (xml, { rootHandler: ElementHandler }, ...)\n    rootHandler = options;\n    options = {};\n  } else {\n    if (typeof options === 'string') {\n\n      // rootHandler passed via (xml, 'someString', ...)\n      rootHandler = this.handler(options);\n      options = {};\n    } else if (typeof rootHandler === 'string') {\n\n      // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)\n      rootHandler = this.handler(rootHandler);\n    }\n  }\n\n  var model = this.model,\n      lax = this.lax;\n\n  var context = new Context((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({}, options, { rootHandler: rootHandler })),\n      parser = new saxen__WEBPACK_IMPORTED_MODULE_0__.Parser({ proxy: true }),\n      stack = createStack();\n\n  rootHandler.context = context;\n\n  // push root handler\n  stack.push(rootHandler);\n\n\n  /**\n   * Handle error.\n   *\n   * @param  {Error} err\n   * @param  {Function} getContext\n   * @param  {boolean} lax\n   *\n   * @return {boolean} true if handled\n   */\n  function handleError(err, getContext, lax) {\n\n    var ctx = getContext();\n\n    var line = ctx.line,\n        column = ctx.column,\n        data = ctx.data;\n\n    // we receive the full context data here,\n    // for elements trim down the information\n    // to the tag name, only\n    if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {\n      data = data.slice(0, data.indexOf(' ')) + '>';\n    }\n\n    var message =\n      'unparsable content ' + (data ? data + ' ' : '') + 'detected\\n\\t' +\n        'line: ' + line + '\\n\\t' +\n        'column: ' + column + '\\n\\t' +\n        'nested error: ' + err.message;\n\n    if (lax) {\n      context.addWarning({\n        message: message,\n        error: err\n      });\n\n      return true;\n    } else {\n      throw error(message);\n    }\n  }\n\n  function handleWarning(err, getContext) {\n\n    // just like handling errors in <lax=true> mode\n    return handleError(err, getContext, true);\n  }\n\n  /**\n   * Resolve collected references on parse end.\n   */\n  function resolveReferences() {\n\n    var elementsById = context.elementsById;\n    var references = context.references;\n\n    var i, r;\n\n    for (i = 0; (r = references[i]); i++) {\n      var element = r.element;\n      var reference = elementsById[r.id];\n      var property = getModdleDescriptor(element).propertiesByName[r.property];\n\n      if (!reference) {\n        context.addWarning({\n          message: 'unresolved reference <' + r.id + '>',\n          element: r.element,\n          property: r.property,\n          value: r.id\n        });\n      }\n\n      if (property.isMany) {\n        var collection = element.get(property.name),\n            idx = collection.indexOf(r);\n\n        // we replace an existing place holder (idx != -1) or\n        // append to the collection instead\n        if (idx === -1) {\n          idx = collection.length;\n        }\n\n        if (!reference) {\n\n          // remove unresolvable reference\n          collection.splice(idx, 1);\n        } else {\n\n          // add or update reference in collection\n          collection[idx] = reference;\n        }\n      } else {\n        element.set(property.name, reference);\n      }\n    }\n  }\n\n  function handleClose() {\n    stack.pop().handleEnd();\n  }\n\n  var PREAMBLE_START_PATTERN = /^<\\?xml /i;\n\n  var ENCODING_PATTERN = / encoding=\"([^\"]+)\"/i;\n\n  var UTF_8_PATTERN = /^utf-8$/i;\n\n  function handleQuestion(question) {\n\n    if (!PREAMBLE_START_PATTERN.test(question)) {\n      return;\n    }\n\n    var match = ENCODING_PATTERN.exec(question);\n    var encoding = match && match[1];\n\n    if (!encoding || UTF_8_PATTERN.test(encoding)) {\n      return;\n    }\n\n    context.addWarning({\n      message:\n        'unsupported document encoding <' + encoding + '>, ' +\n        'falling back to UTF-8'\n    });\n  }\n\n  function handleOpen(node, getContext) {\n    var handler = stack.peek();\n\n    try {\n      stack.push(handler.handleNode(node));\n    } catch (err) {\n\n      if (handleError(err, getContext, lax)) {\n        stack.push(new NoopHandler());\n      }\n    }\n  }\n\n  function handleCData(text, getContext) {\n\n    try {\n      stack.peek().handleText(text);\n    } catch (err) {\n      handleWarning(err, getContext);\n    }\n  }\n\n  function handleText(text, getContext) {\n\n    // strip whitespace only nodes, i.e. before\n    // <!CDATA[ ... ]> sections and in between tags\n\n    if (!text.trim()) {\n      return;\n    }\n\n    handleCData(text, getContext);\n  }\n\n  var uriMap = model.getPackages().reduce(function(uriMap, p) {\n    uriMap[p.uri] = p.prefix;\n\n    return uriMap;\n  }, Object.entries(DEFAULT_NS_MAP).reduce(function(map, [ prefix, url ]) {\n    map[url] = prefix;\n\n    return map;\n  }, model.config && model.config.nsMap || {}));\n\n  parser\n    .ns(uriMap)\n    .on('openTag', function(obj, decodeStr, selfClosing, getContext) {\n\n      // gracefully handle unparsable attributes (attrs=false)\n      var attrs = obj.attrs || {};\n\n      var decodedAttrs = Object.keys(attrs).reduce(function(d, key) {\n        var value = decodeStr(attrs[key]);\n\n        d[key] = value;\n\n        return d;\n      }, {});\n\n      var node = {\n        name: obj.name,\n        originalName: obj.originalName,\n        attributes: decodedAttrs,\n        ns: obj.ns\n      };\n\n      handleOpen(node, getContext);\n    })\n    .on('question', handleQuestion)\n    .on('closeTag', handleClose)\n    .on('cdata', handleCData)\n    .on('text', function(text, decodeEntities, getContext) {\n      handleText(decodeEntities(text), getContext);\n    })\n    .on('error', handleError)\n    .on('warn', handleWarning);\n\n  // async XML parsing to make sure the execution environment\n  // (node or brower) is kept responsive and that certain optimization\n  // strategies can kick in.\n  return new Promise(function(resolve, reject) {\n\n    var err;\n\n    try {\n      parser.parse(xml);\n\n      resolveReferences();\n    } catch (e) {\n      err = e;\n    }\n\n    var rootElement = rootHandler.element;\n\n    if (!err && !rootElement) {\n      err = error('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');\n    }\n\n    var warnings = context.warnings;\n    var references = context.references;\n    var elementsById = context.elementsById;\n\n    if (err) {\n      err.warnings = warnings;\n\n      return reject(err);\n    } else {\n      return resolve({\n        rootElement: rootElement,\n        elementsById: elementsById,\n        references: references,\n        warnings: warnings\n      });\n    }\n  });\n};\n\nReader.prototype.handler = function(name) {\n  return new RootElementHandler(this.model, name);\n};\n\n\n// helpers //////////////////////////\n\nfunction createStack() {\n  var stack = [];\n\n  Object.defineProperty(stack, 'peek', {\n    value: function() {\n      return this[this.length - 1];\n    }\n  });\n\n  return stack;\n}\n\nvar XML_PREAMBLE = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n\nvar ESCAPE_ATTR_CHARS = /<|>|'|\"|&|\\n\\r|\\n/g;\nvar ESCAPE_CHARS = /<|>|&/g;\n\n\nfunction Namespaces(parent) {\n\n  this.prefixMap = {};\n  this.uriMap = {};\n  this.used = {};\n\n  this.wellknown = [];\n  this.custom = [];\n  this.parent = parent;\n\n  this.defaultPrefixMap = parent && parent.defaultPrefixMap || {};\n}\n\nNamespaces.prototype.mapDefaultPrefixes = function(defaultPrefixMap) {\n  this.defaultPrefixMap = defaultPrefixMap;\n};\n\nNamespaces.prototype.defaultUriByPrefix = function(prefix) {\n  return this.defaultPrefixMap[prefix];\n};\n\nNamespaces.prototype.byUri = function(uri) {\n  return this.uriMap[uri] || (\n    this.parent && this.parent.byUri(uri)\n  );\n};\n\nNamespaces.prototype.add = function(ns, isWellknown) {\n\n  this.uriMap[ns.uri] = ns;\n\n  if (isWellknown) {\n    this.wellknown.push(ns);\n  } else {\n    this.custom.push(ns);\n  }\n\n  this.mapPrefix(ns.prefix, ns.uri);\n};\n\nNamespaces.prototype.uriByPrefix = function(prefix) {\n  return this.prefixMap[prefix || 'xmlns'] || (\n    this.parent && this.parent.uriByPrefix(prefix)\n  );\n};\n\nNamespaces.prototype.mapPrefix = function(prefix, uri) {\n  this.prefixMap[prefix || 'xmlns'] = uri;\n};\n\nNamespaces.prototype.getNSKey = function(ns) {\n  return (ns.prefix !== undefined) ? (ns.uri + '|' + ns.prefix) : ns.uri;\n};\n\nNamespaces.prototype.logUsed = function(ns) {\n\n  var uri = ns.uri;\n  var nsKey = this.getNSKey(ns);\n\n  this.used[nsKey] = this.byUri(uri);\n\n  // Inform parent recursively about the usage of this NS\n  if (this.parent) {\n    this.parent.logUsed(ns);\n  }\n};\n\nNamespaces.prototype.getUsed = function(ns) {\n\n  var allNs = [].concat(this.wellknown, this.custom);\n\n  return allNs.filter(ns => {\n    var nsKey = this.getNSKey(ns);\n\n    return this.used[nsKey];\n  });\n};\n\n\nfunction lower(string) {\n  return string.charAt(0).toLowerCase() + string.slice(1);\n}\n\nfunction nameToAlias(name, pkg) {\n  if (hasLowerCaseAlias(pkg)) {\n    return lower(name);\n  } else {\n    return name;\n  }\n}\n\nfunction inherits(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction nsName(ns) {\n  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isString)(ns)) {\n    return ns;\n  } else {\n    return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;\n  }\n}\n\nfunction getNsAttrs(namespaces) {\n\n  return namespaces.getUsed().filter(function(ns) {\n\n    // do not serialize built in <xml> namespace\n    return ns.prefix !== 'xml';\n  }).map(function(ns) {\n    var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');\n    return { name: name, value: ns.uri };\n  });\n\n}\n\nfunction getElementNs(ns, descriptor) {\n  if (descriptor.isGeneric) {\n    return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ localName: descriptor.ns.localName }, ns);\n  } else {\n    return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns);\n  }\n}\n\nfunction getPropertyNs(ns, descriptor) {\n  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ localName: descriptor.ns.localName }, ns);\n}\n\nfunction getSerializableProperties(element) {\n  var descriptor = element.$descriptor;\n\n  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(descriptor.properties, function(p) {\n    var name = p.name;\n\n    if (p.isVirtual) {\n      return false;\n    }\n\n    // do not serialize defaults\n    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_2__.has)(element, name)) {\n      return false;\n    }\n\n    var value = element[name];\n\n    // do not serialize default equals\n    if (value === p.default) {\n      return false;\n    }\n\n    // do not serialize null properties\n    if (value === null) {\n      return false;\n    }\n\n    return p.isMany ? value.length : true;\n  });\n}\n\nvar ESCAPE_ATTR_MAP = {\n  '\\n': '#10',\n  '\\n\\r': '#10',\n  '\"': '#34',\n  '\\'': '#39',\n  '<': '#60',\n  '>': '#62',\n  '&': '#38'\n};\n\nvar ESCAPE_MAP = {\n  '<': 'lt',\n  '>': 'gt',\n  '&': 'amp'\n};\n\nfunction escape(str, charPattern, replaceMap) {\n\n  // ensure we are handling strings here\n  str = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isString)(str) ? str : '' + str;\n\n  return str.replace(charPattern, function(s) {\n    return '&' + replaceMap[s] + ';';\n  });\n}\n\n/**\n * Escape a string attribute to not contain any bad values (line breaks, '\"', ...)\n *\n * @param {String} str the string to escape\n * @return {String} the escaped string\n */\nfunction escapeAttr(str) {\n  return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);\n}\n\nfunction escapeBody(str) {\n  return escape(str, ESCAPE_CHARS, ESCAPE_MAP);\n}\n\nfunction filterAttributes(props) {\n  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(props, function(p) { return p.isAttr; });\n}\n\nfunction filterContained(props) {\n  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(props, function(p) { return !p.isAttr; });\n}\n\n\nfunction ReferenceSerializer(tagName) {\n  this.tagName = tagName;\n}\n\nReferenceSerializer.prototype.build = function(element) {\n  this.element = element;\n  return this;\n};\n\nReferenceSerializer.prototype.serializeTo = function(writer) {\n  writer\n    .appendIndent()\n    .append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>')\n    .appendNewLine();\n};\n\nfunction BodySerializer() {}\n\nBodySerializer.prototype.serializeValue =\nBodySerializer.prototype.serializeTo = function(writer) {\n  writer.append(\n    this.escape\n      ? escapeBody(this.value)\n      : this.value\n  );\n};\n\nBodySerializer.prototype.build = function(prop, value) {\n  this.value = value;\n\n  if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {\n    this.escape = true;\n  }\n\n  return this;\n};\n\nfunction ValueSerializer(tagName) {\n  this.tagName = tagName;\n}\n\ninherits(ValueSerializer, BodySerializer);\n\nValueSerializer.prototype.serializeTo = function(writer) {\n\n  writer\n    .appendIndent()\n    .append('<' + this.tagName + '>');\n\n  this.serializeValue(writer);\n\n  writer\n    .append('</' + this.tagName + '>')\n    .appendNewLine();\n};\n\nfunction ElementSerializer(parent, propertyDescriptor) {\n  this.body = [];\n  this.attrs = [];\n\n  this.parent = parent;\n  this.propertyDescriptor = propertyDescriptor;\n}\n\nElementSerializer.prototype.build = function(element) {\n  this.element = element;\n\n  var elementDescriptor = element.$descriptor,\n      propertyDescriptor = this.propertyDescriptor;\n\n  var otherAttrs,\n      properties;\n\n  var isGeneric = elementDescriptor.isGeneric;\n\n  if (isGeneric) {\n    otherAttrs = this.parseGenericNsAttributes(element);\n  } else {\n    otherAttrs = this.parseNsAttributes(element);\n  }\n\n  if (propertyDescriptor) {\n    this.ns = this.nsPropertyTagName(propertyDescriptor);\n  } else {\n    this.ns = this.nsTagName(elementDescriptor);\n  }\n\n  // compute tag name\n  this.tagName = this.addTagName(this.ns);\n\n  if (isGeneric) {\n    this.parseGenericContainments(element);\n  } else {\n    properties = getSerializableProperties(element);\n\n    this.parseAttributes(filterAttributes(properties));\n    this.parseContainments(filterContained(properties));\n  }\n\n  this.parseGenericAttributes(element, otherAttrs);\n\n  return this;\n};\n\nElementSerializer.prototype.nsTagName = function(descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getElementNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.nsPropertyTagName = function(descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getPropertyNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.isLocalNs = function(ns) {\n  return ns.uri === this.ns.uri;\n};\n\n/**\n * Get the actual ns attribute name for the given element.\n *\n * @param {Object} element\n * @param {Boolean} [element.inherited=false]\n *\n * @return {Object} nsName\n */\nElementSerializer.prototype.nsAttributeName = function(element) {\n\n  var ns;\n\n  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isString)(element)) {\n    ns = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(element);\n  } else {\n    ns = element.ns;\n  }\n\n  // return just local name for inherited attributes\n  if (element.inherited) {\n    return { localName: ns.localName };\n  }\n\n  // parse + log effective ns\n  var effectiveNs = this.logNamespaceUsed(ns);\n\n  // LOG ACTUAL namespace use\n  this.getNamespaces().logUsed(effectiveNs);\n\n  // strip prefix if same namespace like parent\n  if (this.isLocalNs(effectiveNs)) {\n    return { localName: ns.localName };\n  } else {\n    return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ localName: ns.localName }, effectiveNs);\n  }\n};\n\nElementSerializer.prototype.parseGenericNsAttributes = function(element) {\n\n  return Object.entries(element).filter(\n    ([ key, value ]) => !key.startsWith('$') && this.parseNsAttribute(element, key, value)\n  ).map(\n    ([ key, value ]) => ({ name: key, value: value })\n  );\n};\n\nElementSerializer.prototype.parseGenericContainments = function(element) {\n  var body = element.$body;\n\n  if (body) {\n    this.body.push(new BodySerializer().build({ type: 'String' }, body));\n  }\n\n  var children = element.$children;\n\n  if (children) {\n    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(children, child => {\n      this.body.push(new ElementSerializer(this).build(child));\n    });\n  }\n};\n\nElementSerializer.prototype.parseNsAttribute = function(element, name, value) {\n  var model = element.$model;\n\n  var nameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name);\n\n  var ns;\n\n  // parse xmlns:foo=\"http://foo.bar\"\n  if (nameNs.prefix === 'xmlns') {\n    ns = { prefix: nameNs.localName, uri: value };\n  }\n\n  // parse xmlns=\"http://foo.bar\"\n  if (!nameNs.prefix && nameNs.localName === 'xmlns') {\n    ns = { uri: value };\n  }\n\n  if (!ns) {\n    return {\n      name: name,\n      value: value\n    };\n  }\n\n  if (model && model.getPackage(value)) {\n\n    // register well known namespace\n    this.logNamespace(ns, true, true);\n  } else {\n\n    // log custom namespace directly as used\n    var actualNs = this.logNamespaceUsed(ns, true);\n\n    this.getNamespaces().logUsed(actualNs);\n  }\n};\n\n\n/**\n * Parse namespaces and return a list of left over generic attributes\n *\n * @param  {Object} element\n * @return {Array<Object>}\n */\nElementSerializer.prototype.parseNsAttributes = function(element) {\n  var self = this;\n\n  var genericAttrs = element.$attrs;\n\n  var attributes = [];\n\n  // parse namespace attributes first\n  // and log them. push non namespace attributes to a list\n  // and process them later\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(genericAttrs, function(value, name) {\n\n    var nonNsAttr = self.parseNsAttribute(element, name, value);\n\n    if (nonNsAttr) {\n      attributes.push(nonNsAttr);\n    }\n  });\n\n  return attributes;\n};\n\nElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {\n\n  var self = this;\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attributes, function(attr) {\n\n    try {\n      self.addAttribute(self.nsAttributeName(attr.name), attr.value);\n    } catch (e) {\n\n      // eslint-disable-next-line no-undef\n      typeof console !== 'undefined' && console.warn(\n        `missing namespace information for <${\n          attr.name\n        }=${ attr.value }> on`, element, e\n      );\n    }\n  });\n};\n\nElementSerializer.prototype.parseContainments = function(properties) {\n\n  var self = this,\n      body = this.body,\n      element = this.element;\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(properties, function(p) {\n    var value = element.get(p.name),\n        isReference = p.isReference,\n        isMany = p.isMany;\n\n    if (!isMany) {\n      value = [ value ];\n    }\n\n    if (p.isBody) {\n      body.push(new BodySerializer().build(p, value[0]));\n    } else if ((0,moddle__WEBPACK_IMPORTED_MODULE_1__.isSimpleType)(p.type)) {\n      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(value, function(v) {\n        body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));\n      });\n    } else if (isReference) {\n      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(value, function(v) {\n        body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));\n      });\n    } else {\n\n      // allow serialization via type\n      // rather than element name\n      var serialization = getSerialization(p);\n\n      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(value, function(v) {\n        var serializer;\n\n        if (serialization) {\n          if (serialization === SERIALIZE_PROPERTY) {\n            serializer = new ElementSerializer(self, p);\n          } else {\n            serializer = new TypeSerializer(self, p, serialization);\n          }\n        } else {\n          serializer = new ElementSerializer(self);\n        }\n\n        body.push(serializer.build(v));\n      });\n    }\n  });\n};\n\nElementSerializer.prototype.getNamespaces = function(local) {\n\n  var namespaces = this.namespaces,\n      parent = this.parent,\n      parentNamespaces;\n\n  if (!namespaces) {\n    parentNamespaces = parent && parent.getNamespaces();\n\n    if (local || !parentNamespaces) {\n      this.namespaces = namespaces = new Namespaces(parentNamespaces);\n    } else {\n      namespaces = parentNamespaces;\n    }\n  }\n\n  return namespaces;\n};\n\nElementSerializer.prototype.logNamespace = function(ns, wellknown, local) {\n  var namespaces = this.getNamespaces(local);\n\n  var nsUri = ns.uri,\n      nsPrefix = ns.prefix;\n\n  var existing = namespaces.byUri(nsUri);\n\n  if (!existing || local) {\n    namespaces.add(ns, wellknown);\n  }\n\n  namespaces.mapPrefix(nsPrefix, nsUri);\n\n  return ns;\n};\n\nElementSerializer.prototype.logNamespaceUsed = function(ns, local) {\n  var namespaces = this.getNamespaces(local);\n\n  // ns may be\n  //\n  //   * prefix only\n  //   * prefix:uri\n  //   * localName only\n\n  var prefix = ns.prefix,\n      uri = ns.uri,\n      newPrefix, idx,\n      wellknownUri;\n\n  // handle anonymous namespaces (elementForm=unqualified), cf. #23\n  if (!prefix && !uri) {\n    return { localName: ns.localName };\n  }\n\n  wellknownUri = namespaces.defaultUriByPrefix(prefix);\n\n  uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);\n\n  if (!uri) {\n    throw new Error('no namespace uri given for prefix <' + prefix + '>');\n  }\n\n  ns = namespaces.byUri(uri);\n\n  // register new default prefix <xmlns> in local scope\n  if (!ns && !prefix) {\n    ns = this.logNamespace({ uri }, wellknownUri === uri, true);\n  }\n\n  if (!ns) {\n    newPrefix = prefix;\n    idx = 1;\n\n    // find a prefix that is not mapped yet\n    while (namespaces.uriByPrefix(newPrefix)) {\n      newPrefix = prefix + '_' + idx++;\n    }\n\n    ns = this.logNamespace({ prefix: newPrefix, uri: uri }, wellknownUri === uri);\n  }\n\n  if (prefix) {\n    namespaces.mapPrefix(prefix, uri);\n  }\n\n  return ns;\n};\n\nElementSerializer.prototype.parseAttributes = function(properties) {\n  var self = this,\n      element = this.element;\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(properties, function(p) {\n\n    var value = element.get(p.name);\n\n    if (p.isReference) {\n\n      if (!p.isMany) {\n        value = value.id;\n      } else {\n        var values = [];\n        (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(value, function(v) {\n          values.push(v.id);\n        });\n\n        // IDREFS is a whitespace-separated list of references.\n        value = values.join(' ');\n      }\n\n    }\n\n    self.addAttribute(self.nsAttributeName(p), value);\n  });\n};\n\nElementSerializer.prototype.addTagName = function(nsTagName) {\n  var actualNs = this.logNamespaceUsed(nsTagName);\n\n  this.getNamespaces().logUsed(actualNs);\n\n  return nsName(nsTagName);\n};\n\nElementSerializer.prototype.addAttribute = function(name, value) {\n  var attrs = this.attrs;\n\n  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isString)(value)) {\n    value = escapeAttr(value);\n  }\n\n  // de-duplicate attributes\n  // https://github.com/bpmn-io/moddle-xml/issues/66\n  var idx = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.findIndex)(attrs, function(element) {\n    return (\n      element.name.localName === name.localName &&\n      element.name.uri === name.uri &&\n      element.name.prefix === name.prefix\n    );\n  });\n\n  var attr = { name: name, value: value };\n\n  if (idx !== -1) {\n    attrs.splice(idx, 1, attr);\n  } else {\n    attrs.push(attr);\n  }\n};\n\nElementSerializer.prototype.serializeAttributes = function(writer) {\n  var attrs = this.attrs,\n      namespaces = this.namespaces;\n\n  if (namespaces) {\n    attrs = getNsAttrs(namespaces).concat(attrs);\n  }\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attrs, function(a) {\n    writer\n      .append(' ')\n      .append(nsName(a.name)).append('=\"').append(a.value).append('\"');\n  });\n};\n\nElementSerializer.prototype.serializeTo = function(writer) {\n  var firstBody = this.body[0],\n      indent = firstBody && firstBody.constructor !== BodySerializer;\n\n  writer\n    .appendIndent()\n    .append('<' + this.tagName);\n\n  this.serializeAttributes(writer);\n\n  writer.append(firstBody ? '>' : ' />');\n\n  if (firstBody) {\n\n    if (indent) {\n      writer\n        .appendNewLine()\n        .indent();\n    }\n\n    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(this.body, function(b) {\n      b.serializeTo(writer);\n    });\n\n    if (indent) {\n      writer\n        .unindent()\n        .appendIndent();\n    }\n\n    writer.append('</' + this.tagName + '>');\n  }\n\n  writer.appendNewLine();\n};\n\n/**\n * A serializer for types that handles serialization of data types\n */\nfunction TypeSerializer(parent, propertyDescriptor, serialization) {\n  ElementSerializer.call(this, parent, propertyDescriptor);\n\n  this.serialization = serialization;\n}\n\ninherits(TypeSerializer, ElementSerializer);\n\nTypeSerializer.prototype.parseNsAttributes = function(element) {\n\n  // extracted attributes with serialization attribute\n  // <type=typeName> stripped; it may be later\n  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element).filter(\n    attr => attr.name !== this.serialization\n  );\n\n  var descriptor = element.$descriptor;\n\n  // only serialize <type=typeName> if necessary\n  if (descriptor.name === this.propertyDescriptor.type) {\n    return attributes;\n  }\n\n  var typeNs = this.typeNs = this.nsTagName(descriptor);\n  this.getNamespaces().logUsed(this.typeNs);\n\n  // add xsi:type attribute to represent the elements\n  // actual type\n\n  var pkg = element.$model.getPackage(typeNs.uri),\n      typePrefix = (pkg.xml && pkg.xml.typePrefix) || '';\n\n  this.addAttribute(\n    this.nsAttributeName(this.serialization),\n    (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName\n  );\n\n  return attributes;\n};\n\nTypeSerializer.prototype.isLocalNs = function(ns) {\n  return ns.uri === (this.typeNs || this.ns).uri;\n};\n\nfunction SavingWriter() {\n  this.value = '';\n\n  this.write = function(str) {\n    this.value += str;\n  };\n}\n\nfunction FormatingWriter(out, format) {\n\n  var indent = [ '' ];\n\n  this.append = function(str) {\n    out.write(str);\n\n    return this;\n  };\n\n  this.appendNewLine = function() {\n    if (format) {\n      out.write('\\n');\n    }\n\n    return this;\n  };\n\n  this.appendIndent = function() {\n    if (format) {\n      out.write(indent.join('  '));\n    }\n\n    return this;\n  };\n\n  this.indent = function() {\n    indent.push('');\n    return this;\n  };\n\n  this.unindent = function() {\n    indent.pop();\n    return this;\n  };\n}\n\n/**\n * A writer for meta-model backed document trees\n *\n * @param {Object} options output options to pass into the writer\n */\nfunction Writer(options) {\n\n  options = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ format: false, preamble: true }, options || {});\n\n  function toXML(tree, writer) {\n    var internalWriter = writer || new SavingWriter();\n    var formatingWriter = new FormatingWriter(internalWriter, options.format);\n\n    if (options.preamble) {\n      formatingWriter.append(XML_PREAMBLE);\n    }\n\n    var serializer = new ElementSerializer();\n\n    var model = tree.$model;\n\n    serializer.getNamespaces().mapDefaultPrefixes(getDefaultPrefixMappings(model));\n\n    serializer.build(tree).serializeTo(formatingWriter);\n\n    if (!writer) {\n      return internalWriter.value;\n    }\n  }\n\n  return {\n    toXML: toXML\n  };\n}\n\n\n// helpers ///////////\n\n/**\n * @param {Moddle} model\n *\n * @return { Record<string, string> } map from prefix to URI\n */\nfunction getDefaultPrefixMappings(model) {\n\n  const nsMap = model.config && model.config.nsMap || {};\n\n  const prefixMap = {};\n\n  // { prefix -> uri }\n  for (const prefix in DEFAULT_NS_MAP) {\n    prefixMap[prefix] = DEFAULT_NS_MAP[prefix];\n  }\n\n  // { uri -> prefix }\n  for (const uri in nsMap) {\n    const prefix = nsMap[uri];\n\n    prefixMap[prefix] = uri;\n  }\n\n  for (const pkg of model.getPackages()) {\n    prefixMap[pkg.prefix] = pkg.uri;\n  }\n\n  return prefixMap;\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL21vZGRsZS14bWwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFtRjtBQUNwRDtBQUN3Qzs7QUFFdkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLG1EQUFXOztBQUU1Qiw2QkFBNkIsdUNBQXVDLElBQUksa0JBQWtCOztBQUUxRiwyQkFBMkIsbURBQVc7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDOztBQUVBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7O0FBRUEsRUFBRSxnREFBTTs7QUFFUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxHQUFHLDBDQUEwQzs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU8sSUFBSTs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FB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QTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBLFlBQVksZ0RBQU0sR0FBRywrQkFBK0IsZUFBZTs7QUFFbkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFkZHJhLXdlYi8uLi8uLi9ub2RlX21vZHVsZXMvbW9kZGxlLXhtbC9kaXN0L2luZGV4LmpzPzg4YTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9yRWFjaCwgYXNzaWduLCBmaW5kLCBpc1N0cmluZywgZmluZEluZGV4LCBmaWx0ZXIsIGhhcyB9IGZyb20gJ21pbi1kYXNoJztcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gJ3NheGVuJztcbmltcG9ydCB7IGNvZXJjZVR5cGUsIHBhcnNlTmFtZU5TLCBpc1NpbXBsZVR5cGUsIE1vZGRsZSB9IGZyb20gJ21vZGRsZSc7XG5cbmZ1bmN0aW9uIGhhc0xvd2VyQ2FzZUFsaWFzKHBrZykge1xuICByZXR1cm4gcGtnLnhtbCAmJiBwa2cueG1sLnRhZ0FsaWFzID09PSAnbG93ZXJDYXNlJztcbn1cblxudmFyIERFRkFVTFRfTlNfTUFQID0ge1xuICAneHNpJzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hLWluc3RhbmNlJyxcbiAgJ3htbCc6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG59O1xuXG52YXIgU0VSSUFMSVpFX1BST1BFUlRZID0gJ3Byb3BlcnR5JztcblxuZnVuY3Rpb24gZ2V0U2VyaWFsaXphdGlvbihlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LnhtbCAmJiBlbGVtZW50LnhtbC5zZXJpYWxpemU7XG59XG5cbmZ1bmN0aW9uIGdldFNlcmlhbGl6YXRpb25UeXBlKGVsZW1lbnQpIHtcbiAgY29uc3QgdHlwZSA9IGdldFNlcmlhbGl6YXRpb24oZWxlbWVudCk7XG5cbiAgcmV0dXJuIHR5cGUgIT09IFNFUklBTElaRV9QUk9QRVJUWSAmJiAodHlwZSB8fCBudWxsKTtcbn1cblxuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cblxuZnVuY3Rpb24gYWxpYXNUb05hbWUoYWxpYXNOcywgcGtnKSB7XG5cbiAgaWYgKCFoYXNMb3dlckNhc2VBbGlhcyhwa2cpKSB7XG4gICAgcmV0dXJuIGFsaWFzTnMubmFtZTtcbiAgfVxuXG4gIHJldHVybiBhbGlhc05zLnByZWZpeCArICc6JyArIGNhcGl0YWxpemUoYWxpYXNOcy5sb2NhbE5hbWUpO1xufVxuXG4vKipcbiAqIFVuLXByZWZpeCBhIHBvdGVudGlhbGx5IHByZWZpeGVkIHR5cGUgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge05zTmFtZX0gbmFtZU5zXG4gKiBAcGFyYW0ge09iamVjdH0gW3BrZ11cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHByZWZpeGVkVG9OYW1lKG5hbWVOcywgcGtnKSB7XG5cbiAgdmFyIG5hbWUgPSBuYW1lTnMubmFtZSxcbiAgICAgIGxvY2FsTmFtZSA9IG5hbWVOcy5sb2NhbE5hbWU7XG5cbiAgdmFyIHR5cGVQcmVmaXggPSBwa2cgJiYgcGtnLnhtbCAmJiBwa2cueG1sLnR5cGVQcmVmaXg7XG5cbiAgaWYgKHR5cGVQcmVmaXggJiYgbG9jYWxOYW1lLmluZGV4T2YodHlwZVByZWZpeCkgPT09IDApIHtcbiAgICByZXR1cm4gbmFtZU5zLnByZWZpeCArICc6JyArIGxvY2FsTmFtZS5zbGljZSh0eXBlUHJlZml4Lmxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVHlwZU5hbWUobmFtZSwgbnNNYXAsIG1vZGVsKSB7XG5cbiAgLy8gbm9ybWFsaXplIGFnYWluc3QgYWN0dWFsIE5TXG4gIGNvbnN0IG5hbWVOcyA9IHBhcnNlTmFtZU5TKG5hbWUsIG5zTWFwLnhtbG5zKTtcblxuICBjb25zdCBub3JtYWxpemVkTmFtZSA9IGAkeyBuc01hcFtuYW1lTnMucHJlZml4XSB8fCBuYW1lTnMucHJlZml4IH06JHsgbmFtZU5zLmxvY2FsTmFtZSB9YDtcblxuICBjb25zdCBub3JtYWxpemVkTmFtZU5zID0gcGFyc2VOYW1lTlMobm9ybWFsaXplZE5hbWUpO1xuXG4gIC8vIGRldGVybWluZSBhY3R1YWwgdHlwZSBuYW1lLCBiYXNlZCBvbiBwYWNrYWdlLWRlZmluZWQgcHJlZml4XG4gIHZhciBwa2cgPSBtb2RlbC5nZXRQYWNrYWdlKG5vcm1hbGl6ZWROYW1lTnMucHJlZml4KTtcblxuICByZXR1cm4gcHJlZml4ZWRUb05hbWUobm9ybWFsaXplZE5hbWVOcywgcGtnKTtcbn1cblxuZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xuICByZXR1cm4gbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbW9kZGxlIGRlc2NyaXB0b3IgZm9yIGEgZ2l2ZW4gaW5zdGFuY2Ugb3IgdHlwZS5cbiAqXG4gKiBAcGFyYW0gIHtNb2RkbGVFbGVtZW50fEZ1bmN0aW9ufSBlbGVtZW50XG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbW9kZGxlIGRlc2NyaXB0b3JcbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LiRkZXNjcmlwdG9yO1xufVxuXG5cbi8qKlxuICogQSBwYXJzZSBjb250ZXh0LlxuICpcbiAqIEBjbGFzc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0VsZW1lbnRIYW5kbGVyfSBvcHRpb25zLnJvb3RIYW5kbGVyIHRoZSByb290IGhhbmRsZXIgZm9yIHBhcnNpbmcgYSBkb2N1bWVudFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sYXg9ZmFsc2VdIHdoZXRoZXIgb3Igbm90IHRvIGlnbm9yZSBpbnZhbGlkIGVsZW1lbnRzXG4gKi9cbmZ1bmN0aW9uIENvbnRleHQob3B0aW9ucykge1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkge0VsZW1lbnRIYW5kbGVyfSByb290SGFuZGxlclxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBsYXhcbiAgICovXG5cbiAgYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuZWxlbWVudHNCeUlkID0ge307XG4gIHRoaXMucmVmZXJlbmNlcyA9IFtdO1xuICB0aGlzLndhcm5pbmdzID0gW107XG5cbiAgLyoqXG4gICAqIEFkZCBhbiB1bnJlc29sdmVkIHJlZmVyZW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZVxuICAgKi9cbiAgdGhpcy5hZGRSZWZlcmVuY2UgPSBmdW5jdGlvbihyZWZlcmVuY2UpIHtcbiAgICB0aGlzLnJlZmVyZW5jZXMucHVzaChyZWZlcmVuY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBwcm9jZXNzZWQgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RkbGVFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICB0aGlzLmFkZEVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHRocm93IGVycm9yKCdleHBlY3RlZCBlbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzQnlJZCA9IHRoaXMuZWxlbWVudHNCeUlkO1xuXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRNb2RkbGVEZXNjcmlwdG9yKGVsZW1lbnQpO1xuXG4gICAgdmFyIGlkUHJvcGVydHkgPSBkZXNjcmlwdG9yLmlkUHJvcGVydHksXG4gICAgICAgIGlkO1xuXG4gICAgaWYgKGlkUHJvcGVydHkpIHtcbiAgICAgIGlkID0gZWxlbWVudC5nZXQoaWRQcm9wZXJ0eS5uYW1lKTtcblxuICAgICAgaWYgKGlkKSB7XG5cbiAgICAgICAgLy8gZm9yIFFOYW1lIHZhbGlkYXRpb24gYXMgcGVyIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVDaGFyXG4gICAgICAgIGlmICghL14oW2Etel1bXFx3LS5dKjopP1thLXpfXVtcXHctLl0qJC9pLnRlc3QoaWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbGxlZ2FsIElEIDwnICsgaWQgKyAnPicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW1lbnRzQnlJZFtpZF0pIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcignZHVwbGljYXRlIElEIDwnICsgaWQgKyAnPicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudHNCeUlkW2lkXSA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYW4gaW1wb3J0IHdhcm5pbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB3YXJuaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB3YXJuaW5nLm1lc3NhZ2VcbiAgICogQHBhcmFtIHtFcnJvcn0gW3dhcm5pbmcuZXJyb3JdXG4gICAqL1xuICB0aGlzLmFkZFdhcm5pbmcgPSBmdW5jdGlvbih3YXJuaW5nKSB7XG4gICAgdGhpcy53YXJuaW5ncy5wdXNoKHdhcm5pbmcpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBCYXNlSGFuZGxlcigpIHt9XG5cbkJhc2VIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVFbmQgPSBmdW5jdGlvbigpIHt9O1xuQmFzZUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZVRleHQgPSBmdW5jdGlvbigpIHt9O1xuQmFzZUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZU5vZGUgPSBmdW5jdGlvbigpIHt9O1xuXG5cbi8qKlxuICogQSBzaW1wbGUgcGFzcyB0aHJvdWdoIGhhbmRsZXIgdGhhdCBkb2VzIG5vdGhpbmcgZXhjZXB0IGZvclxuICogaWdub3JpbmcgYWxsIGlucHV0IGl0IHJlY2VpdmVzLlxuICpcbiAqIFRoaXMgaXMgdXNlZCB0byBpZ25vcmUgdW5rbm93biBlbGVtZW50cyBhbmRcbiAqIGF0dHJpYnV0ZXMuXG4gKi9cbmZ1bmN0aW9uIE5vb3BIYW5kbGVyKCkgeyB9XG5cbk5vb3BIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUhhbmRsZXIucHJvdG90eXBlKTtcblxuTm9vcEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZU5vZGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBCb2R5SGFuZGxlcigpIHt9XG5cbkJvZHlIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUhhbmRsZXIucHJvdG90eXBlKTtcblxuQm9keUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZVRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHRoaXMuYm9keSA9ICh0aGlzLmJvZHkgfHwgJycpICsgdGV4dDtcbn07XG5cbmZ1bmN0aW9uIFJlZmVyZW5jZUhhbmRsZXIocHJvcGVydHksIGNvbnRleHQpIHtcbiAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xufVxuXG5SZWZlcmVuY2VIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQm9keUhhbmRsZXIucHJvdG90eXBlKTtcblxuUmVmZXJlbmNlSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgdGhyb3cgZXJyb3IoJ2V4cGVjdGVkIG5vIHN1YiBub2RlcycpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZWxlbWVudCA9IHRoaXMuY3JlYXRlUmVmZXJlbmNlKG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZWZlcmVuY2VIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVFbmQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbGVtZW50LmlkID0gdGhpcy5ib2R5O1xufTtcblxuUmVmZXJlbmNlSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlUmVmZXJlbmNlID0gZnVuY3Rpb24obm9kZSkge1xuICByZXR1cm4ge1xuICAgIHByb3BlcnR5OiB0aGlzLnByb3BlcnR5Lm5zLm5hbWUsXG4gICAgaWQ6ICcnXG4gIH07XG59O1xuXG5mdW5jdGlvbiBWYWx1ZUhhbmRsZXIocHJvcGVydHlEZXNjLCBlbGVtZW50KSB7XG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMucHJvcGVydHlEZXNjID0gcHJvcGVydHlEZXNjO1xufVxuXG5WYWx1ZUhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCb2R5SGFuZGxlci5wcm90b3R5cGUpO1xuXG5WYWx1ZUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUVuZCA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciB2YWx1ZSA9IHRoaXMuYm9keSB8fCAnJyxcbiAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBwcm9wZXJ0eURlc2MgPSB0aGlzLnByb3BlcnR5RGVzYztcblxuICB2YWx1ZSA9IGNvZXJjZVR5cGUocHJvcGVydHlEZXNjLnR5cGUsIHZhbHVlKTtcblxuICBpZiAocHJvcGVydHlEZXNjLmlzTWFueSkge1xuICAgIGVsZW1lbnQuZ2V0KHByb3BlcnR5RGVzYy5uYW1lKS5wdXNoKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LnNldChwcm9wZXJ0eURlc2MubmFtZSwgdmFsdWUpO1xuICB9XG59O1xuXG5cbmZ1bmN0aW9uIEJhc2VFbGVtZW50SGFuZGxlcigpIHt9XG5cbkJhc2VFbGVtZW50SGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJvZHlIYW5kbGVyLnByb3RvdHlwZSk7XG5cbkJhc2VFbGVtZW50SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIHBhcnNlciA9IHRoaXMsXG4gICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gIGlmICghZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQgPSB0aGlzLmNyZWF0ZUVsZW1lbnQobm9kZSk7XG5cbiAgICB0aGlzLmNvbnRleHQuYWRkRWxlbWVudChlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBwYXJzZXIgPSB0aGlzLmhhbmRsZUNoaWxkKG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlcjtcbn07XG5cbi8qKlxuICogQGNsYXNzIFJlYWRlci5FbGVtZW50SGFuZGxlclxuICpcbiAqL1xuZnVuY3Rpb24gRWxlbWVudEhhbmRsZXIobW9kZWwsIHR5cGVOYW1lLCBjb250ZXh0KSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy50eXBlID0gbW9kZWwuZ2V0VHlwZSh0eXBlTmFtZSk7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZSk7XG5cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5hZGRSZWZlcmVuY2UgPSBmdW5jdGlvbihyZWZlcmVuY2UpIHtcbiAgdGhpcy5jb250ZXh0LmFkZFJlZmVyZW5jZShyZWZlcmVuY2UpO1xufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZVRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG5cbiAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBkZXNjcmlwdG9yID0gZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50KSxcbiAgICAgIGJvZHlQcm9wZXJ0eSA9IGRlc2NyaXB0b3IuYm9keVByb3BlcnR5O1xuXG4gIGlmICghYm9keVByb3BlcnR5KSB7XG4gICAgdGhyb3cgZXJyb3IoJ3VuZXhwZWN0ZWQgYm9keSB0ZXh0IDwnICsgdGV4dCArICc+Jyk7XG4gIH1cblxuICBCb2R5SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlVGV4dC5jYWxsKHRoaXMsIHRleHQpO1xufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUVuZCA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciB2YWx1ZSA9IHRoaXMuYm9keSxcbiAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBkZXNjcmlwdG9yID0gZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50KSxcbiAgICAgIGJvZHlQcm9wZXJ0eSA9IGRlc2NyaXB0b3IuYm9keVByb3BlcnR5O1xuXG4gIGlmIChib2R5UHJvcGVydHkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gY29lcmNlVHlwZShib2R5UHJvcGVydHkudHlwZSwgdmFsdWUpO1xuICAgIGVsZW1lbnQuc2V0KGJvZHlQcm9wZXJ0eS5uYW1lLCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBtb2RlbCBmcm9tIHRoZSBnaXZlbiBub2RlLlxuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR9IG5vZGUgdGhlIHhtbCBub2RlXG4gKi9cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB2YXIgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcyxcbiAgICAgIFR5cGUgPSB0aGlzLnR5cGUsXG4gICAgICBkZXNjcmlwdG9yID0gZ2V0TW9kZGxlRGVzY3JpcHRvcihUeXBlKSxcbiAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICBpbnN0YW5jZSA9IG5ldyBUeXBlKHt9KSxcbiAgICAgIG1vZGVsID0gdGhpcy5tb2RlbCxcbiAgICAgIHByb3BOYW1lTnM7XG5cbiAgZm9yRWFjaChhdHRyaWJ1dGVzLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXG4gICAgdmFyIHByb3AgPSBkZXNjcmlwdG9yLnByb3BlcnRpZXNCeU5hbWVbbmFtZV0sXG4gICAgICAgIHZhbHVlcztcblxuICAgIGlmIChwcm9wICYmIHByb3AuaXNSZWZlcmVuY2UpIHtcblxuICAgICAgaWYgKCFwcm9wLmlzTWFueSkge1xuICAgICAgICBjb250ZXh0LmFkZFJlZmVyZW5jZSh7XG4gICAgICAgICAgZWxlbWVudDogaW5zdGFuY2UsXG4gICAgICAgICAgcHJvcGVydHk6IHByb3AubnMubmFtZSxcbiAgICAgICAgICBpZDogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIElEUkVGUzogcGFyc2UgcmVmZXJlbmNlcyBhcyB3aGl0ZXNwYWNlLXNlcGFyYXRlZCBsaXN0XG4gICAgICAgIHZhbHVlcyA9IHZhbHVlLnNwbGl0KCcgJyk7XG5cbiAgICAgICAgZm9yRWFjaCh2YWx1ZXMsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICBjb250ZXh0LmFkZFJlZmVyZW5jZSh7XG4gICAgICAgICAgICBlbGVtZW50OiBpbnN0YW5jZSxcbiAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLm5zLm5hbWUsXG4gICAgICAgICAgICBpZDogdlxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcCkge1xuICAgICAgICB2YWx1ZSA9IGNvZXJjZVR5cGUocHJvcC50eXBlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd4bWxucycpIHtcbiAgICAgICAgbmFtZSA9ICc6JyArIG5hbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wTmFtZU5zID0gcGFyc2VOYW1lTlMobmFtZSwgZGVzY3JpcHRvci5ucy5wcmVmaXgpO1xuXG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgYXR0cmlidXRlIGlzIGRlZmluZWQgaW4gYSB3ZWxsLWtub3duIG5hbWVzcGFjZVxuICAgICAgICAvLyBpZiB0aGF0IGlzIHRoZSBjYXNlIHdlIGVtaXQgYSB3YXJuaW5nIHRvIGluZGljYXRlIHBvdGVudGlhbCBtaXN1c2VcbiAgICAgICAgaWYgKG1vZGVsLmdldFBhY2thZ2UocHJvcE5hbWVOcy5wcmVmaXgpKSB7XG5cbiAgICAgICAgICBjb250ZXh0LmFkZFdhcm5pbmcoe1xuICAgICAgICAgICAgbWVzc2FnZTogJ3Vua25vd24gYXR0cmlidXRlIDwnICsgbmFtZSArICc+JyxcbiAgICAgICAgICAgIGVsZW1lbnQ6IGluc3RhbmNlLFxuICAgICAgICAgICAgcHJvcGVydHk6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZS5zZXQobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmdldFByb3BlcnR5Rm9yTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgdmFyIG5hbWVOcyA9IHBhcnNlTmFtZU5TKG5hbWUpO1xuXG4gIHZhciB0eXBlID0gdGhpcy50eXBlLFxuICAgICAgbW9kZWwgPSB0aGlzLm1vZGVsLFxuICAgICAgZGVzY3JpcHRvciA9IGdldE1vZGRsZURlc2NyaXB0b3IodHlwZSk7XG5cbiAgdmFyIHByb3BlcnR5TmFtZSA9IG5hbWVOcy5uYW1lLFxuICAgICAgcHJvcGVydHkgPSBkZXNjcmlwdG9yLnByb3BlcnRpZXNCeU5hbWVbcHJvcGVydHlOYW1lXTtcblxuICAvLyBzZWFyY2ggZm9yIHByb3BlcnRpZXMgYnkgbmFtZSBmaXJzdFxuXG4gIGlmIChwcm9wZXJ0eSAmJiAhcHJvcGVydHkuaXNBdHRyKSB7XG5cbiAgICBjb25zdCBzZXJpYWxpemF0aW9uVHlwZSA9IGdldFNlcmlhbGl6YXRpb25UeXBlKHByb3BlcnR5KTtcblxuICAgIGlmIChzZXJpYWxpemF0aW9uVHlwZSkge1xuICAgICAgY29uc3QgZWxlbWVudFR5cGVOYW1lID0gbm9kZS5hdHRyaWJ1dGVzW3NlcmlhbGl6YXRpb25UeXBlXTtcblxuICAgICAgLy8gdHlwZSBpcyBvcHRpb25hbCwgaWYgaXQgZG9lcyBub3QgZXhpc3RzIHRoZVxuICAgICAgLy8gZGVmYXVsdCB0eXBlIGlzIGFzc3VtZWRcbiAgICAgIGlmIChlbGVtZW50VHlwZU5hbWUpIHtcblxuICAgICAgICAvLyBjb252ZXJ0IHRoZSBwcmVmaXggdXNlZCB0byB0aGUgbWFwcGVkIGZvcm0sIGJ1dCBhbHNvXG4gICAgICAgIC8vIHRha2UgcG9zc2libGUgdHlwZSBwcmVmaXhlcyBmcm9tIFhNTFxuICAgICAgICAvLyBpbnRvIGFjY291bnQsIGkuZS46IHhzaTp0eXBlPVwidHtBY3R1YWxUeXBlfVwiLFxuICAgICAgICBjb25zdCBub3JtYWxpemVkVHlwZU5hbWUgPSBub3JtYWxpemVUeXBlTmFtZShlbGVtZW50VHlwZU5hbWUsIG5vZGUubnMsIG1vZGVsKTtcblxuICAgICAgICBjb25zdCBlbGVtZW50VHlwZSA9IG1vZGVsLmdldFR5cGUobm9ybWFsaXplZFR5cGVOYW1lKTtcblxuICAgICAgICByZXR1cm4gYXNzaWduKHt9LCBwcm9wZXJ0eSwge1xuICAgICAgICAgIGVmZmVjdGl2ZVR5cGU6IGdldE1vZGRsZURlc2NyaXB0b3IoZWxlbWVudFR5cGUpLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2VhcmNoIGZvciBwcm9wZXJ0aWVzIGJ5IG5hbWUgZmlyc3RcbiAgICByZXR1cm4gcHJvcGVydHk7XG4gIH1cblxuICB2YXIgcGtnID0gbW9kZWwuZ2V0UGFja2FnZShuYW1lTnMucHJlZml4KTtcblxuICBpZiAocGtnKSB7XG4gICAgY29uc3QgZWxlbWVudFR5cGVOYW1lID0gYWxpYXNUb05hbWUobmFtZU5zLCBwa2cpO1xuICAgIGNvbnN0IGVsZW1lbnRUeXBlID0gbW9kZWwuZ2V0VHlwZShlbGVtZW50VHlwZU5hbWUpO1xuXG4gICAgLy8gc2VhcmNoIGZvciBjb2xsZWN0aW9uIG1lbWJlcnMgbGF0ZXJcbiAgICBwcm9wZXJ0eSA9IGZpbmQoZGVzY3JpcHRvci5wcm9wZXJ0aWVzLCBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gIXAuaXNWaXJ0dWFsICYmICFwLmlzUmVmZXJlbmNlICYmICFwLmlzQXR0cmlidXRlICYmIGVsZW1lbnRUeXBlLmhhc1R5cGUocC50eXBlKTtcbiAgICB9KTtcblxuICAgIGlmIChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIGFzc2lnbih7fSwgcHJvcGVydHksIHtcbiAgICAgICAgZWZmZWN0aXZlVHlwZTogZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50VHlwZSkubmFtZVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuXG4gICAgLy8gcGFyc2UgdW5rbm93biBlbGVtZW50IChtYXliZSBleHRlbnNpb24pXG4gICAgcHJvcGVydHkgPSBmaW5kKGRlc2NyaXB0b3IucHJvcGVydGllcywgZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuICFwLmlzUmVmZXJlbmNlICYmICFwLmlzQXR0cmlidXRlICYmIHAudHlwZSA9PT0gJ0VsZW1lbnQnO1xuICAgIH0pO1xuXG4gICAgaWYgKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gcHJvcGVydHk7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgZXJyb3IoJ3VucmVjb2duaXplZCBlbGVtZW50IDwnICsgbmFtZU5zLm5hbWUgKyAnPicpO1xufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnRWxlbWVudERlc2NyaXB0b3JbJyArIGdldE1vZGRsZURlc2NyaXB0b3IodGhpcy50eXBlKS5uYW1lICsgJ10nO1xufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnZhbHVlSGFuZGxlciA9IGZ1bmN0aW9uKHByb3BlcnR5RGVzYywgZWxlbWVudCkge1xuICByZXR1cm4gbmV3IFZhbHVlSGFuZGxlcihwcm9wZXJ0eURlc2MsIGVsZW1lbnQpO1xufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnJlZmVyZW5jZUhhbmRsZXIgPSBmdW5jdGlvbihwcm9wZXJ0eURlc2MpIHtcbiAgcmV0dXJuIG5ldyBSZWZlcmVuY2VIYW5kbGVyKHByb3BlcnR5RGVzYywgdGhpcy5jb250ZXh0KTtcbn07XG5cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVyID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodHlwZSA9PT0gJ0VsZW1lbnQnKSB7XG4gICAgcmV0dXJuIG5ldyBHZW5lcmljRWxlbWVudEhhbmRsZXIodGhpcy5tb2RlbCwgdHlwZSwgdGhpcy5jb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEVsZW1lbnRIYW5kbGVyKHRoaXMubW9kZWwsIHR5cGUsIHRoaXMuY29udGV4dCk7XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlIHRoZSBjaGlsZCBlbGVtZW50IHBhcnNpbmdcbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBub2RlIHRoZSB4bWwgbm9kZVxuICovXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlQ2hpbGQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBwcm9wZXJ0eURlc2MsIHR5cGUsIGVsZW1lbnQsIGNoaWxkSGFuZGxlcjtcblxuICBwcm9wZXJ0eURlc2MgPSB0aGlzLmdldFByb3BlcnR5Rm9yTm9kZShub2RlKTtcbiAgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICB0eXBlID0gcHJvcGVydHlEZXNjLmVmZmVjdGl2ZVR5cGUgfHwgcHJvcGVydHlEZXNjLnR5cGU7XG5cbiAgaWYgKGlzU2ltcGxlVHlwZSh0eXBlKSkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlSGFuZGxlcihwcm9wZXJ0eURlc2MsIGVsZW1lbnQpO1xuICB9XG5cbiAgaWYgKHByb3BlcnR5RGVzYy5pc1JlZmVyZW5jZSkge1xuICAgIGNoaWxkSGFuZGxlciA9IHRoaXMucmVmZXJlbmNlSGFuZGxlcihwcm9wZXJ0eURlc2MpLmhhbmRsZU5vZGUobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgY2hpbGRIYW5kbGVyID0gdGhpcy5oYW5kbGVyKHR5cGUpLmhhbmRsZU5vZGUobm9kZSk7XG4gIH1cblxuICB2YXIgbmV3RWxlbWVudCA9IGNoaWxkSGFuZGxlci5lbGVtZW50O1xuXG4gIC8vIGNoaWxkIGhhbmRsZXMgbWF5IGRlY2lkZSB0byBza2lwIGVsZW1lbnRzXG4gIC8vIGJ5IG5vdCByZXR1cm5pbmcgYW55dGhpbmdcbiAgaWYgKG5ld0VsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgaWYgKHByb3BlcnR5RGVzYy5pc01hbnkpIHtcbiAgICAgIGVsZW1lbnQuZ2V0KHByb3BlcnR5RGVzYy5uYW1lKS5wdXNoKG5ld0VsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnNldChwcm9wZXJ0eURlc2MubmFtZSwgbmV3RWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5RGVzYy5pc1JlZmVyZW5jZSkge1xuICAgICAgYXNzaWduKG5ld0VsZW1lbnQsIHtcbiAgICAgICAgZWxlbWVudDogZWxlbWVudFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuY29udGV4dC5hZGRSZWZlcmVuY2UobmV3RWxlbWVudCk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gZXN0YWJsaXNoIGNoaWxkIC0+IHBhcmVudCByZWxhdGlvbnNoaXBcbiAgICAgIG5ld0VsZW1lbnQuJHBhcmVudCA9IGVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkSGFuZGxlcjtcbn07XG5cbi8qKlxuICogQW4gZWxlbWVudCBoYW5kbGVyIHRoYXQgcGVyZm9ybXMgc3BlY2lhbCB2YWxpZGF0aW9uXG4gKiB0byBlbnN1cmUgdGhlIG5vZGUgaXQgZ2V0cyBpbml0aWFsaXplZCB3aXRoIG1hdGNoZXNcbiAqIHRoZSBoYW5kbGVycyB0eXBlIChuYW1lc3BhY2Ugd2lzZSkuXG4gKlxuICogQHBhcmFtIHtNb2RkbGV9IG1vZGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZU5hbWVcbiAqIEBwYXJhbSB7Q29udGV4dH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBSb290RWxlbWVudEhhbmRsZXIobW9kZWwsIHR5cGVOYW1lLCBjb250ZXh0KSB7XG4gIEVsZW1lbnRIYW5kbGVyLmNhbGwodGhpcywgbW9kZWwsIHR5cGVOYW1lLCBjb250ZXh0KTtcbn1cblxuUm9vdEVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRWxlbWVudEhhbmRsZXIucHJvdG90eXBlKTtcblxuUm9vdEVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuXG4gIHZhciBuYW1lID0gbm9kZS5uYW1lLFxuICAgICAgbmFtZU5zID0gcGFyc2VOYW1lTlMobmFtZSksXG4gICAgICBtb2RlbCA9IHRoaXMubW9kZWwsXG4gICAgICB0eXBlID0gdGhpcy50eXBlLFxuICAgICAgcGtnID0gbW9kZWwuZ2V0UGFja2FnZShuYW1lTnMucHJlZml4KSxcbiAgICAgIHR5cGVOYW1lID0gcGtnICYmIGFsaWFzVG9OYW1lKG5hbWVOcywgcGtnKSB8fCBuYW1lO1xuXG4gIC8vIHZlcmlmeSB0aGUgY29ycmVjdCBuYW1lc3BhY2UgaWYgd2UgcGFyc2VcbiAgLy8gdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGhhbmRsZXIgdHJlZVxuICAvL1xuICAvLyB0aGlzIGVuc3VyZXMgd2UgZG9uJ3QgbWlzdGFrZW5seSBpbXBvcnQgd3JvbmcgbmFtZXNwYWNlIGVsZW1lbnRzXG4gIGlmICghdHlwZS5oYXNUeXBlKHR5cGVOYW1lKSkge1xuICAgIHRocm93IGVycm9yKCd1bmV4cGVjdGVkIGVsZW1lbnQgPCcgKyBub2RlLm9yaWdpbmFsTmFtZSArICc+Jyk7XG4gIH1cblxuICByZXR1cm4gRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQuY2FsbCh0aGlzLCBub2RlKTtcbn07XG5cblxuZnVuY3Rpb24gR2VuZXJpY0VsZW1lbnRIYW5kbGVyKG1vZGVsLCB0eXBlTmFtZSwgY29udGV4dCkge1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkdlbmVyaWNFbGVtZW50SGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VFbGVtZW50SGFuZGxlci5wcm90b3R5cGUpO1xuXG5HZW5lcmljRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgdmFyIG5hbWUgPSBub2RlLm5hbWUsXG4gICAgICBucyA9IHBhcnNlTmFtZU5TKG5hbWUpLFxuICAgICAgcHJlZml4ID0gbnMucHJlZml4LFxuICAgICAgdXJpID0gbm9kZS5uc1twcmVmaXggKyAnJHVyaSddLFxuICAgICAgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcztcblxuICByZXR1cm4gdGhpcy5tb2RlbC5jcmVhdGVBbnkobmFtZSwgdXJpLCBhdHRyaWJ1dGVzKTtcbn07XG5cbkdlbmVyaWNFbGVtZW50SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlQ2hpbGQgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgdmFyIGhhbmRsZXIgPSBuZXcgR2VuZXJpY0VsZW1lbnRIYW5kbGVyKHRoaXMubW9kZWwsICdFbGVtZW50JywgdGhpcy5jb250ZXh0KS5oYW5kbGVOb2RlKG5vZGUpLFxuICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICB2YXIgbmV3RWxlbWVudCA9IGhhbmRsZXIuZWxlbWVudCxcbiAgICAgIGNoaWxkcmVuO1xuXG4gIGlmIChuZXdFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjaGlsZHJlbiA9IGVsZW1lbnQuJGNoaWxkcmVuID0gZWxlbWVudC4kY2hpbGRyZW4gfHwgW107XG4gICAgY2hpbGRyZW4ucHVzaChuZXdFbGVtZW50KTtcblxuICAgIC8vIGVzdGFibGlzaCBjaGlsZCAtPiBwYXJlbnQgcmVsYXRpb25zaGlwXG4gICAgbmV3RWxlbWVudC4kcGFyZW50ID0gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBoYW5kbGVyO1xufTtcblxuR2VuZXJpY0VsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVFbmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuYm9keSkge1xuICAgIHRoaXMuZWxlbWVudC4kYm9keSA9IHRoaXMuYm9keTtcbiAgfVxufTtcblxuLyoqXG4gKiBBIHJlYWRlciBmb3IgYSBtZXRhLW1vZGVsXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7TW9kZWx9IG9wdGlvbnMubW9kZWwgdXNlZCB0byByZWFkIHhtbCBmaWxlc1xuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmxheCB3aGV0aGVyIHRvIG1ha2UgcGFyc2UgZXJyb3JzIHdhcm5pbmdzXG4gKi9cbmZ1bmN0aW9uIFJlYWRlcihvcHRpb25zKSB7XG5cbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBNb2RkbGUpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgbW9kZWw6IG9wdGlvbnNcbiAgICB9O1xuICB9XG5cbiAgYXNzaWduKHRoaXMsIHsgbGF4OiBmYWxzZSB9LCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBUaGUgZnJvbVhNTCByZXN1bHQuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gUGFyc2VSZXN1bHRcbiAqXG4gKiBAcHJvcGVydHkge01vZGRsZUVsZW1lbnR9IHJvb3RFbGVtZW50XG4gKiBAcHJvcGVydHkge0FycmF5PE9iamVjdD59IHJlZmVyZW5jZXNcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8RXJyb3I+fSB3YXJuaW5nc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGVsZW1lbnRzQnlJZCAtIGEgbWFwcGluZyBjb250YWluaW5nIGVhY2ggSUQgLT4gTW9kZGxlRWxlbWVudFxuICovXG5cbi8qKlxuICogVGhlIGZyb21YTUwgcmVzdWx0LlxuICpcbiAqIEB0eXBlZGVmIHtFcnJvcn0gUGFyc2VFcnJvclxuICpcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8RXJyb3I+fSB3YXJuaW5nc1xuICovXG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIFhNTCBpbnRvIGEgbW9kZGxlIGRvY3VtZW50IHRyZWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHhtbFxuICogQHBhcmFtIHtFbGVtZW50SGFuZGxlcnxPYmplY3R9IG9wdGlvbnMgb3Igcm9vdEhhbmRsZXJcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxQYXJzZVJlc3VsdCwgUGFyc2VFcnJvcj59XG4gKi9cblJlYWRlci5wcm90b3R5cGUuZnJvbVhNTCA9IGZ1bmN0aW9uKHhtbCwgb3B0aW9ucywgZG9uZSkge1xuXG4gIHZhciByb290SGFuZGxlciA9IG9wdGlvbnMucm9vdEhhbmRsZXI7XG5cbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBFbGVtZW50SGFuZGxlcikge1xuXG4gICAgLy8gcm9vdCBoYW5kbGVyIHBhc3NlZCB2aWEgKHhtbCwgeyByb290SGFuZGxlcjogRWxlbWVudEhhbmRsZXIgfSwgLi4uKVxuICAgIHJvb3RIYW5kbGVyID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuXG4gICAgICAvLyByb290SGFuZGxlciBwYXNzZWQgdmlhICh4bWwsICdzb21lU3RyaW5nJywgLi4uKVxuICAgICAgcm9vdEhhbmRsZXIgPSB0aGlzLmhhbmRsZXIob3B0aW9ucyk7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygcm9vdEhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgIC8vIHJvb3RIYW5kbGVyIHBhc3NlZCB2aWEgKHhtbCwgeyByb290SGFuZGxlcjogJ3NvbWVTdHJpbmcnIH0sIC4uLilcbiAgICAgIHJvb3RIYW5kbGVyID0gdGhpcy5oYW5kbGVyKHJvb3RIYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsLFxuICAgICAgbGF4ID0gdGhpcy5sYXg7XG5cbiAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dChhc3NpZ24oe30sIG9wdGlvbnMsIHsgcm9vdEhhbmRsZXI6IHJvb3RIYW5kbGVyIH0pKSxcbiAgICAgIHBhcnNlciA9IG5ldyBQYXJzZXIoeyBwcm94eTogdHJ1ZSB9KSxcbiAgICAgIHN0YWNrID0gY3JlYXRlU3RhY2soKTtcblxuICByb290SGFuZGxlci5jb250ZXh0ID0gY29udGV4dDtcblxuICAvLyBwdXNoIHJvb3QgaGFuZGxlclxuICBzdGFjay5wdXNoKHJvb3RIYW5kbGVyKTtcblxuXG4gIC8qKlxuICAgKiBIYW5kbGUgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSAge0Vycm9yfSBlcnJcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGdldENvbnRleHRcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gbGF4XG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgaGFuZGxlZFxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyLCBnZXRDb250ZXh0LCBsYXgpIHtcblxuICAgIHZhciBjdHggPSBnZXRDb250ZXh0KCk7XG5cbiAgICB2YXIgbGluZSA9IGN0eC5saW5lLFxuICAgICAgICBjb2x1bW4gPSBjdHguY29sdW1uLFxuICAgICAgICBkYXRhID0gY3R4LmRhdGE7XG5cbiAgICAvLyB3ZSByZWNlaXZlIHRoZSBmdWxsIGNvbnRleHQgZGF0YSBoZXJlLFxuICAgIC8vIGZvciBlbGVtZW50cyB0cmltIGRvd24gdGhlIGluZm9ybWF0aW9uXG4gICAgLy8gdG8gdGhlIHRhZyBuYW1lLCBvbmx5XG4gICAgaWYgKGRhdGEuY2hhckF0KDApID09PSAnPCcgJiYgZGF0YS5pbmRleE9mKCcgJykgIT09IC0xKSB7XG4gICAgICBkYXRhID0gZGF0YS5zbGljZSgwLCBkYXRhLmluZGV4T2YoJyAnKSkgKyAnPic7XG4gICAgfVxuXG4gICAgdmFyIG1lc3NhZ2UgPVxuICAgICAgJ3VucGFyc2FibGUgY29udGVudCAnICsgKGRhdGEgPyBkYXRhICsgJyAnIDogJycpICsgJ2RldGVjdGVkXFxuXFx0JyArXG4gICAgICAgICdsaW5lOiAnICsgbGluZSArICdcXG5cXHQnICtcbiAgICAgICAgJ2NvbHVtbjogJyArIGNvbHVtbiArICdcXG5cXHQnICtcbiAgICAgICAgJ25lc3RlZCBlcnJvcjogJyArIGVyci5tZXNzYWdlO1xuXG4gICAgaWYgKGxheCkge1xuICAgICAgY29udGV4dC5hZGRXYXJuaW5nKHtcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgZXJyb3I6IGVyclxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVXYXJuaW5nKGVyciwgZ2V0Q29udGV4dCkge1xuXG4gICAgLy8ganVzdCBsaWtlIGhhbmRsaW5nIGVycm9ycyBpbiA8bGF4PXRydWU+IG1vZGVcbiAgICByZXR1cm4gaGFuZGxlRXJyb3IoZXJyLCBnZXRDb250ZXh0LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGNvbGxlY3RlZCByZWZlcmVuY2VzIG9uIHBhcnNlIGVuZC5cbiAgICovXG4gIGZ1bmN0aW9uIHJlc29sdmVSZWZlcmVuY2VzKCkge1xuXG4gICAgdmFyIGVsZW1lbnRzQnlJZCA9IGNvbnRleHQuZWxlbWVudHNCeUlkO1xuICAgIHZhciByZWZlcmVuY2VzID0gY29udGV4dC5yZWZlcmVuY2VzO1xuXG4gICAgdmFyIGksIHI7XG5cbiAgICBmb3IgKGkgPSAwOyAociA9IHJlZmVyZW5jZXNbaV0pOyBpKyspIHtcbiAgICAgIHZhciBlbGVtZW50ID0gci5lbGVtZW50O1xuICAgICAgdmFyIHJlZmVyZW5jZSA9IGVsZW1lbnRzQnlJZFtyLmlkXTtcbiAgICAgIHZhciBwcm9wZXJ0eSA9IGdldE1vZGRsZURlc2NyaXB0b3IoZWxlbWVudCkucHJvcGVydGllc0J5TmFtZVtyLnByb3BlcnR5XTtcblxuICAgICAgaWYgKCFyZWZlcmVuY2UpIHtcbiAgICAgICAgY29udGV4dC5hZGRXYXJuaW5nKHtcbiAgICAgICAgICBtZXNzYWdlOiAndW5yZXNvbHZlZCByZWZlcmVuY2UgPCcgKyByLmlkICsgJz4nLFxuICAgICAgICAgIGVsZW1lbnQ6IHIuZWxlbWVudCxcbiAgICAgICAgICBwcm9wZXJ0eTogci5wcm9wZXJ0eSxcbiAgICAgICAgICB2YWx1ZTogci5pZFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BlcnR5LmlzTWFueSkge1xuICAgICAgICB2YXIgY29sbGVjdGlvbiA9IGVsZW1lbnQuZ2V0KHByb3BlcnR5Lm5hbWUpLFxuICAgICAgICAgICAgaWR4ID0gY29sbGVjdGlvbi5pbmRleE9mKHIpO1xuXG4gICAgICAgIC8vIHdlIHJlcGxhY2UgYW4gZXhpc3RpbmcgcGxhY2UgaG9sZGVyIChpZHggIT0gLTEpIG9yXG4gICAgICAgIC8vIGFwcGVuZCB0byB0aGUgY29sbGVjdGlvbiBpbnN0ZWFkXG4gICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgaWR4ID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlZmVyZW5jZSkge1xuXG4gICAgICAgICAgLy8gcmVtb3ZlIHVucmVzb2x2YWJsZSByZWZlcmVuY2VcbiAgICAgICAgICBjb2xsZWN0aW9uLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gYWRkIG9yIHVwZGF0ZSByZWZlcmVuY2UgaW4gY29sbGVjdGlvblxuICAgICAgICAgIGNvbGxlY3Rpb25baWR4XSA9IHJlZmVyZW5jZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXQocHJvcGVydHkubmFtZSwgcmVmZXJlbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDbG9zZSgpIHtcbiAgICBzdGFjay5wb3AoKS5oYW5kbGVFbmQoKTtcbiAgfVxuXG4gIHZhciBQUkVBTUJMRV9TVEFSVF9QQVRURVJOID0gL148XFw/eG1sIC9pO1xuXG4gIHZhciBFTkNPRElOR19QQVRURVJOID0gLyBlbmNvZGluZz1cIihbXlwiXSspXCIvaTtcblxuICB2YXIgVVRGXzhfUEFUVEVSTiA9IC9edXRmLTgkL2k7XG5cbiAgZnVuY3Rpb24gaGFuZGxlUXVlc3Rpb24ocXVlc3Rpb24pIHtcblxuICAgIGlmICghUFJFQU1CTEVfU1RBUlRfUEFUVEVSTi50ZXN0KHF1ZXN0aW9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtYXRjaCA9IEVOQ09ESU5HX1BBVFRFUk4uZXhlYyhxdWVzdGlvbik7XG4gICAgdmFyIGVuY29kaW5nID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG5cbiAgICBpZiAoIWVuY29kaW5nIHx8IFVURl84X1BBVFRFUk4udGVzdChlbmNvZGluZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZXh0LmFkZFdhcm5pbmcoe1xuICAgICAgbWVzc2FnZTpcbiAgICAgICAgJ3Vuc3VwcG9ydGVkIGRvY3VtZW50IGVuY29kaW5nIDwnICsgZW5jb2RpbmcgKyAnPiwgJyArXG4gICAgICAgICdmYWxsaW5nIGJhY2sgdG8gVVRGLTgnXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVPcGVuKG5vZGUsIGdldENvbnRleHQpIHtcbiAgICB2YXIgaGFuZGxlciA9IHN0YWNrLnBlZWsoKTtcblxuICAgIHRyeSB7XG4gICAgICBzdGFjay5wdXNoKGhhbmRsZXIuaGFuZGxlTm9kZShub2RlKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG5cbiAgICAgIGlmIChoYW5kbGVFcnJvcihlcnIsIGdldENvbnRleHQsIGxheCkpIHtcbiAgICAgICAgc3RhY2sucHVzaChuZXcgTm9vcEhhbmRsZXIoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ0RhdGEodGV4dCwgZ2V0Q29udGV4dCkge1xuXG4gICAgdHJ5IHtcbiAgICAgIHN0YWNrLnBlZWsoKS5oYW5kbGVUZXh0KHRleHQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaGFuZGxlV2FybmluZyhlcnIsIGdldENvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVRleHQodGV4dCwgZ2V0Q29udGV4dCkge1xuXG4gICAgLy8gc3RyaXAgd2hpdGVzcGFjZSBvbmx5IG5vZGVzLCBpLmUuIGJlZm9yZVxuICAgIC8vIDwhQ0RBVEFbIC4uLiBdPiBzZWN0aW9ucyBhbmQgaW4gYmV0d2VlbiB0YWdzXG5cbiAgICBpZiAoIXRleHQudHJpbSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGFuZGxlQ0RhdGEodGV4dCwgZ2V0Q29udGV4dCk7XG4gIH1cblxuICB2YXIgdXJpTWFwID0gbW9kZWwuZ2V0UGFja2FnZXMoKS5yZWR1Y2UoZnVuY3Rpb24odXJpTWFwLCBwKSB7XG4gICAgdXJpTWFwW3AudXJpXSA9IHAucHJlZml4O1xuXG4gICAgcmV0dXJuIHVyaU1hcDtcbiAgfSwgT2JqZWN0LmVudHJpZXMoREVGQVVMVF9OU19NQVApLnJlZHVjZShmdW5jdGlvbihtYXAsIFsgcHJlZml4LCB1cmwgXSkge1xuICAgIG1hcFt1cmxdID0gcHJlZml4O1xuXG4gICAgcmV0dXJuIG1hcDtcbiAgfSwgbW9kZWwuY29uZmlnICYmIG1vZGVsLmNvbmZpZy5uc01hcCB8fCB7fSkpO1xuXG4gIHBhcnNlclxuICAgIC5ucyh1cmlNYXApXG4gICAgLm9uKCdvcGVuVGFnJywgZnVuY3Rpb24ob2JqLCBkZWNvZGVTdHIsIHNlbGZDbG9zaW5nLCBnZXRDb250ZXh0KSB7XG5cbiAgICAgIC8vIGdyYWNlZnVsbHkgaGFuZGxlIHVucGFyc2FibGUgYXR0cmlidXRlcyAoYXR0cnM9ZmFsc2UpXG4gICAgICB2YXIgYXR0cnMgPSBvYmouYXR0cnMgfHwge307XG5cbiAgICAgIHZhciBkZWNvZGVkQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycykucmVkdWNlKGZ1bmN0aW9uKGQsIGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBkZWNvZGVTdHIoYXR0cnNba2V5XSk7XG5cbiAgICAgICAgZFtrZXldID0gdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9LCB7fSk7XG5cbiAgICAgIHZhciBub2RlID0ge1xuICAgICAgICBuYW1lOiBvYmoubmFtZSxcbiAgICAgICAgb3JpZ2luYWxOYW1lOiBvYmoub3JpZ2luYWxOYW1lLFxuICAgICAgICBhdHRyaWJ1dGVzOiBkZWNvZGVkQXR0cnMsXG4gICAgICAgIG5zOiBvYmoubnNcbiAgICAgIH07XG5cbiAgICAgIGhhbmRsZU9wZW4obm9kZSwgZ2V0Q29udGV4dCk7XG4gICAgfSlcbiAgICAub24oJ3F1ZXN0aW9uJywgaGFuZGxlUXVlc3Rpb24pXG4gICAgLm9uKCdjbG9zZVRhZycsIGhhbmRsZUNsb3NlKVxuICAgIC5vbignY2RhdGEnLCBoYW5kbGVDRGF0YSlcbiAgICAub24oJ3RleHQnLCBmdW5jdGlvbih0ZXh0LCBkZWNvZGVFbnRpdGllcywgZ2V0Q29udGV4dCkge1xuICAgICAgaGFuZGxlVGV4dChkZWNvZGVFbnRpdGllcyh0ZXh0KSwgZ2V0Q29udGV4dCk7XG4gICAgfSlcbiAgICAub24oJ2Vycm9yJywgaGFuZGxlRXJyb3IpXG4gICAgLm9uKCd3YXJuJywgaGFuZGxlV2FybmluZyk7XG5cbiAgLy8gYXN5bmMgWE1MIHBhcnNpbmcgdG8gbWFrZSBzdXJlIHRoZSBleGVjdXRpb24gZW52aXJvbm1lbnRcbiAgLy8gKG5vZGUgb3IgYnJvd2VyKSBpcyBrZXB0IHJlc3BvbnNpdmUgYW5kIHRoYXQgY2VydGFpbiBvcHRpbWl6YXRpb25cbiAgLy8gc3RyYXRlZ2llcyBjYW4ga2ljayBpbi5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgdmFyIGVycjtcblxuICAgIHRyeSB7XG4gICAgICBwYXJzZXIucGFyc2UoeG1sKTtcblxuICAgICAgcmVzb2x2ZVJlZmVyZW5jZXMoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgIH1cblxuICAgIHZhciByb290RWxlbWVudCA9IHJvb3RIYW5kbGVyLmVsZW1lbnQ7XG5cbiAgICBpZiAoIWVyciAmJiAhcm9vdEVsZW1lbnQpIHtcbiAgICAgIGVyciA9IGVycm9yKCdmYWlsZWQgdG8gcGFyc2UgZG9jdW1lbnQgYXMgPCcgKyByb290SGFuZGxlci50eXBlLiRkZXNjcmlwdG9yLm5hbWUgKyAnPicpO1xuICAgIH1cblxuICAgIHZhciB3YXJuaW5ncyA9IGNvbnRleHQud2FybmluZ3M7XG4gICAgdmFyIHJlZmVyZW5jZXMgPSBjb250ZXh0LnJlZmVyZW5jZXM7XG4gICAgdmFyIGVsZW1lbnRzQnlJZCA9IGNvbnRleHQuZWxlbWVudHNCeUlkO1xuXG4gICAgaWYgKGVycikge1xuICAgICAgZXJyLndhcm5pbmdzID0gd2FybmluZ3M7XG5cbiAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc29sdmUoe1xuICAgICAgICByb290RWxlbWVudDogcm9vdEVsZW1lbnQsXG4gICAgICAgIGVsZW1lbnRzQnlJZDogZWxlbWVudHNCeUlkLFxuICAgICAgICByZWZlcmVuY2VzOiByZWZlcmVuY2VzLFxuICAgICAgICB3YXJuaW5nczogd2FybmluZ3NcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5SZWFkZXIucHJvdG90eXBlLmhhbmRsZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiBuZXcgUm9vdEVsZW1lbnRIYW5kbGVyKHRoaXMubW9kZWwsIG5hbWUpO1xufTtcblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGNyZWF0ZVN0YWNrKCkge1xuICB2YXIgc3RhY2sgPSBbXTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RhY2ssICdwZWVrJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzW3RoaXMubGVuZ3RoIC0gMV07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc3RhY2s7XG59XG5cbnZhciBYTUxfUFJFQU1CTEUgPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIj8+XFxuJztcblxudmFyIEVTQ0FQRV9BVFRSX0NIQVJTID0gLzx8PnwnfFwifCZ8XFxuXFxyfFxcbi9nO1xudmFyIEVTQ0FQRV9DSEFSUyA9IC88fD58Ji9nO1xuXG5cbmZ1bmN0aW9uIE5hbWVzcGFjZXMocGFyZW50KSB7XG5cbiAgdGhpcy5wcmVmaXhNYXAgPSB7fTtcbiAgdGhpcy51cmlNYXAgPSB7fTtcbiAgdGhpcy51c2VkID0ge307XG5cbiAgdGhpcy53ZWxsa25vd24gPSBbXTtcbiAgdGhpcy5jdXN0b20gPSBbXTtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgdGhpcy5kZWZhdWx0UHJlZml4TWFwID0gcGFyZW50ICYmIHBhcmVudC5kZWZhdWx0UHJlZml4TWFwIHx8IHt9O1xufVxuXG5OYW1lc3BhY2VzLnByb3RvdHlwZS5tYXBEZWZhdWx0UHJlZml4ZXMgPSBmdW5jdGlvbihkZWZhdWx0UHJlZml4TWFwKSB7XG4gIHRoaXMuZGVmYXVsdFByZWZpeE1hcCA9IGRlZmF1bHRQcmVmaXhNYXA7XG59O1xuXG5OYW1lc3BhY2VzLnByb3RvdHlwZS5kZWZhdWx0VXJpQnlQcmVmaXggPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgcmV0dXJuIHRoaXMuZGVmYXVsdFByZWZpeE1hcFtwcmVmaXhdO1xufTtcblxuTmFtZXNwYWNlcy5wcm90b3R5cGUuYnlVcmkgPSBmdW5jdGlvbih1cmkpIHtcbiAgcmV0dXJuIHRoaXMudXJpTWFwW3VyaV0gfHwgKFxuICAgIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmJ5VXJpKHVyaSlcbiAgKTtcbn07XG5cbk5hbWVzcGFjZXMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG5zLCBpc1dlbGxrbm93bikge1xuXG4gIHRoaXMudXJpTWFwW25zLnVyaV0gPSBucztcblxuICBpZiAoaXNXZWxsa25vd24pIHtcbiAgICB0aGlzLndlbGxrbm93bi5wdXNoKG5zKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmN1c3RvbS5wdXNoKG5zKTtcbiAgfVxuXG4gIHRoaXMubWFwUHJlZml4KG5zLnByZWZpeCwgbnMudXJpKTtcbn07XG5cbk5hbWVzcGFjZXMucHJvdG90eXBlLnVyaUJ5UHJlZml4ID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gIHJldHVybiB0aGlzLnByZWZpeE1hcFtwcmVmaXggfHwgJ3htbG5zJ10gfHwgKFxuICAgIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnVyaUJ5UHJlZml4KHByZWZpeClcbiAgKTtcbn07XG5cbk5hbWVzcGFjZXMucHJvdG90eXBlLm1hcFByZWZpeCA9IGZ1bmN0aW9uKHByZWZpeCwgdXJpKSB7XG4gIHRoaXMucHJlZml4TWFwW3ByZWZpeCB8fCAneG1sbnMnXSA9IHVyaTtcbn07XG5cbk5hbWVzcGFjZXMucHJvdG90eXBlLmdldE5TS2V5ID0gZnVuY3Rpb24obnMpIHtcbiAgcmV0dXJuIChucy5wcmVmaXggIT09IHVuZGVmaW5lZCkgPyAobnMudXJpICsgJ3wnICsgbnMucHJlZml4KSA6IG5zLnVyaTtcbn07XG5cbk5hbWVzcGFjZXMucHJvdG90eXBlLmxvZ1VzZWQgPSBmdW5jdGlvbihucykge1xuXG4gIHZhciB1cmkgPSBucy51cmk7XG4gIHZhciBuc0tleSA9IHRoaXMuZ2V0TlNLZXkobnMpO1xuXG4gIHRoaXMudXNlZFtuc0tleV0gPSB0aGlzLmJ5VXJpKHVyaSk7XG5cbiAgLy8gSW5mb3JtIHBhcmVudCByZWN1cnNpdmVseSBhYm91dCB0aGUgdXNhZ2Ugb2YgdGhpcyBOU1xuICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICB0aGlzLnBhcmVudC5sb2dVc2VkKG5zKTtcbiAgfVxufTtcblxuTmFtZXNwYWNlcy5wcm90b3R5cGUuZ2V0VXNlZCA9IGZ1bmN0aW9uKG5zKSB7XG5cbiAgdmFyIGFsbE5zID0gW10uY29uY2F0KHRoaXMud2VsbGtub3duLCB0aGlzLmN1c3RvbSk7XG5cbiAgcmV0dXJuIGFsbE5zLmZpbHRlcihucyA9PiB7XG4gICAgdmFyIG5zS2V5ID0gdGhpcy5nZXROU0tleShucyk7XG5cbiAgICByZXR1cm4gdGhpcy51c2VkW25zS2V5XTtcbiAgfSk7XG59O1xuXG5cbmZ1bmN0aW9uIGxvd2VyKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufVxuXG5mdW5jdGlvbiBuYW1lVG9BbGlhcyhuYW1lLCBwa2cpIHtcbiAgaWYgKGhhc0xvd2VyQ2FzZUFsaWFzKHBrZykpIHtcbiAgICByZXR1cm4gbG93ZXIobmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogY3RvcixcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBuc05hbWUobnMpIHtcbiAgaWYgKGlzU3RyaW5nKG5zKSkge1xuICAgIHJldHVybiBucztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKG5zLnByZWZpeCA/IG5zLnByZWZpeCArICc6JyA6ICcnKSArIG5zLmxvY2FsTmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXROc0F0dHJzKG5hbWVzcGFjZXMpIHtcblxuICByZXR1cm4gbmFtZXNwYWNlcy5nZXRVc2VkKCkuZmlsdGVyKGZ1bmN0aW9uKG5zKSB7XG5cbiAgICAvLyBkbyBub3Qgc2VyaWFsaXplIGJ1aWx0IGluIDx4bWw+IG5hbWVzcGFjZVxuICAgIHJldHVybiBucy5wcmVmaXggIT09ICd4bWwnO1xuICB9KS5tYXAoZnVuY3Rpb24obnMpIHtcbiAgICB2YXIgbmFtZSA9ICd4bWxucycgKyAobnMucHJlZml4ID8gJzonICsgbnMucHJlZml4IDogJycpO1xuICAgIHJldHVybiB7IG5hbWU6IG5hbWUsIHZhbHVlOiBucy51cmkgfTtcbiAgfSk7XG5cbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudE5zKG5zLCBkZXNjcmlwdG9yKSB7XG4gIGlmIChkZXNjcmlwdG9yLmlzR2VuZXJpYykge1xuICAgIHJldHVybiBhc3NpZ24oeyBsb2NhbE5hbWU6IGRlc2NyaXB0b3IubnMubG9jYWxOYW1lIH0sIG5zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXNzaWduKHsgbG9jYWxOYW1lOiBuYW1lVG9BbGlhcyhkZXNjcmlwdG9yLm5zLmxvY2FsTmFtZSwgZGVzY3JpcHRvci4kcGtnKSB9LCBucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlOcyhucywgZGVzY3JpcHRvcikge1xuICByZXR1cm4gYXNzaWduKHsgbG9jYWxOYW1lOiBkZXNjcmlwdG9yLm5zLmxvY2FsTmFtZSB9LCBucyk7XG59XG5cbmZ1bmN0aW9uIGdldFNlcmlhbGl6YWJsZVByb3BlcnRpZXMoZWxlbWVudCkge1xuICB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnQuJGRlc2NyaXB0b3I7XG5cbiAgcmV0dXJuIGZpbHRlcihkZXNjcmlwdG9yLnByb3BlcnRpZXMsIGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgbmFtZSA9IHAubmFtZTtcblxuICAgIGlmIChwLmlzVmlydHVhbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGRvIG5vdCBzZXJpYWxpemUgZGVmYXVsdHNcbiAgICBpZiAoIWhhcyhlbGVtZW50LCBuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IGVsZW1lbnRbbmFtZV07XG5cbiAgICAvLyBkbyBub3Qgc2VyaWFsaXplIGRlZmF1bHQgZXF1YWxzXG4gICAgaWYgKHZhbHVlID09PSBwLmRlZmF1bHQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBkbyBub3Qgc2VyaWFsaXplIG51bGwgcHJvcGVydGllc1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBwLmlzTWFueSA/IHZhbHVlLmxlbmd0aCA6IHRydWU7XG4gIH0pO1xufVxuXG52YXIgRVNDQVBFX0FUVFJfTUFQID0ge1xuICAnXFxuJzogJyMxMCcsXG4gICdcXG5cXHInOiAnIzEwJyxcbiAgJ1wiJzogJyMzNCcsXG4gICdcXCcnOiAnIzM5JyxcbiAgJzwnOiAnIzYwJyxcbiAgJz4nOiAnIzYyJyxcbiAgJyYnOiAnIzM4J1xufTtcblxudmFyIEVTQ0FQRV9NQVAgPSB7XG4gICc8JzogJ2x0JyxcbiAgJz4nOiAnZ3QnLFxuICAnJic6ICdhbXAnXG59O1xuXG5mdW5jdGlvbiBlc2NhcGUoc3RyLCBjaGFyUGF0dGVybiwgcmVwbGFjZU1hcCkge1xuXG4gIC8vIGVuc3VyZSB3ZSBhcmUgaGFuZGxpbmcgc3RyaW5ncyBoZXJlXG4gIHN0ciA9IGlzU3RyaW5nKHN0cikgPyBzdHIgOiAnJyArIHN0cjtcblxuICByZXR1cm4gc3RyLnJlcGxhY2UoY2hhclBhdHRlcm4sIGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gJyYnICsgcmVwbGFjZU1hcFtzXSArICc7JztcbiAgfSk7XG59XG5cbi8qKlxuICogRXNjYXBlIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBub3QgY29udGFpbiBhbnkgYmFkIHZhbHVlcyAobGluZSBicmVha3MsICdcIicsIC4uLilcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gZXNjYXBlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBlc2NhcGVkIHN0cmluZ1xuICovXG5mdW5jdGlvbiBlc2NhcGVBdHRyKHN0cikge1xuICByZXR1cm4gZXNjYXBlKHN0ciwgRVNDQVBFX0FUVFJfQ0hBUlMsIEVTQ0FQRV9BVFRSX01BUCk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUJvZHkoc3RyKSB7XG4gIHJldHVybiBlc2NhcGUoc3RyLCBFU0NBUEVfQ0hBUlMsIEVTQ0FQRV9NQVApO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJBdHRyaWJ1dGVzKHByb3BzKSB7XG4gIHJldHVybiBmaWx0ZXIocHJvcHMsIGZ1bmN0aW9uKHApIHsgcmV0dXJuIHAuaXNBdHRyOyB9KTtcbn1cblxuZnVuY3Rpb24gZmlsdGVyQ29udGFpbmVkKHByb3BzKSB7XG4gIHJldHVybiBmaWx0ZXIocHJvcHMsIGZ1bmN0aW9uKHApIHsgcmV0dXJuICFwLmlzQXR0cjsgfSk7XG59XG5cblxuZnVuY3Rpb24gUmVmZXJlbmNlU2VyaWFsaXplcih0YWdOYW1lKSB7XG4gIHRoaXMudGFnTmFtZSA9IHRhZ05hbWU7XG59XG5cblJlZmVyZW5jZVNlcmlhbGl6ZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlZmVyZW5jZVNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZVRvID0gZnVuY3Rpb24od3JpdGVyKSB7XG4gIHdyaXRlclxuICAgIC5hcHBlbmRJbmRlbnQoKVxuICAgIC5hcHBlbmQoJzwnICsgdGhpcy50YWdOYW1lICsgJz4nICsgdGhpcy5lbGVtZW50LmlkICsgJzwvJyArIHRoaXMudGFnTmFtZSArICc+JylcbiAgICAuYXBwZW5kTmV3TGluZSgpO1xufTtcblxuZnVuY3Rpb24gQm9keVNlcmlhbGl6ZXIoKSB7fVxuXG5Cb2R5U2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplVmFsdWUgPVxuQm9keVNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZVRvID0gZnVuY3Rpb24od3JpdGVyKSB7XG4gIHdyaXRlci5hcHBlbmQoXG4gICAgdGhpcy5lc2NhcGVcbiAgICAgID8gZXNjYXBlQm9keSh0aGlzLnZhbHVlKVxuICAgICAgOiB0aGlzLnZhbHVlXG4gICk7XG59O1xuXG5Cb2R5U2VyaWFsaXplci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgaWYgKHByb3AudHlwZSA9PT0gJ1N0cmluZycgJiYgdmFsdWUuc2VhcmNoKEVTQ0FQRV9DSEFSUykgIT09IC0xKSB7XG4gICAgdGhpcy5lc2NhcGUgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBWYWx1ZVNlcmlhbGl6ZXIodGFnTmFtZSkge1xuICB0aGlzLnRhZ05hbWUgPSB0YWdOYW1lO1xufVxuXG5pbmhlcml0cyhWYWx1ZVNlcmlhbGl6ZXIsIEJvZHlTZXJpYWxpemVyKTtcblxuVmFsdWVTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVUbyA9IGZ1bmN0aW9uKHdyaXRlcikge1xuXG4gIHdyaXRlclxuICAgIC5hcHBlbmRJbmRlbnQoKVxuICAgIC5hcHBlbmQoJzwnICsgdGhpcy50YWdOYW1lICsgJz4nKTtcblxuICB0aGlzLnNlcmlhbGl6ZVZhbHVlKHdyaXRlcik7XG5cbiAgd3JpdGVyXG4gICAgLmFwcGVuZCgnPC8nICsgdGhpcy50YWdOYW1lICsgJz4nKVxuICAgIC5hcHBlbmROZXdMaW5lKCk7XG59O1xuXG5mdW5jdGlvbiBFbGVtZW50U2VyaWFsaXplcihwYXJlbnQsIHByb3BlcnR5RGVzY3JpcHRvcikge1xuICB0aGlzLmJvZHkgPSBbXTtcbiAgdGhpcy5hdHRycyA9IFtdO1xuXG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLnByb3BlcnR5RGVzY3JpcHRvciA9IHByb3BlcnR5RGVzY3JpcHRvcjtcbn1cblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gIHZhciBlbGVtZW50RGVzY3JpcHRvciA9IGVsZW1lbnQuJGRlc2NyaXB0b3IsXG4gICAgICBwcm9wZXJ0eURlc2NyaXB0b3IgPSB0aGlzLnByb3BlcnR5RGVzY3JpcHRvcjtcblxuICB2YXIgb3RoZXJBdHRycyxcbiAgICAgIHByb3BlcnRpZXM7XG5cbiAgdmFyIGlzR2VuZXJpYyA9IGVsZW1lbnREZXNjcmlwdG9yLmlzR2VuZXJpYztcblxuICBpZiAoaXNHZW5lcmljKSB7XG4gICAgb3RoZXJBdHRycyA9IHRoaXMucGFyc2VHZW5lcmljTnNBdHRyaWJ1dGVzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIG90aGVyQXR0cnMgPSB0aGlzLnBhcnNlTnNBdHRyaWJ1dGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgaWYgKHByb3BlcnR5RGVzY3JpcHRvcikge1xuICAgIHRoaXMubnMgPSB0aGlzLm5zUHJvcGVydHlUYWdOYW1lKHByb3BlcnR5RGVzY3JpcHRvcik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ucyA9IHRoaXMubnNUYWdOYW1lKGVsZW1lbnREZXNjcmlwdG9yKTtcbiAgfVxuXG4gIC8vIGNvbXB1dGUgdGFnIG5hbWVcbiAgdGhpcy50YWdOYW1lID0gdGhpcy5hZGRUYWdOYW1lKHRoaXMubnMpO1xuXG4gIGlmIChpc0dlbmVyaWMpIHtcbiAgICB0aGlzLnBhcnNlR2VuZXJpY0NvbnRhaW5tZW50cyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBwcm9wZXJ0aWVzID0gZ2V0U2VyaWFsaXphYmxlUHJvcGVydGllcyhlbGVtZW50KTtcblxuICAgIHRoaXMucGFyc2VBdHRyaWJ1dGVzKGZpbHRlckF0dHJpYnV0ZXMocHJvcGVydGllcykpO1xuICAgIHRoaXMucGFyc2VDb250YWlubWVudHMoZmlsdGVyQ29udGFpbmVkKHByb3BlcnRpZXMpKTtcbiAgfVxuXG4gIHRoaXMucGFyc2VHZW5lcmljQXR0cmlidXRlcyhlbGVtZW50LCBvdGhlckF0dHJzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5uc1RhZ05hbWUgPSBmdW5jdGlvbihkZXNjcmlwdG9yKSB7XG4gIHZhciBlZmZlY3RpdmVOcyA9IHRoaXMubG9nTmFtZXNwYWNlVXNlZChkZXNjcmlwdG9yLm5zKTtcbiAgcmV0dXJuIGdldEVsZW1lbnROcyhlZmZlY3RpdmVOcywgZGVzY3JpcHRvcik7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUubnNQcm9wZXJ0eVRhZ05hbWUgPSBmdW5jdGlvbihkZXNjcmlwdG9yKSB7XG4gIHZhciBlZmZlY3RpdmVOcyA9IHRoaXMubG9nTmFtZXNwYWNlVXNlZChkZXNjcmlwdG9yLm5zKTtcbiAgcmV0dXJuIGdldFByb3BlcnR5TnMoZWZmZWN0aXZlTnMsIGRlc2NyaXB0b3IpO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLmlzTG9jYWxOcyA9IGZ1bmN0aW9uKG5zKSB7XG4gIHJldHVybiBucy51cmkgPT09IHRoaXMubnMudXJpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGFjdHVhbCBucyBhdHRyaWJ1dGUgbmFtZSBmb3IgdGhlIGdpdmVuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VsZW1lbnQuaW5oZXJpdGVkPWZhbHNlXVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gbnNOYW1lXG4gKi9cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5uc0F0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgdmFyIG5zO1xuXG4gIGlmIChpc1N0cmluZyhlbGVtZW50KSkge1xuICAgIG5zID0gcGFyc2VOYW1lTlMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgbnMgPSBlbGVtZW50Lm5zO1xuICB9XG5cbiAgLy8gcmV0dXJuIGp1c3QgbG9jYWwgbmFtZSBmb3IgaW5oZXJpdGVkIGF0dHJpYnV0ZXNcbiAgaWYgKGVsZW1lbnQuaW5oZXJpdGVkKSB7XG4gICAgcmV0dXJuIHsgbG9jYWxOYW1lOiBucy5sb2NhbE5hbWUgfTtcbiAgfVxuXG4gIC8vIHBhcnNlICsgbG9nIGVmZmVjdGl2ZSBuc1xuICB2YXIgZWZmZWN0aXZlTnMgPSB0aGlzLmxvZ05hbWVzcGFjZVVzZWQobnMpO1xuXG4gIC8vIExPRyBBQ1RVQUwgbmFtZXNwYWNlIHVzZVxuICB0aGlzLmdldE5hbWVzcGFjZXMoKS5sb2dVc2VkKGVmZmVjdGl2ZU5zKTtcblxuICAvLyBzdHJpcCBwcmVmaXggaWYgc2FtZSBuYW1lc3BhY2UgbGlrZSBwYXJlbnRcbiAgaWYgKHRoaXMuaXNMb2NhbE5zKGVmZmVjdGl2ZU5zKSkge1xuICAgIHJldHVybiB7IGxvY2FsTmFtZTogbnMubG9jYWxOYW1lIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFzc2lnbih7IGxvY2FsTmFtZTogbnMubG9jYWxOYW1lIH0sIGVmZmVjdGl2ZU5zKTtcbiAgfVxufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLnBhcnNlR2VuZXJpY05zQXR0cmlidXRlcyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZWxlbWVudCkuZmlsdGVyKFxuICAgIChbIGtleSwgdmFsdWUgXSkgPT4gIWtleS5zdGFydHNXaXRoKCckJykgJiYgdGhpcy5wYXJzZU5zQXR0cmlidXRlKGVsZW1lbnQsIGtleSwgdmFsdWUpXG4gICkubWFwKFxuICAgIChbIGtleSwgdmFsdWUgXSkgPT4gKHsgbmFtZToga2V5LCB2YWx1ZTogdmFsdWUgfSlcbiAgKTtcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZUdlbmVyaWNDb250YWlubWVudHMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBib2R5ID0gZWxlbWVudC4kYm9keTtcblxuICBpZiAoYm9keSkge1xuICAgIHRoaXMuYm9keS5wdXNoKG5ldyBCb2R5U2VyaWFsaXplcigpLmJ1aWxkKHsgdHlwZTogJ1N0cmluZycgfSwgYm9keSkpO1xuICB9XG5cbiAgdmFyIGNoaWxkcmVuID0gZWxlbWVudC4kY2hpbGRyZW47XG5cbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgZm9yRWFjaChjaGlsZHJlbiwgY2hpbGQgPT4ge1xuICAgICAgdGhpcy5ib2R5LnB1c2gobmV3IEVsZW1lbnRTZXJpYWxpemVyKHRoaXMpLmJ1aWxkKGNoaWxkKSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZU5zQXR0cmlidXRlID0gZnVuY3Rpb24oZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIG1vZGVsID0gZWxlbWVudC4kbW9kZWw7XG5cbiAgdmFyIG5hbWVOcyA9IHBhcnNlTmFtZU5TKG5hbWUpO1xuXG4gIHZhciBucztcblxuICAvLyBwYXJzZSB4bWxuczpmb289XCJodHRwOi8vZm9vLmJhclwiXG4gIGlmIChuYW1lTnMucHJlZml4ID09PSAneG1sbnMnKSB7XG4gICAgbnMgPSB7IHByZWZpeDogbmFtZU5zLmxvY2FsTmFtZSwgdXJpOiB2YWx1ZSB9O1xuICB9XG5cbiAgLy8gcGFyc2UgeG1sbnM9XCJodHRwOi8vZm9vLmJhclwiXG4gIGlmICghbmFtZU5zLnByZWZpeCAmJiBuYW1lTnMubG9jYWxOYW1lID09PSAneG1sbnMnKSB7XG4gICAgbnMgPSB7IHVyaTogdmFsdWUgfTtcbiAgfVxuXG4gIGlmICghbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH07XG4gIH1cblxuICBpZiAobW9kZWwgJiYgbW9kZWwuZ2V0UGFja2FnZSh2YWx1ZSkpIHtcblxuICAgIC8vIHJlZ2lzdGVyIHdlbGwga25vd24gbmFtZXNwYWNlXG4gICAgdGhpcy5sb2dOYW1lc3BhY2UobnMsIHRydWUsIHRydWUpO1xuICB9IGVsc2Uge1xuXG4gICAgLy8gbG9nIGN1c3RvbSBuYW1lc3BhY2UgZGlyZWN0bHkgYXMgdXNlZFxuICAgIHZhciBhY3R1YWxOcyA9IHRoaXMubG9nTmFtZXNwYWNlVXNlZChucywgdHJ1ZSk7XG5cbiAgICB0aGlzLmdldE5hbWVzcGFjZXMoKS5sb2dVc2VkKGFjdHVhbE5zKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFBhcnNlIG5hbWVzcGFjZXMgYW5kIHJldHVybiBhIGxpc3Qgb2YgbGVmdCBvdmVyIGdlbmVyaWMgYXR0cmlidXRlc1xuICpcbiAqIEBwYXJhbSAge09iamVjdH0gZWxlbWVudFxuICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn1cbiAqL1xuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLnBhcnNlTnNBdHRyaWJ1dGVzID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGdlbmVyaWNBdHRycyA9IGVsZW1lbnQuJGF0dHJzO1xuXG4gIHZhciBhdHRyaWJ1dGVzID0gW107XG5cbiAgLy8gcGFyc2UgbmFtZXNwYWNlIGF0dHJpYnV0ZXMgZmlyc3RcbiAgLy8gYW5kIGxvZyB0aGVtLiBwdXNoIG5vbiBuYW1lc3BhY2UgYXR0cmlidXRlcyB0byBhIGxpc3RcbiAgLy8gYW5kIHByb2Nlc3MgdGhlbSBsYXRlclxuICBmb3JFYWNoKGdlbmVyaWNBdHRycywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblxuICAgIHZhciBub25Oc0F0dHIgPSBzZWxmLnBhcnNlTnNBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSwgdmFsdWUpO1xuXG4gICAgaWYgKG5vbk5zQXR0cikge1xuICAgICAgYXR0cmlidXRlcy5wdXNoKG5vbk5zQXR0cik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gYXR0cmlidXRlcztcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZUdlbmVyaWNBdHRyaWJ1dGVzID0gZnVuY3Rpb24oZWxlbWVudCwgYXR0cmlidXRlcykge1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmb3JFYWNoKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGF0dHIpIHtcblxuICAgIHRyeSB7XG4gICAgICBzZWxmLmFkZEF0dHJpYnV0ZShzZWxmLm5zQXR0cmlidXRlTmFtZShhdHRyLm5hbWUpLCBhdHRyLnZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2FybihcbiAgICAgICAgYG1pc3NpbmcgbmFtZXNwYWNlIGluZm9ybWF0aW9uIGZvciA8JHtcbiAgICAgICAgICBhdHRyLm5hbWVcbiAgICAgICAgfT0keyBhdHRyLnZhbHVlIH0+IG9uYCwgZWxlbWVudCwgZVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLnBhcnNlQ29udGFpbm1lbnRzID0gZnVuY3Rpb24ocHJvcGVydGllcykge1xuXG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGJvZHkgPSB0aGlzLmJvZHksXG4gICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gIGZvckVhY2gocHJvcGVydGllcywgZnVuY3Rpb24ocCkge1xuICAgIHZhciB2YWx1ZSA9IGVsZW1lbnQuZ2V0KHAubmFtZSksXG4gICAgICAgIGlzUmVmZXJlbmNlID0gcC5pc1JlZmVyZW5jZSxcbiAgICAgICAgaXNNYW55ID0gcC5pc01hbnk7XG5cbiAgICBpZiAoIWlzTWFueSkge1xuICAgICAgdmFsdWUgPSBbIHZhbHVlIF07XG4gICAgfVxuXG4gICAgaWYgKHAuaXNCb2R5KSB7XG4gICAgICBib2R5LnB1c2gobmV3IEJvZHlTZXJpYWxpemVyKCkuYnVpbGQocCwgdmFsdWVbMF0pKTtcbiAgICB9IGVsc2UgaWYgKGlzU2ltcGxlVHlwZShwLnR5cGUpKSB7XG4gICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbih2KSB7XG4gICAgICAgIGJvZHkucHVzaChuZXcgVmFsdWVTZXJpYWxpemVyKHNlbGYuYWRkVGFnTmFtZShzZWxmLm5zUHJvcGVydHlUYWdOYW1lKHApKSkuYnVpbGQocCwgdikpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc1JlZmVyZW5jZSkge1xuICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24odikge1xuICAgICAgICBib2R5LnB1c2gobmV3IFJlZmVyZW5jZVNlcmlhbGl6ZXIoc2VsZi5hZGRUYWdOYW1lKHNlbGYubnNQcm9wZXJ0eVRhZ05hbWUocCkpKS5idWlsZCh2KSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBhbGxvdyBzZXJpYWxpemF0aW9uIHZpYSB0eXBlXG4gICAgICAvLyByYXRoZXIgdGhhbiBlbGVtZW50IG5hbWVcbiAgICAgIHZhciBzZXJpYWxpemF0aW9uID0gZ2V0U2VyaWFsaXphdGlvbihwKTtcblxuICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24odikge1xuICAgICAgICB2YXIgc2VyaWFsaXplcjtcblxuICAgICAgICBpZiAoc2VyaWFsaXphdGlvbikge1xuICAgICAgICAgIGlmIChzZXJpYWxpemF0aW9uID09PSBTRVJJQUxJWkVfUFJPUEVSVFkpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZXIgPSBuZXcgRWxlbWVudFNlcmlhbGl6ZXIoc2VsZiwgcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZXIgPSBuZXcgVHlwZVNlcmlhbGl6ZXIoc2VsZiwgcCwgc2VyaWFsaXphdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlcmlhbGl6ZXIgPSBuZXcgRWxlbWVudFNlcmlhbGl6ZXIoc2VsZik7XG4gICAgICAgIH1cblxuICAgICAgICBib2R5LnB1c2goc2VyaWFsaXplci5idWlsZCh2KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLmdldE5hbWVzcGFjZXMgPSBmdW5jdGlvbihsb2NhbCkge1xuXG4gIHZhciBuYW1lc3BhY2VzID0gdGhpcy5uYW1lc3BhY2VzLFxuICAgICAgcGFyZW50ID0gdGhpcy5wYXJlbnQsXG4gICAgICBwYXJlbnROYW1lc3BhY2VzO1xuXG4gIGlmICghbmFtZXNwYWNlcykge1xuICAgIHBhcmVudE5hbWVzcGFjZXMgPSBwYXJlbnQgJiYgcGFyZW50LmdldE5hbWVzcGFjZXMoKTtcblxuICAgIGlmIChsb2NhbCB8fCAhcGFyZW50TmFtZXNwYWNlcykge1xuICAgICAgdGhpcy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcyA9IG5ldyBOYW1lc3BhY2VzKHBhcmVudE5hbWVzcGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lc3BhY2VzID0gcGFyZW50TmFtZXNwYWNlcztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZXNwYWNlcztcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5sb2dOYW1lc3BhY2UgPSBmdW5jdGlvbihucywgd2VsbGtub3duLCBsb2NhbCkge1xuICB2YXIgbmFtZXNwYWNlcyA9IHRoaXMuZ2V0TmFtZXNwYWNlcyhsb2NhbCk7XG5cbiAgdmFyIG5zVXJpID0gbnMudXJpLFxuICAgICAgbnNQcmVmaXggPSBucy5wcmVmaXg7XG5cbiAgdmFyIGV4aXN0aW5nID0gbmFtZXNwYWNlcy5ieVVyaShuc1VyaSk7XG5cbiAgaWYgKCFleGlzdGluZyB8fCBsb2NhbCkge1xuICAgIG5hbWVzcGFjZXMuYWRkKG5zLCB3ZWxsa25vd24pO1xuICB9XG5cbiAgbmFtZXNwYWNlcy5tYXBQcmVmaXgobnNQcmVmaXgsIG5zVXJpKTtcblxuICByZXR1cm4gbnM7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUubG9nTmFtZXNwYWNlVXNlZCA9IGZ1bmN0aW9uKG5zLCBsb2NhbCkge1xuICB2YXIgbmFtZXNwYWNlcyA9IHRoaXMuZ2V0TmFtZXNwYWNlcyhsb2NhbCk7XG5cbiAgLy8gbnMgbWF5IGJlXG4gIC8vXG4gIC8vICAgKiBwcmVmaXggb25seVxuICAvLyAgICogcHJlZml4OnVyaVxuICAvLyAgICogbG9jYWxOYW1lIG9ubHlcblxuICB2YXIgcHJlZml4ID0gbnMucHJlZml4LFxuICAgICAgdXJpID0gbnMudXJpLFxuICAgICAgbmV3UHJlZml4LCBpZHgsXG4gICAgICB3ZWxsa25vd25Vcmk7XG5cbiAgLy8gaGFuZGxlIGFub255bW91cyBuYW1lc3BhY2VzIChlbGVtZW50Rm9ybT11bnF1YWxpZmllZCksIGNmLiAjMjNcbiAgaWYgKCFwcmVmaXggJiYgIXVyaSkge1xuICAgIHJldHVybiB7IGxvY2FsTmFtZTogbnMubG9jYWxOYW1lIH07XG4gIH1cblxuICB3ZWxsa25vd25VcmkgPSBuYW1lc3BhY2VzLmRlZmF1bHRVcmlCeVByZWZpeChwcmVmaXgpO1xuXG4gIHVyaSA9IHVyaSB8fCB3ZWxsa25vd25VcmkgfHwgbmFtZXNwYWNlcy51cmlCeVByZWZpeChwcmVmaXgpO1xuXG4gIGlmICghdXJpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdubyBuYW1lc3BhY2UgdXJpIGdpdmVuIGZvciBwcmVmaXggPCcgKyBwcmVmaXggKyAnPicpO1xuICB9XG5cbiAgbnMgPSBuYW1lc3BhY2VzLmJ5VXJpKHVyaSk7XG5cbiAgLy8gcmVnaXN0ZXIgbmV3IGRlZmF1bHQgcHJlZml4IDx4bWxucz4gaW4gbG9jYWwgc2NvcGVcbiAgaWYgKCFucyAmJiAhcHJlZml4KSB7XG4gICAgbnMgPSB0aGlzLmxvZ05hbWVzcGFjZSh7IHVyaSB9LCB3ZWxsa25vd25VcmkgPT09IHVyaSwgdHJ1ZSk7XG4gIH1cblxuICBpZiAoIW5zKSB7XG4gICAgbmV3UHJlZml4ID0gcHJlZml4O1xuICAgIGlkeCA9IDE7XG5cbiAgICAvLyBmaW5kIGEgcHJlZml4IHRoYXQgaXMgbm90IG1hcHBlZCB5ZXRcbiAgICB3aGlsZSAobmFtZXNwYWNlcy51cmlCeVByZWZpeChuZXdQcmVmaXgpKSB7XG4gICAgICBuZXdQcmVmaXggPSBwcmVmaXggKyAnXycgKyBpZHgrKztcbiAgICB9XG5cbiAgICBucyA9IHRoaXMubG9nTmFtZXNwYWNlKHsgcHJlZml4OiBuZXdQcmVmaXgsIHVyaTogdXJpIH0sIHdlbGxrbm93blVyaSA9PT0gdXJpKTtcbiAgfVxuXG4gIGlmIChwcmVmaXgpIHtcbiAgICBuYW1lc3BhY2VzLm1hcFByZWZpeChwcmVmaXgsIHVyaSk7XG4gIH1cblxuICByZXR1cm4gbnM7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24ocHJvcGVydGllcykge1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gIGZvckVhY2gocHJvcGVydGllcywgZnVuY3Rpb24ocCkge1xuXG4gICAgdmFyIHZhbHVlID0gZWxlbWVudC5nZXQocC5uYW1lKTtcblxuICAgIGlmIChwLmlzUmVmZXJlbmNlKSB7XG5cbiAgICAgIGlmICghcC5pc01hbnkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKHYuaWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJRFJFRlMgaXMgYSB3aGl0ZXNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIHJlZmVyZW5jZXMuXG4gICAgICAgIHZhbHVlID0gdmFsdWVzLmpvaW4oJyAnKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHNlbGYuYWRkQXR0cmlidXRlKHNlbGYubnNBdHRyaWJ1dGVOYW1lKHApLCB2YWx1ZSk7XG4gIH0pO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLmFkZFRhZ05hbWUgPSBmdW5jdGlvbihuc1RhZ05hbWUpIHtcbiAgdmFyIGFjdHVhbE5zID0gdGhpcy5sb2dOYW1lc3BhY2VVc2VkKG5zVGFnTmFtZSk7XG5cbiAgdGhpcy5nZXROYW1lc3BhY2VzKCkubG9nVXNlZChhY3R1YWxOcyk7XG5cbiAgcmV0dXJuIG5zTmFtZShuc1RhZ05hbWUpO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBhdHRycyA9IHRoaXMuYXR0cnM7XG5cbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhbHVlID0gZXNjYXBlQXR0cih2YWx1ZSk7XG4gIH1cblxuICAvLyBkZS1kdXBsaWNhdGUgYXR0cmlidXRlc1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYnBtbi1pby9tb2RkbGUteG1sL2lzc3Vlcy82NlxuICB2YXIgaWR4ID0gZmluZEluZGV4KGF0dHJzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGVsZW1lbnQubmFtZS5sb2NhbE5hbWUgPT09IG5hbWUubG9jYWxOYW1lICYmXG4gICAgICBlbGVtZW50Lm5hbWUudXJpID09PSBuYW1lLnVyaSAmJlxuICAgICAgZWxlbWVudC5uYW1lLnByZWZpeCA9PT0gbmFtZS5wcmVmaXhcbiAgICApO1xuICB9KTtcblxuICB2YXIgYXR0ciA9IHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH07XG5cbiAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICBhdHRycy5zcGxpY2UoaWR4LCAxLCBhdHRyKTtcbiAgfSBlbHNlIHtcbiAgICBhdHRycy5wdXNoKGF0dHIpO1xuICB9XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplQXR0cmlidXRlcyA9IGZ1bmN0aW9uKHdyaXRlcikge1xuICB2YXIgYXR0cnMgPSB0aGlzLmF0dHJzLFxuICAgICAgbmFtZXNwYWNlcyA9IHRoaXMubmFtZXNwYWNlcztcblxuICBpZiAobmFtZXNwYWNlcykge1xuICAgIGF0dHJzID0gZ2V0TnNBdHRycyhuYW1lc3BhY2VzKS5jb25jYXQoYXR0cnMpO1xuICB9XG5cbiAgZm9yRWFjaChhdHRycywgZnVuY3Rpb24oYSkge1xuICAgIHdyaXRlclxuICAgICAgLmFwcGVuZCgnICcpXG4gICAgICAuYXBwZW5kKG5zTmFtZShhLm5hbWUpKS5hcHBlbmQoJz1cIicpLmFwcGVuZChhLnZhbHVlKS5hcHBlbmQoJ1wiJyk7XG4gIH0pO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZVRvID0gZnVuY3Rpb24od3JpdGVyKSB7XG4gIHZhciBmaXJzdEJvZHkgPSB0aGlzLmJvZHlbMF0sXG4gICAgICBpbmRlbnQgPSBmaXJzdEJvZHkgJiYgZmlyc3RCb2R5LmNvbnN0cnVjdG9yICE9PSBCb2R5U2VyaWFsaXplcjtcblxuICB3cml0ZXJcbiAgICAuYXBwZW5kSW5kZW50KClcbiAgICAuYXBwZW5kKCc8JyArIHRoaXMudGFnTmFtZSk7XG5cbiAgdGhpcy5zZXJpYWxpemVBdHRyaWJ1dGVzKHdyaXRlcik7XG5cbiAgd3JpdGVyLmFwcGVuZChmaXJzdEJvZHkgPyAnPicgOiAnIC8+Jyk7XG5cbiAgaWYgKGZpcnN0Qm9keSkge1xuXG4gICAgaWYgKGluZGVudCkge1xuICAgICAgd3JpdGVyXG4gICAgICAgIC5hcHBlbmROZXdMaW5lKClcbiAgICAgICAgLmluZGVudCgpO1xuICAgIH1cblxuICAgIGZvckVhY2godGhpcy5ib2R5LCBmdW5jdGlvbihiKSB7XG4gICAgICBiLnNlcmlhbGl6ZVRvKHdyaXRlcik7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5kZW50KSB7XG4gICAgICB3cml0ZXJcbiAgICAgICAgLnVuaW5kZW50KClcbiAgICAgICAgLmFwcGVuZEluZGVudCgpO1xuICAgIH1cblxuICAgIHdyaXRlci5hcHBlbmQoJzwvJyArIHRoaXMudGFnTmFtZSArICc+Jyk7XG4gIH1cblxuICB3cml0ZXIuYXBwZW5kTmV3TGluZSgpO1xufTtcblxuLyoqXG4gKiBBIHNlcmlhbGl6ZXIgZm9yIHR5cGVzIHRoYXQgaGFuZGxlcyBzZXJpYWxpemF0aW9uIG9mIGRhdGEgdHlwZXNcbiAqL1xuZnVuY3Rpb24gVHlwZVNlcmlhbGl6ZXIocGFyZW50LCBwcm9wZXJ0eURlc2NyaXB0b3IsIHNlcmlhbGl6YXRpb24pIHtcbiAgRWxlbWVudFNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBwYXJlbnQsIHByb3BlcnR5RGVzY3JpcHRvcik7XG5cbiAgdGhpcy5zZXJpYWxpemF0aW9uID0gc2VyaWFsaXphdGlvbjtcbn1cblxuaW5oZXJpdHMoVHlwZVNlcmlhbGl6ZXIsIEVsZW1lbnRTZXJpYWxpemVyKTtcblxuVHlwZVNlcmlhbGl6ZXIucHJvdG90eXBlLnBhcnNlTnNBdHRyaWJ1dGVzID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gIC8vIGV4dHJhY3RlZCBhdHRyaWJ1dGVzIHdpdGggc2VyaWFsaXphdGlvbiBhdHRyaWJ1dGVcbiAgLy8gPHR5cGU9dHlwZU5hbWU+IHN0cmlwcGVkOyBpdCBtYXkgYmUgbGF0ZXJcbiAgdmFyIGF0dHJpYnV0ZXMgPSBFbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VOc0F0dHJpYnV0ZXMuY2FsbCh0aGlzLCBlbGVtZW50KS5maWx0ZXIoXG4gICAgYXR0ciA9PiBhdHRyLm5hbWUgIT09IHRoaXMuc2VyaWFsaXphdGlvblxuICApO1xuXG4gIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC4kZGVzY3JpcHRvcjtcblxuICAvLyBvbmx5IHNlcmlhbGl6ZSA8dHlwZT10eXBlTmFtZT4gaWYgbmVjZXNzYXJ5XG4gIGlmIChkZXNjcmlwdG9yLm5hbWUgPT09IHRoaXMucHJvcGVydHlEZXNjcmlwdG9yLnR5cGUpIHtcbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfVxuXG4gIHZhciB0eXBlTnMgPSB0aGlzLnR5cGVOcyA9IHRoaXMubnNUYWdOYW1lKGRlc2NyaXB0b3IpO1xuICB0aGlzLmdldE5hbWVzcGFjZXMoKS5sb2dVc2VkKHRoaXMudHlwZU5zKTtcblxuICAvLyBhZGQgeHNpOnR5cGUgYXR0cmlidXRlIHRvIHJlcHJlc2VudCB0aGUgZWxlbWVudHNcbiAgLy8gYWN0dWFsIHR5cGVcblxuICB2YXIgcGtnID0gZWxlbWVudC4kbW9kZWwuZ2V0UGFja2FnZSh0eXBlTnMudXJpKSxcbiAgICAgIHR5cGVQcmVmaXggPSAocGtnLnhtbCAmJiBwa2cueG1sLnR5cGVQcmVmaXgpIHx8ICcnO1xuXG4gIHRoaXMuYWRkQXR0cmlidXRlKFxuICAgIHRoaXMubnNBdHRyaWJ1dGVOYW1lKHRoaXMuc2VyaWFsaXphdGlvbiksXG4gICAgKHR5cGVOcy5wcmVmaXggPyB0eXBlTnMucHJlZml4ICsgJzonIDogJycpICsgdHlwZVByZWZpeCArIGRlc2NyaXB0b3IubnMubG9jYWxOYW1lXG4gICk7XG5cbiAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59O1xuXG5UeXBlU2VyaWFsaXplci5wcm90b3R5cGUuaXNMb2NhbE5zID0gZnVuY3Rpb24obnMpIHtcbiAgcmV0dXJuIG5zLnVyaSA9PT0gKHRoaXMudHlwZU5zIHx8IHRoaXMubnMpLnVyaTtcbn07XG5cbmZ1bmN0aW9uIFNhdmluZ1dyaXRlcigpIHtcbiAgdGhpcy52YWx1ZSA9ICcnO1xuXG4gIHRoaXMud3JpdGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB0aGlzLnZhbHVlICs9IHN0cjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gRm9ybWF0aW5nV3JpdGVyKG91dCwgZm9ybWF0KSB7XG5cbiAgdmFyIGluZGVudCA9IFsgJycgXTtcblxuICB0aGlzLmFwcGVuZCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIG91dC53cml0ZShzdHIpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdGhpcy5hcHBlbmROZXdMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgb3V0LndyaXRlKCdcXG4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLmFwcGVuZEluZGVudCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgIG91dC53cml0ZShpbmRlbnQuam9pbignICAnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdGhpcy5pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICBpbmRlbnQucHVzaCgnJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdGhpcy51bmluZGVudCA9IGZ1bmN0aW9uKCkge1xuICAgIGluZGVudC5wb3AoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHdyaXRlciBmb3IgbWV0YS1tb2RlbCBiYWNrZWQgZG9jdW1lbnQgdHJlZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvdXRwdXQgb3B0aW9ucyB0byBwYXNzIGludG8gdGhlIHdyaXRlclxuICovXG5mdW5jdGlvbiBXcml0ZXIob3B0aW9ucykge1xuXG4gIG9wdGlvbnMgPSBhc3NpZ24oeyBmb3JtYXQ6IGZhbHNlLCBwcmVhbWJsZTogdHJ1ZSB9LCBvcHRpb25zIHx8IHt9KTtcblxuICBmdW5jdGlvbiB0b1hNTCh0cmVlLCB3cml0ZXIpIHtcbiAgICB2YXIgaW50ZXJuYWxXcml0ZXIgPSB3cml0ZXIgfHwgbmV3IFNhdmluZ1dyaXRlcigpO1xuICAgIHZhciBmb3JtYXRpbmdXcml0ZXIgPSBuZXcgRm9ybWF0aW5nV3JpdGVyKGludGVybmFsV3JpdGVyLCBvcHRpb25zLmZvcm1hdCk7XG5cbiAgICBpZiAob3B0aW9ucy5wcmVhbWJsZSkge1xuICAgICAgZm9ybWF0aW5nV3JpdGVyLmFwcGVuZChYTUxfUFJFQU1CTEUpO1xuICAgIH1cblxuICAgIHZhciBzZXJpYWxpemVyID0gbmV3IEVsZW1lbnRTZXJpYWxpemVyKCk7XG5cbiAgICB2YXIgbW9kZWwgPSB0cmVlLiRtb2RlbDtcblxuICAgIHNlcmlhbGl6ZXIuZ2V0TmFtZXNwYWNlcygpLm1hcERlZmF1bHRQcmVmaXhlcyhnZXREZWZhdWx0UHJlZml4TWFwcGluZ3MobW9kZWwpKTtcblxuICAgIHNlcmlhbGl6ZXIuYnVpbGQodHJlZSkuc2VyaWFsaXplVG8oZm9ybWF0aW5nV3JpdGVyKTtcblxuICAgIGlmICghd3JpdGVyKSB7XG4gICAgICByZXR1cm4gaW50ZXJuYWxXcml0ZXIudmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b1hNTDogdG9YTUxcbiAgfTtcbn1cblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vXG5cbi8qKlxuICogQHBhcmFtIHtNb2RkbGV9IG1vZGVsXG4gKlxuICogQHJldHVybiB7IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfSBtYXAgZnJvbSBwcmVmaXggdG8gVVJJXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRQcmVmaXhNYXBwaW5ncyhtb2RlbCkge1xuXG4gIGNvbnN0IG5zTWFwID0gbW9kZWwuY29uZmlnICYmIG1vZGVsLmNvbmZpZy5uc01hcCB8fCB7fTtcblxuICBjb25zdCBwcmVmaXhNYXAgPSB7fTtcblxuICAvLyB7IHByZWZpeCAtPiB1cmkgfVxuICBmb3IgKGNvbnN0IHByZWZpeCBpbiBERUZBVUxUX05TX01BUCkge1xuICAgIHByZWZpeE1hcFtwcmVmaXhdID0gREVGQVVMVF9OU19NQVBbcHJlZml4XTtcbiAgfVxuXG4gIC8vIHsgdXJpIC0+IHByZWZpeCB9XG4gIGZvciAoY29uc3QgdXJpIGluIG5zTWFwKSB7XG4gICAgY29uc3QgcHJlZml4ID0gbnNNYXBbdXJpXTtcblxuICAgIHByZWZpeE1hcFtwcmVmaXhdID0gdXJpO1xuICB9XG5cbiAgZm9yIChjb25zdCBwa2cgb2YgbW9kZWwuZ2V0UGFja2FnZXMoKSkge1xuICAgIHByZWZpeE1hcFtwa2cucHJlZml4XSA9IHBrZy51cmk7XG4gIH1cblxuICByZXR1cm4gcHJlZml4TWFwO1xufVxuXG5leHBvcnQgeyBSZWFkZXIsIFdyaXRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/moddle-xml/dist/index.js\n");

/***/ })

};
;