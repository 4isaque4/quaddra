"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tiny-svg";
exports.ids = ["vendor-chunks/tiny-svg"];
exports.modules = {

/***/ "(ssr)/../../node_modules/tiny-svg/dist/index.esm.js":
/*!*****************************************************!*\
  !*** ../../node_modules/tiny-svg/dist/index.esm.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   append: () => (/* binding */ append),\n/* harmony export */   appendTo: () => (/* binding */ appendTo),\n/* harmony export */   attr: () => (/* binding */ attr),\n/* harmony export */   classes: () => (/* binding */ classes),\n/* harmony export */   clear: () => (/* binding */ clear),\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   createMatrix: () => (/* binding */ createMatrix),\n/* harmony export */   createPoint: () => (/* binding */ createPoint),\n/* harmony export */   createTransform: () => (/* binding */ createTransform),\n/* harmony export */   innerSVG: () => (/* binding */ innerSVG),\n/* harmony export */   off: () => (/* binding */ off),\n/* harmony export */   on: () => (/* binding */ on),\n/* harmony export */   prepend: () => (/* binding */ prepend),\n/* harmony export */   prependTo: () => (/* binding */ prependTo),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   replace: () => (/* binding */ replace),\n/* harmony export */   select: () => (/* binding */ select),\n/* harmony export */   selectAll: () => (/* binding */ selectAll),\n/* harmony export */   transform: () => (/* binding */ transform)\n/* harmony export */ });\nfunction ensureImported(element, target) {\n\n  if (element.ownerDocument !== target.ownerDocument) {\n    try {\n\n      // may fail on webkit\n      return target.ownerDocument.importNode(element, true);\n    } catch (e) {\n\n      // ignore\n    }\n  }\n\n  return element;\n}\n\n/**\n * appendTo utility\n */\n\n\n/**\n * Append a node to a target element and return the appended node.\n *\n * @param  {SVGElement} element\n * @param  {SVGElement} target\n *\n * @return {SVGElement} the appended node\n */\nfunction appendTo(element, target) {\n  return target.appendChild(ensureImported(element, target));\n}\n\n/**\n * append utility\n */\n\n\n/**\n * Append a node to an element\n *\n * @param  {SVGElement} element\n * @param  {SVGElement} node\n *\n * @return {SVGElement} the element\n */\nfunction append(target, node) {\n  appendTo(node, target);\n  return target;\n}\n\n/**\n * attribute accessor utility\n */\n\nvar LENGTH_ATTR = 2;\n\nvar CSS_PROPERTIES = {\n  'alignment-baseline': 1,\n  'baseline-shift': 1,\n  'clip': 1,\n  'clip-path': 1,\n  'clip-rule': 1,\n  'color': 1,\n  'color-interpolation': 1,\n  'color-interpolation-filters': 1,\n  'color-profile': 1,\n  'color-rendering': 1,\n  'cursor': 1,\n  'direction': 1,\n  'display': 1,\n  'dominant-baseline': 1,\n  'enable-background': 1,\n  'fill': 1,\n  'fill-opacity': 1,\n  'fill-rule': 1,\n  'filter': 1,\n  'flood-color': 1,\n  'flood-opacity': 1,\n  'font': 1,\n  'font-family': 1,\n  'font-size': LENGTH_ATTR,\n  'font-size-adjust': 1,\n  'font-stretch': 1,\n  'font-style': 1,\n  'font-variant': 1,\n  'font-weight': 1,\n  'glyph-orientation-horizontal': 1,\n  'glyph-orientation-vertical': 1,\n  'image-rendering': 1,\n  'kerning': 1,\n  'letter-spacing': 1,\n  'lighting-color': 1,\n  'marker': 1,\n  'marker-end': 1,\n  'marker-mid': 1,\n  'marker-start': 1,\n  'mask': 1,\n  'opacity': 1,\n  'overflow': 1,\n  'pointer-events': 1,\n  'shape-rendering': 1,\n  'stop-color': 1,\n  'stop-opacity': 1,\n  'stroke': 1,\n  'stroke-dasharray': 1,\n  'stroke-dashoffset': 1,\n  'stroke-linecap': 1,\n  'stroke-linejoin': 1,\n  'stroke-miterlimit': 1,\n  'stroke-opacity': 1,\n  'stroke-width': LENGTH_ATTR,\n  'text-anchor': 1,\n  'text-decoration': 1,\n  'text-rendering': 1,\n  'unicode-bidi': 1,\n  'visibility': 1,\n  'word-spacing': 1,\n  'writing-mode': 1\n};\n\n\nfunction getAttribute(node, name) {\n  if (CSS_PROPERTIES[name]) {\n    return node.style[name];\n  } else {\n    return node.getAttributeNS(null, name);\n  }\n}\n\nfunction setAttribute(node, name, value) {\n  var hyphenated = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n\n  var type = CSS_PROPERTIES[hyphenated];\n\n  if (type) {\n\n    // append pixel unit, unless present\n    if (type === LENGTH_ATTR && typeof value === 'number') {\n      value = String(value) + 'px';\n    }\n\n    node.style[hyphenated] = value;\n  } else {\n    node.setAttributeNS(null, name, value);\n  }\n}\n\nfunction setAttributes(node, attrs) {\n\n  var names = Object.keys(attrs), i, name;\n\n  for (i = 0, name; (name = names[i]); i++) {\n    setAttribute(node, name, attrs[name]);\n  }\n}\n\n/**\n * Gets or sets raw attributes on a node.\n *\n * @param  {SVGElement} node\n * @param  {Object} [attrs]\n * @param  {String} [name]\n * @param  {String} [value]\n *\n * @return {String}\n */\nfunction attr(node, name, value) {\n  if (typeof name === 'string') {\n    if (value !== undefined) {\n      setAttribute(node, name, value);\n    } else {\n      return getAttribute(node, name);\n    }\n  } else {\n    setAttributes(node, name);\n  }\n\n  return node;\n}\n\n/**\r\n * Taken from https://github.com/component/classes\r\n *\r\n * Without the component bits.\r\n */\r\n\r\n/**\r\n * toString reference.\r\n */\r\n\r\nconst toString = Object.prototype.toString;\r\n\r\n/**\r\n  * Wrap `el` in a `ClassList`.\r\n  *\r\n  * @param {Element} el\r\n  * @return {ClassList}\r\n  * @api public\r\n  */\r\n\r\nfunction classes(el) {\r\n  return new ClassList(el);\r\n}\r\n\r\nfunction ClassList(el) {\r\n  if (!el || !el.nodeType) {\r\n    throw new Error('A DOM element reference is required');\r\n  }\r\n  this.el = el;\r\n  this.list = el.classList;\r\n}\r\n\r\n/**\r\n  * Add class `name` if not already present.\r\n  *\r\n  * @param {String} name\r\n  * @return {ClassList}\r\n  * @api public\r\n  */\r\n\r\nClassList.prototype.add = function(name) {\r\n  this.list.add(name);\r\n  return this;\r\n};\r\n\r\n/**\r\n  * Remove class `name` when present, or\r\n  * pass a regular expression to remove\r\n  * any which match.\r\n  *\r\n  * @param {String|RegExp} name\r\n  * @return {ClassList}\r\n  * @api public\r\n  */\r\n\r\nClassList.prototype.remove = function(name) {\r\n  if ('[object RegExp]' == toString.call(name)) {\r\n    return this.removeMatching(name);\r\n  }\r\n\r\n  this.list.remove(name);\r\n  return this;\r\n};\r\n\r\n/**\r\n  * Remove all classes matching `re`.\r\n  *\r\n  * @param {RegExp} re\r\n  * @return {ClassList}\r\n  * @api private\r\n  */\r\n\r\nClassList.prototype.removeMatching = function(re) {\r\n  const arr = this.array();\r\n  for (let i = 0; i < arr.length; i++) {\r\n    if (re.test(arr[i])) {\r\n      this.remove(arr[i]);\r\n    }\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n  * Toggle class `name`, can force state via `force`.\r\n  *\r\n  * For browsers that support classList, but do not support `force` yet,\r\n  * the mistake will be detected and corrected.\r\n  *\r\n  * @param {String} name\r\n  * @param {Boolean} force\r\n  * @return {ClassList}\r\n  * @api public\r\n  */\r\n\r\nClassList.prototype.toggle = function(name, force) {\r\n  if ('undefined' !== typeof force) {\r\n    if (force !== this.list.toggle(name, force)) {\r\n      this.list.toggle(name); // toggle again to correct\r\n    }\r\n  } else {\r\n    this.list.toggle(name);\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n  * Return an array of classes.\r\n  *\r\n  * @return {Array}\r\n  * @api public\r\n  */\r\n\r\nClassList.prototype.array = function() {\r\n  return Array.from(this.list);\r\n};\r\n\r\n/**\r\n  * Check if class `name` is present.\r\n  *\r\n  * @param {String} name\r\n  * @return {ClassList}\r\n  * @api public\r\n  */\r\n\r\nClassList.prototype.has =\r\n ClassList.prototype.contains = function(name) {\r\n   return this.list.contains(name);\r\n };\n\n/**\n * Clear utility\n */\n\n/**\n * Removes all children from the given element\n *\n * @param  {SVGElement} element\n * @return {Element} the element (for chaining)\n */\nfunction clear(element) {\n  var child;\n\n  while ((child = element.firstChild)) {\n    element.removeChild(child);\n  }\n\n  return element;\n}\n\nfunction clone(element) {\n  return element.cloneNode(true);\n}\n\nvar ns = {\n  svg: 'http://www.w3.org/2000/svg'\n};\n\n/**\n * DOM parsing utility\n */\n\n\nvar SVG_START = '<svg xmlns=\"' + ns.svg + '\"';\n\nfunction parse(svg) {\n\n  var unwrap = false;\n\n  // ensure we import a valid svg document\n  if (svg.substring(0, 4) === '<svg') {\n    if (svg.indexOf(ns.svg) === -1) {\n      svg = SVG_START + svg.substring(4);\n    }\n  } else {\n\n    // namespace svg\n    svg = SVG_START + '>' + svg + '</svg>';\n    unwrap = true;\n  }\n\n  var parsed = parseDocument(svg);\n\n  if (!unwrap) {\n    return parsed;\n  }\n\n  var fragment = document.createDocumentFragment();\n\n  var parent = parsed.firstChild;\n\n  while (parent.firstChild) {\n    fragment.appendChild(parent.firstChild);\n  }\n\n  return fragment;\n}\n\nfunction parseDocument(svg) {\n\n  var parser;\n\n  // parse\n  parser = new DOMParser();\n  parser.async = false;\n\n  return parser.parseFromString(svg, 'text/xml');\n}\n\n/**\n * Create utility for SVG elements\n */\n\n\n\n/**\n * Create a specific type from name or SVG markup.\n *\n * @param {String} name the name or markup of the element\n * @param {Object} [attrs] attributes to set on the element\n *\n * @returns {SVGElement}\n */\nfunction create(name, attrs) {\n  var element;\n\n  name = name.trim();\n\n  if (name.charAt(0) === '<') {\n    element = parse(name).firstChild;\n    element = document.importNode(element, true);\n  } else {\n    element = document.createElementNS(ns.svg, name);\n  }\n\n  if (attrs) {\n    attr(element, attrs);\n  }\n\n  return element;\n}\n\n/**\n * Events handling utility\n */\n\nfunction on(node, event, listener, useCapture) {\n  node.addEventListener(event, listener, useCapture);\n}\n\nfunction off(node, event, listener, useCapture) {\n  node.removeEventListener(event, listener, useCapture);\n}\n\n/**\n * Geometry helpers\n */\n\n\n// fake node used to instantiate svg geometry elements\nvar node = null;\n\nfunction getNode() {\n  if (node === null) {\n    node = create('svg');\n  }\n\n  return node;\n}\n\nfunction extend(object, props) {\n  var i, k, keys = Object.keys(props);\n\n  for (i = 0; (k = keys[i]); i++) {\n    object[k] = props[k];\n  }\n\n  return object;\n}\n\n\nfunction createPoint(x, y) {\n  var point = getNode().createSVGPoint();\n\n  switch (arguments.length) {\n  case 0:\n    return point;\n  case 2:\n    x = {\n      x: x,\n      y: y\n    };\n    break;\n  }\n\n  return extend(point, x);\n}\n\n/**\n * Create matrix via args.\n *\n * @example\n *\n * createMatrix({ a: 1, b: 1 });\n * createMatrix();\n * createMatrix(1, 2, 0, 0, 30, 20);\n *\n * @return {SVGMatrix}\n */\nfunction createMatrix(a, b, c, d, e, f) {\n  var matrix = getNode().createSVGMatrix();\n\n  switch (arguments.length) {\n  case 0:\n    return matrix;\n  case 1:\n    return extend(matrix, a);\n  case 6:\n    return extend(matrix, {\n      a: a,\n      b: b,\n      c: c,\n      d: d,\n      e: e,\n      f: f\n    });\n  }\n}\n\nfunction createTransform(matrix) {\n  if (matrix) {\n    return getNode().createSVGTransformFromMatrix(matrix);\n  } else {\n    return getNode().createSVGTransform();\n  }\n}\n\n/**\n * Serialization util\n */\n\nvar TEXT_ENTITIES = /([&<>]{1})/g;\nvar ATTR_ENTITIES = /([&<>\\n\\r\"]{1})/g;\n\nvar ENTITY_REPLACEMENT = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '\\''\n};\n\nfunction escape(str, pattern) {\n\n  function replaceFn(match, entity) {\n    return ENTITY_REPLACEMENT[entity] || entity;\n  }\n\n  return str.replace(pattern, replaceFn);\n}\n\nfunction serialize(node, output) {\n\n  var i, len, attrMap, attrNode, childNodes;\n\n  switch (node.nodeType) {\n\n  // TEXT\n  case 3:\n\n    // replace special XML characters\n    output.push(escape(node.textContent, TEXT_ENTITIES));\n    break;\n\n  // ELEMENT\n  case 1:\n    output.push('<', node.tagName);\n\n    if (node.hasAttributes()) {\n      attrMap = node.attributes;\n      for (i = 0, len = attrMap.length; i < len; ++i) {\n        attrNode = attrMap.item(i);\n        output.push(' ', attrNode.name, '=\"', escape(attrNode.value, ATTR_ENTITIES), '\"');\n      }\n    }\n\n    if (node.hasChildNodes()) {\n      output.push('>');\n      childNodes = node.childNodes;\n      for (i = 0, len = childNodes.length; i < len; ++i) {\n        serialize(childNodes.item(i), output);\n      }\n      output.push('</', node.tagName, '>');\n    } else {\n      output.push('/>');\n    }\n    break;\n\n  // COMMENT\n  case 8:\n    output.push('<!--', escape(node.nodeValue, TEXT_ENTITIES), '-->');\n    break;\n\n  // CDATA\n  case 4:\n    output.push('<![CDATA[', node.nodeValue, ']]>');\n    break;\n\n  default:\n    throw new Error('unable to handle node ' + node.nodeType);\n  }\n\n  return output;\n}\n\n/**\n * innerHTML like functionality for SVG elements.\n * based on innerSVG (https://code.google.com/p/innersvg)\n */\n\n\n\nfunction set(element, svg) {\n\n  var parsed = parse(svg);\n\n  // clear element contents\n  clear(element);\n\n  if (!svg) {\n    return;\n  }\n\n  if (!isFragment(parsed)) {\n\n    // extract <svg> from parsed document\n    parsed = parsed.documentElement;\n  }\n\n  var nodes = slice(parsed.childNodes);\n\n  // import + append each node\n  for (var i = 0; i < nodes.length; i++) {\n    appendTo(nodes[i], element);\n  }\n\n}\n\nfunction get(element) {\n  var child = element.firstChild,\n      output = [];\n\n  while (child) {\n    serialize(child, output);\n    child = child.nextSibling;\n  }\n\n  return output.join('');\n}\n\nfunction isFragment(node) {\n  return node.nodeName === '#document-fragment';\n}\n\nfunction innerSVG(element, svg) {\n\n  if (svg !== undefined) {\n\n    try {\n      set(element, svg);\n    } catch (e) {\n      throw new Error('error parsing SVG: ' + e.message);\n    }\n\n    return element;\n  } else {\n    return get(element);\n  }\n}\n\n\nfunction slice(arr) {\n  return Array.prototype.slice.call(arr);\n}\n\n/**\n * Selection utilities\n */\n\nfunction select(node, selector) {\n  return node.querySelector(selector);\n}\n\nfunction selectAll(node, selector) {\n  var nodes = node.querySelectorAll(selector);\n\n  return [].map.call(nodes, function(element) {\n    return element;\n  });\n}\n\n/**\n * prependTo utility\n */\n\n\n/**\n * Prepend a node to a target element and return the prepended node.\n *\n * @param  {SVGElement} node\n * @param  {SVGElement} target\n *\n * @return {SVGElement} the prepended node\n */\nfunction prependTo(node, target) {\n  return target.insertBefore(ensureImported(node, target), target.firstChild || null);\n}\n\n/**\n * prepend utility\n */\n\n\n/**\n * Prepend a node to a target element\n *\n * @param  {SVGElement} target\n * @param  {SVGElement} node\n *\n * @return {SVGElement} the target element\n */\nfunction prepend(target, node) {\n  prependTo(node, target);\n  return target;\n}\n\nfunction remove(element) {\n  var parent = element.parentNode;\n\n  if (parent) {\n    parent.removeChild(element);\n  }\n\n  return element;\n}\n\n/**\n * Replace utility\n */\n\n\nfunction replace(element, replacement) {\n  element.parentNode.replaceChild(ensureImported(replacement, element), element);\n  return replacement;\n}\n\n/**\n * transform accessor utility\n */\n\nfunction wrapMatrix(transformList, transform) {\n  if (transform instanceof SVGMatrix) {\n    return transformList.createSVGTransformFromMatrix(transform);\n  }\n\n  return transform;\n}\n\n\nfunction setTransforms(transformList, transforms) {\n  var i, t;\n\n  transformList.clear();\n\n  for (i = 0; (t = transforms[i]); i++) {\n    transformList.appendItem(wrapMatrix(transformList, t));\n  }\n}\n\n/**\n * Get or set the transforms on the given node.\n *\n * @param {SVGElement} node\n * @param  {SVGTransform|SVGMatrix|Array<SVGTransform|SVGMatrix>} [transforms]\n *\n * @return {SVGTransform} the consolidated transform\n */\nfunction transform(node, transforms) {\n  var transformList = node.transform.baseVal;\n\n  if (transforms) {\n\n    if (!Array.isArray(transforms)) {\n      transforms = [ transforms ];\n    }\n\n    setTransforms(transformList, transforms);\n  }\n\n  return transformList.consolidate();\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3Rpbnktc3ZnL2Rpc3QvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QixZQUFZLFlBQVk7QUFDeEI7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEIsWUFBWSxZQUFZO0FBQ3hCO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtB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QVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QixZQUFZLFlBQVk7QUFDeEI7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixZQUFZLHNEQUFzRDtBQUNsRTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFbU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFkZHJhLXdlYi8uLi8uLi9ub2RlX21vZHVsZXMvdGlueS1zdmcvZGlzdC9pbmRleC5lc20uanM/ZDE3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBlbnN1cmVJbXBvcnRlZChlbGVtZW50LCB0YXJnZXQpIHtcblxuICBpZiAoZWxlbWVudC5vd25lckRvY3VtZW50ICE9PSB0YXJnZXQub3duZXJEb2N1bWVudCkge1xuICAgIHRyeSB7XG5cbiAgICAgIC8vIG1heSBmYWlsIG9uIHdlYmtpdFxuICAgICAgcmV0dXJuIHRhcmdldC5vd25lckRvY3VtZW50LmltcG9ydE5vZGUoZWxlbWVudCwgdHJ1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuXG4gICAgICAvLyBpZ25vcmVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBhcHBlbmRUbyB1dGlsaXR5XG4gKi9cblxuXG4vKipcbiAqIEFwcGVuZCBhIG5vZGUgdG8gYSB0YXJnZXQgZWxlbWVudCBhbmQgcmV0dXJuIHRoZSBhcHBlbmRlZCBub2RlLlxuICpcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IHRhcmdldFxuICpcbiAqIEByZXR1cm4ge1NWR0VsZW1lbnR9IHRoZSBhcHBlbmRlZCBub2RlXG4gKi9cbmZ1bmN0aW9uIGFwcGVuZFRvKGVsZW1lbnQsIHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0LmFwcGVuZENoaWxkKGVuc3VyZUltcG9ydGVkKGVsZW1lbnQsIHRhcmdldCkpO1xufVxuXG4vKipcbiAqIGFwcGVuZCB1dGlsaXR5XG4gKi9cblxuXG4vKipcbiAqIEFwcGVuZCBhIG5vZGUgdG8gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IG5vZGVcbiAqXG4gKiBAcmV0dXJuIHtTVkdFbGVtZW50fSB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG4gIGFwcGVuZFRvKG5vZGUsIHRhcmdldCk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogYXR0cmlidXRlIGFjY2Vzc29yIHV0aWxpdHlcbiAqL1xuXG52YXIgTEVOR1RIX0FUVFIgPSAyO1xuXG52YXIgQ1NTX1BST1BFUlRJRVMgPSB7XG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAxLFxuICAnYmFzZWxpbmUtc2hpZnQnOiAxLFxuICAnY2xpcCc6IDEsXG4gICdjbGlwLXBhdGgnOiAxLFxuICAnY2xpcC1ydWxlJzogMSxcbiAgJ2NvbG9yJzogMSxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24nOiAxLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJzogMSxcbiAgJ2NvbG9yLXByb2ZpbGUnOiAxLFxuICAnY29sb3ItcmVuZGVyaW5nJzogMSxcbiAgJ2N1cnNvcic6IDEsXG4gICdkaXJlY3Rpb24nOiAxLFxuICAnZGlzcGxheSc6IDEsXG4gICdkb21pbmFudC1iYXNlbGluZSc6IDEsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6IDEsXG4gICdmaWxsJzogMSxcbiAgJ2ZpbGwtb3BhY2l0eSc6IDEsXG4gICdmaWxsLXJ1bGUnOiAxLFxuICAnZmlsdGVyJzogMSxcbiAgJ2Zsb29kLWNvbG9yJzogMSxcbiAgJ2Zsb29kLW9wYWNpdHknOiAxLFxuICAnZm9udCc6IDEsXG4gICdmb250LWZhbWlseSc6IDEsXG4gICdmb250LXNpemUnOiBMRU5HVEhfQVRUUixcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAxLFxuICAnZm9udC1zdHJldGNoJzogMSxcbiAgJ2ZvbnQtc3R5bGUnOiAxLFxuICAnZm9udC12YXJpYW50JzogMSxcbiAgJ2ZvbnQtd2VpZ2h0JzogMSxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnOiAxLFxuICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOiAxLFxuICAnaW1hZ2UtcmVuZGVyaW5nJzogMSxcbiAgJ2tlcm5pbmcnOiAxLFxuICAnbGV0dGVyLXNwYWNpbmcnOiAxLFxuICAnbGlnaHRpbmctY29sb3InOiAxLFxuICAnbWFya2VyJzogMSxcbiAgJ21hcmtlci1lbmQnOiAxLFxuICAnbWFya2VyLW1pZCc6IDEsXG4gICdtYXJrZXItc3RhcnQnOiAxLFxuICAnbWFzayc6IDEsXG4gICdvcGFjaXR5JzogMSxcbiAgJ292ZXJmbG93JzogMSxcbiAgJ3BvaW50ZXItZXZlbnRzJzogMSxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6IDEsXG4gICdzdG9wLWNvbG9yJzogMSxcbiAgJ3N0b3Atb3BhY2l0eSc6IDEsXG4gICdzdHJva2UnOiAxLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6IDEsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6IDEsXG4gICdzdHJva2UtbGluZWNhcCc6IDEsXG4gICdzdHJva2UtbGluZWpvaW4nOiAxLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnOiAxLFxuICAnc3Ryb2tlLW9wYWNpdHknOiAxLFxuICAnc3Ryb2tlLXdpZHRoJzogTEVOR1RIX0FUVFIsXG4gICd0ZXh0LWFuY2hvcic6IDEsXG4gICd0ZXh0LWRlY29yYXRpb24nOiAxLFxuICAndGV4dC1yZW5kZXJpbmcnOiAxLFxuICAndW5pY29kZS1iaWRpJzogMSxcbiAgJ3Zpc2liaWxpdHknOiAxLFxuICAnd29yZC1zcGFjaW5nJzogMSxcbiAgJ3dyaXRpbmctbW9kZSc6IDFcbn07XG5cblxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlKG5vZGUsIG5hbWUpIHtcbiAgaWYgKENTU19QUk9QRVJUSUVTW25hbWVdKSB7XG4gICAgcmV0dXJuIG5vZGUuc3R5bGVbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlTlMobnVsbCwgbmFtZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBoeXBoZW5hdGVkID0gbmFtZS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHZhciB0eXBlID0gQ1NTX1BST1BFUlRJRVNbaHlwaGVuYXRlZF07XG5cbiAgaWYgKHR5cGUpIHtcblxuICAgIC8vIGFwcGVuZCBwaXhlbCB1bml0LCB1bmxlc3MgcHJlc2VudFxuICAgIGlmICh0eXBlID09PSBMRU5HVEhfQVRUUiAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSkgKyAncHgnO1xuICAgIH1cblxuICAgIG5vZGUuc3R5bGVbaHlwaGVuYXRlZF0gPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZU5TKG51bGwsIG5hbWUsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKG5vZGUsIGF0dHJzKSB7XG5cbiAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMoYXR0cnMpLCBpLCBuYW1lO1xuXG4gIGZvciAoaSA9IDAsIG5hbWU7IChuYW1lID0gbmFtZXNbaV0pOyBpKyspIHtcbiAgICBzZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgYXR0cnNbbmFtZV0pO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyBvciBzZXRzIHJhdyBhdHRyaWJ1dGVzIG9uIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0gIHtTVkdFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0gIHtPYmplY3R9IFthdHRyc11cbiAqIEBwYXJhbSAge1N0cmluZ30gW25hbWVdXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFt2YWx1ZV1cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGF0dHIobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0QXR0cmlidXRlKG5vZGUsIG5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZXRBdHRyaWJ1dGVzKG5vZGUsIG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxyXG4gKiBUYWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jb21wb25lbnQvY2xhc3Nlc1xyXG4gKlxyXG4gKiBXaXRob3V0IHRoZSBjb21wb25lbnQgYml0cy5cclxuICovXHJcblxyXG4vKipcclxuICogdG9TdHJpbmcgcmVmZXJlbmNlLlxyXG4gKi9cclxuXHJcbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuXHJcbi8qKlxyXG4gICogV3JhcCBgZWxgIGluIGEgYENsYXNzTGlzdGAuXHJcbiAgKlxyXG4gICogQHBhcmFtIHtFbGVtZW50fSBlbFxyXG4gICogQHJldHVybiB7Q2xhc3NMaXN0fVxyXG4gICogQGFwaSBwdWJsaWNcclxuICAqL1xyXG5cclxuZnVuY3Rpb24gY2xhc3NlcyhlbCkge1xyXG4gIHJldHVybiBuZXcgQ2xhc3NMaXN0KGVsKTtcclxufVxyXG5cclxuZnVuY3Rpb24gQ2xhc3NMaXN0KGVsKSB7XHJcbiAgaWYgKCFlbCB8fCAhZWwubm9kZVR5cGUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQSBET00gZWxlbWVudCByZWZlcmVuY2UgaXMgcmVxdWlyZWQnKTtcclxuICB9XHJcbiAgdGhpcy5lbCA9IGVsO1xyXG4gIHRoaXMubGlzdCA9IGVsLmNsYXNzTGlzdDtcclxufVxyXG5cclxuLyoqXHJcbiAgKiBBZGQgY2xhc3MgYG5hbWVgIGlmIG5vdCBhbHJlYWR5IHByZXNlbnQuXHJcbiAgKlxyXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICAqIEByZXR1cm4ge0NsYXNzTGlzdH1cclxuICAqIEBhcGkgcHVibGljXHJcbiAgKi9cclxuXHJcbkNsYXNzTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obmFtZSkge1xyXG4gIHRoaXMubGlzdC5hZGQobmFtZSk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICAqIFJlbW92ZSBjbGFzcyBgbmFtZWAgd2hlbiBwcmVzZW50LCBvclxyXG4gICogcGFzcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byByZW1vdmVcclxuICAqIGFueSB3aGljaCBtYXRjaC5cclxuICAqXHJcbiAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IG5hbWVcclxuICAqIEByZXR1cm4ge0NsYXNzTGlzdH1cclxuICAqIEBhcGkgcHVibGljXHJcbiAgKi9cclxuXHJcbkNsYXNzTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24obmFtZSkge1xyXG4gIGlmICgnW29iamVjdCBSZWdFeHBdJyA9PSB0b1N0cmluZy5jYWxsKG5hbWUpKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVNYXRjaGluZyhuYW1lKTtcclxuICB9XHJcblxyXG4gIHRoaXMubGlzdC5yZW1vdmUobmFtZSk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICAqIFJlbW92ZSBhbGwgY2xhc3NlcyBtYXRjaGluZyBgcmVgLlxyXG4gICpcclxuICAqIEBwYXJhbSB7UmVnRXhwfSByZVxyXG4gICogQHJldHVybiB7Q2xhc3NMaXN0fVxyXG4gICogQGFwaSBwcml2YXRlXHJcbiAgKi9cclxuXHJcbkNsYXNzTGlzdC5wcm90b3R5cGUucmVtb3ZlTWF0Y2hpbmcgPSBmdW5jdGlvbihyZSkge1xyXG4gIGNvbnN0IGFyciA9IHRoaXMuYXJyYXkoKTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKHJlLnRlc3QoYXJyW2ldKSkge1xyXG4gICAgICB0aGlzLnJlbW92ZShhcnJbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gICogVG9nZ2xlIGNsYXNzIGBuYW1lYCwgY2FuIGZvcmNlIHN0YXRlIHZpYSBgZm9yY2VgLlxyXG4gICpcclxuICAqIEZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgY2xhc3NMaXN0LCBidXQgZG8gbm90IHN1cHBvcnQgYGZvcmNlYCB5ZXQsXHJcbiAgKiB0aGUgbWlzdGFrZSB3aWxsIGJlIGRldGVjdGVkIGFuZCBjb3JyZWN0ZWQuXHJcbiAgKlxyXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VcclxuICAqIEByZXR1cm4ge0NsYXNzTGlzdH1cclxuICAqIEBhcGkgcHVibGljXHJcbiAgKi9cclxuXHJcbkNsYXNzTGlzdC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24obmFtZSwgZm9yY2UpIHtcclxuICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBmb3JjZSkge1xyXG4gICAgaWYgKGZvcmNlICE9PSB0aGlzLmxpc3QudG9nZ2xlKG5hbWUsIGZvcmNlKSkge1xyXG4gICAgICB0aGlzLmxpc3QudG9nZ2xlKG5hbWUpOyAvLyB0b2dnbGUgYWdhaW4gdG8gY29ycmVjdFxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmxpc3QudG9nZ2xlKG5hbWUpO1xyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gICogUmV0dXJuIGFuIGFycmF5IG9mIGNsYXNzZXMuXHJcbiAgKlxyXG4gICogQHJldHVybiB7QXJyYXl9XHJcbiAgKiBAYXBpIHB1YmxpY1xyXG4gICovXHJcblxyXG5DbGFzc0xpc3QucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5saXN0KTtcclxufTtcclxuXHJcbi8qKlxyXG4gICogQ2hlY2sgaWYgY2xhc3MgYG5hbWVgIGlzIHByZXNlbnQuXHJcbiAgKlxyXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcclxuICAqIEByZXR1cm4ge0NsYXNzTGlzdH1cclxuICAqIEBhcGkgcHVibGljXHJcbiAgKi9cclxuXHJcbkNsYXNzTGlzdC5wcm90b3R5cGUuaGFzID1cclxuIENsYXNzTGlzdC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgIHJldHVybiB0aGlzLmxpc3QuY29udGFpbnMobmFtZSk7XHJcbiB9O1xuXG4vKipcbiAqIENsZWFyIHV0aWxpdHlcbiAqL1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhlIGdpdmVuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0gIHtTVkdFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtFbGVtZW50fSB0aGUgZWxlbWVudCAoZm9yIGNoYWluaW5nKVxuICovXG5mdW5jdGlvbiBjbGVhcihlbGVtZW50KSB7XG4gIHZhciBjaGlsZDtcblxuICB3aGlsZSAoKGNoaWxkID0gZWxlbWVudC5maXJzdENoaWxkKSkge1xuICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNsb25lKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xufVxuXG52YXIgbnMgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xufTtcblxuLyoqXG4gKiBET00gcGFyc2luZyB1dGlsaXR5XG4gKi9cblxuXG52YXIgU1ZHX1NUQVJUID0gJzxzdmcgeG1sbnM9XCInICsgbnMuc3ZnICsgJ1wiJztcblxuZnVuY3Rpb24gcGFyc2Uoc3ZnKSB7XG5cbiAgdmFyIHVud3JhcCA9IGZhbHNlO1xuXG4gIC8vIGVuc3VyZSB3ZSBpbXBvcnQgYSB2YWxpZCBzdmcgZG9jdW1lbnRcbiAgaWYgKHN2Zy5zdWJzdHJpbmcoMCwgNCkgPT09ICc8c3ZnJykge1xuICAgIGlmIChzdmcuaW5kZXhPZihucy5zdmcpID09PSAtMSkge1xuICAgICAgc3ZnID0gU1ZHX1NUQVJUICsgc3ZnLnN1YnN0cmluZyg0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG5cbiAgICAvLyBuYW1lc3BhY2Ugc3ZnXG4gICAgc3ZnID0gU1ZHX1NUQVJUICsgJz4nICsgc3ZnICsgJzwvc3ZnPic7XG4gICAgdW53cmFwID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBwYXJzZWQgPSBwYXJzZURvY3VtZW50KHN2Zyk7XG5cbiAgaWYgKCF1bndyYXApIHtcbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gIHZhciBwYXJlbnQgPSBwYXJzZWQuZmlyc3RDaGlsZDtcblxuICB3aGlsZSAocGFyZW50LmZpcnN0Q2hpbGQpIHtcbiAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChwYXJlbnQuZmlyc3RDaGlsZCk7XG4gIH1cblxuICByZXR1cm4gZnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRG9jdW1lbnQoc3ZnKSB7XG5cbiAgdmFyIHBhcnNlcjtcblxuICAvLyBwYXJzZVxuICBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gIHBhcnNlci5hc3luYyA9IGZhbHNlO1xuXG4gIHJldHVybiBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHN2ZywgJ3RleHQveG1sJyk7XG59XG5cbi8qKlxuICogQ3JlYXRlIHV0aWxpdHkgZm9yIFNWRyBlbGVtZW50c1xuICovXG5cblxuXG4vKipcbiAqIENyZWF0ZSBhIHNwZWNpZmljIHR5cGUgZnJvbSBuYW1lIG9yIFNWRyBtYXJrdXAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb3IgbWFya3VwIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW2F0dHJzXSBhdHRyaWJ1dGVzIHRvIHNldCBvbiB0aGUgZWxlbWVudFxuICpcbiAqIEByZXR1cm5zIHtTVkdFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGUobmFtZSwgYXR0cnMpIHtcbiAgdmFyIGVsZW1lbnQ7XG5cbiAgbmFtZSA9IG5hbWUudHJpbSgpO1xuXG4gIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gJzwnKSB7XG4gICAgZWxlbWVudCA9IHBhcnNlKG5hbWUpLmZpcnN0Q2hpbGQ7XG4gICAgZWxlbWVudCA9IGRvY3VtZW50LmltcG9ydE5vZGUoZWxlbWVudCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucy5zdmcsIG5hbWUpO1xuICB9XG5cbiAgaWYgKGF0dHJzKSB7XG4gICAgYXR0cihlbGVtZW50LCBhdHRycyk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBFdmVudHMgaGFuZGxpbmcgdXRpbGl0eVxuICovXG5cbmZ1bmN0aW9uIG9uKG5vZGUsIGV2ZW50LCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbn1cblxuZnVuY3Rpb24gb2ZmKG5vZGUsIGV2ZW50LCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbn1cblxuLyoqXG4gKiBHZW9tZXRyeSBoZWxwZXJzXG4gKi9cblxuXG4vLyBmYWtlIG5vZGUgdXNlZCB0byBpbnN0YW50aWF0ZSBzdmcgZ2VvbWV0cnkgZWxlbWVudHNcbnZhciBub2RlID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0Tm9kZSgpIHtcbiAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICBub2RlID0gY3JlYXRlKCdzdmcnKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBleHRlbmQob2JqZWN0LCBwcm9wcykge1xuICB2YXIgaSwgaywga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcblxuICBmb3IgKGkgPSAwOyAoayA9IGtleXNbaV0pOyBpKyspIHtcbiAgICBvYmplY3Rba10gPSBwcm9wc1trXTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cblxuZnVuY3Rpb24gY3JlYXRlUG9pbnQoeCwgeSkge1xuICB2YXIgcG9pbnQgPSBnZXROb2RlKCkuY3JlYXRlU1ZHUG9pbnQoKTtcblxuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgY2FzZSAwOlxuICAgIHJldHVybiBwb2ludDtcbiAgY2FzZSAyOlxuICAgIHggPSB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG4gICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gZXh0ZW5kKHBvaW50LCB4KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgbWF0cml4IHZpYSBhcmdzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogY3JlYXRlTWF0cml4KHsgYTogMSwgYjogMSB9KTtcbiAqIGNyZWF0ZU1hdHJpeCgpO1xuICogY3JlYXRlTWF0cml4KDEsIDIsIDAsIDAsIDMwLCAyMCk7XG4gKlxuICogQHJldHVybiB7U1ZHTWF0cml4fVxuICovXG5mdW5jdGlvbiBjcmVhdGVNYXRyaXgoYSwgYiwgYywgZCwgZSwgZikge1xuICB2YXIgbWF0cml4ID0gZ2V0Tm9kZSgpLmNyZWF0ZVNWR01hdHJpeCgpO1xuXG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICBjYXNlIDA6XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgY2FzZSAxOlxuICAgIHJldHVybiBleHRlbmQobWF0cml4LCBhKTtcbiAgY2FzZSA2OlxuICAgIHJldHVybiBleHRlbmQobWF0cml4LCB7XG4gICAgICBhOiBhLFxuICAgICAgYjogYixcbiAgICAgIGM6IGMsXG4gICAgICBkOiBkLFxuICAgICAgZTogZSxcbiAgICAgIGY6IGZcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm0obWF0cml4KSB7XG4gIGlmIChtYXRyaXgpIHtcbiAgICByZXR1cm4gZ2V0Tm9kZSgpLmNyZWF0ZVNWR1RyYW5zZm9ybUZyb21NYXRyaXgobWF0cml4KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0Tm9kZSgpLmNyZWF0ZVNWR1RyYW5zZm9ybSgpO1xuICB9XG59XG5cbi8qKlxuICogU2VyaWFsaXphdGlvbiB1dGlsXG4gKi9cblxudmFyIFRFWFRfRU5USVRJRVMgPSAvKFsmPD5dezF9KS9nO1xudmFyIEFUVFJfRU5USVRJRVMgPSAvKFsmPD5cXG5cXHJcIl17MX0pL2c7XG5cbnZhciBFTlRJVFlfUkVQTEFDRU1FTlQgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnXFwnJ1xufTtcblxuZnVuY3Rpb24gZXNjYXBlKHN0ciwgcGF0dGVybikge1xuXG4gIGZ1bmN0aW9uIHJlcGxhY2VGbihtYXRjaCwgZW50aXR5KSB7XG4gICAgcmV0dXJuIEVOVElUWV9SRVBMQUNFTUVOVFtlbnRpdHldIHx8IGVudGl0eTtcbiAgfVxuXG4gIHJldHVybiBzdHIucmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlRm4pO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemUobm9kZSwgb3V0cHV0KSB7XG5cbiAgdmFyIGksIGxlbiwgYXR0ck1hcCwgYXR0ck5vZGUsIGNoaWxkTm9kZXM7XG5cbiAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG5cbiAgLy8gVEVYVFxuICBjYXNlIDM6XG5cbiAgICAvLyByZXBsYWNlIHNwZWNpYWwgWE1MIGNoYXJhY3RlcnNcbiAgICBvdXRwdXQucHVzaChlc2NhcGUobm9kZS50ZXh0Q29udGVudCwgVEVYVF9FTlRJVElFUykpO1xuICAgIGJyZWFrO1xuXG4gIC8vIEVMRU1FTlRcbiAgY2FzZSAxOlxuICAgIG91dHB1dC5wdXNoKCc8Jywgbm9kZS50YWdOYW1lKTtcblxuICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgICAgYXR0ck1hcCA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGF0dHJNYXAubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgYXR0ck5vZGUgPSBhdHRyTWFwLml0ZW0oaSk7XG4gICAgICAgIG91dHB1dC5wdXNoKCcgJywgYXR0ck5vZGUubmFtZSwgJz1cIicsIGVzY2FwZShhdHRyTm9kZS52YWx1ZSwgQVRUUl9FTlRJVElFUyksICdcIicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgb3V0cHV0LnB1c2goJz4nKTtcbiAgICAgIGNoaWxkTm9kZXMgPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHNlcmlhbGl6ZShjaGlsZE5vZGVzLml0ZW0oaSksIG91dHB1dCk7XG4gICAgICB9XG4gICAgICBvdXRwdXQucHVzaCgnPC8nLCBub2RlLnRhZ05hbWUsICc+Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcvPicpO1xuICAgIH1cbiAgICBicmVhaztcblxuICAvLyBDT01NRU5UXG4gIGNhc2UgODpcbiAgICBvdXRwdXQucHVzaCgnPCEtLScsIGVzY2FwZShub2RlLm5vZGVWYWx1ZSwgVEVYVF9FTlRJVElFUyksICctLT4nKTtcbiAgICBicmVhaztcblxuICAvLyBDREFUQVxuICBjYXNlIDQ6XG4gICAgb3V0cHV0LnB1c2goJzwhW0NEQVRBWycsIG5vZGUubm9kZVZhbHVlLCAnXV0+Jyk7XG4gICAgYnJlYWs7XG5cbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBoYW5kbGUgbm9kZSAnICsgbm9kZS5ub2RlVHlwZSk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIGlubmVySFRNTCBsaWtlIGZ1bmN0aW9uYWxpdHkgZm9yIFNWRyBlbGVtZW50cy5cbiAqIGJhc2VkIG9uIGlubmVyU1ZHIChodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2lubmVyc3ZnKVxuICovXG5cblxuXG5mdW5jdGlvbiBzZXQoZWxlbWVudCwgc3ZnKSB7XG5cbiAgdmFyIHBhcnNlZCA9IHBhcnNlKHN2Zyk7XG5cbiAgLy8gY2xlYXIgZWxlbWVudCBjb250ZW50c1xuICBjbGVhcihlbGVtZW50KTtcblxuICBpZiAoIXN2Zykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghaXNGcmFnbWVudChwYXJzZWQpKSB7XG5cbiAgICAvLyBleHRyYWN0IDxzdmc+IGZyb20gcGFyc2VkIGRvY3VtZW50XG4gICAgcGFyc2VkID0gcGFyc2VkLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIHZhciBub2RlcyA9IHNsaWNlKHBhcnNlZC5jaGlsZE5vZGVzKTtcblxuICAvLyBpbXBvcnQgKyBhcHBlbmQgZWFjaCBub2RlXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBhcHBlbmRUbyhub2Rlc1tpXSwgZWxlbWVudCk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBnZXQoZWxlbWVudCkge1xuICB2YXIgY2hpbGQgPSBlbGVtZW50LmZpcnN0Q2hpbGQsXG4gICAgICBvdXRwdXQgPSBbXTtcblxuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBzZXJpYWxpemUoY2hpbGQsIG91dHB1dCk7XG4gICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGlzRnJhZ21lbnQobm9kZSkge1xuICByZXR1cm4gbm9kZS5ub2RlTmFtZSA9PT0gJyNkb2N1bWVudC1mcmFnbWVudCc7XG59XG5cbmZ1bmN0aW9uIGlubmVyU1ZHKGVsZW1lbnQsIHN2Zykge1xuXG4gIGlmIChzdmcgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldChlbGVtZW50LCBzdmcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXJyb3IgcGFyc2luZyBTVkc6ICcgKyBlLm1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXQoZWxlbWVudCk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzbGljZShhcnIpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycik7XG59XG5cbi8qKlxuICogU2VsZWN0aW9uIHV0aWxpdGllc1xuICovXG5cbmZ1bmN0aW9uIHNlbGVjdChub2RlLCBzZWxlY3Rvcikge1xuICByZXR1cm4gbm9kZS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0QWxsKG5vZGUsIHNlbGVjdG9yKSB7XG4gIHZhciBub2RlcyA9IG5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cbiAgcmV0dXJuIFtdLm1hcC5jYWxsKG5vZGVzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIHByZXBlbmRUbyB1dGlsaXR5XG4gKi9cblxuXG4vKipcbiAqIFByZXBlbmQgYSBub2RlIHRvIGEgdGFyZ2V0IGVsZW1lbnQgYW5kIHJldHVybiB0aGUgcHJlcGVuZGVkIG5vZGUuXG4gKlxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gbm9kZVxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gdGFyZ2V0XG4gKlxuICogQHJldHVybiB7U1ZHRWxlbWVudH0gdGhlIHByZXBlbmRlZCBub2RlXG4gKi9cbmZ1bmN0aW9uIHByZXBlbmRUbyhub2RlLCB0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldC5pbnNlcnRCZWZvcmUoZW5zdXJlSW1wb3J0ZWQobm9kZSwgdGFyZ2V0KSwgdGFyZ2V0LmZpcnN0Q2hpbGQgfHwgbnVsbCk7XG59XG5cbi8qKlxuICogcHJlcGVuZCB1dGlsaXR5XG4gKi9cblxuXG4vKipcbiAqIFByZXBlbmQgYSBub2RlIHRvIGEgdGFyZ2V0IGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0gIHtTVkdFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IG5vZGVcbiAqXG4gKiBAcmV0dXJuIHtTVkdFbGVtZW50fSB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gcHJlcGVuZCh0YXJnZXQsIG5vZGUpIHtcbiAgcHJlcGVuZFRvKG5vZGUsIHRhcmdldCk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShlbGVtZW50KSB7XG4gIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIFJlcGxhY2UgdXRpbGl0eVxuICovXG5cblxuZnVuY3Rpb24gcmVwbGFjZShlbGVtZW50LCByZXBsYWNlbWVudCkge1xuICBlbGVtZW50LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGVuc3VyZUltcG9ydGVkKHJlcGxhY2VtZW50LCBlbGVtZW50KSwgZWxlbWVudCk7XG4gIHJldHVybiByZXBsYWNlbWVudDtcbn1cblxuLyoqXG4gKiB0cmFuc2Zvcm0gYWNjZXNzb3IgdXRpbGl0eVxuICovXG5cbmZ1bmN0aW9uIHdyYXBNYXRyaXgodHJhbnNmb3JtTGlzdCwgdHJhbnNmb3JtKSB7XG4gIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBTVkdNYXRyaXgpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtTGlzdC5jcmVhdGVTVkdUcmFuc2Zvcm1Gcm9tTWF0cml4KHRyYW5zZm9ybSk7XG4gIH1cblxuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG5cbmZ1bmN0aW9uIHNldFRyYW5zZm9ybXModHJhbnNmb3JtTGlzdCwgdHJhbnNmb3Jtcykge1xuICB2YXIgaSwgdDtcblxuICB0cmFuc2Zvcm1MaXN0LmNsZWFyKCk7XG5cbiAgZm9yIChpID0gMDsgKHQgPSB0cmFuc2Zvcm1zW2ldKTsgaSsrKSB7XG4gICAgdHJhbnNmb3JtTGlzdC5hcHBlbmRJdGVtKHdyYXBNYXRyaXgodHJhbnNmb3JtTGlzdCwgdCkpO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9yIHNldCB0aGUgdHJhbnNmb3JtcyBvbiB0aGUgZ2l2ZW4gbm9kZS5cbiAqXG4gKiBAcGFyYW0ge1NWR0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSAge1NWR1RyYW5zZm9ybXxTVkdNYXRyaXh8QXJyYXk8U1ZHVHJhbnNmb3JtfFNWR01hdHJpeD59IFt0cmFuc2Zvcm1zXVxuICpcbiAqIEByZXR1cm4ge1NWR1RyYW5zZm9ybX0gdGhlIGNvbnNvbGlkYXRlZCB0cmFuc2Zvcm1cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHRyYW5zZm9ybXMpIHtcbiAgdmFyIHRyYW5zZm9ybUxpc3QgPSBub2RlLnRyYW5zZm9ybS5iYXNlVmFsO1xuXG4gIGlmICh0cmFuc2Zvcm1zKSB7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHJhbnNmb3JtcykpIHtcbiAgICAgIHRyYW5zZm9ybXMgPSBbIHRyYW5zZm9ybXMgXTtcbiAgICB9XG5cbiAgICBzZXRUcmFuc2Zvcm1zKHRyYW5zZm9ybUxpc3QsIHRyYW5zZm9ybXMpO1xuICB9XG5cbiAgcmV0dXJuIHRyYW5zZm9ybUxpc3QuY29uc29saWRhdGUoKTtcbn1cblxuZXhwb3J0IHsgYXBwZW5kLCBhcHBlbmRUbywgYXR0ciwgY2xhc3NlcywgY2xlYXIsIGNsb25lLCBjcmVhdGUsIGNyZWF0ZU1hdHJpeCwgY3JlYXRlUG9pbnQsIGNyZWF0ZVRyYW5zZm9ybSwgaW5uZXJTVkcsIG9mZiwgb24sIHByZXBlbmQsIHByZXBlbmRUbywgcmVtb3ZlLCByZXBsYWNlLCBzZWxlY3QsIHNlbGVjdEFsbCwgdHJhbnNmb3JtIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/tiny-svg/dist/index.esm.js\n");

/***/ })

};
;